/*
* Copyright (C) 2007, 2008, 2009 Raazesh Sainudiin
* Copyright (C) 2009 Jennifer Harlow
*
* This file is part of mrs, a C++ class library for statistical set processing.
*
* mrs is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 3 of the License, or (at
* your option) any later version.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#ifndef ___SPNODE_HPP__
#define ___SPNODE_HPP__

#include "sptypes.hpp"
#include "sp_check_visitor.hpp"
#include "spnodevisitor.hpp"


/*! \file spnode.hpp
\brief SPnode (SubPaving) and associated non-member functions declarations

*/

//! Forward class declarations
class LabBox;

/*! \brief The namespace subpavings.

The namespace is used for all classes and non-member methods related to
subpavings.
*/
namespace subpavings {
	
	class SPnodeVisitor;

    /*! \brief SubPaving is an alias for a pointer to an SPnode.
    */
    typedef SPnode* SubPaving;


    /*! \brief SPnodes are nodes in the representation of a subpaving as a
    binary tree.

    A node represents a box (interval vector). SPnodes are linked together
    to form the tree.  The initial box of the subpaving is the box
    represented by the root node of the tree.  A box which has been split
    will be represented as node with one or two children.

    A subpaving of [<b>x</b>] (union of non-overlapping subboxes of
    [<b>x</b>]) is represented by the leaves (degenerate/ child-less)
    nodes in the tree.

    SPnodes are an adaptation of the AIASPnode class [from Jaulin,
    Kieffer, Didrit and Walter, Applied Interval Analysis, Springer, 2001,
    p. 336-348] including changes in coding, class members, and class
    structure.  SPnodes are implemented under C-XSC.

    This class replicates the set computation functionality of the
    subpaving nodes developed by [Jaulin, Kieffer, Didrit and Walter,
    Applied Interval Analysis, Springer, 2001] but also provides additional
    functionality to allow the class to become the basis for derived
    classes of subpaving nodes that can be used for
    <b>statistical set processing</b>.
    */
    class SPnode {

		//src_trunk_0701
		private:
	
		//src_trunk_0701
		/*! \brief Handle exceptions in the construction of a node.
        */
		void constructor_error_handler(); // throw()


    protected:
        /*! \brief Pointer to the interval vector the node represents
        */
        ivector* theBox;

        /*! \brief The dimensions in which we are working.

        ie the dimensions of theBox.

        This data member is not present in the AIASPnode class.
        */
        size_t dimension;

        /*! \brief The label for the box.

        Box labels are used if we need to distinguish between boxes
        generated by/for different situations. The label defaults
        to 0 if it is not specified.  This allows us to have
        model-label specific processes.

        This data member is not present in the AIASPnode class.
        */
        int label;

        /*! \brief The node's parent.

        This data member is not present in the AIASPnode class.
        This allows us to go up from the child node to its parent.
        */
        SPnode* parent;

        /*! \brief The node's left child.
        */
        SPnode* leftChild;

        /*! \brief The node's right child.
        */
        SPnode* rightChild;

        /*! \brief The name given to the node.
        */
        std::string nodeName;
        
        /*! \brief splitting according to instruction string.

        Gets the first level in the string, checks if it is already at that
        level, if not splits and recurses to children in order left then right,
        if it is already at that level strips this off the string and returns
        the remaining string to the caller.
        \param instruction is a string specifiying shape, eg "3, 3, 2, 1"
        */
        std::string splitLeft(std::string instruction);

		//src_trunk_0701
			/*! \brief Reshape the tree rooted at this so that it has the
		shape that is the non-minimal union of the tree orginally
		rooted at this and the tree rooted at the node pointed to
		by \a other.*/
		virtual void _reshapeToUnion(const SPnode * const other);


    public:
        /*! \brief Default constructor.
        */
        explicit SPnode();
        
        //src_trunk_0701
          /*! \brief Initialised constructor with box.
		 
		Throws a MalconstructedBox_Error if \a v has no practical
		(0 or negative) dimensions.

        \param v interval vector for the box this represents.
		\pre v should be a proper ivector, with length >= 1.
        */
        explicit SPnode(const ivector& v);
        
        //src_trunk_0701
         /*! \brief Initialised constructor.
        Initialised with a LabBox (labeled box).
		
		Throws a MalconstructedBox_Error if \a v has no practical
		(0 or negative) dimensions.

		\param lb a labeled box which supplies information about 
		box for this.
		\pre the box of the labeled box should be a proper box,
		with length >= 1.
        */
        explicit SPnode(const LabBox& lb);

        /*! \brief Initialised constructor with box and optional label.

        Initialised with one interval vector for the box and
        optionally initialised with a label.  Label defaults to 0
        if not specified.
        */
        explicit SPnode(ivector& v, int lab = 0);

        /*! \brief Initialised constructor.
        Initialised with a LabBox (labeled box).
        */
        explicit SPnode(LabBox& lb);

        /*! \brief Copy constructor.
        */
        explicit SPnode(const SPnode& other);

        /*! \brief Destructor.
        Declare as virtual because we will use SPNode as a base class.
        */
        virtual ~SPnode();

        /*! \brief Copy assignment operator.
        */
        SPnode& operator=(const SPnode& rhs);

        /*! \brief Recursively rename children based on this node's nodeName.
        */
        void recursiveRename();

		// from src_trunk_0701
		/*! Return boolean to indicate if node is splittable.
		* 
		A node is splittable if there is at least one value in the 
		basic number screen between the inf and sup of the interval
		on the coordinate with maximum diameter (ie, the box 
		can be split into two child boxes which will both be considered
		smaller than the parent box) \b and
		the node volume is >= 2 * cxsc::MinReal (the
		smallest representable real number).*/
		virtual bool isSplittableNode() const;

        /*! \brief Accessor for the dimension of theBox of a node.
        */
        size_t getDimension() const;

        /*! \brief Accessor for theBox of a node.

        Returns a copy of the object pointed to by theBox of a node.
        */
        ivector getBox() const;

        /*! \brief Accessor for label of a node.
        */
        int getLabel() const;

        /*! \brief Set the label of a childless root node.

        Prints an error message to console if this is not a
        childless root node.
        */
        void setLabel(int lab);

        /*! @name Accessors for links between the nodes.
        \note Pointers for parent, leftChild, and rightChild are not
        reference counted so there could potentially be problems with
        the use of returned pointers (for instance, being used to
        delete  nodes). These pointers might be better implemented
        with boost::shared_ptr.
        */
        //@{
        /*! \brief Accessor for the parent of a node.

        Returns a copy of the pointer to parent node.
        */
        SPnode* getParent() const;

        /*! \brief Accessor for the left child of a node.

        Returns a copy of the pointer to leftChild node.
        */
        SPnode* getLeftChild() const;

        /*! \brief Accessor for the right child of a node.

            Returns a copy of the pointer to rightChild node.
        */
        SPnode* getRightChild() const;
        //@}

        /*! \brief Get the node name.
        */
        std::string getNodeName() const;

        /*! \brief Set the node name.
        */
        void setNodeName(std::string newname);


        /*! \brief Return the volume of the box as a double.
        */
        double nodeVolume() const;
        
        
        //src_trunk_0701
        /*! \brief		Throws a NoBox_Error if theBox is NULL. 
			\return the volume of the box associated with the node.
			\pre !isEmpty(). 
			*/
        real nodeRealVolume() const;

        /*! \brief Check if this SPnode is empty.

        Can only check if an actual subpaving object is empty,
        not if it is null.
        */
        bool isEmpty() const;

        /*! \brief Check if this SPnode is a leaf.
        */
        bool isLeaf() const;

        /*! \brief Check if this has a non-empty left child.
        */
        bool hasLCwithBox() const;

        /*! \brief Check if this has a non-empty right child.
        */
        bool hasRCwithBox() const;

        /*! \brief find if this node is a subleaf node.
        */
        bool isSubLeaf() const;
        
        //src_trunk_0701
        	/*! \brief Get the split dimension for this.
		@todo We could just keep the splitDim for all spnode 
		types.  But then we'd have to adjust this when nodes
		were marginalised etc.  but this is expensive ...
		* See RealMappedSPnodeSingleRange etc as well*/
		virtual int getSplitDim() const;

		//src_trunk_0701
		/*! \brief Get number of leaf descendents of this.
			\return Number of leaf descendents of this (1 if this is a leaf).*/
		virtual size_t getNumberLeaves() const;

		//src_trunk_0701
		/*! \brief Return pointers to const nodes.*/ 
		SPnodeConstPtrs& getConstSPnodeLeaves(SPnodeConstPtrs& leaves) const;
	

        /*! \brief Return a reference to all descendent leaf nodes as SPnodes.

        Will be just this if this is a leaf.

        When this function is inherited in derived classes it will return the
        leaf nodes of a tree of the derived class nodes as plain SPnodes.

        \return a reference to a container of node pointers.
        */
        SPnodePtrs& getSPnodeLeaves(SPnodePtrs& leaves) const;


		/*! \brief Fill in a vector of leaf node volumes.

        \param vols a container in which to store volumes.
        \return a reference to the container of volumes to which the volumes of
        all leaves descended from this have been added.
        */
        RealVec& getLeafNodeVolumes(RealVec& vols) const;

        
        //gat41 removed this
        /*! \brief Fill in a vector of leaf node levels.

        Levels are taken from length of node name.  nodeName for root is X.

        \param levels a container in which to store levels.
        \return a reference to the container of levels.
        */
        //IntVec& getLeafNodeLevels(IntVec& levels) const;

        //gat41 removed this
        /*! \brief Fill in a vector of leaf node levels based on a given root level.

        Levels are taken given 'base' or root level.

        \param level a level to use for this node.
        \param levels a container in which to store levels.
        \return a reference to the container of levels.
        */
        //IntVec& getLeafNodeLevels(const int level, IntVec& levels) const;
        
        //src_trunk_0701
        /*! \brief Fill in a vector of leaf node levels.

        Levels are taken from length of node name.  nodeName for root is X.

        \param levels a container in which to store levels.
		\param level the level to allocate to this.
        \return a reference to the container of levels.
        */
        IntVec& getLeafNodeLevels(IntVec& levels, int level = 0) const;
        

        /*! \brief Get a string of leaf node levels.

        Levels start at 0 for root.

        \return a comma-separated string of levels.
        */
        std::string getLeafNodeLevelsString() const;

        /*! \brief Get the node depth.

        Root has depth 0
        */
        int getNodeDepth() const;


        /*! \brief Get depth of the tree descended from this node.

        Depth of this node is 0.
        Returns the depth of the deepest leaf child descendent of this node.
        */
        int getDepth() const;


        /*! \brief Get the volume of the leaf with the smallest volume.

        Returns the volume of the smallest (by vol) leaf node.
        */
        double getSmallestLeafVol() const;

        /*! \brief Get the volume of the leaf with the largest volume.

        Returns the volume of the largest (by vol) leaf node.
        */
        double getLargestLeafVol() const;

//src_trunk_0701
/*! \brief Check tree rooted at this is legal with respect
		to isSplittableNode().
		* 
		'Legal' means that all non-leaf nodes in the tree are 
		splittable, ie return isSplittableNode() = true; 
        
		\return true if all non-leaf nodes in the tree rooted at
		this are splittable, false if any non-leaf node in the tree 
		rooted at this is not splittable.*/
        virtual bool checkTreeStateLegal() const;

        /*! \brief Check if this has a leaf sibling.
        */
        bool hasLeafSibling() const;

		/*! \brief Accept a visitor of the type SPnodeVisitor.
		 
		 \param visitor The visitor to accept.
        */
        virtual void accept(SPnodeVisitor& visitor);
        
        //gat41
        /*! \brief Get the range collection of the vistitor of the type SPnodeVisitor.
			\param visitor the visitor to get the range from
			*/
			virtual void collectRange(SPnodeVisitor& visitor);

			//src_trunk_0701
			/*! \brief  Accept an SPCheckVisitor.
			\param visitor a visitor capable of
		performing some check on this.
		\post this is unchanged.*/
		virtual void acceptSPCheckVisitor(const SPCheckVisitor& visitor) const;


        /*! \brief Output details of a specific node in a tree.

        This is intended for console output or output
        to a mixed alpha and numeric file.
        */
        virtual std::ostream& nodePrint(std::ostream &os) const;

        /*! \brief Output for a node in a binary tree, tab-delimited

        Output intended for a txt file, in numeric form only.

        Replaces the format that that the cxsc::<< operator produces
        for interval vectors.   The format used here includes the box
        label and produces numeric tab-delimited data.

        The format for an n-dimensional interval vector is:

        label [tab] volume [tab] Inf(ivector[1])
        [tab] Sup(ivector[1].[tab] . .
        [tab] Inf(ivector[n]) [tab] Sup(ivector[n]
        */
        virtual std::ostream& leafOutputTabs(std::ostream &os) const;

		/*! @name Output for for <b>all leaves</b> of a binary tree.

        Output intended for a txt file, in numeric form only.

        \param os is the stream to send to
        \param prec is the precision used for printing.   */
        //@{
		virtual std::ostream& leavesOutputTabs(std::ostream &os) const;
		virtual std::ostream& leavesOutputTabs(std::ostream &os, 
												int prec) const;
		//@} 
        
           /*! @name Output for <b>all nodes</b> in binary tree.

        Output for all nodes in binary tree representing a subpaving
        in tab-delimited form.

        Output intended for console output.*/
		//@{
        virtual std::ostream& nodesAllOutput(std::ostream &os,
												int level) const;
		virtual std::ostream& nodesAllOutput(std::ostream &os,
                                    int level, int prec) const;
		//@}

        /*! \brief Make a .dot graph file from an SPnode tree structure.

        Makes a simple .dot graph from the SPnode tree using node names and the
        .png image for this graph.

        \pre a constructed SPnode tree
        \post a .dot file and a .png in the same directory as the program
        creating it was run in.
        */
        virtual bool outputGraphDot() const;

//src_trunk_0701
	/*! \brief Check if the box a node represents contains a datapoint p.

        \param p the value of the data point being tested for containment in
        the box represented by this node.
        \param childInd indicates whether this should be considered
        to be a left child or a right child (ie where we need to take
        splitting dimension and value into account) or as a parent
        node (default).
		
		If a node is being considered as a child node (ie childInd is 
		ON_RIGHT or ON_LEFT) and actaully has a parent node, 
		then is is assumed that the data 
		point would have been in the box associated with the parent
		node, and the question now is just whether it falls into 
		the left or right child. Thus no test for full containment of
		the data point in the box is carried out, and this method
		just checks whether the data point would have fallen 
		from the parent into the left or right child.
		 
		If childInd is ON_PARENT, or if the node has no parent node,
		then the method checks for full containment of the data point
		within the box associated with this node.

        Note that the interval on the parent's split dimension
        of the right child's box is closed at the split value and
        the interval of the left child's box is open.  A datapoint
        whose element in the split dimension is exactly the split
        value should be assessed to be in the right child's box but
        not the left child's box.
        */
        virtual bool nodeContains(const rvector& p,
                        OPERATIONS_ON childInd = ON_PARENT) const;


        /*! \brief Check if ivector z is contained in this or children.

        Note that this checks not only the box represented by this node
        but the children as well.  Returns a BOOL_INTERVAL type, ie can
        be true, false, or indeterminate (indeterminate if the ivector
        covers the border of the subpaving).
        */
        virtual BOOL_INTERVAL spContains(const ivector& z) const;

        /*! \brief Check if rvector p is contained in this node or
        any of its children.

        Note that this checks not only the box represented by this node
        but the children as well.  Returns a BOOL_INTERVAL type but
        this can actually only be BI_TRUE or BI_FALSE
        (not BI_INDET = indeterminate).
        */
        virtual BOOL_INTERVAL spContains(const rvector& p) const;



        /*! \brief Expand a leaf node to make two leaves as children.

        Equivalent to bisecting a box in a regular subpaving.  Makes
        two new sibling child nodes of this one and grafts them on.
        \param comp is the dimension on which to bisect theBox.
        */
        virtual void nodeExpand(int comp);

        /*! \brief Expand a leaf node to have two children and pass
        data  down to the children with no further splitting.

        Finds the splitting dimension and then uses
        nodeExpand(int comp) to split.
        */
        virtual void nodeExpand();
        
        /*! \brief Expand a leaf node to make two leaves as children.
        
        Has parameter boolVal for validation data (ingeritance polymorphism)
        */
        virtual void nodeExpand(bool boolVal);
                
        /*! \brief Reabsorbs both children of the node.

        Effectively cancels any split of the node.
        */
        virtual void nodeReabsorbChildren();

        /*! \brief Tries to reunite nodes.

        Note that the nodes provided, lChild and rChild, are not
        the actual children of this, they are potential children
        which we are trying to either totally bring into
        this (if there are two of them) or to graft onto this
        if there is only one of them.  This is typically a new, part-formed
        node whose formation can be completed by reuniting already two
        already-formed nodes into it or by adding on one child if only
        one is available.  nodeReunite is used in building a tree upwards
        (rather than in pruning leaves of formed tree from the bottom up).

        If two potential children are provided and they are both
        leaves, it combines the two leaf siblings into this.  If the
        potential children are not leaves or if only one potential
        child is provided, it grafts the potential child/children
        onto this as its child/children.
        */
        virtual void nodeReunite(SPnode *lChild, SPnode* rChild);

        /*! \brief Builds a tree downwards.

        Adds a left node on to this as leftChild.

        */
        void nodeAddLeft(SPnode *lChild);

        /*! \brief Builds a tree downwards.

        Adds a right node onto this as rightChild.
        */
        void nodeAddRight(SPnode *rChild);

        /*! \brief Builds a higher level of a tree from existing nodes.

        This adopts a left child rather than attempting.
        to reunite two children into this.
        */
        virtual void nodeAdoptLeft(SPnode *lChild);

        /*! \brief Builds a higher level of a tree from existing nodes.

        This adopts a right child rather than attempting.
        to reunite two children into this.
        */
        virtual void nodeAdoptRight(SPnode *rChild);

        /*! \brief Gets a string of child nodes names.

        Left to right order.

        \return a string of child nodes names in pairs, left to right.
        */
        std::string getChildNodeNames() const;
        
        //src_trunk_0701
        /*! \brief Reshape so that the tree rooted at this has shape that
		is the union of this shape and the shape of another tree.
		
		Throws a NoBox_Error if this has no box or if \a other has no box. 
		
		Throws an IncompatibleDimensions_Error if boxes of this and \a other
		are not the same.
		
		Throws an std::runtime_error if \a other has an illegal state
		(see checkTreeStateLegal()).
		* 
		\param other is the tree to make the union against.
		\pre This has a box and that box is identical to the box of \a other. 
		\post the tree rooted at this has shape that is the
		union of the shape of this before the operation and the shape of 
		\a other.  \a other is unchanged.      */
		virtual void reshapeToUnion(const SPnode& other);
        
        /*! \brief Split a root paving to a specified shape.

        The instruction specifies the required shape in terms of the depth of
        the leaf nodes, in left to right order.  The depth of a leaf node is
        equivalent to the number of bisections of the root box required to make
        the box represented by that leaf.  i.e., the root has depth 0 and if
        that were bisected, the root node would have two child nodes each of
        level 1.  Bisection of any one of the boxes represented by a
        child would give two more children, each of level 2 (2 bisections), etc.

        For example, an instruction string  "3, 3, 2, 1" would give an SPSnode
        tree with 4 leaves, 2 of which would be level 3 (i.e. representing
        boxes resulting from 3 bisections of the root box, each of which would
        have volume 1/8 the size of the root box).  Another leaf would represent
        a box resulting from 2 bisections of the root box (volume 1/4 that of
        the root box) and the 'right-most' leaf (in a drawing of the tree) would
        be the result of a single bisection of the root box and would have half
        the volume of the root box.  This is a valid instruction string because
        it is possible to get leaves of those levels by a series of successive
        bisections of the root box and the volume of the leaves adds up to the
        volume of the root box.

        \param instruction specifies the required shape, eg "3, 3, 2, 1".
        \return true if the instruction could be successfully carried out,
        false if the instruction could not be carried out successfully.
        */
        bool splitRootToShape(std::string instruction);


        /*! Return container of boxes represented by commonality of 2 subpavings.

        Finds the boxes represented by the deepest common level of nodes between
        two SPnode trees  i.e. the 'outer jacket' that is the finest subpaving
        that fits around both of the subpavings represented by the given trees.

        \param boxes is a reference to a container of boxes to be filled.
        \param spn1 root of tree representing a subpaving.
        \param spn2 root of tree representing another subpaving.
        \return a container of boxes that is the outer jacket of spn1, spn2.
        */
        static BoxVec& vecLeafBoxOuterJacket(BoxVec& boxes,
                        const SPnode * const spn1, const SPnode * const spn2);

        /*! Return an SPnode tree representing the outer jacket of 2 subpavings.

        The outer jacket tree is the nodes in common between two SPnode trees.
        i.e. the 'outer jacket' that fits both of the subpavings represented by
        the given trees.

        \param spn1 root of tree representing a subpaving.
        \param spn2 root of tree representing another subpaving.
        \return root of a tree whose leaves represent the boxes that cover both
        subpavings.
        */
        static SPnode* spLeafBoxOuterJacket(const SPnode * const spn1,
                                        const SPnode * const spn2);


        /*! Return the sum of the volume of outer jacket of two subpavings.

        The outerjacket is found using vecLeafBoxOuterJacket.

        \param spn1 root of tree representing a subpaving.
        \param spn2 root of tree representing another subpaving.
        \return the volume of the smallest subpaving containing both subpavings.
        */
        static double volOuterJacket(const SPnode * const spn1,
                                    const SPnode * const spn2);

        /*! Return container of boxes represented by intersection of 2 subpavings.

        The intersection is the boxes covering space in the subpavings
        represented by both trees. This function ignores labels.

        \param boxes is a reference to a container of boxes to be filled.
        \param spn1 root of tree representing a subpaving (can be NULL).
        \param spn2 root of tree representing another subpaving (can be NULL).
        \return a container of boxes that is the intersection of the boxes
        represented by the leaves of spn1 and the boxes represented by the
        leaves ofspn2.
        */
        static BoxVec& vecLeafBoxIntersection(BoxVec& boxes,
                        const SPnode * const spn1, const SPnode * const spn2);

        /*! Return subpaving representing intersection of two subpavings.

        The intersection is the boxes covering space that that is represented by
        both trees. This function ignores labels.

        \param spn1 root of tree representing a subpaving.
        \param spn2 root of tree representing another subpaving.
        \return root of a tree whose leaves represent the boxes that cover
        space in common between both subpavings.
        */
        static SPnode* spLeafBoxIntersection(const SPnode * const spn1,
                                        const SPnode * const spn2);


        /*! Return the sum of the volume of intersection between two subpavings.

        The intersection is taken on leaf nodes using vecLeafBoxIntersection.

        \param spn1 first subpaving to intersect, can be NULL.
        \param spn2 second subpaving to intersect, can be NULL.
        \return the total volume of the space in common between the
        two subpavings.
        */
        static double volIntersection(const SPnode * const spn1,
                                    const SPnode * const spn2);


        /*! Return boxes of space that is the difference between two subpavings.

        The difference is the boxes covering space that is represented by spn1
        but is not in the subpaving represented by spn2.
        This function ignores labels.

        \param boxes is a reference to a container of boxes to be filled.
        \param spn1 root of tree representing a subpaving.
        \param spn2 root of tree representing another subpaving.
        \return boxes of space represented by spn1 that is not represented
        by spn2.
        */
        static BoxVec& vecLeafBoxDifference(BoxVec& boxes,
                        const SPnode * const spn1, const SPnode * const spn2);

        /*! Return boxes of space that is difference between box and subpaving.

        The difference is the boxes covering space that is in box1 but
        is not in the subpaving represented by spn2.
        This function ignores labels.

        \param boxes is a reference to a container of boxes to be filled.
        \param box1 a box.
        \param spn2 root of tree representing a subpaving.
        \return boxes in box1 that is not in subpaving represented by spn2.
        */
        static BoxVec& vecBoxNodeDifference(BoxVec& boxes,
                        ivector box1, const SPnode * const spn2);

        /*! Return a tree representing difference between two subpavings.

         The difference is the boxes covering space that is represented by spn1
         but is not in the subpaving represented by spn2.
         This function ignores labels.

        \param spn1 root of tree representing a subpaving.
        \param spn2 root of tree representing another subpaving.
        \return a root of a tree representing a subpaving which is the space
        represented by spn1 that is not represented by spn2.
        */
        static SPnode* spLeafBoxDifference(const SPnode * const spn1,
                                        const SPnode * const spn2);


        /*! Return the sum of the volume of the difference between 2 subpavings.

        The difference is taken on leaf nodes using vecLeafBoxDifference.

        \param spn1 root of tree representing a subpaving.
        \param spn2 root of tree representing another subpaving.
        \return the total volume of the space represented by spn1 that is not
        represented by spn2.
        */
        static double volDifference(const SPnode * const spn1,
                                    const SPnode * const spn2);


        /*! \brief Forms a minimal SPnode subpaving from leaf boxes

        Make a minimal subpaving tree from a list of interval vectors which
        are represented by leaves of the tree.  The root of the subpaving tree
        will have Box = root, and the leaves in the list will be formable by a
        series of bisections of the given root.

        MakeTreeFromLeaves is applied recursively on bisected halves of root
        and new lists there are no boxes in the list.

        Uses Reunite() and recursive calls to MakeTreeFromLeaves() to work
        upwards to form a minimal subpaving tree.

        \param root the root of the tree.
        \param leafList a collection of non-overlapping interval vector leaves
        each of which can be formed by series of bisections of the given root.
        \return a regular minimal subpaving with rootbox root.
        */
        static SPnode* makeTreeFromLeaves(ivector& root, ImageList& leafList);

        /*! \brief Forms a minimal SPnode subpaving from voxel boxes

        Make a minimal subpaving tree from a list of interval vectors which
        approximate the leaves of the tree.  The root of the subpaving tree will
        have Box = root, and the leaves in the list will have the same width in
        each dimension and be formable by a series of bisections of the given
        root.  i.e. each leaf will be the same size as each other leaf and will
        be a equal-sided hypercube.

        MakeTreeFromVoxels is applied recursively on bisected halves of root
        and new lists until either there are no boxes in the list or the
        largest diameter of the root the smallest we would expect given spacing
        or the root is equal to the largest box in the list.

        Uses Reunite() and recursive calls to MakeTreeFromVoxels() to work
        upwards to form a minimal subpaving tree

        \param root the root of the tree.
        \param leafList a collection of non-overlapping interval vector leaves
        each of which is approximately the same as the boxes formed by series
        of bisections of the given root.
        \param spacing is the spacing from the voxel data, ie the number of
        voxels in any dimension (assumed to be the same for all dimensions).
        \param dim is the number of dimensions we are using.
        \return a regular minimal subpaving with rootbox root.
        */
        static SPnode* makeTreeFromVoxels(ivector& root, ImageList& leafList,
                        double spacing, size_t dim);

        /*! \brief Make a subpaving from vtk file data

        Expects a file of structured point vtk data, with 10 header lines,
        spacing on 4th line, and 255 signifying voxel in the image.
        Uses MakeTreeFromVoxels(...)

        \param filename is the name of the file to get the vtk data from.
        \return a pointer to the root node of a new tree (can be null).
        */
        static SPnode* vtkPaving(const std::string filename);
        
        //src_trunk_0701
        	/*! \brief Swap this and another node.
		
		Swaps all the data members of this with the other node. 
				
		\param spn a reference to the node to swap with
		\post this is identical,in terms of its data members, 
		to spn before the swap, and spn is
		identical to this after the swap.*/
		void swap (SPnode& spn); //throw()



    };
    // end of SPnode class

    /*! a class for spnode-related exceptions.
    */
    class SPnodeException : public std::exception
    {
       std::string s;
       public:
       SPnodeException(std::string ss);
       ~SPnodeException () throw ();
       virtual const char* what() const throw();
    };



    /*! \brief Output the contents of a SubPaving.

    Calls nodePrint recursively for each leaf node.
    */
    std::ostream & operator<<(std::ostream &os, const SPnode * const spn);

    /*! \brief Check if a SubPaving is empty.
    \return true if the given node is NULL or
    SPnode::isEmpty() is true */
    bool isEmpty(const SPnode * const spn);

    /*! \brief Check if a node is a leaf.
       
        \return true if the given node is not NULL
    and SPnode::isLeaf() is true.
    */
    bool isLeaf(const SPnode * const spn);


    /*! \brief Get the volume of the subpaving represented by spn.

    Uses nodeVolume() recursively on the leaf nodes.
    */
    double spVolume(const SPnode * const spn);

    /*! \brief Get the number of leaves of a tree (boxes in the subpaving)

    Counts leaves recursively.
    */
    size_t spLeaves(const SPnode * const spn);
	 

    /*! \brief Check for containment of interval vector in the SubPaving.
    \param z the interval vector we are testing for containment
    in a subpaving
    \param spn a pointer to the subpaving node we are testing to see
    if it contains z
    \return a BOOL_INTERVAL, ie BI_TRUE, or BI_FALSE,
    or BI_INDET if z overlaps the boundary of the subpaving spn.
    */
    BOOL_INTERVAL operator<=(const ivector& z, const SPnode * const spn);
	 
	 //gloria's additions//
	  /*! \brief Get the number of leaves of a tree (boxes in the subpaving)

    Counts leaves recursively.
    */
    size_t spTotalNodes(const SPnode * const spn);
	 //end of gloria's additions


} // end namespace subpavings

//src_trunk_0701
/*! A specialisation of std::swap for SPnode types.*/
namespace std
{
	template <>
	void swap(subpavings::SPnode & s1, 
			subpavings::SPnode & s2); // throw ()
	
}

#endif
