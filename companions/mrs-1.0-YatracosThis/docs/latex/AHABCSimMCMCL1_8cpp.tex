\hypertarget{AHABCSimMCMCL1_8cpp}{\subsection{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp \-File \-Reference}
\label{AHABCSimMCMCL1_8cpp}\index{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp@{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp}}
}
{\ttfamily \#include $<$iomanip$>$}\*
{\ttfamily \#include $<$time.\-h$>$}\*
{\ttfamily \#include $<$fstream$>$}\*
{\ttfamily \#include $<$sstream$>$}\*
{\ttfamily \#include $<$map$>$}\*
{\ttfamily \#include $<$iterator$>$}\*
{\ttfamily \#include \char`\"{}histall.\-hpp\char`\"{}}\*
{\ttfamily \#include \char`\"{}dataprep.\-hpp\char`\"{}}\*
{\ttfamily \#include \char`\"{}\-Small\-Classes.\-hpp\char`\"{}}\*
{\ttfamily \#include \char`\"{}\-M\-C\-M\-C\-G\-Rtools.\-hpp\char`\"{}}\*
{\ttfamily \#include $<$stdexcept$>$}\*
{\ttfamily \#include $<$functional$>$}\*
{\ttfamily \#include $<$algorithm$>$}\*
{\ttfamily \#include $<$cassert$>$}\*
\subsubsection*{\-Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{AHABCSimMCMCL1_8cpp_a38cc676e6c9f06e021b17e537b7bba1d}{\-M\-Y\-D\-E\-B\-U\-G}
\end{DoxyCompactItemize}
\subsubsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator} \hyperlink{AHABCSimMCMCL1_8cpp_a1991e0493ae21cdc93c50cc5f5507f66}{do\-M\-C\-M\-C\-G\-R\-Auto} (string dir\-Name, string sim\-Data\-Files, size\-\_\-t sampling\-Size, size\-\_\-t num\-Rep, double wt, double dx, double cov, int max\-Loops, int samples\-Needed, int thinout, cxsc\-::real tol, int min\-Points)
\item 
int \hyperlink{AHABCSimMCMCL1_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main} (int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}


\subsubsection{\-Define \-Documentation}
\hypertarget{AHABCSimMCMCL1_8cpp_a38cc676e6c9f06e021b17e537b7bba1d}{\index{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp@{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp}!\-M\-Y\-D\-E\-B\-U\-G@{\-M\-Y\-D\-E\-B\-U\-G}}
\index{\-M\-Y\-D\-E\-B\-U\-G@{\-M\-Y\-D\-E\-B\-U\-G}!AHABCSimMCMCL1.cpp@{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp}}
\paragraph[{\-M\-Y\-D\-E\-B\-U\-G}]{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf \-M\-Y\-D\-E\-B\-U\-G}}}\label{AHABCSimMCMCL1_8cpp_a38cc676e6c9f06e021b17e537b7bba1d}


\-Definition at line 50 of file \-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp.



\subsubsection{\-Function \-Documentation}
\hypertarget{AHABCSimMCMCL1_8cpp_a1991e0493ae21cdc93c50cc5f5507f66}{\index{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp@{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp}!do\-M\-C\-M\-C\-G\-R\-Auto@{do\-M\-C\-M\-C\-G\-R\-Auto}}
\index{do\-M\-C\-M\-C\-G\-R\-Auto@{do\-M\-C\-M\-C\-G\-R\-Auto}!AHABCSimMCMCL1.cpp@{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp}}
\paragraph[{do\-M\-C\-M\-C\-G\-R\-Auto}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Collator} {\bf do\-M\-C\-M\-C\-G\-R\-Auto} (
\begin{DoxyParamCaption}
\item[{string}]{dir\-Name, }
\item[{string}]{sim\-Data\-Files, }
\item[{size\-\_\-t}]{sampling\-Size, }
\item[{size\-\_\-t}]{num\-Rep, }
\item[{double}]{wt, }
\item[{double}]{dx, }
\item[{double}]{cov, }
\item[{int}]{max\-Loops, }
\item[{int}]{samples\-Needed, }
\item[{int}]{thinout, }
\item[{cxsc\-::real}]{tol, }
\item[{int}]{min\-Points}
\end{DoxyParamCaption}
)}}\label{AHABCSimMCMCL1_8cpp_a1991e0493ae21cdc93c50cc5f5507f66}


\-Definition at line 138 of file \-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp.



\-References add\-Data\-Ptrs(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::add\-To\-Collation(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::find\-Density\-Region(), subpavings\-::\-S\-Pnode\-::get\-Box(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::get\-Number\-Collated(), subpavings\-::\-Adaptive\-Histogram\-::get\-Sub\-Paving(), subpavings\-::\-Adaptive\-Histogram\-::insert\-From\-R\-S\-Sample(), subpavings\-::\-Adaptive\-Histogram\-::insert\-From\-R\-Vec(), \-Lab\-Pnt\-::\-L, subpavings\-::label\-Data\-From\-Filter(), taylor\-::\-Lb(), subpavings\-::\-L\-O\-G\-S\-A\-M\-P\-L\-E\-S, subpavings\-::\-Adaptive\-Histogram\-Collator\-::make\-Average(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::\-Adaptive\-Histogram\-Collator\-::output\-Average\-To\-Txt\-Tabs(), subpavings\-::output\-File\-Start(), output\-To\-File\-Vertical(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::output\-To\-Txt\-Tabs(), \-Lab\-Pnt\-::\-Pnt, subpavings\-::point\-Mass\-Filter(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::public\-Output\-Log(), subpavings\-::read\-Rvectors\-From\-Txt(), \-R\-S\-Sample\-::\-Samples, taylor\-::sqrt(), and taylor\-::\-Ub().


\begin{DoxyCode}
{
  //=========Some preliminaries for AHABC==================================//
   //set formatting fors input to oss
    ofstream os;         // ofstream object
    os << scientific;  // set formatting for input to oss
    os.precision(16);
 
   // set up a random number generator for uniform rvs in priority queue
    const gsl_rng_type * T;
    gsl_rng * r;
    //create a generator chosen by the environment variable GSL_RNG_TYPE
    gsl_rng_env_setup();
    T = gsl_rng_default;
    r = gsl_rng_alloc (T);
    long s = time (NULL) * getpid();
    gsl_rng_set(r, s);  

   //-------Setup to read in data files------------------------------------//
   //create a vector object to store the filenames of simulated data
  vector<string> simDataFilesVec;
  string fileName;
  cout << "Reading in file names for simulated data: " << endl;    
  ifstream file; // create file for input
  file.open(simDataFiles.c_str());
  // check if this file exists or not
  if ( !file ) { // exit if file doesn't exists'
    cerr << "Could not open " << simDataFiles << ". It does not exist." 
         << endl;
    exit(1);
  }
    // else read in the filenames
  // store the filenames in the vector simDataFilesVec
  while ( !file.eof() ) { // read until end of file or error
    file >> fileName;
    cout << fileName << endl; 
    simDataFilesVec.push_back(fileName);
  }
  // Somehow an extra line will be read in. Need to delete that extra line.
  simDataFilesVec.pop_back();
   
  //container to keep individual data containers for re-sampling
  vector<RVecData> unlabDataVec; //unlabelled data

   //container to keep both simulated and observed data to make root box
   RVecData* dataPtr;
  dataPtr = new RVecData; 

  // put all simulated data into container allData
  cout << "\nPut all data in a container to get rootbox: " << endl;
  for (size_t i = 0;  i < simDataFilesVec.size(); i++) {
    cout << simDataFilesVec[i] << endl;
    //read into allData
    bool retvalue = readRvectorsFromTxt((*dataPtr), simDataFilesVec[i], 0);
    if (retvalue == false)  {
      cerr << "Could not open " << simDataFiles << ". It does not exist." 
        << endl;
      exit(1);
    } 
    //cout << (*(dataPtr)).size() << "is the size of dataPtr at iteration " <<
       i << endl;
    //Then read each data set and push into unlabDataVec 
    RVecData unlabIndData;
    readRvectorsFromTxt(unlabIndData, simDataFilesVec[i], 0);
    unlabDataVec.push_back(unlabIndData);
  } // end of putting simulated data into container
  
  //Make root box from all the data
  cout << "\n" << endl;
  AdaptiveHistogram* histRoot;
  histRoot = new AdaptiveHistogram;
        //cout << (*(dataPtr)).size() << "is the size of dataPtr AFTER
       iteration "  << endl;
  histRoot->insertFromRVec((*dataPtr));
  ivector pavingBox = histRoot->getSubPaving()->getBox();
  //find the data dimensions from the first datapoint
  size_t dataDim = Ub(*(*dataPtr).begin()) - Lb(*(*dataPtr).begin()) + 1;
  cout << "Data has " << dataDim << " dimensions." << endl;
  
  delete dataPtr; //we do not need this in memory
  delete histRoot; //we do not need this in memory
  //-----end of setup to read in data files-------------------------------//
  
  //----go through each RVecData in unlabData for:-------------------------//
  //1. point mass filtering
  //2. build a histogram
  
  //Set up containers to contain weights for each mixture model
  vector< map<rvector, double, less<rvector> > > WeightPMVec;//for point mass
  vector<double> WeightHistVec; //for histogram
  vector<double> WeightPM;
  
    //Set up containers to contain histogram objects
  vector<AdaptiveHistogramCollator*> vecMCMCHist; //if method 2

  //Now loop through each RVecData
  vector<RVecData>::iterator unlabDataIt;
  RVecData::iterator dataIt;
  size_t D = 0;
  for (unlabDataIt = unlabDataVec.begin(); unlabDataIt < unlabDataVec.end(); 
      unlabDataIt++) 
  {
    //to label all output so that it is associated with the right data set
    ostringstream stmD;
    stmD << D+1;
    
    cout << "==============Simulated Data " << D+1 << "==========" << endl;
    RSSample labData; //for point mass filtering 
    if (dataDim == 1) { //for now, do this only in 1D
      //make a map for value of x (the key) and each of its respective 
      //counts (the value)
      map<rvector, size_t, less<rvector> > CountsMap;
      //run a point mass filtering to get "atomic" points
      pointMassFilter((*unlabDataIt), CountsMap);
  
      //Is there a more efficient way for the following:
      //Iterate through the data set again. Label point-mass with 0 and 
      //the rest with 1.
      //Also get a map for the EMF of  point mass data
      map<rvector,double, less<rvector> > EMFMap;
      map<rvector, double, less<rvector> >::iterator EMFMapIt;
      labelDataFromFilter((*unlabDataIt), labData, CountsMap, EMFMap);
          
      /*optional: output RSSample this to .txt
      vector<LabPnt>::iterator LabPntIt; //to iterate over labData.Samples
      string fileName = "Labelled";
      fileName += simDataFilesVec[D];
      oftream os;
      os.open(fileName.c_str());
      for (LabPntIt = labData.Samples.begin(); LabPntIt <
       labData.Samples.end();
        LabPntIt++) { ( *LabPntIt).Print(os);}
      os << flush;
      */ //end of optional output
    
      //Store the weights
      cout << "Atomic points and their EMFs" << endl;
      double pmWeight = 0.0;
      double MaxpmWeight = 0.0;
              rvector AtomWithMaxpm = EMFMap.begin()->first;
      for (EMFMapIt = EMFMap.begin(); EMFMapIt != EMFMap.end(); EMFMapIt++) {
        if(EMFMapIt->second > MaxpmWeight) 
        {//a messy way to keep the max atom and weight...
          MaxpmWeight=EMFMapIt->second;
          AtomWithMaxpm = EMFMapIt->first;
        }
        pmWeight += EMFMapIt->second;
        if( EMFMapIt->second < 0.0)// use < to skip the ? below
        {
          cout << setprecision(16) << EMFMapIt->first 
          << "\t" << EMFMapIt->second << endl;
          cout << "is this atomic in your experimental precision?" << endl; 
      getchar();
        }
      }
      cout << "Maximum Weight of a set of Atoms of size "<< EMFMap.size() 
        << " is " << MaxpmWeight << " at " << AtomWithMaxpm << endl;
      WeightHistVec.push_back(1.0 - pmWeight);
      WeightPMVec.push_back(EMFMap);
      WeightPM.push_back(pmWeight);
    
      //output the weights for the point mass so that we can plot the point
       mass
      //and the normalised histogram
      string weightFileName = dirName;
      weightFileName += "Weights";
      weightFileName += stmD.str();
      weightFileName += ".txt";
      os.open(weightFileName.c_str());
      map<rvector, double, less<rvector> > ::iterator mapIt;
      for (mapIt = (EMFMap).begin(); mapIt != (EMFMap).end(); mapIt++) {
        os << mapIt->second << "\t" << mapIt->first;
      }
      os << endl;
      os << flush;
      os.close();
      cout << "Weights output to " << weightFileName << endl; 
      cout << "=================================================" << endl;
    } // end of point mass filtering for 1D
  
    // Now build the histograms using MCMC with automated convergence
       diagnostics//
    cout  << "\nMaking MCMC histogram for simulated data in " 
        << simDataFilesVec[D] 
        << endl;

    // start by making the histograms that are the starting points for our
       chains
    // Gelman and Carlin [1996] recommend ten or more chains if the target
    // distribution is unimodal (Martinez and Martinze, 2000, p. 453)
    // the starting points are chosen to be widely dispersed
    bool successfulInsertionFirst, successfulInsertionSecond, 
      successfulInsertionThird;
    bool successfulPQSplitSecond;

    //pointers to Adaptivehistogram objects as starting conditions
    AdaptiveHistogram* myHistFirst;
    AdaptiveHistogram* myHistSecond;
    AdaptiveHistogram* myHistThird;
    if (dataDim == 1) {
      //histogram 1
      cout << "Starting Chain 1" << endl;
      myHistFirst = new AdaptiveHistogram(pavingBox);
      // put in the data in a 'pulse' with no splitting, ie into root box
      successfulInsertionFirst = myHistFirst->insertFromRSSample(labData, NOLOG
      , 1);
      
      //histogram 2
      cout << "Starting Chain 2" << endl;
      myHistSecond = new AdaptiveHistogram(pavingBox);
      // the same data into the second histogram
      successfulInsertionSecond = myHistSecond->insertFromRSSample(labData, 
      NOLOG, 1);
      successfulPQSplitSecond = false;
      if (successfulInsertionSecond) {
        // set up function objects for a priority split
        CompCount compCount;
        // split until number of leaves is >= minLeaves
        size_t minLeaves = 10;
        //size_t minLeaves = (labData.Samples.size()/50); // 20 when n = 1000
        CritLeaves_GTE critLeavesGTE(minLeaves);
        size_t minPQPoints = 1; // minimum of one data point in each box
        // do the priority split
        successfulPQSplitSecond = myHistSecond->prioritySplit(compCount,
             critLeavesGTE, NOLOG, minPQPoints); // no logging
      }

    } //end of making starting conditions for dataDim = 1
    
    else { // at current i do not have a point-mass filter set up for data with
       > 1. 
         // But should bring in Jenny's code for filtering.
      //histogram 1
      cout << "Histogram 1" << endl;
      myHistFirst = new AdaptiveHistogram(pavingBox);
      // put in the data in a 'pulse' with no splitting, ie into root box
      successfulInsertionFirst = myHistFirst->insertFromRVec((*unlabDataIt), 
      NOLOG);
      
      //histogram 2
      cout << "Histogram 2" << endl;
      myHistSecond = new AdaptiveHistogram(pavingBox);
      // the same data into the second histogram
      successfulInsertionSecond = myHistSecond->insertFromRVec((*unlabDataIt), 
      NOLOG);
      successfulPQSplitSecond = false;
      if (successfulInsertionSecond) {
        // set up function objects for a priority split
        CompCount compCount;
        // split until number of leaves is >= minLeaves
        size_t minLeaves = 10;
        //size_t minLeaves = ((*unlabDataIt).size()/50); // 20 when n = 1000
        CritLeaves_GTE critLeavesGTE(minLeaves);
        size_t minPQPoints = 0; // minimum of one data point in each box
        // do the priority split
        successfulPQSplitSecond = myHistSecond->prioritySplit(compCount,
             critLeavesGTE, NOLOG, minPQPoints); // no logging
      }
    } // end of making histograms for dataDim > 1

    // set up for MCMC
    // our return object, if all goes well
    AdaptiveHistogramCollator* myCollPtr;
    myCollPtr = new AdaptiveHistogramCollator; 
  
    //set up for output
    // use the cxsc manipulators for changing printing of cxsc::reals to
       console
    int prec = 15;
    cout << cxsc::SaveOpt;
    cout << cxsc::Variable;
    cout << cxsc::SetPrecision(prec+2, prec);
  
    if (successfulInsertionFirst && successfulPQSplitSecond) {
      // containers for adaptive histograms
      // the starting points of the chains
      vector< AdaptiveHistogram* > hists;
      hists.push_back(myHistFirst);
      hists.push_back(myHistSecond);
  
      // how many chains are to be run = number starting histograms
      size_t chains = hists.size(); 
      
      if (chains < 2) {
        throw HistException("Chains < 2");
      }
  
      // set up ingredients for MCMC
      UniformProposal proposal; // set up proposal distribution object
      LogCatalanPrior logPrior; // set up prior distribution object
  
      LOGGING_LEVEL logging = LOGSAMPLES; // leave it like this!
      LOGGING_LEVEL loggingInChangeStates = NOLOG;
  
      gsl_rng * rgsl = NULL;
  
      // should check that each hist to be done has a paving
  
      // set up a random number generator for uniform rvs
      const gsl_rng_type * tgsl;
      // set the library variables *gsl_rng_default and
      // gsl_rng_default_seed to default environmental vars
      gsl_rng_env_setup();
      tgsl = gsl_rng_default; // make tgsl the default type
      rgsl = gsl_rng_alloc (tgsl); // set up with default seed
      
      // set a seed for the data
      int mcmcSeed = 1234;
      gsl_rng_set(rgsl, mcmcSeed); // change the seed to our seed
  
      // set up containers for the stuff we need pass to the MCMC engine
      vector<SPSnodeList> nodeLists(chains);
      Size_tVec numLeavesVec(chains);
      Size_tVec numCherriesVec(chains);
  
      vector<string> sequenceStateFilenames(chains);
      vector<string> sequenceAverageFilenames(chains);
      vector<string> sequenceCollationFilenames(chains);
      vector<string> sequenceDiffsToAverageFilenames(chains);
      vector<string> L1ColNames(chains);
      vector<string> L1RunningSumColNames(chains);
      vector<string> L1SampleVarianceColNames(chains);
      
      std::string baseSequenceStateFilename = dirName;
      baseSequenceStateFilename += "SequenceStates";
      baseSequenceStateFilename += stmD.str();
      std::string baseSequenceStateCollationFilename = dirName;
      baseSequenceStateCollationFilename += "SequenceStateCollations";
      baseSequenceStateCollationFilename +=  stmD.str();
      std::string baseSequenceStateAverageFilename = dirName; 
      baseSequenceStateAverageFilename += "SequenceStateAverages";
      baseSequenceStateAverageFilename += stmD.str();
      std::string baseSequenceStateDiffsToAverageFilename = dirName;
      baseSequenceStateDiffsToAverageFilename += "SequenceStateDiffsToAverage";
      baseSequenceStateDiffsToAverageFilename += stmD.str();
      
      std::string  baseL1ColName = dirName;
      baseL1ColName += "L1_";
      std::string  baseL1RunningSumColName = dirName;
      baseL1RunningSumColName += "L1Sum_";
      std::string  baseL1SampleVarianceColName = dirName;
      baseL1SampleVarianceColName += "L1Var_";
      std::string  overallL1RunningSumColName = dirName;
      overallL1RunningSumColName += "OverallL1Sum";
      
      // files for outputing samples
      std::string samplesCollFilename = dirName;
      samplesCollFilename += "CollatedSamplesFromMCMCGRAuto";
      samplesCollFilename += stmD.str();
      samplesCollFilename += ".txt";
      std::string samplesLogFilename = dirName;
      samplesLogFilename += "LogSamplesFromMCMCGRAuto";
      samplesLogFilename += stmD.str();
      samplesLogFilename += ".txt";
      outputFileStart(samplesCollFilename);
      
      // should realy check on LOGSAMPLESANDGRAPH as well here
      // but at the moment I have not done anything about graphing
      if (logging = LOGSAMPLES) {
        outputFileStart(samplesLogFilename);
      }
      
      //std::string overSequenceAvgCollFilename =
       "CollationsOfAveragesOverSequences.txt";
      //outputFileStart(overSequenceAvgCollFilename);
      
      // a name for the file of diagnostics 
      std::string GRL1Filename = dirName;
      GRL1Filename += "GelmanRubinL1Scalar";
      GRL1Filename += stmD.str();
      GRL1Filename += ".txt";
      //outputFileStart(GRL1Filename);
      
      // a name for the file of working calculations for the diagnostics 
      std::string GRL1WorkingCalcsFilename = dirName;
      GRL1WorkingCalcsFilename += "GelmanRubinL1ScalarWorkingCalcs";
      GRL1WorkingCalcsFilename += stmD.str();
      GRL1WorkingCalcsFilename += ".txt";
      //outputFileStart(GRL1WorkingCalcsFilename);
  
      /* containers for summaries for the 
      * L1-distances-to-average scalar convergence diagnostics */

      /* for each chain we need a container for current L1-distances-to-average
       
       * relative to the current average for all histogram states in the chain
       so far.
       * This is reused and overwritten each time a state is added to the chain
       * and is just a working-space to facilitate getting the L1s we want. */
      std::vector < RealVec > currentL1s(chains); 
  
      // one vector of L1-distances-to-average as a RealVec for each chain
      std::vector < RealVec >* distancesL1Ptr = new std::vector < RealVec >(
      chains);  
  
      /* vector containing one running sum of L1-distances-to-average for each
       chain
      we can work out the average v = L1 for each chain so far from this
      start with a running sum of 0.0 for each chain */
      RealVec* runningSumL1Ptr = new RealVec (chains, cxsc::real(0.0));
      
      /* vector containing one running sum of 
      squared-L1-distances-to-average for each chain
      we can work out the average of the squared v's ie v^2 = L1^2
      for each chain so far from this
      start with a running sum of 0.0 for each chain.
      (Use a dotprecision for each running sum to keep accuracy 
      when accumulating products of reals) */
      VecDotPrec runningSumL1Squared(chains, cxsc::dotprecision(0.0));
  
      /* value of running sum of L1-distances-to-average over all chains
      we can work out the average v = L1 over all chains so far from this */
      real runningSumL1AllChains = cxsc::real(0.0);
      
      #ifdef MYDEBUG
        // keep a vector of all the overall running sums as well
        RealVec* runningSumL1OverallPtr = new RealVec(1, cxsc::real(0.0));
        // keep a vector of the runningsums for each chain as well
        std::vector < RealVec >* runningSumL1ChainsPtr 
                  = new std::vector < RealVec >(chains);
        // keep a vector of the sample variances for each chain as well
        std::vector < RealVec >* sampleVariancesPtr 
                  = new std::vector < RealVec >(chains);
        /* keep a vector of the flag for L1 convergence
         * (it's not a real, but easier to output it if we treat it like one) 
      */
        RealVec* rhatL1FlagPtr = new RealVec(1, cxsc::real(0.0));
        
        /* keep a vector of indicators for whether a state was sampled
         * (not a real, but easier to output it if we treat it like one) */
        RealVec* sampledIndPtr = new RealVec(1, cxsc::real(0.0));
      #endif
  
      RealVec* Ws_L1Ptr = new RealVec(); // to hold the Ws_L1
      RealVec* Bs_L1Ptr = new RealVec(); // to hold the Bs_L1
      RealVec* estVarV_L1Ptr = new RealVec(); // to hold the estimated var(v)
      RealVec* sqrtRhat_L1Ptr = new RealVec(); // to hold the sqrtRhats
  
      // container of each state at each sequence
      vector<AdaptiveHistogramCollator*> sequenceCollators(chains);
  
      //container for the collation of the averages over each sequence at each
       state
      //vector<AdaptiveHistogramCollator*> averageCollators;
  
      //AdaptiveHistogramCollator masterCollator; // not newed so no need to
       delete
  
      bool cancontinue = true;
  
      // this loop is just setting up containers of file names
      // and getting info from the starting histograms that is
      // needed to start the chains
      // and a container of collators, one for each chain,
      for (size_t ci = 0; ci < chains; ci++) {
        
        // do not comment these out
        std::ostringstream stm1;
        stm1 << baseSequenceStateFilename << ci << ".txt";
        sequenceStateFilenames[ci] = stm1.str();
        outputFileStart(sequenceStateFilenames[ci]);
  
        #ifdef MYDEBUG
          {
            std::ostringstream stm;
            stm << baseSequenceStateCollationFilename << ci << ".txt";
            sequenceCollationFilenames[ci] = stm.str();
            outputFileStart(sequenceCollationFilenames[ci]);
          }
          {
            std::ostringstream stm;
            stm << baseSequenceStateAverageFilename << ci << ".txt";
            sequenceAverageFilenames[ci] = stm.str();
            outputFileStart(sequenceAverageFilenames[ci]);
          }
          {
            std::ostringstream stm;
            stm << baseSequenceStateDiffsToAverageFilename << ci << ".txt";
            sequenceDiffsToAverageFilenames[ci] = stm.str();
            outputFileStart(sequenceDiffsToAverageFilenames[ci]);
          }
          {
            std::ostringstream stm;
            stm << baseL1ColName << ci;
            L1ColNames[ci] = stm.str();
          }
          {
            std::ostringstream stm;
            stm << baseL1RunningSumColName << ci;
            L1RunningSumColNames[ci] = stm.str();
          }
          
          {
            std::ostringstream stm;
            stm << baseL1SampleVarianceColName << ci;
            L1SampleVarianceColNames[ci] = stm.str();
          }
        #endif
        /* we only need to do this because we are doing a step-by-step change
       of the
        * histogram states 'from the outside', ie through this example:  we
       need to
        * collect the stuff the histogram's changeMCMCstate method needs to
       make one 
        * change.  */
        
        // set up a container for the leaf children
        SPSnodePtrs leafVec;
        // set up a container for the subleaf children
        SPSnodePtrs cherryVec;
  
        size_t numLeaves = 0;
        size_t numCherries = 0;
  
        // fill the container with the leaf children
        hists[ci]->getSubPaving()->getLeaves(leafVec);
        // fill the container with the subleaf children
        hists[ci]->getSubPaving()->getSubLeaves(cherryVec);
  
        numCherries = cherryVec.size();
  
        // check if node is still splittable
        if (!leafVec.empty()) {
           // but only put into the container the leaves which, if split,
           // would have at least minPoints data points associated with them
           SPSnodePtrsItr lit;
           for (lit = leafVec.begin(); lit < leafVec.end(); lit++) {
              if (((*lit)->getLeftCountIfSplit() >= minPoints) &&
                ((*lit)->getRightCountIfSplit() >= minPoints)) {
                   // leaf can go into container
                   nodeLists[ci].push_back(*lit);
                   numLeaves++;
              }
           }
        }
  
        // no need to check on cherries - they can all go in
        if (numCherries > 0)
           nodeLists[ci].insert(nodeLists[ci].end(), cherryVec.begin(),
                           cherryVec.end());
        if (nodeLists[ci].size() == 0) {
           cancontinue = false;
           break; // break out of the for loop
           std::cout << "No changeable nodes given minPoints = "
                   << minPoints << " in histogram " << ci
                   << ". Sorry, aborting MCMC." << std::endl;
        }
  
        numLeavesVec[ci] = numLeaves;
        numCherriesVec[ci] = numCherries;
  
        // set up one collator for each chain, starting it with the first
       histogram state
        sequenceCollators[ci] = new AdaptiveHistogramCollator( *hists[ci] );
      
        // collect the calculations for the starting points
        
        // one vector of L1s for each chain
        distancesL1Ptr->at(ci).push_back( cxsc::real(0.0) ); 
        
        #ifdef MYDEBUG
          sampleVariancesPtr->at(ci).push_back(cxsc::real(0.0) );
          runningSumL1ChainsPtr->at(ci).push_back( cxsc::real(0.0) );
        #endif
        
        /* running sum of L1s for each chain, held in runningSumL1Ptr
        are all initialised to 0.0 already 
        * 
        * running sum of squared L1s for each chain, held in 
       runningSumL1SquaredPtr
        are all initialised to 0.0 already
        */ 
        #ifdef MYDEBUG_OUTPUT
          // make files for current average and current collations
        {
          sequenceCollators[ci]->publicOutputLog(sequenceCollationFilenames[ci]
      , 1);
          
          AdaptiveHistogramCollator colltempavg
                      = sequenceCollators[ci]->makeAverage();
          colltempavg.publicOutputLog(sequenceAverageFilenames[ci], 1);
          
          AdaptiveHistogramCollator colltempdiffs
                      = sequenceCollators[ci]->makeDifferencesToAverage();
          colltempdiffs.publicOutputLog(sequenceDiffsToAverageFilenames[ci], 1)
      ;
        } // temp objects go out of scope here  
          
        #endif
      
      } // end loop through chains setting up things to be able to start
      
      /* the overall running sum runningSumL1AllChains 
       * was initialised to 0.0 
       * and #ifdef MYDEBUG, runningSumL1Overall was initialised to contain one
       0.0 
       * and similarly rhatL1FlagPtr was initialised to contain one 0.0*/
      
      
      /* start with the convergence statistics for chains with just one state
       in*/
      // the Ws_L1
      Ws_L1Ptr->push_back(cxsc::real(0.0)); 
      // the Bs_L1
      Bs_L1Ptr->push_back(cxsc::real(0.0)); 
      // the estimated var(v)
      estVarV_L1Ptr->push_back(cxsc::real(0.0)); 
      // the sqrtRhats
      sqrtRhat_L1Ptr->push_back(cxsc::real(0.0)); 
  
      bool goodLoop = cancontinue;
      
      if (cancontinue) cout << "About to do MCMC" << endl;
  
      /* set up some variables we need to keep track of states and sampling */

      int samplesSoFar = 0;
      
      size_t states = 1;  /* keep track of states in the chain = 1 so far 
                because  we already have the initial histograms */
      
      /* varibles for monitoring convergence
       * we only have one scalar value at the moment (L1-distance-to-average)
       but
       * we might have more - might want convergence on all diagnostics */
      int rhatFlagCounter = 0;
      int rhatFlagCounterThreshold = 1;   /* how many of the scalar values must
       have
                        * diagnostic within limits for sampling to start?
                        * usually this would probably be the number
                        * of scalar values being used? */
      int rhatL1Flag = 0; // indicator for whether we are burntin on L1 scalar
       value
      int burntin = 0; // indicator for whether we consider ourselves burntin
       yet
      
      size_t burntinReachedState = 0; // keep track of when we (last) reached
       burnin
      
      // counter to keep track of loops
      int loopCounter = 0;
      
      /* We also need a collator for the samples*/
      AdaptiveHistogramCollator* samplesColl = new AdaptiveHistogramCollator();
      
      while (goodLoop && (loopCounter < maxLoops) && (samplesSoFar < 
      samplesNeeded)) {
        
        #ifdef MYDEBUG_OUTPUT
          cout << "****** Change in state number " << states << " ******" << 
      endl;
        #endif
        
        loopCounter++;
        // a collator for the averages for this loop
        //AdaptiveHistogramCollator* avgColl = new AdaptiveHistogramCollator;
  
        /* we want to accumulate the sample variance of the scalar summary
         * for each chain up to the point reached in this loop */
        cxsc::real sumOfSampleVariancesOverChains(0.0);
        
        /* also accumulate sum over all chains of the square of 
         * the running sum of L1-distances-to-average 
         * for each chain up to the point reached in this loop */
        cxsc::real sumOfSquaresOfRunningSums(0.0);
        
        // for each histogram in turn, change the state
        /* this is all a fudge - changeMCMCstate should just be a private
         * method of the histograms but I think I made it public so that
         * I could use it here in the example as a first step to being
         * able to make all of this chain convergence stuff back into
         * a method of the histograms themselves
         */
        for (size_t ci = 0; ci < chains; ci++) {
          
          #ifdef MYDEBUG_OUTPUT
            cout << "--- chain index " << ci << " ---" << endl;
          #endif
          
          /* I refer to the current chain, indexed by ci, as 'the chain
           * in the comments inside this loop */
  
          // changeMCMCState for the chain
          // updates nodes, numLeaves, numCherries, i
          goodLoop = hists[ci]->changeMCMCState(nodeLists[ci],
                 numLeavesVec[ci], numCherriesVec[ci],
                 proposal, logPrior, minPoints,
                 rgsl, loggingInChangeStates,
                 sequenceStateFilenames[ci], states);
                 
          #ifdef FORCEFAILMCMCLOOP
            // for debugging - force a loop failure and see what happens to
       program
            if (states == 5) goodLoop = false;
          #endif 

          if (!goodLoop) {
            throw std::runtime_error("Failed to do MCMC change in state");
            // stop if we aren't happy
          }
          
          if ((numLeavesVec[ci] == 0 && numCherriesVec[ci] == 0)) {
            throw std::runtime_error("No more leaves or cherries in MCMC");
          }
          
          // so assume all is okay if we have not just thrown an exception
          
          // collate the current sample state in the chain
          sequenceCollators[ci]->addToCollation(*(hists[ci]));

          // collect the L1 distances and update the runnings sums
          
          // update our collection of L1s to average for all histogram states
       in the chain
          currentL1s[ci] = sequenceCollators[ci]->getL1DistancesToAverage(
      currentL1s[ci]);
          /* we actually only want the L1 for the last state in the chain,
           * which we collect in the right vector for this chain in distancesL1
       */
          cxsc::real lastStateL1 = currentL1s[ci].back();
          distancesL1Ptr->at(ci).push_back( lastStateL1 );  
          
          
          // update the running sum of L1s for the chain, held in runningSumL1
          cxsc::real newRunningSum = runningSumL1Ptr->at(ci) + lastStateL1;
          runningSumL1Ptr->at(ci) = newRunningSum;
          
          // accumulate the square of the running sum of L1s 
          sumOfSquaresOfRunningSums += newRunningSum*newRunningSum;
          
          /* update the running sum of squared L1s over this chain
           *  held in runningSumL1Squared as a dot precision */
          cxsc::accumulate( runningSumL1Squared[ci], lastStateL1, lastStateL1 )
      ;
          
          // update  the overall running sum runningSumL1AllChains 
          runningSumL1AllChains += lastStateL1;
          
          /* how many histograms have we got so far?
           * this chain should have states+1 states in it.
           * because we have not yet incremented states.*/
          size_t n = sequenceCollators[ci]->getNumberCollated();
          assert(n == states + 1);
          
          /* and n should be at least 2 because we started with the 
           * starting histogram and have now added another state.*/
          assert(n > 1);
          /* could just use n - 1 = states + 1 - 1 = states in formula below
           * once we are happy it is all working!
          
          /* accumulate the sample variance for this chain: 
           * sample variance for the scalar summary v = L1-to-average
           * calculated as (sum of squares - n * square of averages)/(n-1)
           * which equals (sum of squares - square of sums/n)/(n-1) */
          cxsc::real thisSampleVariance( ( 1.0/(n-1) )*( cxsc::rnd(
      runningSumL1Squared[ci])
                    -  (newRunningSum*newRunningSum/(n * 1.0)) ) );
          sumOfSampleVariancesOverChains += thisSampleVariance;
          
          #ifdef MYDEBUG
            sampleVariancesPtr->at(ci).push_back( thisSampleVariance );
            runningSumL1ChainsPtr->at(ci).push_back (newRunningSum);
          #endif
  
          #ifdef MYDEBUG_OUTPUT
            //check thisSampleVariance is correct, doing it the long way
            // distancesL1[ci] has the v_ij for each chain i
            assert( n == distancesL1[ci].size() );
            cxsc::real acc(0.0);
            for (RealVecItr it = distancesL1[ci].begin(); it < distancesL1[ci].
      end(); ++it) {
              acc+= (*it);
            }
            cxsc::real av = acc/(n * 1.0);
            cxsc::dotprecision accDiffs(0.0);
            for (RealVecItr it = distancesL1[ci].begin(); it < distancesL1[ci].
      end(); ++it) {
              cxsc::real thisDiff = (*it) - av;
              // sum up the squares of the differences compared to overall
       average
              cxsc::accumulate(accDiffs, thisDiff, thisDiff);
            }
            cxsc::real altVar = rnd(accDiffs)/( n - 1.0 );
            
            cout << "\nthisSampleVariance is\t" << thisSampleVariance << endl;
            cout << "altSampleVar is\t" << altVar << endl;
            //assert(cxsc::_double(thisSampleVariance) == cxsc::_double(altVar)
       );
          #endif
          
          #ifdef MYDEBUG_OUTPUT
            // make files for current average and current collations
            sequenceCollators[ci]->publicOutputLog(sequenceCollationFilenames[
      ci], states + 1);
          
            AdaptiveHistogramCollator colltempavg
                        = sequenceCollators[ci]->makeAverage();
            colltempavg.publicOutputLog(sequenceAverageFilenames[ci], states + 
      1);
            
            AdaptiveHistogramCollator colltempdiffs
                        = sequenceCollators[ci]->makeDifferencesToAverage();
            colltempdiffs.publicOutputLog(sequenceDiffsToAverageFilenames[ci], 
      states + 1);
          #endif
            
        } // end change state for each histogram in turn
  
        /* each chain now has a new state which has been collated into
         * its collator and info for L1 distances-to-average have been
       collected
         * and the sample variance of the scalar summary for each chain
         * has been put into sampleVariances, so we can now work out the
         * convergence diagnostics */
  
        // increment number of states   
        states++;

        #ifdef MYDEBUG
          // store the current runningSumL1AllChains as well
          runningSumL1OverallPtr->push_back(runningSumL1AllChains);
          
        #endif
  
        // the Ws_L1: average, over chains, of sample variance of scalar value
        cxsc::real thisW = sumOfSampleVariancesOverChains/(chains * 1.0); 
        Ws_L1Ptr->push_back(thisW); 
        // the Bs_L1
        cxsc::real thisB = (1.0/( (chains - 1) * states ) 
                  * ( sumOfSquaresOfRunningSums 
                  - (runningSumL1AllChains 
                  * runningSumL1AllChains/(chains * 1.0)) ) );
        Bs_L1Ptr->push_back(thisB); 
        
        #ifdef MYDEBUG_OUTPUT
          //check thisB is correct, doing it the long way
          // runningSumL1 has one running sum for each chain
          RealVec chainAverages;
          cxsc::real accRunningSums(0.0);
          for (RealVecItr it = runningSumL1.begin(); it < runningSumL1.end(); +
      +it) {
            cxsc::real thisChainRunningSum = (*it);
            cxsc::real thisChainAv = thisChainRunningSum/(states * 1.0);
            chainAverages.push_back(thisChainAv);
            accRunningSums+=thisChainRunningSum;
          }
          cxsc::real overallAv = accRunningSums/(states * chains * 1.0);
          cxsc::dotprecision accDiffs(0.0);
          for (RealVecItr it = chainAverages.begin(); it < chainAverages.end();
       ++it) {
            cxsc::real thisDiff = (*it) - overallAv;
            // sum up the squares of the differences compared to overall
       average
            cxsc::accumulate(accDiffs, thisDiff, thisDiff);
          }
          cxsc::real altB = rnd(accDiffs)*( states/(chains - 1.0) );
          
          cout << "\nthisB is\t" << thisB << endl;
          cout << "altB is\t" << altB << endl;
          //assert(thisB == altB);
        
        #endif
        
        // the estimated var(v)
        cxsc::real thisVarV = states/(states-1.0) * thisW + (1.0/states)*thisB;
        estVarV_L1Ptr->push_back(thisVarV); 
        // the sqrtRhats
        cxsc::real thisSqrtRhat_L1 = cxsc::sqrt(thisVarV/thisW);
        sqrtRhat_L1Ptr->push_back(thisSqrtRhat_L1); 
        
        // check on the diagnostics
        if (thisSqrtRhat_L1 <= 1.0 + tol && thisSqrtRhat_L1 >= 1.0 - tol) {
          //flagRhat++; //increment the flagRhat counter
          
          // if we have not been converged before on this scalar value
          if (!rhatL1Flag)  {
            #ifdef MYDEBUG
              
              cout << "\nL1 convergence test satisfied at " 
                  << states << endl;
              
            #endif
          
            // set the flag for this scalar value
            rhatL1Flag = 1;
            
            // and increment the flag counter = we are converged on this scalar
       value
            rhatFlagCounter ++; 
          }
        }
        else { // not converged on this scalar value
          
          // if we were okay on this scalar value before
          if (rhatL1Flag) {
            #ifdef MYDEBUG
              cout << "\nL1 convergence test NOT now satisfied at " 
                << states << endl;
          
            #endif
            rhatL1Flag = 0; // update the flag
            rhatFlagCounter--; // decrement the flag counter
          }     
        }
        
        #ifdef MYDEBUG
          // store the L1flag as well, as a real, which is a fudge...
          rhatL1FlagPtr->push_back(rhatL1Flag);
          
        #endif
        
        /* we'd do this for all other scalar values as well, if applicable,
       then ...*/
          
        // check if we have enough flags to consider ourselves burntin
        if ( !burntin && (rhatFlagCounter >= rhatFlagCounterThreshold) ) {
          
          burntin = 1; 
          burntinReachedState = states;
          
          #ifdef MYDEBUG
            // if we have not been burntin, give a message
             cout << "Burnin convergence test satisfied at state " 
                << burntinReachedState << endl;
            
          #endif
        }
        
        // but it may be that we were burntin and no longer are
        else if ( burntin && (rhatFlagCounter < rhatFlagCounterThreshold) ) {
          
          burntin = 0; 
          burntinReachedState = 0;
          
          delete samplesColl; // get rid of the old samples collator
          samplesColl = new AdaptiveHistogramCollator(); // and take a new one
          
          samplesSoFar = 0;
          
          // want to change all the 1's in sampledIndPtr so far to 0s
          cxsc::real newVal(0.0);
          
          #ifdef MYDEBUG
            std::replace_if (sampledIndPtr->begin(), sampledIndPtr->end(), 
              std::bind2nd(greater< cxsc::real >(),newVal), newVal);
          #endif
          
          // restart the log file if we are logging
          // note nothing done here yet about logging graphs as well  
          if (logging = LOGSAMPLES) {
            outputFileStart(samplesLogFilename);
          }   
          
          #ifdef MYDEBUG
            cout << "Burnin convergence test now NOT satisfied at state " 
                << states << endl;
            
          #endif
        }
        
        /* take samples if we are burntin and this is a sampling point
       according to 
         * the thinout specified 
         * note - we will only be in the loop at all if we still need more
       samples*/
        if (burntin && ((states-burntinReachedState)%thinout == 0)) {
          
          #ifdef MYDEBUG
            cout << "sampling at state " << states << endl;
            sampledIndPtr->push_back (cxsc::real(1.0)); 
  
          #endif
          
          // take one sample from each chain until we have enough samples
          // and increment samplesSoFar for each one taken
          vector<AdaptiveHistogram*>::iterator ait;
          for (ait = hists.begin(); 
              (ait < hists.end() && samplesSoFar < samplesNeeded);
              ++ait) {
            
            samplesColl->addToCollation(**ait);
            
            samplesSoFar++;
            
            if (logging = LOGSAMPLES) {
              (*ait)->outputLogPlain(samplesLogFilename, samplesSoFar);
            }
            
          }
          
        } // finished taking samples for this loop
        else {
          #ifdef MYDEBUG
            
            sampledIndPtr->push_back (cxsc::real(0.0)); 
          #endif
        }
        
        assert(samplesColl->getNumberCollated() == samplesSoFar);
        
        // back into loop
        #if !defined(MYDEBUG_OUTPUT)
          #ifdef MYDEBUG
            // output a line every now and again so that we know it's still
       alive
            if (loopCounter%100 == 0) {
              cout << "\n...I'm still going: completed change in state number "
       << states << " ...\n" << endl;
            }
          #endif
        #endif
  
      }    // finished while loop - either loop failed or reached maxLoops or
       have all our samples
      
      cancontinue = goodLoop;
      
      #ifdef MYDEBUG_OUTPUT
        cout << "****** finished all loops loopCounter = " << loopCounter << "
       ******" << endl;
      #endif
      
      #ifdef MYDEBUG
        cout << "number of samples collected is = " << samplesColl->
      getNumberCollated() << endl;
      #endif
  
      // free the random number generator
      gsl_rng_free (rgsl);
  
      cout << cxsc::RestoreOpt; // undo changes we made to cout printing for
       cxsc values

      /* is all okay with the loop
       * and we have all our samples */
      if (cancontinue && (samplesSoFar >= samplesNeeded) ) {  
        #ifdef MYDEBUG
          // output the overall collator
          samplesColl->outputToTxtTabs(samplesCollFilename);
        #endif
        
        // make the return object be the average of the samples
        *myCollPtr = samplesColl->makeAverage();
        
        // keep the MCMC histogram into a container
        vecMCMCHist.push_back(myCollPtr); 
        // optional output for histogram
        string histFileName = dirName;
        histFileName += "AverageMCMC"; 
        histFileName += stmD.str();
        histFileName += ".txt";
        myCollPtr->outputAverageToTxtTabs(histFileName);
        // end of optional output for histogram

        // output the convergence diagnostics
        /*
        outputFile(GRL1Filename, "\n\n\n Final diagnostics");
        outputFile(GRL1Filename, "W", Ws_L1);
        outputFile(GRL1Filename, "");
        outputFile(GRL1Filename, "B", Bs_L1);
        outputFile(GRL1Filename, "");
        outputFile(GRL1Filename, "estVarV", estVarV_L1);
        outputFile(GRL1Filename, "");
        outputFile(GRL1Filename, "sqrtRhat",sqrtRhat_L1);
        outputFile(GRL1Filename, "");
        */
        {
          std::vector < std::string > colNames;
          colNames.push_back("W");
          colNames.push_back("B");
          colNames.push_back("estVarV");
          colNames.push_back("sqrtRhat");
          #ifdef MYDEBUG
            colNames.push_back("rhatL1Flag");
            colNames.push_back("sampled?");
          #endif
          std::vector < RealVec* > data;
          data.push_back(Ws_L1Ptr);
          data.push_back(Bs_L1Ptr);
          data.push_back(estVarV_L1Ptr);
          data.push_back(sqrtRhat_L1Ptr);
          #ifdef MYDEBUG
            data.push_back(rhatL1FlagPtr);
            data.push_back(sampledIndPtr);
          #endif
          int precData = 5;
          outputToFileVertical(data, colNames, GRL1Filename, precData);
        } // all the stuff created in these {} goes out of scope here
        
        #ifdef MYDEBUG
        {
          /* output working calcs: all L1s for each chain, 
           * running sums for each chain, sample variances,
           * overall running sums */
          std::vector < std::string > colNames;
          colNames.insert(colNames.end(), L1ColNames.begin(), L1ColNames.end())
      ;
          colNames.insert(colNames.end(), L1RunningSumColNames.begin(), 
      L1RunningSumColNames.end());
          colNames.insert(colNames.end(), L1SampleVarianceColNames.begin(), 
      L1SampleVarianceColNames.end());
          colNames.push_back(overallL1RunningSumColName);
          
          std::vector < RealVec* > data;
          data = addDataPtrs(data, *distancesL1Ptr);
          data = addDataPtrs(data, *runningSumL1ChainsPtr);
          data = addDataPtrs(data, *sampleVariancesPtr);
          data.push_back(runningSumL1OverallPtr);
          
          int precData = 10;
          outputToFileVertical(data, colNames, GRL1WorkingCalcsFilename, 
      precData);
        }
        #endif

        cout << "\n\nFinished MCMC successfully\n" << endl;
        cout << "Check output files " << GRL1Filename
                << " for diagnostics" << endl;
        if (logging = LOGSAMPLES) {
          cout << "and\t" << samplesLogFilename
              << " for log of samples" <<endl;
        }
        #ifdef MYDEBUG
          cout << "and\t" << GRL1WorkingCalcsFilename
              << " for working calculations for diagnostics" <<endl;
        #endif
        #ifdef MYDEBUG_OUTPUT
          cout << "and\t" << baseSequenceStateCollationFilename << "*.txt, \n\t
      "
              << baseSequenceStateAverageFilename << "*.txt \n\t"
              << baseSequenceStateDiffsToAverageFilename << "*.txt \n"
              << "for sequence development details" <<endl;
        #endif
        cout << endl;
      }
      
      /* clean up the newed stuff
       * 
       * note that this does not get cleaned up if we throw an exception in the
       while loop
       * - should probably deal with that at some point but all the newed
       memory will be 
       * freed when it terminates anyway so assuming this code is just run as a
       one-off example,
       * it will be okay for the moment */

      vector<AdaptiveHistogram*>::iterator ait;
      for (ait = hists.begin(); ait < hists.end(); ++ait) {
        if (NULL != *ait) delete (*ait);
      }
  
      vector<AdaptiveHistogramCollator*>::iterator acit;
      for (acit = sequenceCollators.begin(); acit < sequenceCollators.end(); ++
      acit) {
        if (NULL != *acit) delete (*acit);
      }
      /*
      for (acit = averageCollators.begin(); acit < averageCollators.end();
       acit++) {
        if (NULL != *acit) delete (*acit);
      }
      */

      delete samplesColl;
  
      delete distancesL1Ptr;  
  
      delete runningSumL1Ptr;
      
      #ifdef MYDEBUG
        delete runningSumL1OverallPtr;
        delete runningSumL1ChainsPtr;
        delete sampleVariancesPtr;
        delete rhatL1FlagPtr;
        delete sampledIndPtr;
      #endif
  
      delete Ws_L1Ptr;
      delete Bs_L1Ptr;
      delete estVarV_L1Ptr;
      delete sqrtRhat_L1Ptr;
            
      /* since I throw an exception in the while loop if it is not a good loop,
       *  really the only reason for failing here is that we did not get the
       right 
       * number of samples, but might as well leave it like this - belt &
       braces*/      
      if (!cancontinue || (samplesSoFar < samplesNeeded) ) {
        cout << "\nMCMC not successful" << endl;
        cout << "Output files will not be complete - delete or ignore:\n"
              << GRL1Filename;
        #ifdef MYDEBUG
          cout << "\n" << GRL1WorkingCalcsFilename;
        #endif
        if (logging = LOGSAMPLES) {
          cout << "\n" << samplesLogFilename;
        }
        #ifdef MYDEBUG_OUTPUT
          cout << "\n" << baseSequenceStateCollationFilename << "*.txt,"
          << "\n" <<  baseSequenceStateAverageFilename << "*.txt,"
          << "\n" <<  baseSequenceStateDiffsToAverageFilename << "*.txt";
        #endif
        cout << endl;
        
        if (!cancontinue) {
          throw std::runtime_error("MCMC failed");
        }
        if (samplesSoFar < samplesNeeded) {
          // we have not been able to get the required samples - need to give
       up
          throw std::runtime_error("Did not get required number of samples");
        }
      }

    } // end check on successful insertion of data into histograms
  
    else {
      throw std::runtime_error("MCMC failed: could not insert data into all
       starting histograms");
    }

    D++; // counter to go through unlabDataVec
  } // end of going through unlabDataVec

  //-----get marginal histograms for dimensions more than 1 --------------//
  //---- and density region----------------//
  cout << "Get the density region and/or marginal histograms" << endl;
  //Marginalise
   D = 0; //reset D to 0
  //iterate through each data set
  for (unlabDataIt = unlabDataVec.begin(); 
      unlabDataIt < unlabDataVec.end(); unlabDataIt++) {  
    if (dataDim == 1) { // get density region only for 1D data
      cout << "\nGet " << cov << " density region for dataset " << D;
      
      ostringstream stm1; stm1 << cov;
      string covFileName = dirName;
      covFileName += stm1.str(); 
      covFileName += "RegionBoxes";
      ostringstream stm2; stm2 << D+1;
      covFileName += "Data";
      covFileName += stm2.str();
      covFileName += ".txt";
      
      vector<CollatorSPnode*> covNodes;
      vecMCMCHist[D]->findDensityRegion(cov, WeightPM[D], covNodes, covFileName
      );

      cout << " and output to " << covFileName << endl;
    } // done with dataDim == 1
  
    // only do the marginalisation if dimension > 1
    else { //(dataDim > 1) 
      bool done = false;
      while (!done) {
        for (size_t i = 1; i <= dataDim; i++){
          //marginalise for univariate histograms
          cout << "\nMaking marginal histogram for coordinate " << i 
              << endl;
          int myints[] = {i}; 
          std::vector < int > margDims (myints, 
                      myints + sizeof(myints) / sizeof(int) );
          AdaptiveHistogramCollator marginal;
          marginal = vecMCMCHist[D]->marginalise(margDims);

          //output to .txt          
          string margFileName = dirName; 
          margFileName += "MarginalHist";   // provide a filename
          ostringstream stm1; stm1 << i;
          margFileName += stm1.str();
          ostringstream stm4; stm4 << D;
          margFileName += "Data";
          margFileName += stm4.str();
          margFileName +=  ".txt";
          // output the marginal to file
          marginal.outputToTxtTabs(margFileName); 
      
          // get density region
          cout << "Get " << cov << " density region ";
          ostringstream stm3;
          stm3 << cov;
          string covFileName = dirName;
          covFileName += stm3.str(); 
          covFileName += "RegionBoxes";
          covFileName += stm1.str();
          covFileName += "Data";
          covFileName += stm4.str();
          covFileName += ".txt";
          vector<CollatorSPnode*> covNodes;
          marginal.findDensityRegion(cov, 0, covNodes, covFileName);  
          cout << " and output to " << covFileName << endl;   
            
          if(i == dataDim) { done = true; } // can't make marginal for
                                  // pair dataDim-dataDim
          //marginalise for (dataDim choose 2) pairs
          for (size_t j=(i+1); j <= dataDim; j++) {
            cout << "\nMaking marginal histogram for pair " << i 
              << " " << j << endl;
            int myints[] = {i,j}; 
            std::vector < int > margDims (myints, 
                    myints + sizeof(myints) / sizeof(int) );
            AdaptiveHistogramCollator marginal; 

            marginal = vecMCMCHist[D]->marginalise(margDims);
            
            margFileName = dirName;
            margFileName += "MarginalHist";     // provide a filename
            ostringstream stm2; stm2 << j;
            margFileName += stm1.str();
            margFileName += "_";
            margFileName += stm2.str();
            margFileName += "Data";
            margFileName += stm4.str();
            margFileName +=  ".txt";
            // output the marginal to file
            marginal.outputToTxtTabs(margFileName);  
            cout << "Marginal output is in " << margFileName << endl;
        
            // get density region
            cout << "Get " << cov << " density region ";
            string covFileName = dirName;
            covFileName += stm3.str(); 
            covFileName += "RegionBoxes";
            covFileName += stm1.str();
            covFileName += "_";
            covFileName += stm2.str();
            covFileName += "Data";
            covFileName += stm4.str();
            covFileName += ".txt";
            vector<CollatorSPnode*> covNodes;
            marginal.findDensityRegion(cov, 0, covNodes, covFileName);            
            cout << "and output to " << covFileName << endl;          
          } // end of j
        } // end of i
      } // end of while
    } // end of dim > 1
    D++; //increment the data container count
  } // end of going through unlabDataVed
  //----end of marginalising histograms to get scatter histogram plots---//
  
  //TODO: The following procedure takes up a lot of memory. Need to make it 
  //more memory efficient!!!!
  //--Sample from RVecData in unlabData and get estimated log-likelihood-//
  cout << "\nSample from simulated datasets and get estimated log-likelihood" 
      << endl;
  for (size_t i = 0; i < numRep; i++) {
    //cout << "===========Round " << i << "==============" << endl;
    // container to store the likelihood ratios for this i
    vector< vector<real> > loglikMat; 
    
    //iterate through unlabDataVec
    D = 0; // reset counter for unlabDataVec
    for (unlabDataIt = unlabDataVec.begin(); unlabDataIt < unlabDataVec.end(); 
      unlabDataIt++) 
    {
      cout << "\nSampling from simulated dataset " << D << endl;
  
      //container to store the likelihood ratios for this dataset
      vector<real> loglikVec; 
    
      //label the data and make into RSSample
      RSSample labSampledData;
  
      //we need to sample without repetition
      set<int, less<int> > indexSet;
      if ( samplingSize >= (*unlabDataIt).size() ) { 
        cerr << "\nTerminated. Sampling size more than or equal to n." << endl;
        exit(1);
      }
      while ( indexSet.size() < samplingSize ) {
        //draw a random number in [0,1)
        double rand = gsl_rng_uniform(r);
        //turn this into an index in [0, (*unlabDataIt).size()-1]
        int index = static_cast<int>(ceil(rand*((*unlabDataIt).size()
                                          -1)));
        indexSet.insert(index);
      }           
      
      // sample from (*unlabDataIt)
      RVecData sampledData;
      set<int, less<int> >::iterator setIt;
      for (setIt = indexSet.begin(); setIt != indexSet.end(); setIt++) {
        //put element in allData indexed into data
        sampledData.push_back((*unlabDataIt)[*setIt]);
      }
      
      if (dataDim == 1) { // only filter for 1D
        //make a map for value of x (the key) and each of its respective 
        //counts (the value)
        map<rvector, size_t, less<rvector> > CountsMap;   
        //run a point mass filter to get "atomic" points
        cout << "run point mass filter over sampled data:" << endl;
        pointMassFilter(sampledData, CountsMap);
    
        //EMFMap is not needed anymore actually - will see how i can turn it
       off or do something else
                                //TODO: see TODO comment in
       "../../../src/sptools.cpp" 1220ish Line
        map<rvector, double, less<rvector> > EMFMap; 
        cout << "label data" << endl;
        labelDataFromFilter(sampledData, labSampledData, CountsMap, EMFMap);
      }
      else { // for now make RVecData into RSSample object for higher dim
     //TODO: This can be done (not for GT's PhD necessarily) "trans-dimensional
       density estimation!"
     //this is a beautiful extension of estimating axis-parallel
       low-dimensional atomic densities 
     //inside root box in R^d or other subsets specified by prior constraints
        RVecData::iterator it;
        for (it = sampledData.begin(); it < sampledData.end(); it++) {
          LabPnt labThisData;
          labThisData.Pnt = (*it);
          labThisData.L = 1;
          //labThisData.Print(cout);
          labSampledData.Samples.push_back(labThisData);
        }
      }

      cout << "Get estimated likelihood" << endl;
      //get estimated log-likelihood over each histogram
      //go through each histogram
      for(size_t k=0; k < vecMCMCHist.size(); k++) {
        real estLogLik;
        if (dataDim == 1) {
          estLogLik=vecMCMCHist[k]->getEstLogLikelihoodFromRSSample(
          labSampledData, dx, wt, WeightHistVec[k], WeightPMVec[k]);
        }
        else {
          estLogLik=vecMCMCHist[k]->getEstLogLikelihoodFromRSSample(
          labSampledData, dx, wt);
        }
        cout << setprecision(16) <<"Estimated lik for Hist " << k << ": " << 
      estLogLik << endl;
        loglikVec.push_back(estLogLik);
      }       
      //now get the ratios
      real Dividend = loglikVec[D];
      for(size_t k=0; k < loglikVec.size(); k++) {
        //Gloria's ratio of loglikelihoods: log(lik1)/log(lik2)
        //loglikVec[k] = Dividend/loglikVec[k];
        //Not quite log Likelihood Ratio
       -2log(lik1/lik2)=-2.0*log(lik1)+2*log(lik2)
        //loglikVec[k] = -2.0*Dividend + 2.0*loglikVec[k];
        //log relative likelihood:
       lik1/lik2=exp(log(lik1/lik2))=exp(log(lik1)-log(lik2))
        //loglikVec[k] = exp(Dividend - loglikVec[k]);
        //do nothing and leave the loglikelihoods as it is
      }
      //push back the log-likehood at the end of the vector
      loglikVec.push_back(Dividend);
      loglikMat.push_back(loglikVec);

      D++; // counter to go through unlabDataVec
    } // end of going through unlabDataVec

    //output liklogMat for round i to .txt
    string EstLikOut = dirName;
    EstLikOut += "EstLkl";
    ostringstream stm1;
    stm1 << i+1;
    EstLikOut += stm1.str(); 
    EstLikOut += ".txt";
    os.open(EstLikOut.c_str());
    vector< vector<real> >::iterator it1;
    vector<real>::iterator it2; 
    for (it1 = loglikMat.begin(); it1 < loglikMat.end(); it1++) {
      for (it2 = (*it1).begin(); it2 < (*it1).end(); it2++) {
        os << (*it2) << "\t";
        //cout << setprecision(16) <<(*it2) << "\t";
      }
      os << endl;
      //cout << setprecision(16) <<endl;
    } 
    os << flush;
    os.close();
    cout << "Likelihood ratios output to " << EstLikOut << endl; 
    cout << "=================================================" << endl;          
  } // end of numRep
   //-----------output the estimated likelihood to .txt file------------//
 //---------------end of sampling and estimating likelihood----------------// 
   
   //output the weights for the point mass so that we can plot the point mass
   //and the normalised histogram
   //output liklogMat for round i to .txt
   string weightFileName = dirName;
   weightFileName += "Weights.txt";
    os.open(weightFileName.c_str());
   vector<map<rvector, double, less<rvector> > >::iterator vecIt;
   map<rvector, double, less<rvector> > ::iterator mapIt;
  for (vecIt = WeightPMVec.begin(); vecIt < WeightPMVec.end(); vecIt++) {
    for (mapIt = (*vecIt).begin(); mapIt != (*vecIt).end(); mapIt++) {
        os << mapIt->first << "\t" << mapIt->second;
    }
    os << endl;
  } 
  
    os << flush;
    os.close();
    cout << "Weights output to " << weightFileName << endl; 
    cout << "=================================================" << endl;  
   
   // free the random generator
   gsl_rng_free(r);


  //can i make the doMCMCGRAuto function to be a void function?
  AdaptiveHistogramCollator coll;
  return coll;
} // end of AHABC
\end{DoxyCode}
\hypertarget{AHABCSimMCMCL1_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{\index{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp@{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp}!main@{main}}
\index{main@{main}!AHABCSimMCMCL1.cpp@{\-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp}}
\paragraph[{main}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf main} (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}}\label{AHABCSimMCMCL1_8cpp_a0ddf1224851353fc92bfbff6f499fa97}


\-Definition at line 68 of file \-A\-H\-A\-B\-C\-Sim\-M\-C\-M\-C\-L1.\-cpp.



\-References do\-M\-C\-M\-C\-G\-R\-Auto(), subpavings\-::output\-File\-Start(), and subpavings\-::\-Adaptive\-Histogram\-Collator\-::output\-To\-Txt\-Tabs().


\begin{DoxyCode}
{  
  //========user-defined input parameters for AHABC=========================//
   //directory to store files in
  string dirName = argv[1];
  
  // names of files
  string simDataFiles = argv[2]; // this is a row vector of filenames
 
  //sample for numRep times the sampled data of samplingSize
  size_t samplingSize = atoi(argv[3]);
  size_t numRep = atoi(argv[4]);
  
  //parameters for log-likelihood estimation
  double wt = atof(argv[5]); //mass to ensure positive density 
                    //everywhere in domain
  double dx = atof(argv[6]); //1 for non-atomic densities
  
   //user-defined coverage value to get wanted density region
  double cov = atof(argv[7]);
  
  //========user-defined parameters for MCMC====================//
  int maxLoops = atoi(argv[8]); // maximum changes of state from initial state
       to try
  int samplesNeeded = atoi(argv[9]); // how many samples do we want (ie once
       chains have burned in)
  int thinout = atoi(argv[10]); // sample every thinout state, ie thinout-1
       states between samples
  /* note that all chains will be sampled in parallel, once burnin has
       happened,

   * eg if we want 100 samples and have 4 chains and thinout 5, then we will
       sample
   * the last state from each chain as soon as convergence has been achieved 
   * (and thus get 4 samples), and then wait 5-1 = 4 states, and on the 5th,
       again 
   * sample from all 4 chains (assuming that convergence is still okay), etc
       etc
   * so it will take 1 + (100-4)/4*5 = 1 + 25*5 = 1 + 120 = 121 states from
       burnin inclusive
   * of the burnin state itself to get the full sample */
  double tol = atof(argv[11]); //tolerance for automated burn in criteria
  
  int minPoints = atoi(argv[12]); // minPoints
  
  //========Hardcoded parameters====================================//
  //int maxLoops = 5000; // maximum changes of state from initial state to try
  //int samplesNeeded = 10; // how many samples do we want (ie once chains have
       burned in)
  //int thinout = 5; // sample every thinout state, ie thinout-1 states between
       samples
  
  //cxsc::real tol(0.1); //tolerance for automated burn in criteria
  
  // should really do more checks on parameters, but just check thinout here
  if (thinout < 1 ) {
    throw std::invalid_argument("Invalid thinout argument");
  }
  //===========done with working on parameters==========================//
  
  try {
    AdaptiveHistogramCollator avg = doMCMCGRAuto(
        dirName, simDataFiles, samplingSize, numRep,
        wt, dx, cov,
        maxLoops, samplesNeeded, thinout, tol, minPoints);

    std::string samplesCollAverageFilename = dirName;
    samplesCollAverageFilename += "AveragedSamplesFromMCMCGRAuto";
    outputFileStart(samplesCollAverageFilename);
  
    avg.outputToTxtTabs(samplesCollAverageFilename);
    
    return 0;
  }
  catch (std::runtime_error& e) {
    cout << "\nFailed doMCMCGRAuto: original error:\n" 
      << std::string(e.what()) << "\n" << endl;
  }
} 
\end{DoxyCode}
