\hypertarget{MCMCGRAutoJ_8cpp}{\subsection{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp \-File \-Reference}
\label{MCMCGRAutoJ_8cpp}\index{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp@{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}}
}


\-Testing \-Stats\-Sub\-Pavings (aka \-S\-P\-Snodes) with \-M\-C\-M\-C with the \-Gelman-\/\-Rubin convergence diagnostics -\/ with automatic start to sampling once burnin has happened \-Jenny's version.  


{\ttfamily \#include \char`\"{}histall.\-hpp\char`\"{}}\*
{\ttfamily \#include \char`\"{}dataprep.\-hpp\char`\"{}}\*
{\ttfamily \#include \char`\"{}\-M\-C\-M\-C\-G\-Rtools.\-hpp\char`\"{}}\*
{\ttfamily \#include $<$time.\-h$>$}\*
{\ttfamily \#include $<$fstream$>$}\*
{\ttfamily \#include $<$sstream$>$}\*
{\ttfamily \#include $<$cassert$>$}\*
{\ttfamily \#include $<$stdexcept$>$}\*
{\ttfamily \#include $<$functional$>$}\*
{\ttfamily \#include $<$algorithm$>$}\*
\subsubsection*{\-Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{MCMCGRAutoJ_8cpp_a38cc676e6c9f06e021b17e537b7bba1d}{\-M\-Y\-D\-E\-B\-U\-G}
\end{DoxyCompactItemize}
\subsubsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator} \hyperlink{MCMCGRAutoJ_8cpp_a694f27abadce5523048bda1d5157019f}{do\-M\-C\-M\-C\-G\-R\-Auto} (size\-\_\-t n, int d, int mix, int max\-Loops, int samples\-Needed, int thinout, cxsc\-::real tol)
\item 
int \hyperlink{MCMCGRAutoJ_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main} (int argc, char $\ast$argv\mbox{[}$\,$\mbox{]})
\end{DoxyCompactItemize}


\subsubsection{\-Detailed \-Description}
\-Testing \-Stats\-Sub\-Pavings (aka \-S\-P\-Snodes) with \-M\-C\-M\-C with the \-Gelman-\/\-Rubin convergence diagnostics -\/ with automatic start to sampling once burnin has happened \-Jenny's version. 

\-Definition in file \hyperlink{MCMCGRAutoJ_8cpp_source}{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}.



\subsubsection{\-Define \-Documentation}
\hypertarget{MCMCGRAutoJ_8cpp_a38cc676e6c9f06e021b17e537b7bba1d}{\index{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp@{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}!\-M\-Y\-D\-E\-B\-U\-G@{\-M\-Y\-D\-E\-B\-U\-G}}
\index{\-M\-Y\-D\-E\-B\-U\-G@{\-M\-Y\-D\-E\-B\-U\-G}!MCMCGRAutoJ.cpp@{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}}
\paragraph[{\-M\-Y\-D\-E\-B\-U\-G}]{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf \-M\-Y\-D\-E\-B\-U\-G}}}\label{MCMCGRAutoJ_8cpp_a38cc676e6c9f06e021b17e537b7bba1d}


\-Definition at line 46 of file \-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp.



\subsubsection{\-Function \-Documentation}
\hypertarget{MCMCGRAutoJ_8cpp_a694f27abadce5523048bda1d5157019f}{\index{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp@{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}!do\-M\-C\-M\-C\-G\-R\-Auto@{do\-M\-C\-M\-C\-G\-R\-Auto}}
\index{do\-M\-C\-M\-C\-G\-R\-Auto@{do\-M\-C\-M\-C\-G\-R\-Auto}!MCMCGRAutoJ.cpp@{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}}
\paragraph[{do\-M\-C\-M\-C\-G\-R\-Auto}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Collator} {\bf do\-M\-C\-M\-C\-G\-R\-Auto} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{n, }
\item[{int}]{d, }
\item[{int}]{mix, }
\item[{int}]{max\-Loops, }
\item[{int}]{samples\-Needed, }
\item[{int}]{thinout, }
\item[{cxsc\-::real}]{tol}
\end{DoxyParamCaption}
)}}\label{MCMCGRAutoJ_8cpp_a694f27abadce5523048bda1d5157019f}


\-Definition at line 119 of file \-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp.



\-References add\-Data\-Ptrs(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::add\-To\-Collation(), \-Draw\-Unif\-Box(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::get\-Number\-Collated(), subpavings\-::\-Adaptive\-Histogram\-::get\-Sub\-Paving(), subpavings\-::\-Adaptive\-Histogram\-::insert\-From\-R\-Vec(), subpavings\-::\-L\-O\-G\-S\-A\-M\-P\-L\-E\-S, subpavings\-::\-Adaptive\-Histogram\-Collator\-::make\-Average(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::output\-File\-Start(), output\-To\-File\-Vertical(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::output\-To\-Txt\-Tabs(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::public\-Output\-Log(), subpavings\-::\-Adaptive\-Histogram\-::split\-To\-Shape(), and taylor\-::sqrt().


\begin{DoxyCode}
{
  //======set up for output========================================//     
  // use the cxsc manipulators for changing printing of cxsc::reals to console
  int prec = 15;
  cout << cxsc::SaveOpt;
  cout << cxsc::Variable;
  cout << cxsc::SetPrecision(prec+2, prec);

  AdaptiveHistogramCollator samplesAvg; // our return object, if all goes well

  //===========prepare to generate some data for the tests ================//
  // set up a random number generator
  const gsl_rng_type * T;
  gsl_rng * r;

  //create a generator chosen by the environment variable GSL_RNG_TYPE

  gsl_rng_env_setup();
  T = gsl_rng_default;
  r = gsl_rng_alloc (T);
  // set a seed for the data
  int dataSeed = 1234;
  gsl_rng_set(r, dataSeed);

  //-------define the root box--------------------
  ivector pavingBox(d);
  interval pavingInterval(0,1);
  for(int i=1; i <= d; i++) { pavingBox[i] = pavingInterval; }

  //------------data generating partition-------------
  //data sampled as uniform mixture over leaves of sub-paving myPart
  //make an Adaptive Histogram object with a specified box
  AdaptiveHistogram myPart(pavingBox);
  // a container for the boxes
  vector<ivector> Pboxes;
  //mixture shape
  string mixShape;
  if (mix == 1) {mixShape = "1,1"; }// this is the basic uniform
  else if (mix == 2) { mixShape = "1,2,2"; }
  else if (mix==3) { mixShape = "2,3,4,4,3,4,4,2"; }   
  else if (mix==4) {mixShape = "
      5,6,7,8,9,10,10,5,5,6,6,5,6,6,7,7,6,5,5,6,7,8,9,
      10,10,5,7,8,8,6,5,5,5,5,7,7,7,8,9,10,10,5,5,5,6,7,7,5,5,6,6,5,5,5,5,5,5,6,7,8,9,10,10"; }     
  myPart.splitToShape(mixShape);// uniform mixture      
  SPSnodePtrs Pleaves; // set up empty container for leaf node pointers
  SPSnodePtrsItr it; // and an iterator over the container
  myPart.getSubPaving()->getLeaves(Pleaves); // fill the container

  // container is filled by reading leaves off tree from left to right
  for(it = Pleaves.begin(); it < Pleaves.end(); it++) {
    Pboxes.push_back((*it)->getBox());
  }
  size_t PartSize = Pboxes.size();

   //--------------generate data-----------------------------------------
    cout << "Generating data: " << endl;
    // data sampled as uniform equi-mixture over leaves of sub-paving myPart
    //create a generator chosen by the environment variable GSL_RNG_TYPE   
    RVecData theData;   
    for (int i = 0; i < n; i++) {
      rvector thisrv(d);
      size_t RndBoxNum = floor(PartSize*gsl_rng_uniform(r));
      for(int i=1; i <= d; i++) {
        thisrv = DrawUnifBox(r,Pboxes[RndBoxNum]);
      }
      // put points generated into container
      theData.push_back(thisrv);
    }

   // free the random number generator
   gsl_rng_free (r);

  /*  // output data to a file
   string dataFile = "dataFile.txt";
   ofstream osd(dataFile.c_str());         // replace data
   if (osd.is_open()) {
      RVecDataItr dit;
      for (dit = theData.begin(); dit < theData.end(); dit++) {
        //osd << *dit << "\n";
        osd << (*dit)[1] << "\t" << (*dit)[2] << "\n";
      }
      osd.close();
   }
   else {
      std::cout << "Error: could not open file named "
        << dataFile << std::endl << std::endl;
   }
  */

  //================Gelman-Rubin method=========================//
   // start by making the histograms that are the starting points for our
       chains
   
   // Gelman and Carlin [1996] recommend ten or more chains if the target
   // distribution is unimodal (Martinez and Martinze, 2000, p. 453)
   // the starting points are chosen to be widely dispersed

  //------Starting histograms-------------------------------//
  //histogram 1
  cout << "Histogram 1" << endl;
   AdaptiveHistogram* myHistFirst = new AdaptiveHistogram(pavingBox);
  // put in the data in a 'pulse' with no splitting, ie into root box
  bool successfulInsertionFirst = myHistFirst->insertFromRVec(theData);

  //histogram 2
  cout << "Histogram 2" << endl;
  AdaptiveHistogram* myHistSecond = new AdaptiveHistogram(pavingBox);
  // the same data into the second histogram
  bool successfulInsertionSecond = myHistSecond->insertFromRVec(theData);
  bool successfulPQSplitSecond = false;
  if (successfulInsertionSecond) {
      // set up function objects for a priority split
      CompCount compCount;
      // split until number of leaves is >= minLeaves
      //size_t minLeaves = 50;
      size_t minLeaves = (n/50); // 20 when n = 1000
      CritLeaves_GTE critLeavesGTE(minLeaves);
      size_t minPQPoints = 1; // minimum of one data point in each box
      // do the priority split
      successfulPQSplitSecond = myHistSecond->prioritySplit(compCount,
           critLeavesGTE, NOLOG, minPQPoints); // no logging
   }

  //histogram 3
  cout << "Histogram 3" << endl;
  AdaptiveHistogram* myHistThird = new AdaptiveHistogram(pavingBox);
  myHistThird->splitToShape("1,2,2"); // make a specific starting shape
  // put in the data in a 'pulse' with no further splitting
  bool successfulInsertionThird = myHistThird->insertFromRVec(theData);
  
  #ifdef FORCEFAILINSERTION
    // debugging - force a failure here to check what program does
    successfulInsertionThird = false;
  #endif

  //--------Start the MCMC------------------------------------------------//
  if (successfulInsertionFirst && successfulPQSplitSecond && 
      successfulInsertionThird) {
     
    // containers for adaptive histograms
    // the starting points of the chains
    vector< AdaptiveHistogram* > hists;
    hists.push_back(myHistFirst);
    hists.push_back(myHistSecond);
    hists.push_back(myHistThird);

    // how many chains are to be run = number starting histograms
    size_t chains = hists.size(); 
    
    if (chains < 2) {
      throw HistException("Chains < 2");
    }
    
    // set up proposal distribution object
    UniformProposal proposal;
    // set up prior distribution object
    LogCatalanPrior logPrior;

    size_t minPoints = 1;
    
    LOGGING_LEVEL logging = LOGSAMPLES; // leave it like this!
    LOGGING_LEVEL loggingInChangeStates = NOLOG;

    gsl_rng * rgsl = NULL;

    // should check that each hist to be done has a paving

    // set up a random number generator for uniform rvs
    const gsl_rng_type * tgsl;
    // set the library variables *gsl_rng_default and
    // gsl_rng_default_seed to default environmental vars
    gsl_rng_env_setup();
    tgsl = gsl_rng_default; // make tgsl the default type
    rgsl = gsl_rng_alloc (tgsl); // set up with default seed
    
    // set a seed for the data
    int mcmcSeed = 1234;
    gsl_rng_set(rgsl, mcmcSeed); // change the seed to our seed

    // set up containers for the stuff we need pass to the MCMC engine
    vector<SPSnodeList> nodeLists(chains);
    Size_tVec numLeavesVec(chains);
    Size_tVec numCherriesVec(chains);

    vector<string> sequenceStateFilenames(chains);
    vector<string> sequenceAverageFilenames(chains);
    vector<string> sequenceCollationFilenames(chains);
    vector<string> sequenceDiffsToAverageFilenames(chains);
    vector<string> L1ColNames(chains);
    vector<string> L1RunningSumColNames(chains);
    vector<string> L1SampleVarianceColNames(chains);
    
    std::string baseSequenceStateFilename = "SequenceStates";
    std::string baseSequenceStateCollationFilename = "SequenceStateCollations";
    std::string baseSequenceStateAverageFilename = "SequenceStateAverages";
    std::string baseSequenceStateDiffsToAverageFilename = "
      SequenceStateDiffsToAverage";
    
    std::string  baseL1ColName = "L1_";
    std::string  baseL1RunningSumColName = "L1Sum_";
    std::string  baseL1SampleVarianceColName = "L1Var_";
    std::string  overallL1RunningSumColName = "OverallL1Sum";
    
    // files for outputing samples
    std::string samplesCollFilename = "CollatedSamplesFromMCMCGRAuto.txt";
    std::string samplesLogFilename = "LogSamplesFromMCMCGRAuto.txt";
    outputFileStart(samplesCollFilename);
    
    // should realy check on LOGSAMPLESANDGRAPH as well here
    // but at the moment I have not done anything about graphing
    if (logging = LOGSAMPLES) {
      outputFileStart(samplesLogFilename);
    }
    
    //std::string overSequenceAvgCollFilename =
       "CollationsOfAveragesOverSequences.txt";
    //outputFileStart(overSequenceAvgCollFilename);
    
    // a name for the file of diagnostics 
    std::string GRL1Filename = "GelmanRubinL1Scalar.txt";
    //outputFileStart(GRL1Filename);
    
    // a name for the file of working calculations for the diagnostics 
    std::string GRL1WorkingCalcsFilename = "GelmanRubinL1ScalarWorkingCalcs.txt
      ";
    //outputFileStart(GRL1WorkingCalcsFilename);
    
    
    /* containers for summaries for the 
    * L1-distances-to-average scalar convergence diagnostics */
    
    /* for each chain we need a container for current L1-distances-to-average 
     * relative to the current average for all histogram states in the chain so
       far.
     * This is reused and overwritten each time a state is added to the chain
     * and is just a working-space to facilitate getting the L1s we want. */
    std::vector < RealVec > currentL1s(chains); 

    // one vector of L1-distances-to-average as a RealVec for each chain
    std::vector < RealVec >* distancesL1Ptr = new std::vector < RealVec >(
      chains);  

    /* vector containing one running sum of L1-distances-to-average for each
       chain
    we can work out the average v = L1 for each chain so far from this
    start with a running sum of 0.0 for each chain */
    RealVec* runningSumL1Ptr = new RealVec (chains, cxsc::real(0.0));
    
    /* vector containing one running sum of 
    squared-L1-distances-to-average for each chain
    we can work out the average of the squared v's ie v^2 = L1^2
    for each chain so far from this
    start with a running sum of 0.0 for each chain.
    (Use a dotprecision for each running sum to keep accuracy 
    when accumulating products of reals) */
    VecDotPrec runningSumL1Squared(chains, cxsc::dotprecision(0.0));

    /* value of running sum of L1-distances-to-average over all chains
    we can work out the average v = L1 over all chains so far from this */
    real runningSumL1AllChains = cxsc::real(0.0);
    
    #ifdef MYDEBUG
      // keep a vector of all the overall running sums as well
      RealVec* runningSumL1OverallPtr = new RealVec(1, cxsc::real(0.0));
      // keep a vector of the runningsums for each chain as well
      std::vector < RealVec >* runningSumL1ChainsPtr 
                = new std::vector < RealVec >(chains);
      // keep a vector of the sample variances for each chain as well
      std::vector < RealVec >* sampleVariancesPtr 
                = new std::vector < RealVec >(chains);
      /* keep a vector of the flag for L1 convergence
       * (it's not a real, but easier to output it if we treat it like one) */
      RealVec* rhatL1FlagPtr = new RealVec(1, cxsc::real(0.0));
      
      /* keep a vector of indicators for whether a state was sampled
       * (not a real, but easier to output it if we treat it like one) */
      RealVec* sampledIndPtr = new RealVec(1, cxsc::real(0.0));
    #endif

    RealVec* Ws_L1Ptr = new RealVec(); // to hold the Ws_L1
    RealVec* Bs_L1Ptr = new RealVec(); // to hold the Bs_L1
    RealVec* estVarV_L1Ptr = new RealVec(); // to hold the estimated var(v)
    RealVec* sqrtRhat_L1Ptr = new RealVec(); // to hold the sqrtRhats

    // container of each state at each sequence
    vector<AdaptiveHistogramCollator*> sequenceCollators(chains);

    //container for the collation of the averages over each sequence at each
       state
    //vector<AdaptiveHistogramCollator*> averageCollators;

    //AdaptiveHistogramCollator masterCollator; // not newed so no need to
       delete

    bool cancontinue = true;

    // this loop is just setting up containers of file names
    // and getting info from the starting histograms that is
    // needed to start the chains
    // and a container of collators, one for each chain,
    for (size_t ci = 0; ci < chains; ci++) {
      
      // do not comment these out
      std::ostringstream stm1;
      stm1 << baseSequenceStateFilename << ci << ".txt";
      sequenceStateFilenames[ci] = stm1.str();
      outputFileStart(sequenceStateFilenames[ci]);

      #ifdef MYDEBUG
        {
          std::ostringstream stm;
          stm << baseSequenceStateCollationFilename << ci << ".txt";
          sequenceCollationFilenames[ci] = stm.str();
          outputFileStart(sequenceCollationFilenames[ci]);
        }
        {
          std::ostringstream stm;
          stm << baseSequenceStateAverageFilename << ci << ".txt";
          sequenceAverageFilenames[ci] = stm.str();
          outputFileStart(sequenceAverageFilenames[ci]);
        }
        {
          std::ostringstream stm;
          stm << baseSequenceStateDiffsToAverageFilename << ci << ".txt";
          sequenceDiffsToAverageFilenames[ci] = stm.str();
          outputFileStart(sequenceDiffsToAverageFilenames[ci]);
        }
        {
          std::ostringstream stm;
          stm << baseL1ColName << ci;
          L1ColNames[ci] = stm.str();
        }
        {
          std::ostringstream stm;
          stm << baseL1RunningSumColName << ci;
          L1RunningSumColNames[ci] = stm.str();
        }
        
        {
          std::ostringstream stm;
          stm << baseL1SampleVarianceColName << ci;
          L1SampleVarianceColNames[ci] = stm.str();
        }
      #endif
      /* we only need to do this because we are doing a step-by-step change of
       the
      * histogram states 'from the outside', ie through this example:  we need
       to
      * collect the stuff the histogram's changeMCMCstate method needs to make
       one 
      * change.  */
      
      // set up a container for the leaf children
      SPSnodePtrs leafVec;
      // set up a container for the subleaf children
      SPSnodePtrs cherryVec;

      size_t numLeaves = 0;
      size_t numCherries = 0;

      // fill the container with the leaf children
      hists[ci]->getSubPaving()->getLeaves(leafVec);
      // fill the container with the subleaf children
      hists[ci]->getSubPaving()->getSubLeaves(cherryVec);

      numCherries = cherryVec.size();

      // check if node is still splittable
      if (!leafVec.empty()) {
         // but only put into the container the leaves which, if split,
         // would have at least minPoints data points associated with them
         SPSnodePtrsItr lit;
         for (lit = leafVec.begin(); lit < leafVec.end(); lit++) {
            if (((*lit)->getLeftCountIfSplit() >= minPoints) &&
              ((*lit)->getRightCountIfSplit() >= minPoints)) {
                 // leaf can go into container
                 nodeLists[ci].push_back(*lit);
                 numLeaves++;
            }
         }
      }

      // no need to check on cherries - they can all go in
      if (numCherries > 0)
         nodeLists[ci].insert(nodeLists[ci].end(), cherryVec.begin(),
                         cherryVec.end());
      if (nodeLists[ci].size() == 0) {
         cancontinue = false;
         break; // break out of the for loop
         std::cout << "No changeable nodes given minPoints = "
                 << minPoints << " in histogram " << ci
                 << ". Sorry, aborting MCMC." << std::endl;
      }

      numLeavesVec[ci] = numLeaves;
      numCherriesVec[ci] = numCherries;

      // set up one collator for each chain, starting it with the first
       histogram state
      sequenceCollators[ci] = new AdaptiveHistogramCollator( *hists[ci] );
    
      // collect the calculations for the starting points
      
      // one vector of L1s for each chain
      distancesL1Ptr->at(ci).push_back( cxsc::real(0.0) ); 
      
      #ifdef MYDEBUG
        sampleVariancesPtr->at(ci).push_back(cxsc::real(0.0) );
        runningSumL1ChainsPtr->at(ci).push_back( cxsc::real(0.0) );
      #endif
      
      /* running sum of L1s for each chain, held in runningSumL1Ptr
      are all initialised to 0.0 already 
      * 
      * running sum of squared L1s for each chain, held in 
       runningSumL1SquaredPtr
      are all initialised to 0.0 already
      */ 
      
      
      #ifdef MYDEBUG_OUTPUT
        // make files for current average and current collations
      {
        sequenceCollators[ci]->publicOutputLog(sequenceCollationFilenames[ci], 
      1);
        
        AdaptiveHistogramCollator colltempavg
                    = sequenceCollators[ci]->makeAverage();
        colltempavg.publicOutputLog(sequenceAverageFilenames[ci], 1);
        
        AdaptiveHistogramCollator colltempdiffs
                    = sequenceCollators[ci]->makeDifferencesToAverage();
        colltempdiffs.publicOutputLog(sequenceDiffsToAverageFilenames[ci], 1);
      } // temp objects go out of scope here  
        
      #endif
    
    } // end loop through chains setting up things to be able to start
    
    /* the overall running sum runningSumL1AllChains 
     * was initialised to 0.0 
     * and #ifdef MYDEBUG, runningSumL1Overall was initialised to contain one
       0.0 
     * and similarly rhatL1FlagPtr was initialised to contain one 0.0*/
    
    
    /* start with the convergence statistics for chains with just one state in
      */
    // the Ws_L1
    Ws_L1Ptr->push_back(cxsc::real(0.0)); 
    // the Bs_L1
    Bs_L1Ptr->push_back(cxsc::real(0.0)); 
    // the estimated var(v)
    estVarV_L1Ptr->push_back(cxsc::real(0.0)); 
    // the sqrtRhats
    sqrtRhat_L1Ptr->push_back(cxsc::real(0.0)); 

    bool goodLoop = cancontinue;
    
    if (cancontinue) cout << "About to do MCMC" << endl;

    /* set up some variables we need to keep track of states and sampling */
    
    int samplesSoFar = 0;
    
    size_t states = 1;  /* keep track of states in the chain = 1 so far 
              because  we already have the initial histograms */
    
    
    /* varibles for monitoring convergence
     * we only have one scalar value at the moment (L1-distance-to-average) but
     * we might have more - might want convergence on all diagnostics */
    int rhatFlagCounter = 0;
    int rhatFlagCounterThreshold = 1;   /* how many of the scalar values must
       have
                      * diagnostic within limits for sampling to start?
                      * usually this would probably be the number
                      * of scalar values being used? */
    int rhatL1Flag = 0; // indicator for whether we are burntin on L1 scalar
       value
    int burntin = 0; // indicator for whether we consider ourselves burntin yet
    
    size_t burntinReachedState = 0; // keep track of when we (last) reached
       burnin
    
    // counter to keep track of loops
    int loopCounter = 0;
    
    /* We also need a collator for the samples*/
    AdaptiveHistogramCollator* samplesColl = new AdaptiveHistogramCollator();
    
    while (goodLoop && (loopCounter < maxLoops) && (samplesSoFar < 
      samplesNeeded)) {
      
      #ifdef MYDEBUG_OUTPUT
        cout << "****** Change in state number " << states << " ******" << endl
      ;
      #endif
      
      loopCounter++;
      // a collator for the averages for this loop
      //AdaptiveHistogramCollator* avgColl = new AdaptiveHistogramCollator;

      /* we want to accumulate the sample variance of the scalar summary
       * for each chain up to the point reached in this loop */
      cxsc::real sumOfSampleVariancesOverChains(0.0);
      
      /* also accumulate sum over all chains of the square of 
       * the running sum of L1-distances-to-average 
       * for each chain up to the point reached in this loop */
      cxsc::real sumOfSquaresOfRunningSums(0.0);
      
      

      // for each histogram in turn, change the state
      /* 
       * this is all a fudge - changeMCMCstate should just be a private
       * method of the histograms but I think I made it public so that
       * I could use it here in the example as a first step to being
       * able to make all of this chain convergence stuff back into
       * a method of the histograms themselves
       */
      for (size_t ci = 0; ci < chains; ci++) {
        
        #ifdef MYDEBUG_OUTPUT
          cout << "--- chain index " << ci << " ---" << endl;
        #endif
        
        /* I refer to the current chain, indexed by ci, as 'the chain
         * in the comments inside this loop */

        // changeMCMCState for the chain
        // updates nodes, numLeaves, numCherries, i
        goodLoop = hists[ci]->changeMCMCState(nodeLists[ci],
               numLeavesVec[ci], numCherriesVec[ci],
               proposal, logPrior, minPoints,
               rgsl, loggingInChangeStates,
               sequenceStateFilenames[ci], states);
               
        #ifdef FORCEFAILMCMCLOOP
          // for debugging - force a loop failure and see what happens to
       program
          if (states == 5) goodLoop = false;
        #endif 

        if (!goodLoop) {
          throw std::runtime_error("Failed to do MCMC change in state");
          // stop if we aren't happy
        }
        
        if ((numLeavesVec[ci] == 0 && numCherriesVec[ci] == 0)) {
          throw std::runtime_error("No more leaves or cherries in MCMC");
        }
        
        // so assume all is okay if we have not just thrown an exception
        
        // collate the current sample state in the chain
        sequenceCollators[ci]->addToCollation(*(hists[ci]));

        // collect the L1 distances and update the runnings sums
        
        // update our collection of L1s to average for all histogram states in
       the chain
        currentL1s[ci] = sequenceCollators[ci]->getL1DistancesToAverage(
      currentL1s[ci]);
        /* we actually only want the L1 for the last state in the chain,
         * which we collect in the right vector for this chain in distancesL1 
      */
        cxsc::real lastStateL1 = currentL1s[ci].back();
        distancesL1Ptr->at(ci).push_back( lastStateL1 );  
        
        
        // update the running sum of L1s for the chain, held in runningSumL1
        cxsc::real newRunningSum = runningSumL1Ptr->at(ci) + lastStateL1;
        runningSumL1Ptr->at(ci) = newRunningSum;
        
        // accumulate the square of the running sum of L1s 
        sumOfSquaresOfRunningSums += newRunningSum*newRunningSum;
        
        /* update the running sum of squared L1s over this chain
         *  held in runningSumL1Squared as a dot precision */
        cxsc::accumulate( runningSumL1Squared[ci], lastStateL1, lastStateL1 );
        
        // update  the overall running sum runningSumL1AllChains 
        runningSumL1AllChains += lastStateL1;
        
        /* how many histograms have we got so far?
         * this chain should have states+1 states in it.
         * because we have not yet incremented states.*/
        size_t n = sequenceCollators[ci]->getNumberCollated();
        assert(n == states + 1);
        
        /* and n should be at least 2 because we started with the 
         * starting histogram and have now added another state.*/
        assert(n > 1);
        /* could just use n - 1 = states + 1 - 1 = states in formula below
         * once we are happy it is all working!
        
        /* accumulate the sample variance for this chain: 
         * sample variance for the scalar summary v = L1-to-average
         * calculated as (sum of squares - n * square of averages)/(n-1)
         * which equals (sum of squares - square of sums/n)/(n-1) */
        cxsc::real thisSampleVariance( ( 1.0/(n-1) )*( cxsc::rnd(
      runningSumL1Squared[ci])
                  -  (newRunningSum*newRunningSum/(n * 1.0)) ) );
        sumOfSampleVariancesOverChains += thisSampleVariance;
        
        #ifdef MYDEBUG
          sampleVariancesPtr->at(ci).push_back( thisSampleVariance );
          runningSumL1ChainsPtr->at(ci).push_back (newRunningSum);
        #endif

        
        #ifdef MYDEBUG_OUTPUT
          //check thisSampleVariance is correct, doing it the long way
          // distancesL1[ci] has the v_ij for each chain i
          assert( n == distancesL1[ci].size() );
          cxsc::real acc(0.0);
          for (RealVecItr it = distancesL1[ci].begin(); it < distancesL1[ci].
      end(); ++it) {
            acc+= (*it);
          }
          cxsc::real av = acc/(n * 1.0);
          cxsc::dotprecision accDiffs(0.0);
          for (RealVecItr it = distancesL1[ci].begin(); it < distancesL1[ci].
      end(); ++it) {
            cxsc::real thisDiff = (*it) - av;
            // sum up the squares of the differences compared to overall
       average
            cxsc::accumulate(accDiffs, thisDiff, thisDiff);
          }
          cxsc::real altVar = rnd(accDiffs)/( n - 1.0 );
          
          cout << "\nthisSampleVariance is\t" << thisSampleVariance << endl;
          cout << "altSampleVar is\t" << altVar << endl;
          //assert(cxsc::_double(thisSampleVariance) == cxsc::_double(altVar)
       );
        
        #endif
        
        
        #ifdef MYDEBUG_OUTPUT
          // make files for current average and current collations
          sequenceCollators[ci]->publicOutputLog(sequenceCollationFilenames[ci]
      , states + 1);
        
          AdaptiveHistogramCollator colltempavg
                      = sequenceCollators[ci]->makeAverage();
          colltempavg.publicOutputLog(sequenceAverageFilenames[ci], states + 1)
      ;
          
          AdaptiveHistogramCollator colltempdiffs
                      = sequenceCollators[ci]->makeDifferencesToAverage();
          colltempdiffs.publicOutputLog(sequenceDiffsToAverageFilenames[ci], 
      states + 1);
        #endif
          
      } // end change state for each histogram in turn

      /* each chain now has a new state which has been collated into
       * its collator and info for L1 distances-to-average have been collected
       * and the sample variance of the scalar summary for each chain
       * has been put into sampleVariances, so we can now work out the
       * convergence diagnostics */

      // increment number of states   
      states++;

      #ifdef MYDEBUG
        // store the current runningSumL1AllChains as well
        runningSumL1OverallPtr->push_back(runningSumL1AllChains);
        
      #endif

      // the Ws_L1: average, over chains, of sample variance of scalar value
      cxsc::real thisW = sumOfSampleVariancesOverChains/(chains * 1.0); 
      Ws_L1Ptr->push_back(thisW); 
      // the Bs_L1
      cxsc::real thisB = (1.0/( (chains - 1) * states ) 
                * ( sumOfSquaresOfRunningSums 
                - (runningSumL1AllChains 
                * runningSumL1AllChains/(chains * 1.0)) ) );
      Bs_L1Ptr->push_back(thisB); 
      
      #ifdef MYDEBUG_OUTPUT
        //check thisB is correct, doing it the long way
        // runningSumL1 has one running sum for each chain
        RealVec chainAverages;
        cxsc::real accRunningSums(0.0);
        for (RealVecItr it = runningSumL1.begin(); it < runningSumL1.end(); ++
      it) {
          cxsc::real thisChainRunningSum = (*it);
          cxsc::real thisChainAv = thisChainRunningSum/(states * 1.0);
          chainAverages.push_back(thisChainAv);
          accRunningSums+=thisChainRunningSum;
        }
        cxsc::real overallAv = accRunningSums/(states * chains * 1.0);
        cxsc::dotprecision accDiffs(0.0);
        for (RealVecItr it = chainAverages.begin(); it < chainAverages.end(); +
      +it) {
          cxsc::real thisDiff = (*it) - overallAv;
          // sum up the squares of the differences compared to overall average
          cxsc::accumulate(accDiffs, thisDiff, thisDiff);
        }
        cxsc::real altB = rnd(accDiffs)*( states/(chains - 1.0) );
        
        cout << "\nthisB is\t" << thisB << endl;
        cout << "altB is\t" << altB << endl;
        //assert(thisB == altB);
      
      #endif
      
      // the estimated var(v)
      cxsc::real thisVarV = states/(states-1.0) * thisW + (1.0/states)*thisB;
      estVarV_L1Ptr->push_back(thisVarV); 
      // the sqrtRhats
      cxsc::real thisSqrtRhat_L1 = cxsc::sqrt(thisVarV/thisW);
      sqrtRhat_L1Ptr->push_back(thisSqrtRhat_L1); 
      
      // check on the diagnostics
      if (thisSqrtRhat_L1 <= 1.0 + tol && thisSqrtRhat_L1 >= 1.0 - tol) {
        //flagRhat++; //increment the flagRhat counter
        
        // if we have not been converged before on this scalar value
        if (!rhatL1Flag)  {
          #ifdef MYDEBUG
            
            cout << "\nL1 convergence test satisfied at " 
                << states << endl;
            
          #endif
        
          // set the flag for this scalar value
          rhatL1Flag = 1;
          
          // and increment the flag counter = we are converged on this scalar
       value
          rhatFlagCounter ++; 
        }
      }
      else { // not converged on this scalar value
        
        // if we were okay on this scalar value before
        if (rhatL1Flag) {
          #ifdef MYDEBUG
            cout << "\nL1 convergence test NOT now satisfied at " 
              << states << endl;
        
          #endif
          rhatL1Flag = 0; // update the flag
          rhatFlagCounter--; // decrement the flag counter
        }     
      }
      
      #ifdef MYDEBUG
        // store the L1flag as well, as a real, which is a fudge...
        rhatL1FlagPtr->push_back(rhatL1Flag);
        
      #endif
      
      /* we'd do this for all other scalar values as well, if applicable, then
       ...*/
        
      // check if we have enough flags to consider ourselves burntin
      if ( !burntin && (rhatFlagCounter >= rhatFlagCounterThreshold) ) {
        
        burntin = 1; 
        burntinReachedState = states;
        
        #ifdef MYDEBUG
          // if we have not been burntin, give a message
           cout << "Burnin convergence test satisfied at state " 
              << burntinReachedState << endl;
          
        #endif
        
        /* old comments from Gloria's code :
         * maybe can also have an upper bound for flagRhat defined by user.
         * once there is enough "flagRhat", we can stop the chain" */
      }
      
      // but it may be that we were burntin and no longer are
      else if ( burntin && (rhatFlagCounter < rhatFlagCounterThreshold) ) {
        
        burntin = 0; 
        burntinReachedState = 0;
        
        delete samplesColl; // get rid of the old samples collator
        samplesColl = new AdaptiveHistogramCollator(); // and take a new one
        
        samplesSoFar = 0;
        
        // want to change all the 1's in sampledIndPtr so far to 0s
        cxsc::real newVal(0.0);
        
        #ifdef MYDEBUG
          std::replace_if (sampledIndPtr->begin(), sampledIndPtr->end(), 
            std::bind2nd(greater< cxsc::real >(),newVal), newVal);
        #endif
        
        // restart the log file if we are logging
        // note nothing done here yet about logging graphs as well  
        if (logging = LOGSAMPLES) {
          outputFileStart(samplesLogFilename);
        }   
        
        #ifdef MYDEBUG
          cout << "Burnin convergence test now NOT satisfied at state " 
              << states << endl;
          
        #endif
        
        /* old comments from Gloria's code :
         * maybe can also have an upper bound for flagRhat defined by user.
         * once there is enough "flagRhat", we can stop the chain" */
      }
      
      /* take samples if we are burntin and this is a sampling point according
       to 
       * the thinout specified 
       * note - we will only be in the loop at all if we still need more
       samples*/
      if (burntin && ((states-burntinReachedState)%thinout == 0)) {
        
        #ifdef MYDEBUG
          cout << "sampling at state " << states << endl;
          sampledIndPtr->push_back (cxsc::real(1.0)); 

        #endif
        
        // take one sample from each chain until we have enough samples
        // and increment samplesSoFar for each one taken
        vector<AdaptiveHistogram*>::iterator ait;
        for (ait = hists.begin(); 
            (ait < hists.end() && samplesSoFar < samplesNeeded);
            ++ait) {
          
          samplesColl->addToCollation(**ait);
          
          samplesSoFar++;
          
          if (logging = LOGSAMPLES) {
            (*ait)->outputLogPlain(samplesLogFilename, samplesSoFar);
          }
          
        }
        
      } // finished taking samples for this loop
      else {
        #ifdef MYDEBUG
          
          sampledIndPtr->push_back (cxsc::real(0.0)); 
        #endif
      }
      
      assert(samplesColl->getNumberCollated() == samplesSoFar);
      
      
      // back into loop
      #if !defined(MYDEBUG_OUTPUT)
        #ifdef MYDEBUG
          // output a line every now and again so that we know it's still alive
          if (loopCounter%100 == 0) {
            cout << "\n...I'm still going: completed change in state number " <
      < states << " ...\n" << endl;
          }
        #endif
      #endif

    }    // finished while loop - either loop failed or reached maxLoops or
       have all our samples
    
    cancontinue = goodLoop;
    
    #ifdef MYDEBUG_OUTPUT
      cout << "****** finished all loops loopCounter = " << loopCounter << "
       ******" << endl;
    #endif
    
    #ifdef MYDEBUG
      cout << "number of samples collected is = " << samplesColl->
      getNumberCollated() << endl;
    #endif

    // free the random number generator
    gsl_rng_free (rgsl);

    cout << cxsc::RestoreOpt; // undo changes we made to cout printing for cxsc
       values
  
    
    /* is all okay with the loop
     * and we have all our samples */
    if (cancontinue && (samplesSoFar >= samplesNeeded) ) {  
      #ifdef MYDEBUG
        // output the overall collator
        samplesColl->outputToTxtTabs(samplesCollFilename);
      #endif
      
      // make the return object be the average of the samples
      samplesAvg = samplesColl->makeAverage();
        
      // output the convergence diagnostics
      /*
      outputFile(GRL1Filename, "\n\n\n Final diagnostics");
      outputFile(GRL1Filename, "W", Ws_L1);
      outputFile(GRL1Filename, "");
      outputFile(GRL1Filename, "B", Bs_L1);
      outputFile(GRL1Filename, "");
      outputFile(GRL1Filename, "estVarV", estVarV_L1);
      outputFile(GRL1Filename, "");
      outputFile(GRL1Filename, "sqrtRhat",sqrtRhat_L1);
      outputFile(GRL1Filename, "");
      */
      {
        std::vector < std::string > colNames;
        colNames.push_back("W");
        colNames.push_back("B");
        colNames.push_back("estVarV");
        colNames.push_back("sqrtRhat");
        #ifdef MYDEBUG
          colNames.push_back("rhatL1Flag");
          colNames.push_back("sampled?");
        #endif
        std::vector < RealVec* > data;
        data.push_back(Ws_L1Ptr);
        data.push_back(Bs_L1Ptr);
        data.push_back(estVarV_L1Ptr);
        data.push_back(sqrtRhat_L1Ptr);
        #ifdef MYDEBUG
          data.push_back(rhatL1FlagPtr);
          data.push_back(sampledIndPtr);
        #endif
        int precData = 5;
        outputToFileVertical(data, colNames, GRL1Filename, precData);
      } // all the stuff created in these {} goes out of scope here
      
      
      #ifdef MYDEBUG
      {
        /* output working calcs: all L1s for each chain, 
         * running sums for each chain, sample variances,
         * overall running sums */
        std::vector < std::string > colNames;
        colNames.insert(colNames.end(), L1ColNames.begin(), L1ColNames.end());
        colNames.insert(colNames.end(), L1RunningSumColNames.begin(), 
      L1RunningSumColNames.end());
        colNames.insert(colNames.end(), L1SampleVarianceColNames.begin(), 
      L1SampleVarianceColNames.end());
        colNames.push_back(overallL1RunningSumColName);
        
        std::vector < RealVec* > data;
        data = addDataPtrs(data, *distancesL1Ptr);
        data = addDataPtrs(data, *runningSumL1ChainsPtr);
        data = addDataPtrs(data, *sampleVariancesPtr);
        data.push_back(runningSumL1OverallPtr);
        
        int precData = 10;
        outputToFileVertical(data, colNames, GRL1WorkingCalcsFilename, precData
      );
      
      }
      #endif

      cout << "\n\nFinished MCMC successfully\n" << endl;
      cout << "Check output files " << GRL1Filename
            //  << " and " << GRTotalHeightFilename
              << " for diagnostics" << endl;
      if (logging = LOGSAMPLES) {
        cout << "and\t" << samplesLogFilename
            << " for log of samples" <<endl;
      }
      #ifdef MYDEBUG
        cout << "and\t" << GRL1WorkingCalcsFilename
            << " for working calculations for diagnostics" <<endl;
      #endif
      #ifdef MYDEBUG_OUTPUT
        cout << "and\t" << baseSequenceStateCollationFilename << "*.txt, \n\t"
            << baseSequenceStateAverageFilename << "*.txt \n\t"
            << baseSequenceStateDiffsToAverageFilename << "*.txt \n"
            << "for sequence development details" <<endl;
      #endif
      cout << endl;
    }
    
    /* clean up the newed stuff
     * 
     * note that this does not get cleaned up if we throw an exception in the
       while loop
     * - should probably deal with that at some point but all the newed memory
       will be 
     * freed when it terminates anyway so assuming this code is just run as a
       one-off example,
     * it will be okay for the moment */
    
    vector<AdaptiveHistogram*>::iterator ait;
    for (ait = hists.begin(); ait < hists.end(); ++ait) {
      if (NULL != *ait) delete (*ait);
    }

    vector<AdaptiveHistogramCollator*>::iterator acit;
    for (acit = sequenceCollators.begin(); acit < sequenceCollators.end(); ++
      acit) {
      if (NULL != *acit) delete (*acit);
    }
    /*
    for (acit = averageCollators.begin(); acit < averageCollators.end();
       acit++) {
      if (NULL != *acit) delete (*acit);
    }
    */
    delete samplesColl;

    delete distancesL1Ptr;  

    delete runningSumL1Ptr;
    
    #ifdef MYDEBUG
      delete runningSumL1OverallPtr;
      delete runningSumL1ChainsPtr;
      delete sampleVariancesPtr;
      delete rhatL1FlagPtr;
      delete sampledIndPtr;
    #endif

    delete Ws_L1Ptr;
    delete Bs_L1Ptr;
    delete estVarV_L1Ptr;
    delete sqrtRhat_L1Ptr;
          
    /* since I throw an exception in the while loop if it is not a good loop,
     *  really the only reason for failing here is that we did not get the
       right 
     * number of samples, but might as well leave it like this - belt & braces
      */      
    if (!cancontinue || (samplesSoFar < samplesNeeded) ) {
      cout << "\nMCMC not successful" << endl;
      cout << "Output files will not be complete - delete or ignore:\n"
            << GRL1Filename;
      #ifdef MYDEBUG
        cout << "\n" << GRL1WorkingCalcsFilename;
      #endif
      if (logging = LOGSAMPLES) {
        cout << "\n" << samplesLogFilename;
      }
      #ifdef MYDEBUG_OUTPUT
        cout << "\n" << baseSequenceStateCollationFilename << "*.txt,"
        << "\n" <<  baseSequenceStateAverageFilename << "*.txt,"
        << "\n" <<  baseSequenceStateDiffsToAverageFilename << "*.txt";
      #endif
      cout << endl;
      
      if (!cancontinue) {
        throw std::runtime_error("MCMC failed");
      }
      if (samplesSoFar < samplesNeeded) {
        // we have not been able to get the required samples - need to give up
        throw std::runtime_error("Did not get required number of samples");
      }
    }
    
  } // end check on successful insertion of data into histograms
  else {
    throw std::runtime_error("MCMC failed: could not insert data into all
       starting histograms");
  }

  return samplesAvg;

} // end of MCMC test program
\end{DoxyCode}
\hypertarget{MCMCGRAutoJ_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{\index{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp@{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}!main@{main}}
\index{main@{main}!MCMCGRAutoJ.cpp@{\-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp}}
\paragraph[{main}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf main} (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$}]{argv\mbox{[}$\,$\mbox{]}}
\end{DoxyParamCaption}
)}}\label{MCMCGRAutoJ_8cpp_a0ddf1224851353fc92bfbff6f499fa97}


\-Definition at line 61 of file \-M\-C\-M\-C\-G\-R\-Auto\-J.\-cpp.



\-References do\-M\-C\-M\-C\-G\-R\-Auto(), subpavings\-::output\-File\-Start(), and subpavings\-::\-Adaptive\-Histogram\-Collator\-::output\-To\-Txt\-Tabs().


\begin{DoxyCode}
{
  //========user-defined parameters====================//
  /*
  size_t n=atoi(argv[1]);  // number of datapoints to generate for each
       histogram
  int d = atoi(argv[2]); // dimensions
  int mix = atoi(argv[3]); //mix
  int maxloops = atoi(argv[4]); // maximum changes of state from initial state
       to try
  int samplesNeeded = atoi(argv[5]); // how many samples do we want (ie once
       chains have burned in)
  int thinout = atoi(argv[6]); // sample every thinout state, ie thinout-1
       states between samples
  */
  /* note that all chains will be sampled in parallel, once burnin has
       happened,

   * eg if we want 100 samples and have 4 chains and thinout 5, then we will
       sample
   * the last state from each chain as soon as convergence has been achieved 
   * (and thus get 4 samples), and then wait 5-1 = 4 states, and on the 5th,
       again 
   * sample from all 4 chains (assuming that convergence is still okay), etc
       etc
   * so it will take 1 + (100-4)/4*5 = 1 + 25*5 = 1 + 120 = 121 states from
       burnin inclusive
   * of the burnin state itself to get the full sample */
  
  /*
  double tol = atof(argv[7]); //tolerance for automated burn in criteria
  */
  //========Hardcoded parameters====================================//
  size_t n=100;  // number of datapoints to generate for each histogram
  int d = 2; // dimensions
  int mix = 1; //mix
  
  int maxLoops = 5000; // maximum changes of state from initial state to try
  int samplesNeeded = 10; // how many samples do we want (ie once chains have
       burned in)
  int thinout = 5; // sample every thinout state, ie thinout-1 states between
       samples
  
  cxsc::real tol(0.1); //tolerance for automated burn in criteria
  
  // should really do more checks on parameters, but just check thinout here
  if (thinout < 1 ) {
    throw std::invalid_argument("Invalid thinout argument");
  }
  //===========done with working on parameters==========================//

  try {
    AdaptiveHistogramCollator avg = doMCMCGRAuto(n, d,  mix, 
        maxLoops, samplesNeeded, thinout, tol);

    std::string samplesCollAverageFilename = "AveragedSamplesFromMCMCGRAuto.txt
      ";
    outputFileStart(samplesCollAverageFilename);
  
    avg.outputToTxtTabs(samplesCollAverageFilename);
    
    return 0;
  }
  catch (std::runtime_error& e) {
    cout << "\nFailed doMCMCGRAuto: original error:\n" 
      << std::string(e.what()) << "\n" << endl;
  }
}
\end{DoxyCode}
