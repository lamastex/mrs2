\hypertarget{classsubpavings_1_1SPSnode}{\subsection{subpavings\-:\-:\-S\-P\-Snode \-Class \-Reference}
\label{classsubpavings_1_1SPSnode}\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}}
}


\-A derived class based on \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} for processing sample data.  




{\ttfamily \#include $<$spsnode.\-hpp$>$}



\-Inheritance diagram for subpavings\-:\-:\-S\-P\-Snode\-:


\-Collaboration diagram for subpavings\-:\-:\-S\-P\-Snode\-:
\subsubsection*{\-Public \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1SPSnode_ae8fb89ca868b4ec2b47d0273cd32f5f5}{\-S\-P\-Snode} ()
\begin{DoxyCompactList}\small\item\em \-Default constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode_abcddd86c703c7263435686a5f7ad42f5}{\-S\-P\-Snode} (ivector \&v, bool cnt\-Only, int lab=0)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode_a51f7f0ed3dd43f8851556ea4a3cb4209}{\-S\-P\-Snode} (ivector \&v, int lab=0)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode_a775af2d808a8a9a59f29e6c25b6f0e4f}{\-S\-P\-Snode} (ivector \&v, size\-\_\-t max, bool cnt\-Only, int lab=0)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode_ad8f8a441fe2406ef50dc3d1fb06cb5b9}{\-S\-P\-Snode} (ivector \&v, size\-\_\-t max, int lab=0)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode_af4aa97973f8fac14503ec22574675a99}{\-S\-P\-Snode} (\hyperlink{classLabBox}{\-Lab\-Box} \&lb, bool cnt\-Only=false)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode_a86d9a45e0f5a59b94d556279dafd92f9}{\-S\-P\-Snode} (\hyperlink{classLabBox}{\-Lab\-Box} \&lb, size\-\_\-t max, bool cnt\-Only=false)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode_a56a33f7824a42568a7c9535e2ed10c88}{\-S\-P\-Snode} (const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} \&other)
\begin{DoxyCompactList}\small\item\em \-Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} \& \hyperlink{classsubpavings_1_1SPSnode_a65971d98a726cba6cf111882f984de06}{operator=} (const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} \&rhs)
\begin{DoxyCompactList}\small\item\em \-Copy assignment operator. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_ab4bee06d1b314b064d88842ba720d4a3}{get\-Counter} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the counter. \end{DoxyCompactList}\item 
int \hyperlink{classsubpavings_1_1SPSnode_afe262ee997e6ac57a15193a7d585f0ac}{get\-Split\-Dim} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the split dimension. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_aeaa3e348d84106def631d3cd742a1420}{get\-Split\-Value} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the split value. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_a4285801767cd577432a0b13cdbdaba43}{get\-Counts\-Only} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the counts\-Only value. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_af005697b49cff9ea37fc3bc9ed19da30}{\-Node\-Data} \hyperlink{classsubpavings_1_1SPSnode_a8906934b09d85e67c49d38548e0cd38a}{get\-Data} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the node's data collection. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_aa4b207c66d28113dc641d7cddf691547}{clear\-Data} () const 
\begin{DoxyCompactList}\small\item\em \-Clears the node's data collection. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_a69cbe84e4c59cd1369d3900d3ff05a01}{make\-Empty\-Node} ()
\begin{DoxyCompactList}\small\item\em \-Clears the node's data collection and counter. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1SPSnode_a7cf5893a0c2bcfe03caf2865203e6678}{check\-Tree\-State\-Legal} () const 
\begin{DoxyCompactList}\small\item\em \-Check tree rooted at this is legal with respect to \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node()}. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1SPSnode_a48e85710afe1e6b7f4d63afa891d4e38}{check\-Tree\-State\-Legal} (size\-\_\-t min\-Child\-Points, double min\-Vol) const 
\begin{DoxyCompactList}\small\item\em \-Check tree rooted at this is legal with respect to is\-Splittable\-Node(size\-\_\-t min\-Child\-Points, double min\-Vol). \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1SPSnode_ae6a71f8266d023f98489dafcc56d3819}{check\-Tree\-State\-Legal} (size\-\_\-t min\-Child\-Points)
\begin{DoxyCompactList}\small\item\em \-Check tree rooted at this is legal with respect to is\-Splittable\-Node(size\-\_\-t min\-Child\-Points). \end{DoxyCompactList}\item 
virtual bool \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node} () const 
\item 
bool \hyperlink{classsubpavings_1_1SPSnode_af8f9559a17318b187769c20e85316135}{is\-Splittable\-Node} (size\-\_\-t min\-Child\-Points, double min\-Vol) const 
\begin{DoxyCompactList}\small\item\em \-Method to check whether a node is splittable. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1SPSnode_acba45b1fe208f6218a87400eb454b28d}{is\-Splittable\-Node} (size\-\_\-t min\-Child\-Points) const 
\begin{DoxyCompactList}\small\item\em \-Method to check whether a node is splittable. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_ad077233e00a7093d66e35cca6fc6db6b}{get\-Left\-Count\-If\-Split} () const 
\begin{DoxyCompactList}\small\item\em \-The count the left child would have if this node was split. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_aa10917d57d9a50cb2d393a422188a51f}{get\-Right\-Count\-If\-Split} () const 
\begin{DoxyCompactList}\small\item\em \-The count the right child would have if this node was split. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_a1b3356a466432a282290af76df3adb08}{get\-Min\-Child\-Count\-If\-Split} () const 
\begin{DoxyCompactList}\small\item\em \-Smallest number of points in either child if this was split. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_a3df75e24c4a3a468b63f79667645c1dc}{get\-Min\-Child\-Count\-If\-Split\-N\-E\-W} () const 
\item 
\hyperlink{namespacesubpavings_a612fc5639b45583b9fd33bd304354f81}{\-Size\-\_\-t\-Vec} \& \hyperlink{classsubpavings_1_1SPSnode_acbe47754c218f0c895a900330491cbb3}{get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split} (\hyperlink{namespacesubpavings_a612fc5639b45583b9fd33bd304354f81}{\-Size\-\_\-t\-Vec} \&grandchild\-Counts) const 
\begin{DoxyCompactList}\small\item\em return a container of counts for prospective grandchildren. \end{DoxyCompactList}\item 
double \hyperlink{classsubpavings_1_1SPSnode_abd4de519f005b145ef131f0c9d4331a0}{get\-Min\-Child\-Vol\-If\-Split} () const 
\begin{DoxyCompactList}\small\item\em \-Smallest volume of either child if this was split. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_a612fc5639b45583b9fd33bd304354f81}{\-Size\-\_\-t\-Vec} \& \hyperlink{classsubpavings_1_1SPSnode_a2f8ce829fd9ba3ef3838d640ae201e9e}{get\-Leaf\-Node\-Counts} (\hyperlink{namespacesubpavings_a612fc5639b45583b9fd33bd304354f81}{\-Size\-\_\-t\-Vec} \&counts) const 
\item 
\hyperlink{namespacesubpavings_ad23942a388da964ca7487e496d0f2923}{\-S\-P\-Snode\-Ptrs} \& \hyperlink{classsubpavings_1_1SPSnode_a6a833240b503da0e2b640782e8671954}{get\-Leaves} (\hyperlink{namespacesubpavings_ad23942a388da964ca7487e496d0f2923}{\-S\-P\-Snode\-Ptrs} \&leaves) const 
\begin{DoxyCompactList}\small\item\em \-Return a reference to all descendent leaf nodes. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_ad23942a388da964ca7487e496d0f2923}{\-S\-P\-Snode\-Ptrs} \& \hyperlink{classsubpavings_1_1SPSnode_a8683fb9b17016cbe615408b51e791b9c}{get\-All\-Nodes} (\hyperlink{namespacesubpavings_ad23942a388da964ca7487e496d0f2923}{\-S\-P\-Snode\-Ptrs} \&all\-Nodes) const 
\begin{DoxyCompactList}\small\item\em \-Return a reference to all nodes. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_ad23942a388da964ca7487e496d0f2923}{\-S\-P\-Snode\-Ptrs} \& \hyperlink{classsubpavings_1_1SPSnode_af5ff16174902743a78b2d3db3e0a1c70}{get\-Sub\-Leaves} (\hyperlink{namespacesubpavings_ad23942a388da964ca7487e496d0f2923}{\-S\-P\-Snode\-Ptrs} \&subleaves) const 
\begin{DoxyCompactList}\small\item\em \-Return a reference to all sub-\/leaf descendent nodes. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_aeac2247b4626b1adfa609d3ff109ceb2}{get\-Root\-Counter} () const 
\begin{DoxyCompactList}\small\item\em \-The count in the node's ultimate ancestor root. \end{DoxyCompactList}\item 
rvector \hyperlink{classsubpavings_1_1SPSnode_aa5ae31017fb2fdee8b9168009d8d08a6}{get\-Mean} () const 
\begin{DoxyCompactList}\small\item\em \-Get the sample mean. \end{DoxyCompactList}\item 
rvector \hyperlink{classsubpavings_1_1SPSnode_a4369d3887385551e053d3873b600f8a1}{get\-Uniform\-Mean} () const 
\begin{DoxyCompactList}\small\item\em \-Get the uniform mean vector where each element is the midpoint of the coordinate. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_aa3a4a9df979f04453e82d76866b52850}{get\-Cheb\-Dist\-Mean} () const 
\begin{DoxyCompactList}\small\item\em \-Get the \-Chebyshev distance for the mean. \end{DoxyCompactList}\item 
double \hyperlink{classsubpavings_1_1SPSnode_a31ee93bb53be29fd0e50ff7fcd189c98}{get\-Emp\-Mass} () const 
\begin{DoxyCompactList}\small\item\em get the empirical mass of the node \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_a7713822499beb30a3d30f43b79c608b8}{get\-Cheb\-Dist\-Covar} () const 
\begin{DoxyCompactList}\small\item\em \-Get the \-Chebyshev distance for the var-\/covar. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_aa0ea6455e40f7f2bdb1e972ab080f5a5}{get\-Hellinger\-Dist} () const 
\begin{DoxyCompactList}\small\item\em \-Get the \-Bhattarchaya coefficient. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_afe386393d18f1e251972e959e79c3847}{get\-Hellinger\-Dist1\-D} () const 
\item 
real \hyperlink{classsubpavings_1_1SPSnode_adf589d16a3e20b4285f428c8dc42d75d}{get\-Sum\-Leaf\-Count\-Over\-Vol} () const 
\begin{DoxyCompactList}\small\item\em \-Get the sum of the count over volume in the leaf nodes. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_a6a75d9675312fb76aaf98bbeb084f9d6}{get\-Smallest\-Leaf\-Count} () const 
\begin{DoxyCompactList}\small\item\em \-Get the count of the leaf with the smallest count. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_ae094573d2988d458e00a549039a6ad56}{get\-Largest\-Leaf\-Count} () const 
\begin{DoxyCompactList}\small\item\em \-Get the count in the leaf with the smallest count. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_a45f10ce1371120a0c1be29fa0ad8bac5}{get\-Log\-Lik} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get this leaf node's contribution to loglikelihood. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_ab28c35298b721467721228a33a194433}{get\-Split\-Change\-Log\-Lik} () const 
\begin{DoxyCompactList}\small\item\em \-Get change in log likelihood on split of this node. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a9fd3a2a06ee14b5d5c307a2c7d795cef}{get\-Merge\-Change\-Log\-Lik} () const 
\begin{DoxyCompactList}\small\item\em \-Get change in log likelihood on merge of this' leaf chidren. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a3b5e815e94d8a276d7b13c0dc25a8dc4}{get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get best change in \-E\-M\-P under \-C\-O\-P\-E\-R\-R from splitting any leaf. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a53b9e7117d36f7730d458f26d74e0d28}{get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C} () const 
\begin{DoxyCompactList}\small\item\em \-Get best change in \-E\-M\-P under \-A\-I\-C from splitting any leaf. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a7cf8fbd3c03d1edeedbd5a793c9b822d}{get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get best change in \-E\-M\-P under \-C\-O\-P\-E\-R\-R from merging any subleaf. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a0e8b9126a14255276600bf5293d33e24}{get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C} () const 
\begin{DoxyCompactList}\small\item\em \-Get best change in \-E\-M\-P under \-A\-I\-C from merging any subleaf. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_a483f3b91707cda0deaee7a05d0523f3b}{get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get this node's scaled contribution to \-E\-M\-P under \-C\-O\-P\-E\-R\-R. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_aa939623d58172bc7f24ddf5dd249b5c2}{get\-E\-M\-P\-Contribution\-A\-I\-C} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get this node's scaled contribution to \-E\-M\-P under \-A\-I\-C. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a33925f531930c000200f452209b0128c}{get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get scaled change in sum term in \-E\-M\-P under \-C\-O\-P\-E\-R\-R on split. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_af75b1acec69e86469838524097fab408}{get\-Split\-Change\-E\-M\-P\-A\-I\-C} () const 
\begin{DoxyCompactList}\small\item\em \-Get change in sum term in \-E\-M\-P under \-A\-I\-C on split. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a2c8cc31ffdb9c74b82cce176c8d14585}{get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get scaled change in sum term in \-E\-M\-P under \-C\-O\-P\-E\-R\-R on merge. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a42114089fcad779bec855496154ded19}{get\-Merge\-Change\-E\-M\-P\-A\-I\-C} () const 
\begin{DoxyCompactList}\small\item\em \-Get change in sum term in \-E\-M\-P under \-A\-I\-C on merge. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_ad128b1715d294a65c905579ab43890d2}{reshape\-To\-Union} (const \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} \&other)
\begin{DoxyCompactList}\small\item\em \-Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of another tree. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_afe32d323547d5169b03ed9058922ac9d}{reshape\-To\-Union} (const \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} \&other, size\-\_\-t min\-Child\-Points)
\begin{DoxyCompactList}\small\item\em \-Reshape so that the tree rooted at this has shape that is as close as possible to the union of this shape and the shape of another tree. \end{DoxyCompactList}\item 
virtual std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_aba02715cb75f803df7c3ffd1eaf027e8}{node\-Print} (std\-::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em \-Output details of a specific node. \end{DoxyCompactList}\item 
virtual std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a3cc0c8bb64c854ef16ba03891f5945d6}{leaf\-Output\-Tabs} (std\-::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em \-Output for a node in a binary tree, tab-\/delimited. \end{DoxyCompactList}\item 
virtual std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_abe732a753f432c2239c9f82a47d089b1}{leaves\-Output\-Tabs} (std\-::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em \-Output for for {\bfseries all leaves} of a binary tree. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a817a8a29925937c189cc009366fe6bfb}{leaves\-Output\-Tabs\-With\-E\-M\-Ps} (const size\-\_\-t big\-N, std\-::ostream \&os, const int prec=5) const 
\begin{DoxyCompactList}\small\item\em \-Output for for {\bfseries all leaves} of a binary tree. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a11c1e7c0e652b891c08dfefebd285904}{leaves\-Output\-Tabs\-With\-Hist\-Height} (std\-::ostream \&os, const int prec) const 
\begin{DoxyCompactList}\small\item\em \-Output for for {\bfseries all leaves} of a binary tree. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a7f8027e04d883efdf7b627208775b989}{leaves\-Output\-Tabs\-With\-Hist\-Height} (const size\-\_\-t big\-N, std\-::ostream \&os, const int prec=5) const 
\begin{DoxyCompactList}\small\item\em \-Output for for {\bfseries all leaves} of a binary tree. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a24b8bd122c6509dd0bdb1d11b52edb7a}{leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps} (const size\-\_\-t big\-N, std\-::ostream \&os, const int prec=5) const 
\begin{DoxyCompactList}\small\item\em \-Output for for {\bfseries all leaves} of a binary tree. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_ad8b17faf69caa46fcfa021b61d09e278}{get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get scaled \-E\-M\-P sum under \-C\-O\-P\-E\-R\-R for tree rooted at this. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1SPSnode_a26329c8ddf55f351a673fe258e5abd15}{get\-E\-M\-P\-Sum\-A\-I\-C} (const size\-\_\-t n) const 
\begin{DoxyCompactList}\small\item\em \-Get the unscaled \-E\-M\-P sum under \-A\-I\-C for tree rooted at this. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1SPSnode_a918067afb150c053f7450fd18c6ecd22}{node\-Contains} (const rvector \&p, \hyperlink{namespacesubpavings_ae1ea349cda4812634df03761ebfc1c98}{\-O\-P\-E\-R\-A\-T\-I\-O\-N\-S\-\_\-\-O\-N} child\-Ind=\hyperlink{namespacesubpavings_ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781}{\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T}) const 
\begin{DoxyCompactList}\small\item\em \-Check if the box a node represents contains a datapoint p. \end{DoxyCompactList}\item 
int \hyperlink{classsubpavings_1_1SPSnode_a1ac36ca4768f69aab39ae45aaace5988}{sps\-Contains} (ivector \&z, int count\-Box, int count\-In\-Box) const 
\begin{DoxyCompactList}\small\item\em \-Get the number of points in any box. \end{DoxyCompactList}\item 
virtual void \hyperlink{classsubpavings_1_1SPSnode_adf0575b58b84a0910a8d5b67b6ec0f48}{node\-Expand} (int comp)
\begin{DoxyCompactList}\small\item\em \-Expand a leaf node. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_a0728b0ec4deee17f6a729a97c8b5a560}{node\-Expand} (const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, int comp)
\begin{DoxyCompactList}\small\item\em \-Expand a leaf node. \end{DoxyCompactList}\item 
virtual void \hyperlink{classsubpavings_1_1SPSnode_ae432186483a5ec950dab0eb00b08a9bc}{node\-Expand} ()
\begin{DoxyCompactList}\small\item\em \-Expand a leaf node. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_a19a54cd8f89112dbed3f43c2f405921f}{node\-Expand} (const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test)
\begin{DoxyCompactList}\small\item\em \-Expand a leaf node. \end{DoxyCompactList}\item 
virtual void \hyperlink{classsubpavings_1_1SPSnode_a68cc1a1722c627a99dcefc3491847fb2}{node\-Reabsorb\-Children} ()
\begin{DoxyCompactList}\small\item\em \-Reabsorbs both children of the node. \end{DoxyCompactList}\item 
virtual void \hyperlink{classsubpavings_1_1SPSnode_a61c584952df4fa77109cb4bb9b46f657}{node\-Reunite} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$l\-Child, \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$r\-Child)
\begin{DoxyCompactList}\small\item\em \-Try to reunite nodes to form one leaf. \end{DoxyCompactList}\item 
virtual void \hyperlink{classsubpavings_1_1SPSnode_ae1d11e62b133e13be6c14f7ff759f152}{node\-Adopt\-Left} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$l\-Child)
\begin{DoxyCompactList}\small\item\em \-Builds a higher level of a tree from existing nodes. \end{DoxyCompactList}\item 
virtual void \hyperlink{classsubpavings_1_1SPSnode_a4049a0078541b24d5451957f6f7dcd68}{node\-Adopt\-Right} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$r\-Child)
\begin{DoxyCompactList}\small\item\em \-Builds a higher level of a tree from existing nodes. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1SPSnode_af0d351af2a515188522e13e0c6502a18}{insert\-One\-Find} (\hyperlink{namespacesubpavings_a8792314c11b28ac2b8c4c85c47526f3a}{\-Big\-Data\-Itr} new\-Itr, \hyperlink{namespacesubpavings_ae1ea349cda4812634df03761ebfc1c98}{\-O\-P\-E\-R\-A\-T\-I\-O\-N\-S\-\_\-\-O\-N} child\-Ind, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test)
\begin{DoxyCompactList}\small\item\em \-Inserts data into this node. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_a8ce80cd650645f34e79fbc1d4beb2326}{swap\-S\-P\-S} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} \&spn)
\begin{DoxyCompactList}\small\item\em \-Swap this and another node. \-Swaps all the data members of this with the other node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}{\bf \-Accessors for links between the nodes.}\par
{\em \-These accessor methods shadow equivalent methods in the base class. \-Thus the method used is determined at compile time, not run time as would be the case if virtual methods were used. \-Because the pointers to parents and children are part of the base class definition, the methods have to cast the base class form to the derived class form in order for the pointer returned to be able to be used with derived class members.

\-Note that pointers for parent, left\-Child, and right\-Child are not reference counted so there could potentially be problems with the use of returned pointers (for instance, being used to delete nodes). \-These pointers might be better implemented with boost\-::shared\-\_\-ptr . }\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1SPSnode_a88c1d25d8e0b9738f5199cc4435c08b4}{get\-Parent} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the parent of a node. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1SPSnode_af7588b657e2819dd5dda525e08143ffc}{get\-Left\-Child} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the left child of a node. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1SPSnode_acc7d3e22be28d76da5c8c228aaaa95c7}{get\-Right\-Child} () const 
\begin{DoxyCompactList}\small\item\em \-Accessor for the right child of a node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Get the sample variance-\/covariance matrix.}\par
{\em \-This calculates the sample variance-\/covariance matrix from the accumulators for the sumproducts and sums of data point elements.

cov(i,j) = \mbox{[}sumproduct(i,j)-\/sum(i)xsum(j)/counter\mbox{]}/(counter-\/1)

\begin{DoxyReturn}{\-Returns}
a \-Real\-Vec or reference to a \-Real\-Vec representing the sample variance-\/covariance matrix in row-\/major order. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacesubpavings_af2d57bb6e12f4a73169f2e496d6a641f}{\-Real\-Vec} \hyperlink{classsubpavings_1_1SPSnode_a7637c85b772a280a9769b97f7bace3c3}{get\-Var\-Covar} () const 
\item 
\hyperlink{namespacesubpavings_af2d57bb6e12f4a73169f2e496d6a641f}{\-Real\-Vec} \& \hyperlink{classsubpavings_1_1SPSnode_a1bc0843e834ae4d09db3bc148b64761b}{get\-Var\-Covar} (\hyperlink{namespacesubpavings_af2d57bb6e12f4a73169f2e496d6a641f}{\-Real\-Vec} \&var\-Covar) const 
\item 
\hyperlink{namespacesubpavings_af2d57bb6e12f4a73169f2e496d6a641f}{\-Real\-Vec} \hyperlink{classsubpavings_1_1SPSnode_a83c7f66b07ab9afd1934b080fd4af8c4}{get\-Uniform\-Var\-Covar} () const 
\item 
\hyperlink{namespacesubpavings_af2d57bb6e12f4a73169f2e496d6a641f}{\-Real\-Vec} \& \hyperlink{classsubpavings_1_1SPSnode_a8ca1683e838159d5a33048344bec9b49}{get\-Uniform\-Var\-Covar} (\hyperlink{namespacesubpavings_af2d57bb6e12f4a73169f2e496d6a641f}{\-Real\-Vec} \&var\-Covar) const 
\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{\-Static \-Public \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1SPSnode_ac6259d2964d38acbb759c9f212853ef7}{stripped\-Constructor} (const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$const other)
\item 
static \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1SPSnode_a2dfb3087cff36fdf558bf75d5ee039c9}{union\-Tree\-Structure} (const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$const lhs, const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$const rhs)
\end{DoxyCompactItemize}
\subsubsection*{\-Protected \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classsubpavings_1_1SPSnode_add75213a0cf94b42aa82aca57b02da3e}{\-\_\-reshape\-To\-Union} (const \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} $\ast$const other)
\begin{DoxyCompactList}\small\item\em \-Internal method to reshape this to a union. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1SPSnode_acae5407bbd325c9c4852c5a77304cee9}{\-\_\-reshape\-To\-Union} (const \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} $\ast$const other, size\-\_\-t min\-Child\-Points, const std\-::string \&error\-Filename)
\begin{DoxyCompactList}\small\item\em \-Internal method to reshape this to a union with a restriction of min\-Child\-Points. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Protected \-Attributes}
\begin{DoxyCompactItemize}
\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_a4d836fd2b3cd074343475de6f9511c95}{space\-Indication}
\begin{DoxyCompactList}\small\item\em \-An indication of the maximum number of data points a node needs to carry. \end{DoxyCompactList}\item 
int \hyperlink{classsubpavings_1_1SPSnode_afbda0af3b68cf12874faa64aa8a9b154}{split\-Dim}
\begin{DoxyCompactList}\small\item\em \-Dimension the node's box has been split along. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1SPSnode_a60ef987525bfd22dd0a5adadc141f0b6}{split\-Value}
\begin{DoxyCompactList}\small\item\em \-The value, on split dimension, where node's box was split. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1SPSnode_a99af67614faaf93216ec0991e96ddb02}{counts\-Only}
\begin{DoxyCompactList}\small\item\em \-Determines the amount of statistical summary data in node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}{\bf mutable data members.}\par
{\em \-These data members are mutable to allow them to be modified by const functions as data passed to or through the node.

\-Only leaf nodes have data associated with them but the recursively computable statistics, such as counter and sum, are maintained for all nodes. \-Thus when a data point is sent to the root node and progresses down the tree to find which leaf node it should be associated with, the counter is incremented and the data sum increased for each non-\/leaf node it passes through (ie, where it is contained in the box of that node but that node is not a leaf node so the box has been sub-\/ divided and the datapoint continues on to one of the children). }\begin{DoxyCompactItemize}
\item 
size\-\_\-t \hyperlink{classsubpavings_1_1SPSnode_a890b23bcab9091b420d88b99d16badc5}{counter}
\begin{DoxyCompactList}\small\item\em \-A counter for how many data points are covered by the\-Box. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_ad8f0a077ee1c4678bcd1868f3aecd605}{\-Vec\-Dot\-Prec} \hyperlink{classsubpavings_1_1SPSnode_a1e5698e870376a507cd4a09bddc01643}{dp\-Sums}
\begin{DoxyCompactList}\small\item\em \-A container representing the sum of the data points covered by the\-Box. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_ad8f0a077ee1c4678bcd1868f3aecd605}{\-Vec\-Dot\-Prec} \hyperlink{classsubpavings_1_1SPSnode_a7ff8f1c83a231af97c32808e0851dc78}{dp\-Sum\-Products}
\begin{DoxyCompactList}\small\item\em \-A container representing the sumproduct matrix of the data points covered by the\-Box. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_af005697b49cff9ea37fc3bc9ed19da30}{\-Node\-Data} \hyperlink{classsubpavings_1_1SPSnode_a2d45b1e3b34a39d128143a0829f051f8}{data\-Itrs}
\begin{DoxyCompactList}\small\item\em \-A container for the association of data with a node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{\-Private \-Types}
\begin{DoxyCompactItemize}
\item 
enum \{ \hyperlink{classsubpavings_1_1SPSnode_a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367}{default\-Max\-Pts} =  1000
 \}
\begin{DoxyCompactList}\small\item\em \-To define the default maximum number of datapoints the node is expected to have associated with it. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Private \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classsubpavings_1_1SPSnode_a8011280b8a3a0729c581a00f3bb031ff}{recalculate\-Stats} (rvector \&newdata) const 
\begin{DoxyCompactList}\small\item\em \-Recalculate summary statistics associated with node. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_aa70c978a273b7266c75e7d617ae4d100}{recalculate\-Sums} (rvector \&newdata) const 
\begin{DoxyCompactList}\small\item\em \-Recalculate summary statistics associated with node. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_ab49e57afe0939b41930e0cbb22c9ba8a}{recalculate\-Sum\-Products} (rvector \&newdata) const 
\begin{DoxyCompactList}\small\item\em \-Recalculate summary statistics associated with node. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_ac549870ef3b7994d9e87b952a012a7e9}{node\-Expansion\-Only} (int comp)
\begin{DoxyCompactList}\small\item\em \-Expand the node with no reallocation of data. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_adf3d76ca267b87c46d1fcb1ca3cecd84}{split\-Data} (const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test)
\begin{DoxyCompactList}\small\item\em \-Send the data associated with this down to children. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a799dd8e194518c3dd525ecba26072585}{node\-Data\-Print} (std\-::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em \-Print the data in a specified format. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a5f5cc02f707a2b98f7a93543c71298b2}{node\-Mean\-Print} (std\-::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em \-Print the mean in a specified format. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_a03042a5084349960b1fd35396dc509a5}{node\-Var\-Covar\-Print} (std\-::ostream \&os) const 
\begin{DoxyCompactList}\small\item\em \-Print the variance-\/covariance in a specified format. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_ac273545c33e3abb0114811e7a1b06f98}{leaf\-Output\-Tabs\-With\-E\-M\-Ps} (const size\-\_\-t big\-N, std\-::ostream \&os, const int prec=5) const 
\begin{DoxyCompactList}\small\item\em \-Output for a node in a binary tree, tab-\/delimited. \end{DoxyCompactList}\item 
virtual std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_aaf9ac8d98bda6e99c74b946d85c6bc61}{leaf\-Output\-Tabs\-With\-Hist\-Height} (const size\-\_\-t big\-N, std\-::ostream \&os, const int prec=5) const 
\begin{DoxyCompactList}\small\item\em \-Output for a node in a binary tree, tab-\/delimited. \end{DoxyCompactList}\item 
std\-::ostream \& \hyperlink{classsubpavings_1_1SPSnode_ad64bd4af47589b21d9c8dde5135c3d0a}{leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps} (const size\-\_\-t big\-N, std\-::ostream \&os, const int prec=5) const 
\begin{DoxyCompactList}\small\item\em \-Output for a node in a binary tree, tab-\/delimited. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1SPSnode_a785e03fc466a6a1ea851f08338f8103d}{set\-Splits} ()
\begin{DoxyCompactList}\small\item\em \-Set the split\-Dimension and \-Split\-Value when children grafted. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Static \-Private \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{namespacesubpavings_af005697b49cff9ea37fc3bc9ed19da30}{\-Node\-Data} \& \hyperlink{classsubpavings_1_1SPSnode_ac16a08aea6f8316526c46382e3252959}{gather\-Data} (\hyperlink{namespacesubpavings_af005697b49cff9ea37fc3bc9ed19da30}{\-Node\-Data} \&container, \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$spn)
\begin{DoxyCompactList}\small\item\em \-Return a reference to the node data. \end{DoxyCompactList}\item 
static \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1SPSnode_a6c28eccf9962c4b9010f2f04b0231d30}{union\-No\-Data} (const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$const lhs, const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$const rhs)
\end{DoxyCompactItemize}


\subsubsection{\-Detailed \-Description}
\-A derived class based on \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} for processing sample data. 

\-The base class \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} is a node in the representation of a regular subpaving as a binary tree. \-A node represents a box (interval vector). \-S\-Pnodes are linked together to form the tree. \-The initial box of the subpaving is the box represented by the root node of the tree. \-A box which has been split will be represented as node with 1 or 2 children.

\-A subpaving of \mbox{[}{\bfseries x}\mbox{]} (union of non-\/overlapping subboxes of \mbox{[}{\bfseries x}\mbox{]}) is represented by the leaves (degenerate/child-\/less) nodes in the tree.

\-The \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} class has additional data members for statistical data analysis. \-The \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} class is used to form a regular subpaving representing containers of sample data where some data-\/related criteria is used to determine when the subpaving should be bisected. \-For example, keeping the number of data points associated with a node below a specified maximum -\/-\/ \char`\"{}a maximally statistically equivalent
    blocks\char`\"{} criterion.

\-Data points are of type csxc\-::rvector.

\-Leaves of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} class have data associated with them in the form of pointers to some big collection of sample data. \-If an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} is bisected the data associated with it descends to its children, so that only leaf \-S\-P\-Snodes have data associated with them. \-However, \char`\"{}recursively-\/computable statistical summaries\char`\"{}, such as, count, sum, etc, of the data which would be contained in the box an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} represents are kept for all \-S\-P\-Snodes and continue to be updated when the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} has children and data reaching the node is passed on to be finally associated with a leaf.

\-For an algebraic statistical formalisation of \-Fisher's ideas on recursively computable statistics see \char`\"{}\-Notions of Sufficiency\char`\"{} by \-S.\-L. \-Lauritzen, \-Contributed \-Paper, 44th \-Session of the \-International \-Statistical \-Institute, \-Madrid, \-Spain, \-September 12th-\/-\/22nd, 1983.

\-By default, all recursively computable statistics provided are maintained in each \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode}. \-However, since this uses memory and is not always needed, an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} can be constructed to only maintain count statistics.

\-When a box is split along some dimension d, only the right (upper) subbox is closed on the actual split value (the midpoint of the interval which is the dth element in the interval vector/box to be bisected) whereas the left (lower) box has an open interval on this value. \-Thus \mbox{[}1 5\mbox{]} is subdivided to \mbox{[}1 3) and \mbox{[}3 5\mbox{]}. \-The parent \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} class can ignore this point but it must be addressed if we are to be able to decide which subbox (left or right) a datapoint sitting exactly on the split value in the split dimension should descend to. \-This is an extension of the empirical distribution to a partition of the root box with the leaves of the subpaving.

\-The class also needs to know which dimension the box represented by a node was split on and what the split value was, so that data reaching the node can be correctly (ie, in cognisance of the open and closed intervals described above) associated with either the right or left child. \-These values therefore become data members of the class, with default values for leaf nodes. 

\-Definition at line 109 of file spsnode.\-hpp.



\subsubsection{\-Member \-Enumeration \-Documentation}
\hypertarget{classsubpavings_1_1SPSnode_a208ab19f2444e75f9602f8fd136fc03d}{\paragraph[{anonymous enum}]{\setlength{\rightskip}{0pt plus 5cm}anonymous enum\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a208ab19f2444e75f9602f8fd136fc03d}


\-To define the default maximum number of datapoints the node is expected to have associated with it. 

\-This is used for efficiency only to reserve vector space and a node can have more than this default maximum number of data points associated with it. \begin{Desc}
\item[\-Enumerator\-: ]\par
\begin{description}
\index{default\-Max\-Pts@{default\-Max\-Pts}!subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}}\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!default\-Max\-Pts@{default\-Max\-Pts}}\item[{\em 
\hypertarget{classsubpavings_1_1SPSnode_a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367}{default\-Max\-Pts}\label{classsubpavings_1_1SPSnode_a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367}
}]\end{description}
\end{Desc}



\-Definition at line 121 of file spsnode.\-hpp.


\begin{DoxyCode}
{defaultMaxPts = 1000};
\end{DoxyCode}


\subsubsection{\-Constructor \& \-Destructor \-Documentation}
\hypertarget{classsubpavings_1_1SPSnode_ae8fb89ca868b4ec2b47d0273cd32f5f5}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ae8fb89ca868b4ec2b47d0273cd32f5f5}


\-Default constructor. 



\-Definition at line 679 of file spsnode.\-cpp.



\-References data\-Itrs, default\-Max\-Pts, and space\-Indication.



\-Referenced by operator=(), \-S\-P\-Snode(), and stripped\-Constructor().


\begin{DoxyCode}
                     :  counter(0), splitDim(-1), splitValue(0.0),
                                countsOnly(true)
    {
        try {
            //invokes the base class default constructor
            // then does additional data members

            //dpSums, a vector of dotprecision terms, is not initialised
            //dpSumProducts, similarly not initialised

            // reserve space
            spaceIndication = static_cast<size_t>(defaultMaxPts);
            // not sure whether to do this or not - leave for the moment
            dataItrs.reserve(spaceIndication);
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            std::cerr << msg << std::endl;
            throw;
        }

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_abcddd86c703c7263435686a5f7ad42f5}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{v, }
\item[{bool}]{cnt\-Only, }
\item[{int}]{lab = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_abcddd86c703c7263435686a5f7ad42f5}


\-Initialised constructor. 

\-Initialised with an interval vector for the box it represents and a value for counts\-Only which controls whether all available stats are maintained (false) or just counts (true), and optionally initialised with a label which defaults to 0 if not provided. 

\-Definition at line 732 of file spsnode.\-cpp.



\-References data\-Itrs, default\-Max\-Pts, and space\-Indication.


\begin{DoxyCode}
                                                      : SPnode(v, lab),
        counter(0), splitDim(-1), splitValue(0.0), countsOnly(cntOnly)
    {
        try {
            //invokes the base class constructor with ivector & label
            // and then initialises additional data members

            //dpSums, a vector of dotprecision terms, is not initialised
            //dpSumProducts, similarly not initialised

            spaceIndication = static_cast<size_t>(defaultMaxPts);
            //reserve space - not sure if important - leave for moment
            dataItrs.reserve(spaceIndication);
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a51f7f0ed3dd43f8851556ea4a3cb4209}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{v, }
\item[{int}]{lab = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a51f7f0ed3dd43f8851556ea4a3cb4209}


\-Initialised constructor. 

\-Initialised with an interval vector for the box it represents and optionally initialised with a label which defaults to 0 if not provided. \-The value for counts\-Only will default to false (i.\-e., all stats maintained by default). 

\-Definition at line 707 of file spsnode.\-cpp.



\-References data\-Itrs, default\-Max\-Pts, and space\-Indication.


\begin{DoxyCode}
                                        : SPnode(v, lab),
        counter(0), splitDim(-1), splitValue(0.0), countsOnly(true)
    {
        try {
            //invokes the base class constructor with ivector & label
            // and then initialises additional data members

            //dpSums, a vector of dotprecision terms, is not initialised
            //dpSumProducts, similarly not initialised

            spaceIndication = static_cast<size_t>(defaultMaxPts);
            //reserve space - not sure if important - leave for moment
            dataItrs.reserve(spaceIndication);
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a775af2d808a8a9a59f29e6c25b6f0e4f}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{v, }
\item[{size\-\_\-t}]{max, }
\item[{bool}]{cnt\-Only, }
\item[{int}]{lab = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a775af2d808a8a9a59f29e6c25b6f0e4f}


\-Initialised constructor. 

\-Initialised with an interval vector for the box it represents, a space indication, and a value for counts\-Only which controls wether all available stats are maintained (false) or just counts (true), and optionally initialised with a label for the model which defaults to 0 if not provided. 

\-Definition at line 785 of file spsnode.\-cpp.



\-References data\-Itrs, and space\-Indication.


\begin{DoxyCode}
                                                                  :
        SPnode(v, lab),
        spaceIndication(max), counter(0), splitDim(-1), splitValue(0.0),
        countsOnly(cntOnly)
    {
        try {
            //cout << "node constructor" << "\t" << cntOnly << endl;
            //invokes the base class constructor with ivector argument
            // and then initialises additional data members

            //dpSums, a vector of dotprecision terms, is not initialised
            //dpSumProducts, similarly not initialised

            //reserve space - not sure if important - leave for moment
            dataItrs.reserve(spaceIndication+1);
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ad8f8a441fe2406ef50dc3d1fb06cb5b9}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{v, }
\item[{size\-\_\-t}]{max, }
\item[{int}]{lab = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ad8f8a441fe2406ef50dc3d1fb06cb5b9}


\-Initialised constructor. 

\-Initialised with an interval vector for the box it represents, a space indication, and optionally initialised with a label for the model which defaults to 0 if not provided. \-The value for counts\-Only will default to false (i.\-e., all stats maintained by default). 

\-Definition at line 758 of file spsnode.\-cpp.



\-References data\-Itrs, and space\-Indication.


\begin{DoxyCode}
                                                    :
        SPnode(v, lab),
        spaceIndication(max), counter(0), splitDim(-1), splitValue(0.0),
        countsOnly(true)
    {
        try {
            //invokes the base class constructor with ivector argument
            // and then initialises additional data members

            //dpSums, a vector of dotprecision terms, is not initialised
            //dpSumProducts, similarly not initialised

            //reserve space - not sure if important - leave for moment
            dataItrs.reserve(spaceIndication+1);
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_af4aa97973f8fac14503ec22574675a99}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
\item[{{\bf \-Lab\-Box} \&}]{lb, }
\item[{bool}]{cnt\-Only = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_af4aa97973f8fac14503ec22574675a99}


\-Initialised constructor. 

\-Initialised with a \hyperlink{classLabBox}{\-Lab\-Box} for the labeled box it represents. \-Also optionally initialised with a value for counts\-Only, defaults to false (i.\-e., all stats maintained by default). 

\-Definition at line 837 of file spsnode.\-cpp.



\-References data\-Itrs, default\-Max\-Pts, and space\-Indication.


\begin{DoxyCode}
                                             : SPnode(lb), counter(0),
        splitDim(-1), splitValue(0.0), countsOnly(cntOnly)
    {
        try {
            //invokes the base class constructor with LabBox argument
            // and then initialises additional data members

            //dpSums, a vector of dotprecision terms, is not initialised
            //dpSumProducts, similarly not initialised

            spaceIndication = static_cast<size_t>(defaultMaxPts);
            //reserve space - not sure if important - leave for moment
            dataItrs.reserve(spaceIndication);
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a86d9a45e0f5a59b94d556279dafd92f9}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
\item[{{\bf \-Lab\-Box} \&}]{lb, }
\item[{size\-\_\-t}]{max, }
\item[{bool}]{cnt\-Only = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a86d9a45e0f5a59b94d556279dafd92f9}


\-Initialised constructor. 

\-Initialised with a \hyperlink{classLabBox}{\-Lab\-Box} for the labeled box it represents, and a space indication. \-Also optionally initialised with a value for counts\-Only, defaults to false (i.\-e., all stats maintained by default). 

\-Definition at line 812 of file spsnode.\-cpp.



\-References data\-Itrs, and space\-Indication.


\begin{DoxyCode}
                                                         : SPnode(lb),
        spaceIndication(max), counter(0), splitDim(-1), splitValue(0.0),
        countsOnly(cntOnly)
    {
        try {

            //invokes the base class constructor with LabBox argument
            //and then initialises additional data members

            //dpSums, a vector of dotprecision terms, is not initialised
            //dpSumProducts, similarly not initialised

            //reserve space - not sure if important - leave for moment
            dataItrs.reserve(spaceIndication+1);
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a56a33f7824a42568a7c9535e2ed10c88}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-S\-P\-Snode@{\-S\-P\-Snode}}
\index{\-S\-P\-Snode@{\-S\-P\-Snode}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-S\-P\-Snode}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-::\-S\-P\-Snode} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-P\-Snode} \&}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a56a33f7824a42568a7c9535e2ed10c88}


\-Copy constructor. 



\-Definition at line 861 of file spsnode.\-cpp.



\-References data\-Itrs, get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::left\-Child, subpavings\-::\-S\-Pnode\-::node\-Add\-Left(), subpavings\-::\-S\-Pnode\-::node\-Add\-Right(), subpavings\-::\-S\-Pnode\-::node\-Name, subpavings\-::\-S\-Pnode\-::right\-Child, and \-S\-P\-Snode().


\begin{DoxyCode}
                                         : SPnode(*(other.theBox),
        other.label), spaceIndication(other.spaceIndication),
        counter(other.counter), dpSums(other.dpSums),
            dpSumProducts(other.dpSumProducts), splitDim(other.splitDim),
        splitValue(other.splitValue), countsOnly(other.countsOnly)
    {
        try {
            //reserve space
            dataItrs.reserve((other.dataItrs).size());
            //copy dataItrs from other to this
            dataItrs = other.dataItrs;
            nodeName = other.nodeName;

            //recursion on the children
            if (other.leftChild) {
                nodeAddLeft(new SPSnode(*(other.getLeftChild())));
            }
            else leftChild=NULL;

            if (other.rightChild) {
                nodeAddRight(new SPSnode(*(other.getRightChild())));
            }
            else rightChild=NULL;
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }
    }
\end{DoxyCode}


\subsubsection{\-Member \-Function \-Documentation}
\hypertarget{classsubpavings_1_1SPSnode_add75213a0cf94b42aa82aca57b02da3e}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-\_\-reshape\-To\-Union@{\-\_\-reshape\-To\-Union}}
\index{\-\_\-reshape\-To\-Union@{\-\_\-reshape\-To\-Union}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-\_\-reshape\-To\-Union}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::\-\_\-reshape\-To\-Union} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-Pnode} $\ast$const}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected, virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_add75213a0cf94b42aa82aca57b02da3e}


\-Internal method to reshape this to a union. 



\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_a7ac37cce7f65b0f4c71d37b06d581d17}{subpavings\-::\-S\-Pnode}.



\-Definition at line 621 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::\-\_\-reshape\-To\-Union().



\-Referenced by reshape\-To\-Union().


\begin{DoxyCode}
{
  SPnode::_reshapeToUnion(other);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_acae5407bbd325c9c4852c5a77304cee9}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!\-\_\-reshape\-To\-Union@{\-\_\-reshape\-To\-Union}}
\index{\-\_\-reshape\-To\-Union@{\-\_\-reshape\-To\-Union}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{\-\_\-reshape\-To\-Union}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::\-\_\-reshape\-To\-Union} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-Pnode} $\ast$const}]{other, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{const std\-::string \&}]{error\-Filename}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_acae5407bbd325c9c4852c5a77304cee9}


\-Internal method to reshape this to a union with a restriction of min\-Child\-Points. 


\begin{DoxyParams}{\-Parameters}
{\em min\-Child\-Points} & is the minimum child points to allow for a split (as usual, if one child gets all the points and the number of points in this is $>$= min\-Child\-Points, the split is allowed). \\
\hline
{\em error\-File\-Name} & is a file to which to log messages about nodes which could not be split because of {\itshape min\-Child\-Points\/}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if this was able to reshape to exactly the union of this and {\itshape other\/}, false if the extent to which descendents of this could split to mimic other was limted by {\itshape min\-Child\-Points\/}. 
\end{DoxyReturn}


\-Definition at line 629 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Left\-Child(), subpavings\-::\-S\-Pnode\-::get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::is\-Leaf(), and subpavings\-::output\-File().


\begin{DoxyCode}
{
  // indictator for being able to do union exactly
  bool success = true;
  
  if ( other != NULL && !(other->isEmpty()) ) {

    // this is not a leaf, other is a leaf
    if (!isLeaf() && other->isLeaf()) {

      // no need to do anything
    }

    // this is a leaf, other is not a leaf
    if (isLeaf() && !other->isLeaf()) {

      //we need to expand this
      if (isSplittableNode(minChildPoints)) nodeExpand();
      else {
        success = false;
        // log file
        std::string line = "Could not split " + getNodeName() 
         + " because of minChildPoints";
        
        outputFile(errorFilename, line); 
        
      }
      
    }

    // now recurse on the children if both have children
    // note - it won't go here is !success because still isLeaf()
    if (!isLeaf() && !other->isLeaf()) {
      success = getLeftChild()->_reshapeToUnion(
          other->getLeftChild(), minChildPoints, errorFilename);
      success = getRightChild()->_reshapeToUnion(
          other->getRightChild(), minChildPoints, errorFilename)
          && success;
    }
    
    return success;
  }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a7cf5893a0c2bcfe03caf2865203e6678}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!check\-Tree\-State\-Legal@{check\-Tree\-State\-Legal}}
\index{check\-Tree\-State\-Legal@{check\-Tree\-State\-Legal}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{check\-Tree\-State\-Legal}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::check\-Tree\-State\-Legal} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a7cf5893a0c2bcfe03caf2865203e6678}


\-Check tree rooted at this is legal with respect to \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node()}. 

'\-Legal' means that all non-\/leaf nodes in the tree are splittable, ie return \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node()} = true;

\begin{DoxyReturn}{\-Returns}
true if all non-\/leaf nodes in the tree rooted at this are splittable, false if any non-\/leaf node in the tree rooted at this is not splittable. 
\end{DoxyReturn}


\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_afde5e15be5259cf61821f175452d165f}{subpavings\-::\-S\-Pnode}.



\-Definition at line 1043 of file spsnode.\-cpp.



\-Referenced by check\-Tree\-State\-Legal().


\begin{DoxyCode}
{
  return SPnode::checkTreeStateLegal();
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a48e85710afe1e6b7f4d63afa891d4e38}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!check\-Tree\-State\-Legal@{check\-Tree\-State\-Legal}}
\index{check\-Tree\-State\-Legal@{check\-Tree\-State\-Legal}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{check\-Tree\-State\-Legal}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::check\-Tree\-State\-Legal} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a48e85710afe1e6b7f4d63afa891d4e38}


\-Check tree rooted at this is legal with respect to is\-Splittable\-Node(size\-\_\-t min\-Child\-Points, double min\-Vol). 

'\-Legal' means that all non-\/leaf nodes in the tree are splittable, ie return is\-Splittable\-Node(size\-\_\-t min\-Child\-Points, double min\-Vol) = true;


\begin{DoxyParams}{\-Parameters}
{\em min\-Child\-Points} & is the minimum number of points that there would be in the children if the node were to be split. \\
\hline
{\em min\-Vol} & is the minimum node volume to be tested for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if all non-\/leaf nodes in the tree rooted at this are splittable with respect to {\itshape min\-Child\-Points\/} and {\itshape min\-Vol\/}, false if any non-\/leaf node in the tree rooted at this is not splittable according to these criteria. 
\end{DoxyReturn}


\-Definition at line 1048 of file spsnode.\-cpp.



\-References check\-Tree\-State\-Legal(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), and is\-Splittable\-Node().


\begin{DoxyCode}
{
  // check current state is legal by looking at everything not a leaf
  bool legal = true;
  if ( !isLeaf() ) {
    legal = isSplittableNode(minChildPoints, minVol);
    if (legal && hasLCwithBox() ) {
        legal = 
          getLeftChild()->checkTreeStateLegal(minChildPoints,
                            minVol);
    }
    if (legal && hasRCwithBox() ) {
        legal = 
          getRightChild()->checkTreeStateLegal(minChildPoints,
                            minVol);
    }
  }
  
  return legal;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ae6a71f8266d023f98489dafcc56d3819}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!check\-Tree\-State\-Legal@{check\-Tree\-State\-Legal}}
\index{check\-Tree\-State\-Legal@{check\-Tree\-State\-Legal}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{check\-Tree\-State\-Legal}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::check\-Tree\-State\-Legal} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{min\-Child\-Points}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_ae6a71f8266d023f98489dafcc56d3819}


\-Check tree rooted at this is legal with respect to is\-Splittable\-Node(size\-\_\-t min\-Child\-Points). 

'\-Legal' means that all non-\/leaf nodes in the tree are splittable, ie return is\-Splittable\-Node(size\-\_\-\-T min\-Child\-Points) = true;


\begin{DoxyParams}{\-Parameters}
{\em min\-Child\-Points} & is the minimum number of points that there would be in the children if the node were to be split. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if all non-\/leaf nodes in the tree rooted at this are splittable with respect to {\itshape min\-Child\-Points\/}, false otherwise. 
\end{DoxyReturn}


\-Definition at line 1070 of file spsnode.\-cpp.



\-References check\-Tree\-State\-Legal(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), and is\-Splittable\-Node().


\begin{DoxyCode}
{
  // check current state is legal by looking at everything not a leaf
  bool legal = true;
  if ( !isLeaf() ) {
    legal = isSplittableNode(minChildPoints);
    if (legal && hasLCwithBox() ) {
        legal = 
          getLeftChild()->checkTreeStateLegal(minChildPoints);
    }
    if (legal && hasRCwithBox() ) {
        legal = 
          getRightChild()->checkTreeStateLegal(minChildPoints);
    }
  }
  
  return legal;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aa4b207c66d28113dc641d7cddf691547}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!clear\-Data@{clear\-Data}}
\index{clear\-Data@{clear\-Data}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{clear\-Data}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::clear\-Data} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aa4b207c66d28113dc641d7cddf691547}


\-Clears the node's data collection. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_af7739cf5333fccbe27610cbbd1138719}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1018 of file spsnode.\-cpp.



\-References data\-Itrs.


\begin{DoxyCode}
    { dataItrs.clear(); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ac16a08aea6f8316526c46382e3252959}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!gather\-Data@{gather\-Data}}
\index{gather\-Data@{gather\-Data}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{gather\-Data}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Node\-Data} \& {\bf \-S\-P\-Snode\-::gather\-Data} (
\begin{DoxyParamCaption}
\item[{{\bf \-Node\-Data} \&}]{container, }
\item[{{\bf \-S\-P\-Snode} $\ast$}]{spn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ac16a08aea6f8316526c46382e3252959}


\-Return a reference to the node data. 

\begin{DoxyReturn}{\-Returns}
a reference to a container of data associated with the node {\bfseries  and its descendents }. 
\end{DoxyReturn}


\-Definition at line 482 of file spsnode.\-cpp.



\-References data\-Itrs, get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().



\-Referenced by node\-Adopt\-Left(), node\-Adopt\-Right(), node\-Reabsorb\-Children(), and node\-Reunite().


\begin{DoxyCode}
    {
        if (!spn->isLeaf()) {
            if (spn->hasLCwithBox()) {
                container =
                    gatherData(container,
                            spn->getLeftChild());
            }
            if (spn->hasRCwithBox()) {
                container =
                    gatherData(container,
                            spn->getRightChild());
            }
        }
        else { // is a leaf
            // copy data from spn's dataItrs into temp container
            container.insert(container.end(),
                            (spn->dataItrs).begin(),
                            (spn->dataItrs).end());
        }

        return container;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a8683fb9b17016cbe615408b51e791b9c}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-All\-Nodes@{get\-All\-Nodes}}
\index{get\-All\-Nodes@{get\-All\-Nodes}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-All\-Nodes}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-Ptrs} \& {\bf \-S\-P\-Snode\-::get\-All\-Nodes} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode\-Ptrs} \&}]{all\-Nodes}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a8683fb9b17016cbe615408b51e791b9c}


\-Return a reference to all nodes. 

\begin{DoxyReturn}{\-Returns}
a reference to a container of node pointers. 
\end{DoxyReturn}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_ac637655f207bc9bc049145a2bd904fdf}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1348 of file spsnode.\-cpp.



\-References get\-All\-Nodes(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box(), and subpavings\-::\-S\-Pnode\-::is\-Empty().



\-Referenced by get\-All\-Nodes().


\begin{DoxyCode}
    {
        if (!isEmpty()) { // this is not empty
      //if (!hasLCwithBox() && !hasRCwithBox()) { // this is a leaf
            // arrgh horrible - cast away const if this node is a leaf
        //cout << nodeName << endl;
            allNodes.push_back(const_cast<SPSnode*>(this));
        }
      
      //if children, recurse on the children
        if (hasLCwithBox()) {
            getLeftChild()->getAllNodes(allNodes);
        }

        if (hasRCwithBox()) {
            getRightChild()->getAllNodes(allNodes);
        }       
        return allNodes;
   }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a0e8b9126a14255276600bf5293d33e24}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C@{get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C}}
\index{get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C@{get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a0e8b9126a14255276600bf5293d33e24}


\-Get best change in \-E\-M\-P under \-A\-I\-C from merging any subleaf. 

n, the value to use for scaling, cancels out of change.

\begin{DoxyReturn}{\-Returns}
best (lowest or most negative) scaled change in \-A\-I\-C from merging any of the subleaves. 
\end{DoxyReturn}


\-Definition at line 2239 of file spsnode.\-cpp.



\-References get\-Merge\-Change\-E\-M\-P\-A\-I\-C(), get\-Sub\-Leaves(), and subpavings\-::\-S\-Pnode\-::is\-Sub\-Leaf().



\-Referenced by subpavings\-::\-Crit\-A\-I\-C\-Merge\-Change\-\_\-\-G\-T\-E\-::operator()().


\begin{DoxyCode}
    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        if (isSubLeaf()) {  // this is a subleaf
            bestEMPChange = getMergeChangeEMPAIC();
        }

        else { // this is not a sub leaf
            // set up a container for the subleaf children
            SPSnodePtrs subleaves;
            // fill the container with the leaf children
            getSubLeaves(subleaves);

            // find the best child for splitting
            SPSnodePtrsItr it;
            SPSnode* best = *(subleaves.begin());

            bestEMPChange = best->getMergeChangeEMPAIC();

            for(it = subleaves.begin(); it < subleaves.end(); it++) {
                if ((*it)->getMergeChangeEMPAIC() < bestEMPChange) {

                    bestEMPChange = (*it)->getMergeChangeEMPAIC();
                }
            }
        } // end else not a subleaf

        return bestEMPChange;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a7cf8fbd3c03d1edeedbd5a793c9b822d}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}}
\index{get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a7cf8fbd3c03d1edeedbd5a793c9b822d}


\-Get best change in \-E\-M\-P under \-C\-O\-P\-E\-R\-R from merging any subleaf. 


\begin{DoxyParams}{\-Parameters}
{\em n} & the value to use for scaling, the total number of points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
best (lowest or most negative) scaled change in \-C\-O\-P\-E\-R\-R from merging any of the subleaves. 
\end{DoxyReturn}


\-Definition at line 2204 of file spsnode.\-cpp.



\-References get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), get\-Sub\-Leaves(), and subpavings\-::\-S\-Pnode\-::is\-Sub\-Leaf().


\begin{DoxyCode}
    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        if (isSubLeaf()) {  // this is a subleaf
            bestEMPChange = getMergeChangeEMPCOPERR(n);
        }

        else { // this is not a subleaf
            // set up a container for the subleaf children
            SPSnodePtrs subleaves;
            // fill the container with the leaf children
            getSubLeaves(subleaves);

            // find the best child for splitting
            SPSnodePtrsItr it;
            SPSnode* best = *(subleaves.begin());

            bestEMPChange = best->getMergeChangeEMPCOPERR(n);

            for(it = subleaves.begin(); it < subleaves.end(); it++) {
                if ((*it)->getMergeChangeEMPCOPERR(n) < bestEMPChange) {

                    bestEMPChange = (*it)->getMergeChangeEMPCOPERR(n);
                }
            }
        } // end else not a subleaf

        return bestEMPChange;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a53b9e7117d36f7730d458f26d74e0d28}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C@{get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C}}
\index{get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C@{get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a53b9e7117d36f7730d458f26d74e0d28}


\-Get best change in \-E\-M\-P under \-A\-I\-C from splitting any leaf. 

n, the value to use for scaling, cancels out of change.

\begin{DoxyReturn}{\-Returns}
best (lowest or most negative) scaled change in \-A\-I\-C from splitting any of the leaves. 
\end{DoxyReturn}


\-Definition at line 2169 of file spsnode.\-cpp.



\-References get\-Leaves(), get\-Split\-Change\-E\-M\-P\-A\-I\-C(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().



\-Referenced by subpavings\-::\-Crit\-A\-I\-C\-Change\-\_\-\-G\-T\-E\-::operator()().


\begin{DoxyCode}
    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        if (isLeaf()) {  // this is a leaf
            bestEMPChange = getSplitChangeEMPAIC();
        }

        else { // this is not a leaf
            // set up a container for the leaf children
            SPSnodePtrs leaves;
            // fill the container with the leaf children
            getLeaves(leaves);

            // find the best child for splitting
            SPSnodePtrsItr it;
            SPSnode* best = *(leaves.begin());

            bestEMPChange = best->getSplitChangeEMPAIC();

            for(it = leaves.begin(); it < leaves.end(); it++) {
                if ((*it)->getSplitChangeEMPAIC() < bestEMPChange) {

                    bestEMPChange = (*it)->getSplitChangeEMPAIC();
                }
            }
        } // end else not a leaf

        return bestEMPChange;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a3b5e815e94d8a276d7b13c0dc25a8dc4}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}}
\index{get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a3b5e815e94d8a276d7b13c0dc25a8dc4}


\-Get best change in \-E\-M\-P under \-C\-O\-P\-E\-R\-R from splitting any leaf. 


\begin{DoxyParams}{\-Parameters}
{\em n} & the value to use for scaling, the total number of points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
best (lowest or most negative) scaled change in \-C\-O\-P\-E\-R\-R from splitting any of the leaves. 
\end{DoxyReturn}


\-Definition at line 2134 of file spsnode.\-cpp.



\-References get\-Leaves(), get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().



\-Referenced by subpavings\-::\-Crit\-C\-O\-P\-E\-R\-R\-Change\-\_\-\-G\-T\-E\-::operator()(), and subpavings\-::\-Crit\-C\-O\-P\-E\-R\-R\-Merge\-Change\-\_\-\-G\-T\-E\-::operator()().


\begin{DoxyCode}
    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        if (isLeaf()) {  // this is a leaf
            bestEMPChange = getSplitChangeEMPCOPERR(n);
        }

        else { // this is not a leaf
            // set up a container for the leaf children
            SPSnodePtrs leaves;
            // fill the container with the leaf children
            getLeaves(leaves);

            // find the best child for splitting
            SPSnodePtrsItr it;
            SPSnode* best = *(leaves.begin());

            bestEMPChange = best->getSplitChangeEMPCOPERR(n);

            for(it = leaves.begin(); it < leaves.end(); it++) {
                if ((*it)->getSplitChangeEMPCOPERR(n) < bestEMPChange) {

                    bestEMPChange = (*it)->getSplitChangeEMPCOPERR(n);
                }
            }
        } // end else not a leaf

        return bestEMPChange;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a7713822499beb30a3d30f43b79c608b8}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Cheb\-Dist\-Covar@{get\-Cheb\-Dist\-Covar}}
\index{get\-Cheb\-Dist\-Covar@{get\-Cheb\-Dist\-Covar}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Cheb\-Dist\-Covar}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Cheb\-Dist\-Covar} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a7713822499beb30a3d30f43b79c608b8}


\-Get the \-Chebyshev distance for the var-\/covar. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a63ea0f67b354888a8a12c0ffc81b0e5e}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1561 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::dimension, get\-Uniform\-Var\-Covar(), and get\-Var\-Covar().



\-Referenced by subpavings\-::\-Comp\-Covar\-::operator()(), and subpavings\-::\-Comp\-Covar\-Mass\-::operator()().


\begin{DoxyCode}
  {
    RealVec Covar = getVarCovar();
    RealVec unifCovar = getUniformVarCovar();

    real ChebDist = 0;
    //loop through the real vector and get the Chebyshev distances
    
    for (int i = 0; i < dimension*dimension; i++) {
        real temp = abs(Covar[i] - unifCovar[i]);
        //std::cout << temp << "\t" << ChebDist << std::endl;
        ChebDist  = ( temp > ChebDist) ? temp : ChebDist;
      }
      
      //cout << "getChebDist: " << endl;
    return ChebDist;
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aa3a4a9df979f04453e82d76866b52850}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Cheb\-Dist\-Mean@{get\-Cheb\-Dist\-Mean}}
\index{get\-Cheb\-Dist\-Mean@{get\-Cheb\-Dist\-Mean}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Cheb\-Dist\-Mean}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Cheb\-Dist\-Mean} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aa3a4a9df979f04453e82d76866b52850}


\-Get the \-Chebyshev distance for the mean. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a24fc7b09a8293edce2e3b602763a45e3}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1542 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::dimension, get\-Mean(), and get\-Uniform\-Mean().



\-Referenced by subpavings\-::\-Comp\-Mean\-::operator()(), and subpavings\-::\-Comp\-Mean\-Mass\-::operator()().


\begin{DoxyCode}
  {
    rvector Mean = getMean();
    rvector MeanUnif = getUniformMean();
    real ChebDist = 0;
    //loop through the means and get the Chebyshev distances
    for (int i = 1; i <= dimension; i++) {
        real temp = abs(Mean[i] - MeanUnif[i]);
        //std::cout << temp << "\t" << ChebDist << std::endl;
        ChebDist  = ( temp > ChebDist) ? temp : ChebDist;
      }
      
      //cout << "getChebDist: " << endl;
      //std::cout << getNodeName() << "\t" << getMean() << "\t" <<
       getUniformMean() << std::endl;
    return ChebDist;
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_acbe47754c218f0c895a900330491cbb3}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split@{get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split}}
\index{get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split@{get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Size\-\_\-t\-Vec} \& {\bf \-S\-P\-Snode\-::get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split} (
\begin{DoxyParamCaption}
\item[{{\bf \-Size\-\_\-t\-Vec} \&}]{grandchild\-Counts}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_acbe47754c218f0c895a900330491cbb3}


return a container of counts for prospective grandchildren. 

\-Should be called only on leaf nodes.

returns an indexable container of the number of points the prospective children of each prospective child (ie all four prospective grandchildren) would be associated with, indexed like this \mbox{[}0\mbox{]} = left child's left child count, \mbox{[}1\mbox{]} = left child's rght child count, \mbox{[}2\mbox{]} = rght child's left child count, \mbox{[}3\mbox{]} = rght child's rght child count, 
\begin{DoxyParams}{\-Parameters}
{\em grandchild\-Counts} & a reference to a container to be filled with the prospective grandchild counts \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
grandchild\-Counts filled with the prospective grandchild counts. 
\end{DoxyReturn}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_ad1e930cb7befb42cd1985e91f3ddd9b6}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1238 of file spsnode.\-cpp.



\-References \-Lower(), \-Max\-Diam(), \-Max\-Diam\-Comp(), and \-Upper().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Split().


\begin{DoxyCode}
  {
    try {

      // first find what the children's boxes would be would be
      int splitMe; // variable to hold first longest dimension
      ivector box = getBox();
      double temp1 = MaxDiam(box, splitMe);

      // ivectors to be new boxes for new children
      ivector rCBox;
      ivector lCBox;
      
      // Call Upper() to get what would be the right hand child box
      Upper(box, rCBox, splitMe);
      // Call Lower() to get what would be the left hand child box
      Lower(box, lCBox, splitMe);
      
      // mid point of my box on first longest dimension
      cxsc::real midSplit = cxsc::mid(box[splitMe]);

      // and if those children were split
      // left Child 
      int splitChildren = MaxDiamComp(lCBox);
      
      cxsc::real midSplitLC = cxsc::mid(lCBox[splitChildren]);
      
      // right child 
      // will split on the same dimension as LC
      
      cxsc::real midSplitRC = cxsc::mid(rCBox[splitChildren]);
      
      // now find how many of this node's data points would go right
      // and left children of left and right children
      size_t rightRightCount = 0;
      size_t rightLeftCount = 0;
      size_t leftRightCount = 0;
      size_t leftLeftCount = 0;
      NodeDataItr it;

      for (it = dataItrs.begin(); it < dataItrs.end(); it++) {
        // DataItrs is a container of iterators to a BigDataCollection
        rvector p = **it;
        // increment left child?
        if ( p[splitMe] < midSplit ) {
          if ( p[splitChildren] < midSplitLC ) leftLeftCount++;
          else rightLeftCount++;
        }
        else { // on right of me
          if ( p[splitChildren] < midSplitRC) leftRightCount++;
          else rightRightCount++;
        }
      }

      grandchildCounts.push_back(leftLeftCount);
      grandchildCounts.push_back(rightLeftCount);
      grandchildCounts.push_back(leftRightCount);
      grandchildCounts.push_back(rightRightCount);


      return grandchildCounts;
    }
    catch (exception& e) {
      string msg = string(e.what());
      throw SPnodeException("Error in getChildrensLeftAndRightCountsIfSplit:\n"
       + msg);
    }
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ab4bee06d1b314b064d88842ba720d4a3}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Counter@{get\-Counter}}
\index{get\-Counter@{get\-Counter}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Counter}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-S\-P\-Snode\-::get\-Counter} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_ab4bee06d1b314b064d88842ba720d4a3}


\-Accessor for the counter. 



\-Definition at line 997 of file spsnode.\-cpp.



\-References counter.



\-Referenced by subpavings\-::\-Real\-Mapped\-S\-Pnode\-::\-\_\-get\-Log\-Likelihood(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Merge(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Split(), subpavings\-::check\-Node\-Count\-For\-Split(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::check\-Node\-Count\-For\-Split(), subpavings\-::\-Adaptive\-Histogram\-::check\-Node\-Count\-For\-Split(), subpavings\-::\-Collator\-S\-Pnode\-::\-Collator\-S\-Pnode(), subpavings\-::\-Collator\-S\-P\-Vnode\-::\-Collator\-S\-P\-Vnode(), subpavings\-::\-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Merge(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::get2\-D\-I\-A\-E(), subpavings\-::\-Adaptive\-Histogram\-::get2\-D\-I\-A\-E(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Emp\-Mass(), get\-Emp\-Mass(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::get\-Fin\-Mix\-I\-A\-E(), subpavings\-::\-Adaptive\-Histogram\-::get\-Fin\-Mix\-I\-A\-E(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::get\-Fin\-Mix\-Interval\-I\-A\-E(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Hellinger\-Dist(), get\-Hellinger\-Dist(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Hellinger\-Dist1\-D(), get\-Hellinger\-Dist1\-D(), subpavings\-::\-Real\-Mapped\-S\-Pnode\-::get\-Log\-Likelihood(), get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), get\-Merge\-Change\-Log\-Lik(), get\-Min\-Child\-Count\-If\-Split\-N\-E\-W(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::get\-Min\-Vol(), subpavings\-::\-Adaptive\-Histogram\-::get\-Min\-Vol(), subpavings\-::\-Adaptive\-Histogram\-::get\-Root\-Counter(), subpavings\-::\-Adaptive\-Histogram\-::get\-Score\-A\-I\-C(), subpavings\-::\-Adaptive\-Histogram\-::get\-Score\-C\-O\-P\-E\-R\-R(), subpavings\-::\-Adaptive\-Histogram\-::get\-Unif\-I\-A\-E(), subpavings\-::\-Comp\-Count\-Val\-::operator()(), subpavings\-::\-Comp\-Count\-::operator()(), subpavings\-::\-Comp\-Height\-Val\-::operator()(), subpavings\-::\-Split\-On\-K\-::operator()(), subpavings\-::\-Comp\-Area\-Val\-::operator()(), subpavings\-::\-Split\-On\-Vol\-Div\-K\-::operator()(), subpavings\-::\-Split\-On\-Kand\-Vol\-::operator()(), subpavings\-::\-Crit\-C\-O\-P\-E\-R\-R\-Change\-\_\-\-G\-T\-E\-::operator()(), subpavings\-::\-Comp\-Height\-::operator()(), subpavings\-::\-Comp\-Area\-::operator()(), subpavings\-::\-Comp\-Ext\-Area\-::operator()(), subpavings\-::\-Crit\-C\-O\-P\-E\-R\-R\-Merge\-Change\-\_\-\-G\-T\-E\-::operator()(), subpavings\-::\-Adaptive\-Histogram\-::output\-Log(), subpavings\-::\-Adaptive\-Histogram\-::output\-To\-Txt\-Tabs\-With\-E\-M\-Ps(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Merge(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate\-With\-Switch(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var(), subpavings\-::\-Real\-Mapped\-S\-Pnode\-::\-Real\-Mapped\-S\-Pnode(), subpavings\-::\-Adaptive\-Histogram\-::recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), subpavings\-::\-Adaptive\-Histogram\-::recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), and sps\-Contains().


\begin{DoxyCode}
    { return counter; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a4285801767cd577432a0b13cdbdaba43}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Counts\-Only@{get\-Counts\-Only}}
\index{get\-Counts\-Only@{get\-Counts\-Only}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Counts\-Only}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Counts\-Only} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a4285801767cd577432a0b13cdbdaba43}


\-Accessor for the counts\-Only value. 



\-Definition at line 1009 of file spsnode.\-cpp.



\-References counts\-Only.


\begin{DoxyCode}
    { return countsOnly; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a8906934b09d85e67c49d38548e0cd38a}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Data@{get\-Data}}
\index{get\-Data@{get\-Data}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Data}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Node\-Data} {\bf \-S\-P\-Snode\-::get\-Data} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a8906934b09d85e67c49d38548e0cd38a}


\-Accessor for the node's data collection. 

\-Returns a copy of the node's collection of iterators to the big data set. 

\-Definition at line 1014 of file spsnode.\-cpp.



\-References data\-Itrs.



\-Referenced by sps\-Contains().


\begin{DoxyCode}
    { return dataItrs; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aa939623d58172bc7f24ddf5dd249b5c2}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-E\-M\-P\-Contribution\-A\-I\-C@{get\-E\-M\-P\-Contribution\-A\-I\-C}}
\index{get\-E\-M\-P\-Contribution\-A\-I\-C@{get\-E\-M\-P\-Contribution\-A\-I\-C}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-E\-M\-P\-Contribution\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-E\-M\-P\-Contribution\-A\-I\-C} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aa939623d58172bc7f24ddf5dd249b5c2}


\-Get this node's scaled contribution to \-E\-M\-P under \-A\-I\-C. 

\-Under \-A\-I\-C, \-E\-M\-P is -\/1 x sum over leaves of (counts in leaf x ln(count in leaf / (n $\ast$ vol of leaf))) where n is the total number of data points in the histogram. \-And this is -\/1 $\ast$ the node's contribution to the loglikelihood of the data given the current state.

\-Should only be called on leaf nodes. 
\begin{DoxyParams}{\-Parameters}
{\em n} & the value to use for scaling, the total number of points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
counter $\ast$ (-\/ln(counter/(n$\ast$volume))) for this node. 
\end{DoxyReturn}


\-Definition at line 2291 of file spsnode.\-cpp.



\-References get\-Log\-Lik().



\-Referenced by get\-E\-M\-P\-Sum\-A\-I\-C().


\begin{DoxyCode}
    {
        return -getLogLik(n);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a483f3b91707cda0deaee7a05d0523f3b}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R@{get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R}}
\index{get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R@{get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a483f3b91707cda0deaee7a05d0523f3b}


\-Get this node's scaled contribution to \-E\-M\-P under \-C\-O\-P\-E\-R\-R. 

\-Under \-C\-O\-P\-E\-R\-R, \-E\-M\-P is -\/1/n$^\wedge$2 x sum over leaves of (counts in leaf squared / volume of leaf) where n is the total number of data points in the histogram \-Should only be called on leaf nodes 
\begin{DoxyParams}{\-Parameters}
{\em n} & the value to use for scaling, the total number of points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
-\/counter$^\wedge$2/(n$\ast$volume) for this node. 
\end{DoxyReturn}


\-Definition at line 2272 of file spsnode.\-cpp.



\-References counter, and subpavings\-::\-S\-Pnode\-::node\-Volume().



\-Referenced by get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R().


\begin{DoxyCode}
    {
        // current number of data points associated to node is counter
        // current node volume from nodeVolume, and each child will have half

        dotprecision contribution(0.0);
        if ((n > 0) && (counter > 0)) {
            accumulate(contribution, -(1.0*counter)/(1.0*n),
                    (1.0*counter)/(n*nodeVolume()));
        }

        // contribution is -counter^2/(n^2 * vol)
        // default cxsc rounding to nearest

        //return contribution;
        return rnd(contribution);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a31ee93bb53be29fd0e50ff7fcd189c98}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Emp\-Mass@{get\-Emp\-Mass}}
\index{get\-Emp\-Mass@{get\-Emp\-Mass}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Emp\-Mass}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf \-S\-P\-Snode\-::get\-Emp\-Mass} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a31ee93bb53be29fd0e50ff7fcd189c98}


get the empirical mass of the node 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_afb9e32e6d78db527309d95ccc8c0049f}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1581 of file spsnode.\-cpp.



\-References get\-Counter(), and get\-Root\-Counter().



\-Referenced by subpavings\-::\-Comp\-Mean\-Mass\-::operator()(), subpavings\-::\-Comp\-Covar\-Mass\-::operator()(), subpavings\-::\-Comp\-Hellinger\-Dist1\-D\-Mass\-::operator()(), subpavings\-::\-Comp\-Hellinger\-Dist1\-D\-Mass\-Diam\-::operator()(), subpavings\-::\-Comp\-Hellinger\-Dist\-Mass\-::operator()(), subpavings\-::\-Comp\-Hellinger\-Dist\-Mass\-Diam\-::operator()(), and subpavings\-::\-Comp\-Vol\-Inv\-::operator()().


\begin{DoxyCode}
  {
    int n = getRootCounter();
    double empMass = (getCounter()*1.0)/(1.0*n);
    //cout << nodeName << "\t" << empMass << endl;
    return empMass;
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a26329c8ddf55f351a673fe258e5abd15}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-E\-M\-P\-Sum\-A\-I\-C@{get\-E\-M\-P\-Sum\-A\-I\-C}}
\index{get\-E\-M\-P\-Sum\-A\-I\-C@{get\-E\-M\-P\-Sum\-A\-I\-C}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-E\-M\-P\-Sum\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-E\-M\-P\-Sum\-A\-I\-C} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a26329c8ddf55f351a673fe258e5abd15}


\-Get the unscaled \-E\-M\-P sum under \-A\-I\-C for tree rooted at this. 


\begin{DoxyParams}{\-Parameters}
{\em n} & the total number of points in the histogram, for scaling \\
\hline
\end{DoxyParams}


\-Definition at line 2543 of file spsnode.\-cpp.



\-References get\-E\-M\-P\-Contribution\-A\-I\-C(), get\-E\-M\-P\-Sum\-A\-I\-C(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().



\-Referenced by get\-E\-M\-P\-Sum\-A\-I\-C(), and subpavings\-::\-Adaptive\-Histogram\-::recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C().


\begin{DoxyCode}
    {
        dotprecision retValue;
        retValue = 0.0;

        // uses  member function getEMPContributionAIC for leaf result
        if (!(isEmpty()) && isLeaf()) { // this is a non-empty leaf
            retValue = getEMPContributionAIC(n);
        }

        //recurse on the children
        if (getLeftChild()!=NULL) {
            retValue+=getLeftChild()->getEMPSumAIC(n);
        }

        if (getRightChild()!=NULL) {
            retValue+=getRightChild()->getEMPSumAIC(n);
        }
        return retValue;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ad8b17faf69caa46fcfa021b61d09e278}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}}
\index{get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_ad8b17faf69caa46fcfa021b61d09e278}


\-Get scaled \-E\-M\-P sum under \-C\-O\-P\-E\-R\-R for tree rooted at this. 


\begin{DoxyParams}{\-Parameters}
{\em n} & the total number of points in the histogram, for scaling \\
\hline
\end{DoxyParams}


\-Definition at line 2519 of file spsnode.\-cpp.



\-References get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R(), get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().



\-Referenced by get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), and subpavings\-::\-Adaptive\-Histogram\-::recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R().


\begin{DoxyCode}
    {
        dotprecision retValue;
        retValue = 0.0;

        // uses  member function getEMPContributionCOPERR for leaf value
        if (!(isEmpty()) && isLeaf()) { // this is a non-empty leaf
            retValue = getEMPContributionCOPERR(n);
        }

        //recurse on the children
        if (getLeftChild()!=NULL) {
            retValue = retValue + getLeftChild()->getEMPSumCOPERR(n);
        }

        if (getRightChild()!=NULL) {
            retValue = retValue + getRightChild()->getEMPSumCOPERR(n);
        }

        return retValue;

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aa0ea6455e40f7f2bdb1e972ab080f5a5}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Hellinger\-Dist@{get\-Hellinger\-Dist}}
\index{get\-Hellinger\-Dist@{get\-Hellinger\-Dist}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Hellinger\-Dist}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Hellinger\-Dist} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aa0ea6455e40f7f2bdb1e972ab080f5a5}


\-Get the \-Bhattarchaya coefficient. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a2e0a1a393daed9e3f5887162b68b0e6e}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1591 of file spsnode.\-cpp.



\-References data\-Itrs, subpavings\-::\-S\-Pnode\-::dimension, taylor\-::exp(), get\-Counter(), get\-Mean(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), get\-Root\-Counter(), get\-Uniform\-Mean(), get\-Uniform\-Var\-Covar(), get\-Var\-Covar(), taylor\-::pow(), and taylor\-::sqrt().



\-Referenced by subpavings\-::\-Comp\-Hellinger\-Dist\-Mass\-::operator()(), and subpavings\-::\-Comp\-Hellinger\-Dist\-Mass\-Diam\-::operator()().


\begin{DoxyCode}
   {
    RealVec Covar = getVarCovar(); //get the covariance matrix/
    real HD = 0.0; //initialize hellinger distance to 0.

    // if there are no points, cov should be undefined. But since we want to
       push
    // this node to the bottom of the queue, hence let HD = 0.
    // if there is one point, the variance is 0. At the moment, we do not 
    // want to split boxes with only one point and so also let HD = 0.
    if ( getCounter() == 0 || getCounter() == 1 ) { return HD = 0.0; } 

    else {
  //    cout << "===========================" << getNodeName() << "\t" <<
       getCounter() << endl;
      //get the differences of the mean vectors
      rvector diffMean = getMean() - getUniformMean();
      //cout << "mean differences: " << diffMean << endl;

      //make a gsl matrix for the mean difference
      gsl_matrix * diffMeanMat = gsl_matrix_alloc(dimension, 1);
      for (int i = 0; i < dimension; i++) {
        for (int j = 0; j < 1; j++) {
          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));
        }
      }

      // get the variances
      RealVec unifCovar = getUniformVarCovar();

      // initialize matrix objects
      gsl_matrix * CovarMat = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * CovarMatMult = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * UnifCovarMat = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * PMat = gsl_matrix_alloc(dimension, dimension); //make this
       same as
                                              //CovarMat first
      int n = getRootCounter();
    
      // problem with stably inverting the covariance matrix - if determinant
       is wrong, will get -DB
      // fill up the matrics for the var-covar
      int k = 0; //counter for RealVec
      for (int i = 0; i < dimension; i++) {
        for (int j=0; j < dimension; j++) {

          if ( i == j ) {
            gsl_matrix_set(CovarMat, i, j, _double(Covar[k]) + 0.00000001); //
      cast to double
            gsl_matrix_set(CovarMatMult, i, j, 100*(_double(Covar[k]))+0.000000
      01);
          }
          else {
            gsl_matrix_set(CovarMat, i, j, _double(Covar[k])); //cast to double
            gsl_matrix_set(CovarMatMult, i, j, 100*(_double(Covar[k])));
          }
          
          gsl_matrix_set(PMat, i, j, _double(Covar[k])); //cast to double
          gsl_matrix_set(UnifCovarMat, i, j, _double(unifCovar[k])); //cast to
       double
          k++;
        }
      }

      // if variance is -ve, atomic data points? treat as only one point (not
      // a very good assumption at the moment) and let HD = 0. 
      for ( int i = 0; i < dimension; i++) {
        for (int j = 0; j < dimension; j++) {
          if ( (i == j) && (gsl_matrix_get(CovarMat, i, j) < 0) ) {
            cerr << "Negative variance!" << endl;
            cout.precision(20);
            cout << getCounter() << endl;
            NodeDataItr dataItr;
            cout << getNodeName() << endl;
            cout.precision(20);
            cout << "Data is" << std::endl;
            for (dataItr = dataItrs.begin();
              dataItr!= dataItrs.end(); dataItr++) {
              BigDataItr bigIt = *dataItr;
              rvector theData = *bigIt;
              cout << theData << endl; 
            } // end loop through data container
        
            //cerr << "Variance cannot be negative." << endl; 
            //exit(1); 
            
            
            //gsl_matrix_free(CovarMat);
            //gsl_matrix_free(UnifCovarMat);
            //gsl_matrix_free(PMat);
            return HD = 0.0;
             
          }
        }
      }
  
      //else {
        /*cout << "CovarMat: " << endl;
        for (int i = 0; i < dimension; i++) {
          for (int j=0; j < dimension; j++) {
            cout << i << "\t" << j << "\t" << gsl_matrix_get(CovarMat, i, j) <<
       endl; 
          }
        }
        cout << "CovarMatMult: " << endl;
        for (int i = 0; i < dimension; i++) {
          for (int j=0; j < dimension; j++) {
            cout << i << "\t" << j << "\t" << gsl_matrix_get(CovarMatMult, i,
       j) << endl; 
          }
        }
        cout << "UnifCovarMat: " << endl;
        for (int i = 0; i < dimension; i++) {
          for (int j=0; j < dimension; j++) {
            cout << i << "\t" << j << "\t" << gsl_matrix_get(UnifCovarMat, i,
       j) << endl; 
          }
        }   
          */
        //add the two matrices
        gsl_matrix_add(PMat, UnifCovarMat);
        gsl_matrix_scale(PMat, 0.5);
        
        gsl_matrix * PMatForInv = gsl_matrix_alloc(dimension, dimension);
        PMatForInv = PMat; 
        /*cout << "PMat: " << endl;
        for (int i = 0; i < dimension; i++) {
          for (int j=0; j < dimension; j++) {
            cout << i << "\t" << j << "\t" << gsl_matrix_get(PMat, i, j) <<
       endl; 
          }
        }*/

        // get the determinants of CovarMat, UnifCovarMat, PMat
        int s;
        gsl_permutation * p = gsl_permutation_alloc(dimension);
        gsl_linalg_LU_decomp(CovarMatMult, p, &s);
        //cout << "CovarMat LU decomp: " << endl;
        for (int i = 0; i < dimension; i++) {
          for (int j=0; j < dimension; j++) {
            //cout << i << "\t" << j << "\t" << gsl_matrix_get(CovarMat, i, j)
       << endl; 
          }
        }
        double detCovarMat = gsl_linalg_LU_det(CovarMatMult, s)/(pow(100,
      dimension));
        //cout << "det covar mat: " << detCovarMat << "\t" << endl;
        gsl_permutation_free(p);
        // it is possible to get negative determinants, and negative DB,
       temporarily sweeping this under the rug 
        if (detCovarMat < 0) { cout << "Negative determinant." << endl; exit(1)
      ; }//return HD = 0.0; }
        else {
          
          int s1;
          gsl_permutation * p1 = gsl_permutation_alloc(dimension);
          gsl_linalg_LU_decomp(UnifCovarMat, p1, &s1);
          //cout << "UnifCovarMat decomp: " << endl;
          for (int i = 0; i < dimension; i++) {
            for (int j=0; j < dimension; j++) {
              //cout << i << "\t" << j << "\t" << gsl_matrix_get(UnifCovarMat,
       i, j) << endl; 
            }
          }
          double detUnifCovarMat = gsl_linalg_LU_det(UnifCovarMat, s1);
          //cout << "det unif covar mat: " << detUnifCovarMat << endl;
          gsl_permutation_free(p1);

          int s2;
          gsl_permutation * p2 = gsl_permutation_alloc(dimension);
          gsl_linalg_LU_decomp(PMat, p2, &s2);
          double detPMat = gsl_linalg_LU_det(PMat, s2);
          //cout << "det p mat: " << detPMat << endl;
  
          //now get the inverse of P
          gsl_matrix * Pinverse = gsl_matrix_alloc(dimension, dimension); 
          gsl_linalg_LU_invert(PMat, p2, Pinverse);
          gsl_permutation_free(p2);
          //cout << "p inverse " << endl;
          for (int i = 0; i < dimension; i++) {
            for (int j=0; j < dimension; j++) {
              //cout << i << "\t" << j << "\t" << gsl_matrix_get(Pinverse, i,
       j) << endl; 
            }
          }
      
          //now get the Bhattacharya coefficient
          //DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 +
       0.5*log(detP/sqrt{detP1}{detP2});
          gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, dimension);
          gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);
        
          // now convert all to rmatrix for easier computations
          rmatrix diffMeanR(0, dimension-1, 0, 0);
          for (int i = 0; i < dimension; i++) {
            for (int j=0; j < 1; j++) {
              diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); 
            }
          }
        
          rmatrix diffMeanTransR(0, 0, 0, dimension-1);
          for (int i = 0; i < 1; i++) {
            for (int j=0; j < dimension; j++) {
              diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j)
      ; 
            }
          }
        
          rmatrix PinvR(0, dimension-1, 0, dimension-1);
          for (int i = 0; i < dimension; i++) {
            for (int j=0; j < dimension; j++) {
              PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); 
            }
          }
        
          //free the gsl_matrices
          gsl_matrix_free(CovarMat);
          gsl_matrix_free(UnifCovarMat);
          gsl_matrix_free(PMat);
        
          //cout << diffMeanR << endl;
          //cout << diffMeanTransR << endl;
          //cout << PinvR << endl;
        
          //now get the Bhattacharya coefficient
          //DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 +
       0.5*log(detP/sqrt{detP1}{detP2});
          //cout << (diffMeanTransR*PinvR)*diffMeanR << endl;
          rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;
          //cout << MatOp << "\t" << MatOp[0][0] << endl;
          assert(MatOp >= 0);
          real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/sqrt(detCovarMat*
      detUnifCovarMat));
          //cout << "DB: " << DB << endl;
          if (DB < 0) { return HD = 0.0; }
          else {
            real BC = exp(-DB);
            assert(BC >= 0);
          //cout << "BC: " << BC << endl;
            real HD = sqrt(1-BC);
          //cout << "HD: " << HD << endl;
            assert(HD >=0);
            return HD;
          }
        } // end of determinant is not zero
      }
  }   
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_afe386393d18f1e251972e959e79c3847}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Hellinger\-Dist1\-D@{get\-Hellinger\-Dist1\-D}}
\index{get\-Hellinger\-Dist1\-D@{get\-Hellinger\-Dist1\-D}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Hellinger\-Dist1\-D}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Hellinger\-Dist1\-D} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_afe386393d18f1e251972e959e79c3847}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a3b56f3b8a024ab6929087e803e7af765}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1820 of file spsnode.\-cpp.



\-References data\-Itrs, taylor\-::exp(), get\-Counter(), get\-Mean(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), get\-Uniform\-Mean(), get\-Uniform\-Var\-Covar(), get\-Var\-Covar(), and taylor\-::sqrt().



\-Referenced by subpavings\-::\-Comp\-Hellinger\-Dist1\-D\-::operator()(), subpavings\-::\-Comp\-Hellinger\-Dist1\-D\-Mass\-::operator()(), and subpavings\-::\-Comp\-Hellinger\-Dist1\-D\-Mass\-Diam\-::operator()().


\begin{DoxyCode}
   {
    real HD = 0.0; 
    RealVec Covar = getVarCovar();

    // if the variance is negative - need to investiage this more
    
    if (Covar[0] < 0) {
      cout << getCounter() << endl;
      cout << Covar[0] << endl;
      NodeDataItr dataItr;
      cout << getNodeName() << endl;
      cout.precision(20);
      cout << "Data is" << std::endl;
          for (dataItr = dataItrs.begin();
                dataItr!= dataItrs.end(); dataItr++) {

                BigDataItr bigIt = *dataItr;
                rvector theData = *bigIt;

                cout << theData << endl; 
      } // end loop through data container
      
      cerr << "Variance cannot be negative." << endl; 
    //  exit(1);
      return HD = 0.0; 
    }

    // can continue if variance is not negative

      // if there are no points, should be undefined. But since we want to push
      // this node to the bottom of the queue, hence let HD = 0.
      // if there is one point, the variance is 0. At the moment, we do not 
      //want to split boxes with only one point and so also let HD = 0.
      // if variance is -ve, atomic data points? treat as only one point (not
      // a very good assumption at the moment) and let HD = 0. 
      if ( getCounter() == 0  || Covar[0] <= 0 ) { return HD = 0.0; } 
      /*else if ( Covar[0] == 0 ) { 
        cout << getCounter() << endl;
        cout << getEmpMass() << endl;
        cout << nodeVolume() << endl;
        cout << getMean() << endl;
        //cerr << "no variance. check!" << endl;
        //exit(1);
      }*/

      else {
        //get the differences of the mean vectors
        rvector diffMean = getMean() - getUniformMean();
        //cout << "mean differences: " << diffMean[1] << endl;
        
        // get the variances
        RealVec unifCovar = getUniformVarCovar();
        //cout << "Covar: " << Covar[0] <<  endl;
        //cout << "unifCovar: " << unifCovar[0] << endl;
        //if all the elements for CovarMat are all zero, we do not have any
       points in 
        //this leaf node - so return hellinger distance as 0
  
        // use the sqrt of the squared hellinger distance for two normal
       distributions
        // 1 - sqrt(2*sigma1*sigma2/(sigma1^2 +
       sigma2^2))*exp(-0.25*(mu1-mu2)^2/(sigma1^2+sigma2^2))
        //cout << diffMean << "\t";
        interval covarI = interval(Covar[0]);
        interval unifCovarI = interval(unifCovar[0]);
        interval sumVar = covarI + unifCovarI;
        //cout << sumVar << "\t";
        interval insqrt = 2*sqrt(covarI)*sqrt(unifCovarI)/sumVar;
        //cout << insqrt << "\t";
        interval H2 = interval(1,1) - sqrt(insqrt) *exp((-0.25*diffMean[1]*
      diffMean[1])/sumVar);
        //cout << "H2: " << H2 << endl;
        HD = mid(sqrt(H2));
        //cout << HD << endl;
        if ( HD > 1 || HD < 0) { 
          cerr << "HD should be between 0 and 1." << endl;
          exit(0);
        }
        return HD;
      }

  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ae094573d2988d458e00a549039a6ad56}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Largest\-Leaf\-Count@{get\-Largest\-Leaf\-Count}}
\index{get\-Largest\-Leaf\-Count@{get\-Largest\-Leaf\-Count}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Largest\-Leaf\-Count}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-S\-P\-Snode\-::get\-Largest\-Leaf\-Count} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_ae094573d2988d458e00a549039a6ad56}


\-Get the count in the leaf with the smallest count. 

\-Returns the count of the largest (by count) leaf node. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_adfb30c9946f868e143c81e6bf35a7a6f}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1454 of file spsnode.\-cpp.



\-References counter, get\-Leaves(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().


\begin{DoxyCode}
    {
        size_t largestCount = 0;

        if (isLeaf()) {  // this is a leaf
            largestCount = counter;
        }

        else { // this is not a leaf

            // set up a container for the leaf children
            SPSnodePtrs leaves;
            // fill the container with the leaf children
            // could be just this if no children
            getLeaves(leaves);

            // find the largest child by volume
            SPSnodePtrsItr it;
            largestCount = (*(leaves.begin()))->counter;

            for(it = leaves.begin(); it < leaves.end(); it++) {
                if ((*it)->counter > largestCount) {
                    largestCount = (*it)->counter;
                }
            }
        } // end else not a leaf

        return largestCount;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a2f8ce829fd9ba3ef3838d640ae201e9e}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Leaf\-Node\-Counts@{get\-Leaf\-Node\-Counts}}
\index{get\-Leaf\-Node\-Counts@{get\-Leaf\-Node\-Counts}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Leaf\-Node\-Counts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Size\-\_\-t\-Vec} \& {\bf \-S\-P\-Snode\-::get\-Leaf\-Node\-Counts} (
\begin{DoxyParamCaption}
\item[{{\bf \-Size\-\_\-t\-Vec} \&}]{counts}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a2f8ce829fd9ba3ef3838d640ae201e9e}
\-Fills in container of leaf counts, left to right.

\-Traverses the leaves left to right, puts the leaf counts into container.


\begin{DoxyParams}{\-Parameters}
{\em counts} & is reference to the container to fill in. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
the container filled in with leaf counts. 
\end{DoxyReturn}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a0d6df4752e05170510e43b67d8eb3110}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1308 of file spsnode.\-cpp.



\-References counter, get\-Leaf\-Node\-Counts(), get\-Left\-Child(), and get\-Right\-Child().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::get\-Leaf\-Counts(), and get\-Leaf\-Node\-Counts().


\begin{DoxyCode}
    {

        if (getLeftChild()!=NULL) {
            getLeftChild()->getLeafNodeCounts(counts);
        }
        if (getRightChild()!=NULL) {
            getRightChild()->getLeafNodeCounts(counts);
        }
        if (getLeftChild()==NULL && getRightChild()==NULL) {

            counts.push_back(counter);
        }
        return counts;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a6a833240b503da0e2b640782e8671954}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Leaves@{get\-Leaves}}
\index{get\-Leaves@{get\-Leaves}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Leaves}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-Ptrs} \& {\bf \-S\-P\-Snode\-::get\-Leaves} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode\-Ptrs} \&}]{leaves}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a6a833240b503da0e2b640782e8671954}


\-Return a reference to all descendent leaf nodes. 

\-Will be just this if this is a leaf.

\begin{DoxyReturn}{\-Returns}
a reference to a container of node pointers. 
\end{DoxyReturn}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a6f3850e716947e051a9e9af16c2b4508}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1328 of file spsnode.\-cpp.



\-References get\-Leaves(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), and subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box().



\-Referenced by \-Multi\-Tree\-Manager\-::add\-To\-Outcome\-Space(), \-Multi\-Tree\-Manager\-::add\-To\-Outcome\-Space\-And\-Graph(), do\-M\-C\-M\-C\-G\-R\-Auto(), subpavings\-::\-Adaptive\-Histogram\-::find\-Density\-Region(), get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C(), get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), subpavings\-::\-Adaptive\-Histogram\-::get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample(), subpavings\-::\-Adaptive\-Histogram\-::get\-Fin\-Mix\-Interval\-I\-A\-E(), subpavings\-::\-Adaptive\-Histogram\-::get\-Laplace\-Interval\-I\-A\-E(), get\-Largest\-Leaf\-Count(), get\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-::get\-Lognormal\-Interval\-I\-A\-E(), get\-Smallest\-Leaf\-Count(), get\-Sum\-Leaf\-Count\-Over\-Vol(), subpavings\-::\-Adaptive\-Histogram\-::get\-Unif\-I\-A\-E(), main(), subpavings\-::\-Adaptive\-Histogram\-::make\-Empty(), subpavings\-::\-Adaptive\-Histogram\-::\-M\-C\-M\-Csamples(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches(), and subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
    {
        //if children, recurse on the children
        if (hasLCwithBox()) {
            getLeftChild()->getLeaves(leaves);
        }

        if (hasRCwithBox()) {
            getRightChild()->getLeaves(leaves);
        }

        if (!hasLCwithBox() && !hasRCwithBox()) { // this is a leaf
            // arrgh horrible - cast away const if this node is a leaf
            leaves.push_back(const_cast<SPSnode*>(this));
        }
        return leaves;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_af7588b657e2819dd5dda525e08143ffc}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Left\-Child@{get\-Left\-Child}}
\index{get\-Left\-Child@{get\-Left\-Child}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Left\-Child}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-S\-P\-Snode\-::get\-Left\-Child} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_af7588b657e2819dd5dda525e08143ffc}


\-Accessor for the left child of a node. 

\-Hides the base class version of this method.

\-Returns a copy of the pointer to left\-Child node. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_a2ae7370c24e6c51a99c8bd29b2ffcec3}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a3ef0b662df21eb88689644cb5d1279d2}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1034 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::left\-Child.



\-Referenced by subpavings\-::\-Real\-Mapped\-S\-Pnode\-::\-\_\-get\-Log\-Likelihood(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Merge(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Split(), subpavings\-::check\-Node\-Count\-For\-Split(), subpavings\-::\-Adaptive\-Histogram\-::check\-Node\-Count\-For\-Split(), check\-Tree\-State\-Legal(), subpavings\-::\-Collator\-S\-Pnode\-::\-Collator\-S\-Pnode(), subpavings\-::\-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Merge(), gather\-Data(), get\-All\-Nodes(), get\-E\-M\-P\-Sum\-A\-I\-C(), get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), get\-Leaf\-Node\-Counts(), get\-Leaves(), get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), get\-Merge\-Change\-Log\-Lik(), get\-Min\-Child\-Count\-If\-Split\-N\-E\-W(), get\-Sub\-Leaves(), insert\-One\-Find(), leaves\-Output\-Tabs(), leaves\-Output\-Tabs\-With\-E\-M\-Ps(), leaves\-Output\-Tabs\-With\-Hist\-Height(), leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps(), node\-Reabsorb\-Children(), operator=(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var(), subpavings\-::\-Real\-Mapped\-S\-Pnode\-::\-Real\-Mapped\-S\-Pnode(), sps\-Contains(), \-S\-P\-Snode(), stripped\-Constructor(), and union\-No\-Data().


\begin{DoxyCode}
    { return (SPSnode*) leftChild; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ad077233e00a7093d66e35cca6fc6db6b}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Left\-Count\-If\-Split@{get\-Left\-Count\-If\-Split}}
\index{get\-Left\-Count\-If\-Split@{get\-Left\-Count\-If\-Split}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Left\-Count\-If\-Split}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-S\-P\-Snode\-::get\-Left\-Count\-If\-Split} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_ad077233e00a7093d66e35cca6fc6db6b}


\-The count the left child would have if this node was split. 

\-Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the left child if the node were to be split.

\-Note that the left child's interval on the split dimension would be an open interval. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a64b5d63790c02a454aa0e86222b1a3d3}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1170 of file spsnode.\-cpp.



\-References data\-Itrs, subpavings\-::\-S\-Pnode\-::get\-Box(), and \-Max\-Diam\-Comp().



\-Referenced by get\-Min\-Child\-Count\-If\-Split(), get\-Min\-Child\-Count\-If\-Split\-N\-E\-W(), get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), and get\-Split\-Change\-Log\-Lik().


\begin{DoxyCode}
{
  
  // first find what the dimension for the split would be 
  // if the split were made
  // right hand child's box would be if that child
  // were to be created
  cxsc::ivector box = getBox();
  
  int split = MaxDiamComp(box);
  
  cxsc::real midSplit = cxsc::mid(box[split]);

  // left child would have everything up to but not including
  // midSplit, on the split dimension
  size_t leftCount = 0;
  NodeDataItr it;

  for (it = dataItrs.begin(); it < dataItrs.end(); it++) {
    // DataItrs is a container of iterators to a BigDataCollection
    // increment rightCount if the point is in rC
    if(  (**it)[split] < midSplit ) leftCount++;
  }

  return leftCount;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a45f10ce1371120a0c1be29fa0ad8bac5}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Log\-Lik@{get\-Log\-Lik}}
\index{get\-Log\-Lik@{get\-Log\-Lik}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Log\-Lik}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Log\-Lik} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a45f10ce1371120a0c1be29fa0ad8bac5}


\-Get this leaf node's contribution to loglikelihood. 

\-A leaf node's contribution to the log likelihood of overall state given the data is (count in leaf x ln(count in leaf / (n $\ast$ vol of leaf))) where n is the total number of data points in the histogram.

\-Should only be called on leaf nodes. 
\begin{DoxyParams}{\-Parameters}
{\em n} & the value to use for scaling, the total number of points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
counter $\ast$ (ln(counter/(n$\ast$volume))) for this node. 
\end{DoxyReturn}


\-Definition at line 2028 of file spsnode.\-cpp.



\-References counter, and subpavings\-::\-S\-Pnode\-::node\-Volume().



\-Referenced by get\-E\-M\-P\-Contribution\-A\-I\-C(), and subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C().


\begin{DoxyCode}
    {
        // contribution to loglikelihood is counter*log(counter/(n * vol))

        dotprecision contribution(0.0);
        if ((n > 0) && (counter > 0)) {

            accumulate(contribution, 1.0*counter, log(1.0*counter));
            accumulate(contribution, -1.0*counter, log(1.0*n));
            accumulate(contribution, -1.0*counter, log(nodeVolume()));
        }
        // default cxsc rounding to nearest
        return rnd(contribution);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aa5ae31017fb2fdee8b9168009d8d08a6}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Mean@{get\-Mean}}
\index{get\-Mean@{get\-Mean}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Mean}]{\setlength{\rightskip}{0pt plus 5cm}rvector {\bf \-S\-P\-Snode\-::get\-Mean} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aa5ae31017fb2fdee8b9168009d8d08a6}


\-Get the sample mean. 

\-This calculates the sample mean from the accumulators for the sums of data point elements. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a2d2b97cb6916b19ad2affc4907265b6f}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1499 of file spsnode.\-cpp.



\-References counter, counts\-Only, subpavings\-::\-S\-Pnode\-::dimension, and dp\-Sums.



\-Referenced by get\-Cheb\-Dist\-Mean(), get\-Hellinger\-Dist(), get\-Hellinger\-Dist1\-D(), and subpavings\-::\-Adaptive\-Histogram\-::get\-Root\-Paving\-Mean().


\begin{DoxyCode}
    {
       // cout << "Get Mean for " << getNodeName() << endl;
    //  cout << getCountsOnly() << "\t" << getCounter() << endl;
      
        // set up an rvector retMean of the correct dimensions
        rvector retMean(dimension);
        // loop through the elements in the dpSums vector
        for (size_t i = 0; i< dimension; i++) {

            // if no data elements each element or if only counts are held,
            // that element of the mean is 0.0
            if (countsOnly || (counter == 0)) {
                // cxsc::rvector is indexed 1 to n
                retMean[i+1] = 0.0;
            }
            // if data elements, find the element-by-element mean
            else {
                // default cxsc rounding dotprecision rnd_next
                retMean[i+1] = rnd(dpSums[i])/(1.0*counter);
            }
        }// end loop through the elements in dpSums

        return retMean;

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a42114089fcad779bec855496154ded19}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Merge\-Change\-E\-M\-P\-A\-I\-C@{get\-Merge\-Change\-E\-M\-P\-A\-I\-C}}
\index{get\-Merge\-Change\-E\-M\-P\-A\-I\-C@{get\-Merge\-Change\-E\-M\-P\-A\-I\-C}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Merge\-Change\-E\-M\-P\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Merge\-Change\-E\-M\-P\-A\-I\-C} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a42114089fcad779bec855496154ded19}


\-Get change in sum term in \-E\-M\-P under \-A\-I\-C on merge. 

\-Under \-A\-I\-C, \-E\-M\-P is -\/1 x sum over leaves of (counts in leaf x ln(count in leaf / (n $\ast$ volume of leaf))) where n is the total number of data points in the histogram.

\-Should only be called on subleaf nodes (two leaf children)

\begin{DoxyReturn}{\-Returns}
the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node were merged. 
\end{DoxyReturn}


\-Definition at line 2360 of file spsnode.\-cpp.



\-References get\-Merge\-Change\-Log\-Lik().



\-Referenced by get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C(), subpavings\-::\-Comp\-E\-M\-P\-Sum\-Change\-Merge\-A\-I\-C\-::operator()(), and subpavings\-::\-Adaptive\-Histogram\-::priority\-Merge().


\begin{DoxyCode}
    {
        return -getMergeChangeLogLik();
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a2c8cc31ffdb9c74b82cce176c8d14585}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}}
\index{get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a2c8cc31ffdb9c74b82cce176c8d14585}


\-Get scaled change in sum term in \-E\-M\-P under \-C\-O\-P\-E\-R\-R on merge. 

\-Under \-C\-O\-P\-E\-R\-R, \-E\-M\-P is -\/1/n$^\wedge$2 x sum over leaves of (counts in leaf squared / (n $\ast$ volume of leaf)) where n is the total number of data points in the histogram.

\-Should only be called on subleaf nodes (two leaf children).


\begin{DoxyParams}{\-Parameters}
{\em n} & the value to use for scaling, the total number of points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
the change in the sum over leaves of (counts in leaf squared over (n $\ast$ volume of leaf) which would result if this node were merged. 
\end{DoxyReturn}


\-Definition at line 2331 of file spsnode.\-cpp.



\-References counter, get\-Counter(), get\-Left\-Child(), get\-Right\-Child(), and subpavings\-::\-S\-Pnode\-::node\-Volume().



\-Referenced by get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), subpavings\-::\-Comp\-E\-M\-P\-Sum\-Change\-Merge\-C\-O\-P\-E\-R\-R\-::operator()(), and subpavings\-::\-Adaptive\-Histogram\-::priority\-Merge().


\begin{DoxyCode}
    {
        // first find what the left hand child's counter is
        size_t leftCount = getLeftChild()->getCounter();

        // and right child
        size_t rightCount = getRightChild()->getCounter();

        // current number of data points associated to node is counter
        // current node volume from nodeVolume, and each child will have half

        // change is 1/(n^2 * vol) x (2(lc_count^2 + rc_count^2) - counter^2)
        // Change is scaled by n, total points in histogram
        dotprecision change;
        change = 0.0;
        if (n > 0) {
            accumulate(change, (1.0*leftCount)/(1.0*n),
                                (2.0*leftCount)/(n*nodeVolume()));
            accumulate(change, (1.0*(counter - leftCount))/(1.0*n),
                                (2.0*(counter - leftCount))/(n*nodeVolume()));
            accumulate(change, -(1.0*counter)/(n*nodeVolume()),
                                    (1.0*counter)/(1.0*n));
        }
        return change;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a9fd3a2a06ee14b5d5c307a2c7d795cef}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Merge\-Change\-Log\-Lik@{get\-Merge\-Change\-Log\-Lik}}
\index{get\-Merge\-Change\-Log\-Lik@{get\-Merge\-Change\-Log\-Lik}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Merge\-Change\-Log\-Lik}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Merge\-Change\-Log\-Lik} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a9fd3a2a06ee14b5d5c307a2c7d795cef}


\-Get change in log likelihood on merge of this' leaf chidren. 

log likelihood is sum over leaves of (counts in leaf x ln(count in leaf / (n $\ast$ volume of leaf))) where n is the total number of data points in the histogram.

\-Should only be called on cherry leaf nodes (two leaf children).

\begin{DoxyReturn}{\-Returns}
the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node's leaf chilren were merged back into this. 
\end{DoxyReturn}


\-Definition at line 2090 of file spsnode.\-cpp.



\-References counter, get\-Counter(), get\-Left\-Child(), and get\-Right\-Child().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Merge(), and get\-Merge\-Change\-E\-M\-P\-A\-I\-C().


\begin{DoxyCode}
    {
        dotprecision change;
        change = 0.0;

        // if counter is 0 there can be no change on merging
        if (counter > 0) {

            // first find what the left hand child's counter is
            size_t leftCount = getLeftChild()->getCounter();

            // and right child
            size_t rightCount = getRightChild()->getCounter();

            // change is (count*ln(count)
            //      - (lc_count*ln(lc_count) + rc_count*ln(rc_count) +
            //          count*ln(2))
            // note that the terms involving the total count in the histogram
            // and the volume of this node cancel so this change
            // is effectively scaled and does not need to use n

            dotprecision currentEMP(0.0);
            dotprecision childEMP(0.0);
            if (leftCount > 0) accumulate(childEMP, 1.0*leftCount,
                             log(1.0*leftCount));

            if (rightCount > 0) accumulate(childEMP, 1.0*rightCount,
                             log(1.0*rightCount));

            accumulate(childEMP, 1.0*counter, log(2.0));

            accumulate(currentEMP, 1.0*counter, log(1.0*counter));

            change = currentEMP - childEMP;
        }

        return change;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a1b3356a466432a282290af76df3adb08}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Min\-Child\-Count\-If\-Split@{get\-Min\-Child\-Count\-If\-Split}}
\index{get\-Min\-Child\-Count\-If\-Split@{get\-Min\-Child\-Count\-If\-Split}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Min\-Child\-Count\-If\-Split}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-S\-P\-Snode\-::get\-Min\-Child\-Count\-If\-Split} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a1b3356a466432a282290af76df3adb08}


\-Smallest number of points in either child if this was split. 

\-Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the left and right child if the node were to be split. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a43024ae81075f8a822ccccad013b3ef7}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1198 of file spsnode.\-cpp.



\-References counter, and get\-Left\-Count\-If\-Split().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Merge(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Split(), subpavings\-::check\-Node\-Count\-For\-Split(), subpavings\-::\-Adaptive\-Histogram\-::check\-Node\-Count\-For\-Split(), subpavings\-::\-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Merge(), subpavings\-::\-Split\-On\-K\-::operator()(), and subpavings\-::\-Split\-On\-Vol\-Div\-K\-::operator()().


\begin{DoxyCode}
  {
    try {
      size_t min = getLeftCountIfSplit();
      if ((counter - min) < min) min = counter - min;
      return min;
    }
    catch (exception& e) {
      string msg = string(e.what());
      throw SPnodeException("Error in getMinChildCountIfSplit:\n" + msg);
    }
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a3df75e24c4a3a468b63f79667645c1dc}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Min\-Child\-Count\-If\-Split\-N\-E\-W@{get\-Min\-Child\-Count\-If\-Split\-N\-E\-W}}
\index{get\-Min\-Child\-Count\-If\-Split\-N\-E\-W@{get\-Min\-Child\-Count\-If\-Split\-N\-E\-W}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Min\-Child\-Count\-If\-Split\-N\-E\-W}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-S\-P\-Snode\-::get\-Min\-Child\-Count\-If\-Split\-N\-E\-W} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a3df75e24c4a3a468b63f79667645c1dc}


\-Definition at line 1212 of file spsnode.\-cpp.



\-References counter, get\-Counter(), get\-Left\-Child(), get\-Left\-Count\-If\-Split(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().



\-Referenced by is\-Splittable\-Node().


\begin{DoxyCode}
{
  size_t min = 0;
  
  if (isLeaf()) {
    min = getLeftCountIfSplit();
  }
  else {
    min = getLeftChild()->getCounter();
  }
  
  if ((counter - min) < min) min = counter - min;
  
  return min;
  
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_abd4de519f005b145ef131f0c9d4331a0}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Min\-Child\-Vol\-If\-Split@{get\-Min\-Child\-Vol\-If\-Split}}
\index{get\-Min\-Child\-Vol\-If\-Split@{get\-Min\-Child\-Vol\-If\-Split}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Min\-Child\-Vol\-If\-Split}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf subpavings\-::\-S\-P\-Snode\-::get\-Min\-Child\-Vol\-If\-Split} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_abd4de519f005b145ef131f0c9d4331a0}


\-Smallest volume of either child if this was split. 

\-Does not split the nodes, just returns the volume of the left and right child if the node were to be split. \hypertarget{classsubpavings_1_1SPSnode_a88c1d25d8e0b9738f5199cc4435c08b4}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Parent@{get\-Parent}}
\index{get\-Parent@{get\-Parent}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Parent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-S\-P\-Snode\-::get\-Parent} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a88c1d25d8e0b9738f5199cc4435c08b4}


\-Accessor for the parent of a node. 

\-Hides the base class version of this method.

\-Returns a copy of the pointer to parent node. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_ad25db2635b9fa09515a3cb75f4a7ccef}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_ae42cbf85bd00caf12e6acac68ae1fcd3}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1029 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::parent.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Merge(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Split(), get\-Root\-Counter(), subpavings\-::\-Adaptive\-Histogram\-::merge\-Up(), node\-Contains(), and subpavings\-::\-Adaptive\-Histogram\-::priority\-Merge().


\begin{DoxyCode}
    { return (SPSnode*) parent; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_acc7d3e22be28d76da5c8c228aaaa95c7}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Right\-Child@{get\-Right\-Child}}
\index{get\-Right\-Child@{get\-Right\-Child}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Right\-Child}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-S\-P\-Snode\-::get\-Right\-Child} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_acc7d3e22be28d76da5c8c228aaaa95c7}


\-Accessor for the right child of a node. 

\-Hides the base class version of this method.

\-Returns a copy of the pointer to right\-Child node. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_a9477b1cfe157f5730a5514c944953689}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_af681e178575b285f123c1c01bac9ac42}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1039 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::right\-Child.



\-Referenced by subpavings\-::\-Real\-Mapped\-S\-Pnode\-::\-\_\-get\-Log\-Likelihood(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Merge(), subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Split(), check\-Tree\-State\-Legal(), subpavings\-::\-Collator\-S\-Pnode\-::\-Collator\-S\-Pnode(), subpavings\-::\-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Merge(), gather\-Data(), get\-All\-Nodes(), get\-E\-M\-P\-Sum\-A\-I\-C(), get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), get\-Leaf\-Node\-Counts(), get\-Leaves(), get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), get\-Merge\-Change\-Log\-Lik(), get\-Sub\-Leaves(), insert\-One\-Find(), leaves\-Output\-Tabs(), leaves\-Output\-Tabs\-With\-E\-M\-Ps(), leaves\-Output\-Tabs\-With\-Hist\-Height(), leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps(), node\-Reabsorb\-Children(), operator=(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches(), subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var(), subpavings\-::\-Real\-Mapped\-S\-Pnode\-::\-Real\-Mapped\-S\-Pnode(), sps\-Contains(), \-S\-P\-Snode(), stripped\-Constructor(), and union\-No\-Data().


\begin{DoxyCode}
    { return (SPSnode*) rightChild; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aa10917d57d9a50cb2d393a422188a51f}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Right\-Count\-If\-Split@{get\-Right\-Count\-If\-Split}}
\index{get\-Right\-Count\-If\-Split@{get\-Right\-Count\-If\-Split}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Right\-Count\-If\-Split}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf subpavings\-::\-S\-P\-Snode\-::get\-Right\-Count\-If\-Split} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aa10917d57d9a50cb2d393a422188a51f}


\-The count the right child would have if this node was split. 

\-Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the right child if the node were to be split.

\-Note that the left child's interval on the split dimension would be a closed interval. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a9a51fbde60e061846a93981688cc67af}{subpavings\-::\-S\-P\-S\-Vnode}.

\hypertarget{classsubpavings_1_1SPSnode_aeac2247b4626b1adfa609d3ff109ceb2}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Root\-Counter@{get\-Root\-Counter}}
\index{get\-Root\-Counter@{get\-Root\-Counter}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Root\-Counter}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-S\-P\-Snode\-::get\-Root\-Counter} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aeac2247b4626b1adfa609d3ff109ceb2}


\-The count in the node's ultimate ancestor root. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a346a5ff0d8177212b23342cada4b5c18}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1485 of file spsnode.\-cpp.



\-References counter, get\-Parent(), get\-Root\-Counter(), and subpavings\-::\-S\-Pnode\-::parent.



\-Referenced by subpavings\-::\-Collator\-S\-Pnode\-::\-Collator\-S\-Pnode(), get\-Emp\-Mass(), get\-Hellinger\-Dist(), get\-Root\-Counter(), subpavings\-::\-Adaptive\-Histogram\-::get\-Unif\-I\-A\-E(), subpavings\-::\-Comp\-E\-M\-P\-Sum\-Change\-C\-O\-P\-E\-R\-R\-::operator()(), subpavings\-::\-Comp\-E\-M\-P\-Sum\-Change\-Merge\-C\-O\-P\-E\-R\-R\-::operator()(), subpavings\-::\-Comp\-Area\-::operator()(), and subpavings\-::\-Comp\-Ext\-Area\-::operator()().


\begin{DoxyCode}
    {
        size_t retValue = 0;
        if (parent == NULL) { // this is root
            retValue = counter;
        }
        else {
            // recurse upwards
            retValue = getParent()->getRootCounter();
        }
        return retValue;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a6a75d9675312fb76aaf98bbeb084f9d6}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Smallest\-Leaf\-Count@{get\-Smallest\-Leaf\-Count}}
\index{get\-Smallest\-Leaf\-Count@{get\-Smallest\-Leaf\-Count}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Smallest\-Leaf\-Count}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-S\-P\-Snode\-::get\-Smallest\-Leaf\-Count} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a6a75d9675312fb76aaf98bbeb084f9d6}


\-Get the count of the leaf with the smallest count. 

\-Returns the count in the smallest (by count) leaf node. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a5d355f8da3eb609f5c81ce63b437fcf9}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1422 of file spsnode.\-cpp.



\-References counter, get\-Leaves(), and subpavings\-::\-S\-Pnode\-::is\-Leaf().


\begin{DoxyCode}
    {
        size_t smallestCount = 0;

        if (isLeaf()) {  // this is a leaf
            smallestCount = counter;
        }

        else { // this is not a leaf
            // set up a container for the leaf children
            SPSnodePtrs leaves;
            // fill the container with the leaf children
            getLeaves(leaves);

            // find the smallest child by count
            SPSnodePtrsItr it;
            SPSnode* smallest = *(leaves.begin());

            smallestCount = smallest->counter;

            for(it = leaves.begin(); it < leaves.end(); it++) {
                if ((*it)->counter < smallestCount) {

                    smallestCount = (*it)->counter;
                }
            }
        } // end else not a leaf

        return smallestCount;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_af75b1acec69e86469838524097fab408}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Split\-Change\-E\-M\-P\-A\-I\-C@{get\-Split\-Change\-E\-M\-P\-A\-I\-C}}
\index{get\-Split\-Change\-E\-M\-P\-A\-I\-C@{get\-Split\-Change\-E\-M\-P\-A\-I\-C}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Split\-Change\-E\-M\-P\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Split\-Change\-E\-M\-P\-A\-I\-C} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_af75b1acec69e86469838524097fab408}


\-Get change in sum term in \-E\-M\-P under \-A\-I\-C on split. 

\-Under \-A\-I\-C, \-E\-M\-P is -\/1 x sum over leaves of (counts in leaf x ln(count in leaf / (n $\ast$ volume of leaf))) where n is the total number of data points in the histogram.

\-Should only be called on leaf nodes.

\begin{DoxyReturn}{\-Returns}
the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node were split. 
\end{DoxyReturn}


\-Definition at line 2324 of file spsnode.\-cpp.



\-References get\-Split\-Change\-Log\-Lik().



\-Referenced by get\-Best\-Split\-Change\-E\-M\-P\-A\-I\-C(), and subpavings\-::\-Comp\-E\-M\-P\-Sum\-Change\-A\-I\-C\-::operator()().


\begin{DoxyCode}
    {
        return -getSplitChangeLogLik();

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a33925f531930c000200f452209b0128c}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}}
\index{get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R@{get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{n}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a33925f531930c000200f452209b0128c}


\-Get scaled change in sum term in \-E\-M\-P under \-C\-O\-P\-E\-R\-R on split. 

\-Under \-C\-O\-P\-E\-R\-R, \-E\-M\-P is -\/1/n$^\wedge$2 x sum over leaves of (counts in leaf squared / (n $\ast$ volume of leaf)) where n is the total number of data points in the histogram.

\-Should only be called on leaf nodes.


\begin{DoxyParams}{\-Parameters}
{\em n} & the value to use for scaling, the total number of points. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
the change in the sum over leaves of (counts in leaf squared over (n $\ast$ volume of leaf) which would result if this node were split. 
\end{DoxyReturn}


\-Definition at line 2297 of file spsnode.\-cpp.



\-References counter, get\-Left\-Count\-If\-Split(), and subpavings\-::\-S\-Pnode\-::node\-Volume().



\-Referenced by get\-Best\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), and subpavings\-::\-Comp\-E\-M\-P\-Sum\-Change\-C\-O\-P\-E\-R\-R\-::operator()().


\begin{DoxyCode}
    {
        // first find what the left hand child's counter would be if that child
        // were to be created
        size_t leftCount = getLeftCountIfSplit();

        // current number of data points associated to node is counter
        // current node volume from nodeVolume, and each child will have half

        // change is 1/(n^2 * vol) x (counter^2 - 2(lc_count^2 + rc_count^2))
        // if we split and lc_count, rc_count were the new counts in
        // left and right children respectively
        // Change is scaled by n, total points in histogram
        dotprecision change;
        change = 0.0;
        if (n > 0) {
            accumulate(change, (1.0*counter)/(n*nodeVolume()),
                                (1.0*counter)/(1.0*n));
            accumulate(change, (1.0*leftCount)/(1.0*n),
                                -(2.0*leftCount)/(n*nodeVolume()));
            accumulate(change, (1.0*(counter - leftCount))/(1.0*n),
                                -(2.0*(counter - leftCount))/(n*nodeVolume()));
        }
        return change;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ab28c35298b721467721228a33a194433}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Split\-Change\-Log\-Lik@{get\-Split\-Change\-Log\-Lik}}
\index{get\-Split\-Change\-Log\-Lik@{get\-Split\-Change\-Log\-Lik}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Split\-Change\-Log\-Lik}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf \-S\-P\-Snode\-::get\-Split\-Change\-Log\-Lik} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_ab28c35298b721467721228a33a194433}


\-Get change in log likelihood on split of this node. 

log likelihood is sum over leaves of (counts in leaf x ln(count in leaf / (n $\ast$ volume of leaf))) where n is the total number of data points in the histogram.

\-Should only be called on leaf nodes.

\begin{DoxyReturn}{\-Returns}
the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node were split. 
\end{DoxyReturn}


\-Definition at line 2044 of file spsnode.\-cpp.



\-References counter, and get\-Left\-Count\-If\-Split().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Split(), and get\-Split\-Change\-E\-M\-P\-A\-I\-C().


\begin{DoxyCode}
    {
        
       // cout << "caling get split change llk" << endl;
        
        dotprecision change;
        change = 0.0;

        // if counter is 0 there can be no change on splitting
        if (counter > 0) {

            // first find what the left hand child's counter would be if
            // that child were to be created
            size_t leftCount = getLeftCountIfSplit();
            // current number of data points associated to node is counter
            size_t rightCount = counter-leftCount;
    
            // current node volume from nodeVolume; each child will have half
            // change is
            //      (lc_count*ln(lc_count) + rc_count*ln(rc_count) +
            //          count*ln(2)) - (count*ln(count)
            // if we split and lc_count, rc_count were the new counts in
            // left and right children respectively
            // note that the terms involving the total count in the histogram
            // and the volume of this node cancel so this change
            // is effectively scaled and does not need to use n

            dotprecision currentEMP(0.0);
            dotprecision childEMP(0.0);

            if (leftCount > 0) accumulate(childEMP, 1.0*leftCount,
                             log(1.0*leftCount));

            if (rightCount > 0) accumulate(childEMP, 1.0*rightCount,
                             log(1.0*rightCount));

            accumulate(childEMP, 1.0*counter, log(2.0));

            accumulate(currentEMP, 1.0*counter, log(1.0*counter));

            change = childEMP - currentEMP;
        }
        return change;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_afe262ee997e6ac57a15193a7d585f0ac}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Split\-Dim@{get\-Split\-Dim}}
\index{get\-Split\-Dim@{get\-Split\-Dim}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Split\-Dim}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf \-S\-P\-Snode\-::get\-Split\-Dim} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_afe262ee997e6ac57a15193a7d585f0ac}


\-Accessor for the split dimension. 



\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_ad04e240d9152c1a927c2ec280aa29371}{subpavings\-::\-S\-Pnode}.



\-Definition at line 1001 of file spsnode.\-cpp.



\-References split\-Dim.



\-Referenced by subpavings\-::\-S\-P\-S\-Vnode\-::node\-Contains(), and node\-Contains().


\begin{DoxyCode}
    { return splitDim; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aeaa3e348d84106def631d3cd742a1420}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Split\-Value@{get\-Split\-Value}}
\index{get\-Split\-Value@{get\-Split\-Value}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Split\-Value}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Split\-Value} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_aeaa3e348d84106def631d3cd742a1420}


\-Accessor for the split value. 



\-Definition at line 1005 of file spsnode.\-cpp.



\-References split\-Value.



\-Referenced by subpavings\-::\-S\-P\-S\-Vnode\-::node\-Contains(), and node\-Contains().


\begin{DoxyCode}
    { return splitValue; }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_af5ff16174902743a78b2d3db3e0a1c70}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Sub\-Leaves@{get\-Sub\-Leaves}}
\index{get\-Sub\-Leaves@{get\-Sub\-Leaves}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Sub\-Leaves}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-Ptrs} \& {\bf \-S\-P\-Snode\-::get\-Sub\-Leaves} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode\-Ptrs} \&}]{subleaves}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_af5ff16174902743a78b2d3db3e0a1c70}


\-Return a reference to all sub-\/leaf descendent nodes. 

\-Sub-\/leaf nodes have at least one child but any child must be a leaf, ie sub-\/leaves are the parents of leaf nodes.

\-Will be just this if this is a subleaf.

\begin{DoxyReturn}{\-Returns}
a reference to a container of node pointers. 
\end{DoxyReturn}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_aa5408d2d74de8b95325c5973cf43f7fb}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1373 of file spsnode.\-cpp.



\-References get\-Left\-Child(), get\-Right\-Child(), get\-Sub\-Leaves(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box(), and subpavings\-::\-S\-Pnode\-::is\-Sub\-Leaf().



\-Referenced by get\-Best\-Merge\-Change\-E\-M\-P\-A\-I\-C(), get\-Best\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), get\-Sub\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-::\-M\-C\-M\-Csamples(), subpavings\-::\-Adaptive\-Histogram\-::merge\-Up(), and subpavings\-::\-Adaptive\-Histogram\-::priority\-Merge().


\begin{DoxyCode}
    {
        //if children, recurse on the children
        if (hasLCwithBox()) {
            getLeftChild()->getSubLeaves(subleaves);
        }

        if (hasRCwithBox()) {
            getRightChild()->getSubLeaves(subleaves);
        }

        if (isSubLeaf()) { // this is a subleaf
            // arrgh horrible - cast away const if this node is a subleaf
            subleaves.push_back(const_cast<SPSnode*>(this));
        }
        return subleaves;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_adf589d16a3e20b4285f428c8dc42d75d}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Sum\-Leaf\-Count\-Over\-Vol@{get\-Sum\-Leaf\-Count\-Over\-Vol}}
\index{get\-Sum\-Leaf\-Count\-Over\-Vol@{get\-Sum\-Leaf\-Count\-Over\-Vol}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Sum\-Leaf\-Count\-Over\-Vol}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-S\-P\-Snode\-::get\-Sum\-Leaf\-Count\-Over\-Vol} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_adf589d16a3e20b4285f428c8dc42d75d}


\-Get the sum of the count over volume in the leaf nodes. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_ac741a9772d992ba74911cf692e1ed772}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1394 of file spsnode.\-cpp.



\-References counter, get\-Leaves(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), and subpavings\-::\-S\-Pnode\-::node\-Volume().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::get\-Root\-Sum\-Leaf\-Count\-Over\-Vol().


\begin{DoxyCode}
    {
        dotprecision sum(0.0);

        if (isLeaf()) {  // this is a leaf
            accumulate(sum, 1.0*counter, (1.0/nodeVolume()));
        }

        else { // this is not a leaf

            SPSnodePtrs leaves;
            // fill the container with the leaf children
            getLeaves(leaves);

            SPSnodePtrsItr it;

            for(it = leaves.begin(); it < leaves.end(); it++) {
                accumulate(sum, 1.0*((*it)->getCounter()),
                            (1.0/(*it)->nodeVolume()));
            }
        }
        return rnd(sum);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a4369d3887385551e053d3873b600f8a1}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Uniform\-Mean@{get\-Uniform\-Mean}}
\index{get\-Uniform\-Mean@{get\-Uniform\-Mean}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Uniform\-Mean}]{\setlength{\rightskip}{0pt plus 5cm}rvector {\bf \-S\-P\-Snode\-::get\-Uniform\-Mean} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a4369d3887385551e053d3873b600f8a1}


\-Get the uniform mean vector where each element is the midpoint of the coordinate. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_ae2cfb09a96d3c6b0d716236cbfccebd3}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1528 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::dimension, and subpavings\-::\-S\-Pnode\-::get\-Box().



\-Referenced by get\-Cheb\-Dist\-Mean(), get\-Hellinger\-Dist(), and get\-Hellinger\-Dist1\-D().


\begin{DoxyCode}
  {
    rvector unifMean(dimension);
    
    // loop through the coordinates of this box to get the midpoint at each
    // coordinate
    ivector thisBox = getBox();
    for (size_t i = 1; i <= dimension; i++) {
      unifMean[i] = mid(thisBox[i]);
    }
    return unifMean;
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a83c7f66b07ab9afd1934b080fd4af8c4}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Uniform\-Var\-Covar@{get\-Uniform\-Var\-Covar}}
\index{get\-Uniform\-Var\-Covar@{get\-Uniform\-Var\-Covar}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Uniform\-Var\-Covar}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Real\-Vec} {\bf \-S\-P\-Snode\-::get\-Uniform\-Var\-Covar} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a83c7f66b07ab9afd1934b080fd4af8c4}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a0a9c9ba4802d37fdb0ee1fff25908fbb}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1960 of file spsnode.\-cpp.



\-Referenced by get\-Cheb\-Dist\-Covar(), get\-Hellinger\-Dist(), and get\-Hellinger\-Dist1\-D().


\begin{DoxyCode}
    {
        RealVec retVarCovar;
        retVarCovar = getUniformVarCovar(retVarCovar);
        return retVarCovar;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a8ca1683e838159d5a33048344bec9b49}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Uniform\-Var\-Covar@{get\-Uniform\-Var\-Covar}}
\index{get\-Uniform\-Var\-Covar@{get\-Uniform\-Var\-Covar}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Uniform\-Var\-Covar}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Real\-Vec} \& {\bf \-S\-P\-Snode\-::get\-Uniform\-Var\-Covar} (
\begin{DoxyParamCaption}
\item[{{\bf \-Real\-Vec} \&}]{var\-Covar}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a8ca1683e838159d5a33048344bec9b49}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_ab1f050670fdcdc6f68e009a0cba0ed35}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1969 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::dimension, and subpavings\-::\-S\-Pnode\-::get\-Box().


\begin{DoxyCode}
    {
      unifVarCovar.reserve(dimension*dimension);
      ivector thisBox = getBox();
      
      // fill in the matrix where the diag are (1/12)*(b-a)^2 and off-diag 
      // are 0.
      for (size_t i = 0; i < dimension*dimension; i++) {
          unifVarCovar.push_back(0.0); //first fill up the container with 0
      }
      // then fill up the diags
      for (size_t i = 0; i < dimension; i++) {
        int pos = i*dimension + i;
        unifVarCovar[pos] = 1.0/12.0 * (Sup(thisBox[i+1]) - Inf(thisBox[i+1])) 
                      * (Sup(thisBox[i+1]) - Inf(thisBox[i+1]));
      }
      
      //for (size_t i = 0; i < dimension*dimension; i++) {cout <<
       unifVarCovar[i] << endl;}

        return unifVarCovar;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a7637c85b772a280a9769b97f7bace3c3}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Var\-Covar@{get\-Var\-Covar}}
\index{get\-Var\-Covar@{get\-Var\-Covar}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Var\-Covar}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Real\-Vec} {\bf \-S\-P\-Snode\-::get\-Var\-Covar} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a7637c85b772a280a9769b97f7bace3c3}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_abdef36aad99bfe53f78d4e8304ac59d6}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1953 of file spsnode.\-cpp.



\-Referenced by get\-Cheb\-Dist\-Covar(), get\-Hellinger\-Dist(), get\-Hellinger\-Dist1\-D(), and subpavings\-::\-Adaptive\-Histogram\-::get\-Root\-Paving\-Var\-Covar().


\begin{DoxyCode}
    {
        RealVec retVarCovar;
        retVarCovar = getVarCovar(retVarCovar);
        return retVarCovar;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a1bc0843e834ae4d09db3bc148b64761b}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!get\-Var\-Covar@{get\-Var\-Covar}}
\index{get\-Var\-Covar@{get\-Var\-Covar}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{get\-Var\-Covar}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Real\-Vec} \& {\bf \-S\-P\-Snode\-::get\-Var\-Covar} (
\begin{DoxyParamCaption}
\item[{{\bf \-Real\-Vec} \&}]{var\-Covar}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a1bc0843e834ae4d09db3bc148b64761b}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a61adf71c4652c4ec29a9dc323174d1a3}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1903 of file spsnode.\-cpp.



\-References counter, counts\-Only, subpavings\-::\-S\-Pnode\-::dimension, dp\-Sum\-Products, and dp\-Sums.


\begin{DoxyCode}
    {
        varCovar.clear();
        varCovar.reserve(dimension*dimension);

        // loop through the elements in the dpSumProducts vector
        for (size_t k = 0; k < dimension*dimension; k++) {

            // counts only held or if 0 or 1 data points
            // each element of the var-covar is 0.0
            if (countsOnly || (counter <= 1)) {
                varCovar.push_back(0.0);
            }
            // if >1 data points find element-by-element var-covar

            /*the var-covar is the sample var-covar
            which is
            [sumproduct(i,j)-sum(i)sum(j)/counter]/(counter-1)

            element k in the vector of dotprecison sumproducts
            corresponds to row k/n, (row 0 to n-1)
            and column k-row*n (col 0 to n-1)
            in a matrix view of the sumproducts */

            else {
                size_t i = k/dimension; // row  (int/int = int)
                size_t j = k - i*dimension; // column

                // make another dotprecision variable
                dotprecision temp1 = dpSumProducts[k];

                dotprecision temp2(0.0);
                // sum(i) x sum(j)
                // default cxsc rounding dotprecision rnd_next
                accumulate(temp2,  rnd(dpSums[i]),
                        rnd(dpSums[j]));

                real div = -1.0/counter;

                // sumproduct(i,j) - sum(i)(sum(j)/counter
                // default cxsc rounding
                accumulate(temp1, rnd(temp2), div);
                // calculate the variance covariance element
                varCovar.push_back(rnd(temp1)/(1.0*(counter-1)));
            }
        }// end loop through the elements in dpSumProducts

        return varCovar;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_af0d351af2a515188522e13e0c6502a18}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!insert\-One\-Find@{insert\-One\-Find}}
\index{insert\-One\-Find@{insert\-One\-Find}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{insert\-One\-Find}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-S\-P\-Snode\-::insert\-One\-Find} (
\begin{DoxyParamCaption}
\item[{{\bf \-Big\-Data\-Itr}}]{new\-Itr, }
\item[{{\bf \-O\-P\-E\-R\-A\-T\-I\-O\-N\-S\-\_\-\-O\-N}}]{child\-Ind, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_af0d351af2a515188522e13e0c6502a18}


\-Inserts data into this node. 

\-Called recursively from the root and through the tree, seeking leaf node whose box contains the data point. \-If data is inserted, this method also tests whether the node should be expanded following the addition of the data. \-Following an expansion, insert\-One\-Find is used again to pass the the node's data down to its new children.


\begin{DoxyParams}{\-Parameters}
{\em new\-Itr} & an iterator to the data in big data collection. \\
\hline
{\em child\-Ind} & an indicator for whether the current node is a treated as a left or right child or a root. \-This is passed to \hyperlink{classsubpavings_1_1SPSnode_a918067afb150c053f7450fd18c6ecd22}{node\-Contains()} when testing whether the node contains the data. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \-This object can a dummy which never splits the node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
a pointer to the node the data is 'inserted' into, before it is split, or \-N\-U\-L\-L if no insert. 
\end{DoxyReturn}


\-Definition at line 3094 of file spsnode.\-cpp.



\-References data\-Itrs, get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-S\-Pnode\-::left\-Child, node\-Contains(), node\-Expand(), subpavings\-::\-O\-N\-\_\-\-L\-E\-F\-T, subpavings\-::\-O\-N\-\_\-\-R\-I\-G\-H\-T, recalculate\-Stats(), and subpavings\-::\-S\-Pnode\-::right\-Child.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::insert\-Data\-From\-Container(), subpavings\-::\-Adaptive\-Histogram\-::insert\-One(), node\-Adopt\-Left(), node\-Adopt\-Right(), and node\-Reunite().


\begin{DoxyCode}
    {
        rvector newData = *newItr;

        // start at the top

        SPSnode* retObj = NULL;

        if(nodeContains(newData, childInd)) {

            recalculateStats(newData);

            bool wasLeaf = (isLeaf());

            // if it is a leaf, add the data and return this object
            if(wasLeaf) {

                dataItrs.push_back(newItr);

                // give this node as return value
                retObj = this;

                // split if we need to
                if (boolTest(this)) {
                    // expand and split data to children

                    nodeExpand(boolTest);

                } // end if we need to split

            } // end of isLeaf

            // if not a leaf before we had split, and contains data
            // recurse on the children if any
            if (!wasLeaf) {

                if(rightChild!=NULL && !rightChild->isEmpty()){

                    retObj =
                    (getRightChild())->insertOneFind(
                        newItr, ON_RIGHT, boolTest);
                }
                // only try left if we did not find on the right
                if(retObj == NULL && leftChild!=NULL &&
                                    !leftChild->isEmpty()) {

                    retObj =
                    (getLeftChild())->insertOneFind(newItr,
                    ON_LEFT, boolTest);
                }
            }

        } // end if node contains

        // will return null if does not contain the data

        return retObj;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!is\-Splittable\-Node@{is\-Splittable\-Node}}
\index{is\-Splittable\-Node@{is\-Splittable\-Node}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{is\-Splittable\-Node}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::is\-Splittable\-Node} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}
\-Return boolean to indicate if node is splittable.

\-A node is splittable if the node volume is $>$= 2 $\ast$ cxsc\-::\-Min\-Real (the smallest representable real number). 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_ac3e8e3499bcb0acb42181b781d7796b3}{subpavings\-::\-S\-Pnode}.



\-Definition at line 1093 of file spsnode.\-cpp.



\-Referenced by check\-Tree\-State\-Legal(), and is\-Splittable\-Node().


\begin{DoxyCode}
{
  return SPnode::isSplittableNode();
} 
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_af8f9559a17318b187769c20e85316135}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!is\-Splittable\-Node@{is\-Splittable\-Node}}
\index{is\-Splittable\-Node@{is\-Splittable\-Node}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{is\-Splittable\-Node}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::is\-Splittable\-Node} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_af8f9559a17318b187769c20e85316135}


\-Method to check whether a node is splittable. 

\-Decides whether a node is splittable based on checking volume and number of points that would result in child nodes on split.

\-Node must satisfy the basic \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node()} test {\bfseries and} volume must be $>$=min\-Vol to split {\bfseries and} if {\itshape min\-Child\-Points\/} $>$ 0, then 
\begin{DoxyItemize}
\item either the node must have at least min\-Child\-Points and all the points go to one of the children (the other getting none) 
\item or the smallest number of points which would go to the either of the prospective new children must be $>$= min\-Child\-Points 
\end{DoxyItemize}

\begin{DoxyNote}{\-Note}
if {\itshape min\-Vol\/} is $<$ minimum for passing \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node()} then node will fail test even if node volume $>$ min\-Vol, ie \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node()} overrides all other criteria.
\end{DoxyNote}
\-Thus in general the method will only return true if the given node satisfies both the min\-Vol test and, if it were to be split, both children would have at least min\-Child\-Points data points, {\bfseries but} if all the data points would go to {\bfseries one} child (none to the other), this will also satisfy the min\-Child\-Points test.

\-If the node has already been split, the test will use the actual numbers of points in the children; if the node is a leaf (ie not split) then the test will consider the number of points that would go to the each child if it were to be split.


\begin{DoxyParams}{\-Parameters}
{\em min\-Child\-Points} & is the minimum number of points that there would be in the children if the node were to be split. \\
\hline
{\em min\-Vol} & is the minimum node volume to be tested for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if has been a test conditions satisfied, false otherwise. 
\end{DoxyReturn}


\-Definition at line 1100 of file spsnode.\-cpp.



\-References is\-Splittable\-Node(), and subpavings\-::\-S\-Pnode\-::node\-Volume().


\begin{DoxyCode}
{
    
  bool retValue = (nodeVolume() >= minVol);
//  cout << nodeVolume() << "\t" << minVol << endl;
  
  //cout << nodeVolume() << "\t" << minVol << endl;
  
  if (retValue) {
    retValue = isSplittableNode(minChildPoints);
  }
  else {
    #ifdef DEBUG_CHECK_NODE_COUNT
      cout << "isSplittableNode: node failed vol test" << endl;
    #endif
  }
  return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_acba45b1fe208f6218a87400eb454b28d}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!is\-Splittable\-Node@{is\-Splittable\-Node}}
\index{is\-Splittable\-Node@{is\-Splittable\-Node}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{is\-Splittable\-Node}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::is\-Splittable\-Node} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{min\-Child\-Points}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_acba45b1fe208f6218a87400eb454b28d}


\-Method to check whether a node is splittable. 

\-Decides whether a node is splittable based number of points that would result in child nodes on split.

\-Node must satisfy the basic \hyperlink{classsubpavings_1_1SPSnode_afcaf3b298a975017982e88a068bab8af}{is\-Splittable\-Node()} test {\bfseries and} if {\itshape min\-Child\-Points\/} $>$ 0, then 
\begin{DoxyItemize}
\item either the node must have at least min\-Child\-Points and all the points go to one of the children (the other getting none) 
\item or the smallest number of points which would go to the either of the prospective new children must be $>$= min\-Child\-Points 
\end{DoxyItemize}

\-Thus in general the method will only return true if, if it were to be split, both children would have at least min\-Child\-Points data points, {\bfseries but} if all the data points would go to {\bfseries one} child (none to the other), this will also satisfy the min\-Child\-Points test.

\-If the node has already been split, the test will use the actual numbers of points in the children; if the node is a leaf (ie not split) then the test will consider the number of points that would go to the each child if it were to be split.


\begin{DoxyParams}{\-Parameters}
{\em min\-Child\-Points} & is the minimum number of points that there would be in the children if the node were to be split. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if has been a test conditions satisfied, false otherwise. 
\end{DoxyReturn}


\-Definition at line 1122 of file spsnode.\-cpp.



\-References counter, subpavings\-::\-S\-Pnode\-::get\-Box(), get\-Min\-Child\-Count\-If\-Split\-N\-E\-W(), is\-Splittable\-Node(), \-Max\-Diam\-Comp(), and subpavings\-::\-S\-Pnode\-::node\-Name.


\begin{DoxyCode}
{
    bool retValue = isSplittableNode();  //basic check
  if (!retValue) {
    #ifdef DEBUG_CHECK_NODE_COUNT
      cout << "isSplittableNode: node failed basic is splittable test" << endl;
    #endif
    #ifdef DEBUG_MCMC_SPLIT_FAIL
      cout << "Failed isSplittableNode: I am " << nodeName << endl;
      {
        ivector box = getBox();
        interval maxD = box[MaxDiamComp(box)];
  
        cout << cxsc::SaveOpt;
        cout << Scientific << SetPrecision(35,30);
        cout << "interval to be split is " << maxD << endl;
        cout << cxsc::RestoreOpt;
      }
    #endif
  }
  #ifdef DEBUG_CHECK_NODE_COUNT
    cout << "isSplittableNode minChildPoints = " << minChildPoints << endl;
  #endif
  if (retValue && minChildPoints > 0) {
    retValue = false; // need to retest
  
    size_t  minChildCount = getMinChildCountIfSplitNEW();
    
        
    if ( (counter >= minChildPoints) &&
      ((minChildCount == 0) || (minChildCount >= minChildPoints)) ) {
        retValue = true;
      }
    #ifdef DEBUG_CHECK_NODE_COUNT
      cout << "isSplittableNode minChildCount = " << minChildCount << endl;
      cout << "(minChildCount >= minChildPoints) = " << (minChildCount >= 
      minChildPoints) << endl;
  
      cout << "isSplittable = " << retValue << endl;
    #endif
  }
    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a3cc0c8bb64c854ef16ba03891f5945d6}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaf\-Output\-Tabs@{leaf\-Output\-Tabs}}
\index{leaf\-Output\-Tabs@{leaf\-Output\-Tabs}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaf\-Output\-Tabs}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaf\-Output\-Tabs} (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a3cc0c8bb64c854ef16ba03891f5945d6}


\-Output for a node in a binary tree, tab-\/delimited. 

\-Output intended for a txt file, in numeric form only.

\-Replaces the format that that the cxsc\-:\-:$<$$<$ operator produces for interval vectors. \-The format used here includes the box label and produces numeric tab-\/delimited data. \-The format for an n-\/dimensional interval vector is\-:

label \mbox{[}tab\mbox{]} counter \mbox{[}tab\mbox{]} volume \mbox{[}tabl\mbox{]} \-Inf(ivector\mbox{[}1\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}1\mbox{]}) \mbox{[}tab\mbox{]} ... \mbox{[}tab\mbox{]} \-Inf(ivector\mbox{[}n\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}n\mbox{]}) 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_a0f2381175b37224a185eedbe9601d814}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a01b35db8ce4b99460ff352f6d25a529c}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 348 of file spsnode.\-cpp.



\-References taylor\-::\-Lb(), and taylor\-::\-Ub().



\-Referenced by leaves\-Output\-Tabs().


\begin{DoxyCode}
    {
        int prec = 5; // precision for output

        if(theBox != NULL) { // do nothing if there is no box

            ivector thisBox = *theBox; // copy of theBox

            // output the node name, nodeVolume, counter
            os << nodeName;
            os << "\t" << nodeVolume();
            os << "\t" << counter;
            // followed by the intervals of box using Inf and Sup
            // ie unlike cxsc output, there is no [  ] around them

            streamsize oldPrec = os.precision();
            os << setprecision(prec);

            for (int i= Lb(thisBox); i <= Ub(thisBox) ; i++) {

                os << "\t" << Inf(thisBox[i])
                    << "\t" << Sup(thisBox[i]);
            }
            os << setprecision(oldPrec);

        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ac273545c33e3abb0114811e7a1b06f98}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaf\-Output\-Tabs\-With\-E\-M\-Ps@{leaf\-Output\-Tabs\-With\-E\-M\-Ps}}
\index{leaf\-Output\-Tabs\-With\-E\-M\-Ps@{leaf\-Output\-Tabs\-With\-E\-M\-Ps}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaf\-Output\-Tabs\-With\-E\-M\-Ps}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaf\-Output\-Tabs\-With\-E\-M\-Ps} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{big\-N, }
\item[{std\-::ostream \&}]{os, }
\item[{const int}]{prec = {\ttfamily 5}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ac273545c33e3abb0114811e7a1b06f98}


\-Output for a node in a binary tree, tab-\/delimited. 

\-Output intended for a txt file, in numeric form only.

\-Replaces the format that that the cxsc\-:\-:$<$$<$ operator produces for interval vectors. \-The format used here includes the box label and produces numeric tab-\/delimited data.

\-The format for a d-\/dimensional interval vector is

node\-Name \mbox{[}tab\mbox{]} counter \mbox{[}tab\mbox{]} volume \mbox{[}tab\mbox{]} scaled \-E\-M\-P contribution \-C\-O\-P\-E\-R\-R \mbox{[}tab\mbox{]} change in scaled \-E\-M\-P contribution \-C\-O\-P\-E\-R\-R if split \mbox{[}tab\mbox{]} scaled \-E\-M\-P contribution \-A\-I\-C \mbox{[}tab\mbox{]} change in scaled \-E\-M\-P contribution \-A\-I\-C if split \mbox{[}tab\mbox{]} \-Inf(ivector\mbox{[}1\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}1\mbox{]}.\mbox{[}tab\mbox{]} . . \mbox{[}tab\mbox{]} \-Inf(ivector\mbox{[}d\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}d\mbox{]} 
\begin{DoxyParams}{\-Parameters}
{\em big\-N} & is total datapoints, used by the emps calculation \\
\hline
{\em os} & is the stream to send to \\
\hline
{\em prec} & is the precision used for printing, defaulting to 5 \\
\hline
\end{DoxyParams}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a2ab7acc0aff92694976546f1555f67ed}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 378 of file spsnode.\-cpp.



\-References taylor\-::\-Lb(), and taylor\-::\-Ub().



\-Referenced by leaves\-Output\-Tabs\-With\-E\-M\-Ps().


\begin{DoxyCode}
    {
        if(theBox != NULL) { // do nothing if there is no box

            ivector thisBox = *theBox; // copy of theBox

            // output the name, (not label), nodeVolume, counter
            os << nodeName;
            //os << label;
            os << "\t" << nodeVolume();
            os << "\t" << counter;
            // EMP contributions and changes if split
            os << "\t" << getEMPContributionCOPERR(bigN);
            os << "\t" << rnd(getSplitChangeEMPCOPERR(bigN));
            os << "\t" << getEMPContributionAIC(bigN);
            os << "\t" << rnd(getSplitChangeEMPAIC());

            // followed by the intervals of box using Inf and Sup
            // ie unlike cxsc output, there is no [  ] around them
            streamsize oldPrec = os.precision();
            os << setprecision(prec);

            for (int i= Lb(thisBox); i <= Ub(thisBox) ; i++) {

                os << "\t" << Inf(thisBox[i])
                    << "\t" << Sup(thisBox[i]);
            }
            os << setprecision(oldPrec);

        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aaf9ac8d98bda6e99c74b946d85c6bc61}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaf\-Output\-Tabs\-With\-Hist\-Height@{leaf\-Output\-Tabs\-With\-Hist\-Height}}
\index{leaf\-Output\-Tabs\-With\-Hist\-Height@{leaf\-Output\-Tabs\-With\-Hist\-Height}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaf\-Output\-Tabs\-With\-Hist\-Height}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaf\-Output\-Tabs\-With\-Hist\-Height} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{big\-N, }
\item[{std\-::ostream \&}]{os, }
\item[{const int}]{prec = {\ttfamily 5}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private, virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_aaf9ac8d98bda6e99c74b946d85c6bc61}


\-Output for a node in a binary tree, tab-\/delimited. 

\-Output intended for a txt file, in numeric form only.

\-Includes the height of a bin represented by this leaf node for a normalised histogram, ie counter/(node volume $\ast$ total count in tree)

\-Replaces the format that that the cxsc\-:\-:$<$$<$ operator produces for interval vectors. \-The format used here includes the box label and produces numeric tab-\/delimited data. \-The format for a d-\/dimensional interval vector is\-:

node\-Name \mbox{[}tab\mbox{]} counter \mbox{[}tab\mbox{]} volume \mbox{[}tabl\mbox{]} counter/(volume$\ast$total count) \mbox{[}tab\mbox{]} \-Inf(ivector\mbox{[}1\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}1\mbox{]}) \mbox{[}tab\mbox{]} ... \mbox{[}tab\mbox{]} \-Inf(ivector\mbox{[}d\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}d\mbox{]}) 
\begin{DoxyParams}{\-Parameters}
{\em big\-N} & is total data points, used by the height calculation \\
\hline
{\em os} & is the stream to send to \\
\hline
{\em prec} & is the precision used for printing, defaulting to 5 \\
\hline
\end{DoxyParams}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a6eff83d7095798158c0bc17ee70e54c0}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 414 of file spsnode.\-cpp.



\-References taylor\-::\-Lb(), and taylor\-::\-Ub().



\-Referenced by leaves\-Output\-Tabs\-With\-Hist\-Height().


\begin{DoxyCode}
    {
        if(theBox != NULL) { // do nothing if there is no box

            ivector thisBox = *theBox; // copy of theBox
            double vol = nodeVolume();

            // output the node name, nodeVolume, counter, counter/(bigN * vol)
            os << nodeName;
            os << "\t" << vol;
            os << "\t" << counter;
            os << "\t" << counter/(vol * bigN);
            // followed by the intervals of box using Inf and Sup
            // ie unlike cxsc output, there is no [  ] around them
            streamsize oldPrec = os.precision();
            os << setprecision(prec);

            for (int i= Lb(thisBox); i <= Ub(thisBox) ; i++) {

                os << "\t" << Inf(thisBox[i])
                    << "\t" << Sup(thisBox[i]);
            }
            os << setprecision(oldPrec);

        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ad64bd4af47589b21d9c8dde5135c3d0a}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps@{leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps}}
\index{leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps@{leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{big\-N, }
\item[{std\-::ostream \&}]{os, }
\item[{const int}]{prec = {\ttfamily 5}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ad64bd4af47589b21d9c8dde5135c3d0a}


\-Output for a node in a binary tree, tab-\/delimited. 

\-Output intended for a txt file, in numeric form only.

\-Replaces the format that that the cxsc\-:\-:$<$$<$ operator produces for interval vectors. \-The format used here includes the box label and produces numeric tab-\/delimited data.

\-Includes the height of a bin represented by this leaf node for a normalised histogram, ie counter/(node volume $\ast$ total count in tree)

\-The format for a d-\/dimensional interval vector is

node\-Name \mbox{[}tab\mbox{]} counter \mbox{[}tab\mbox{]} volume \mbox{[}tabl\mbox{]} counter/(volume$\ast$total count) scaled \-E\-M\-P contribution \-C\-O\-P\-E\-R\-R \mbox{[}tab\mbox{]} change in scaled \-E\-M\-P contribution \-C\-O\-P\-E\-R\-R if split \mbox{[}tab\mbox{]} scaled \-E\-M\-P contribution \-A\-I\-C \mbox{[}tab\mbox{]} change in scaled \-E\-M\-P contribution \-A\-I\-C if split \mbox{[}tab\mbox{]} \-Inf(ivector\mbox{[}1\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}1\mbox{]}.\mbox{[}tab\mbox{]} . . \mbox{[}tab\mbox{]} \-Inf(ivector\mbox{[}d\mbox{]}) \mbox{[}tab\mbox{]} \-Sup(ivector\mbox{[}d\mbox{]} 
\begin{DoxyParams}{\-Parameters}
{\em big\-N} & is total data points, used by emps and height calculations \\
\hline
{\em os} & is the stream to send to \\
\hline
{\em prec} & is the precision used for printing, defaulting to 5 \\
\hline
\end{DoxyParams}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a4ed4d26826f77814558a0ad3770582f4}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 444 of file spsnode.\-cpp.



\-References taylor\-::\-Lb(), and taylor\-::\-Ub().



\-Referenced by leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps().


\begin{DoxyCode}
    {
        if(theBox != NULL) { // do nothing if there is no box

            ivector thisBox = *theBox; // copy of theBox
            double vol = nodeVolume();

            // output the node name, nodeVolume, counter, counter/(n * vol)
            os << nodeName;
            //os << label;
            os << "\t" << nodeVolume();
            os << "\t" << counter;
            os << "\t" << counter/(vol * bigN);
            // EMP contributions and changes if split
            os << "\t" << getEMPContributionCOPERR(bigN);
            os << "\t" << rnd(getSplitChangeEMPCOPERR(bigN));
            os << "\t" << getEMPContributionAIC(bigN);
            os << "\t" << rnd(getSplitChangeEMPAIC());

            // followed by the intervals of box using Inf and Sup
            // ie unlike cxsc output, there is no [  ] around them
            streamsize oldPrec = os.precision();
            os << setprecision(prec);

            for (int i= Lb(thisBox); i <= Ub(thisBox) ; i++) {

                os << "\t" << Inf(thisBox[i])
                    << "\t" << Sup(thisBox[i]);
            }
            os << setprecision(oldPrec);

        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_abe732a753f432c2239c9f82a47d089b1}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaves\-Output\-Tabs@{leaves\-Output\-Tabs}}
\index{leaves\-Output\-Tabs@{leaves\-Output\-Tabs}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaves\-Output\-Tabs}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaves\-Output\-Tabs} (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_abe732a753f432c2239c9f82a47d089b1}


\-Output for for {\bfseries all leaves} of a binary tree. 

\-Output intended for a txt file, in numeric form only.

\-Recursively uses \hyperlink{classsubpavings_1_1SPSnode_a3cc0c8bb64c854ef16ba03891f5945d6}{leaf\-Output\-Tabs()} to output information for each leaf node. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_a3663133a2c9f0fce79f3f551c1d163de}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_abcac815b9e5e60a3d18fa3534a12c518}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2403 of file spsnode.\-cpp.



\-References get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), leaf\-Output\-Tabs(), and leaves\-Output\-Tabs().



\-Referenced by leaves\-Output\-Tabs(), subpavings\-::\-Adaptive\-Histogram\-::output\-Log\-Plain(), and subpavings\-::\-Adaptive\-Histogram\-::output\-To\-Txt\-Tabs().


\begin{DoxyCode}
    {
        // uses  member function leafOutputTabs to generate node output
        if (!(isEmpty()) && isLeaf()) { // this is a non-empty leaf
            leafOutputTabs(os);
            return (os << "\n");

        }

        //recurse on the children
        if (getLeftChild()!=NULL) {
            getLeftChild()->leavesOutputTabs(os);
        }

        if (getRightChild()!=NULL) {
            getRightChild()->leavesOutputTabs(os);
        }

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a817a8a29925937c189cc009366fe6bfb}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaves\-Output\-Tabs\-With\-E\-M\-Ps@{leaves\-Output\-Tabs\-With\-E\-M\-Ps}}
\index{leaves\-Output\-Tabs\-With\-E\-M\-Ps@{leaves\-Output\-Tabs\-With\-E\-M\-Ps}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaves\-Output\-Tabs\-With\-E\-M\-Ps}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaves\-Output\-Tabs\-With\-E\-M\-Ps} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{big\-N, }
\item[{std\-::ostream \&}]{os, }
\item[{const int}]{prec = {\ttfamily 5}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a817a8a29925937c189cc009366fe6bfb}


\-Output for for {\bfseries all leaves} of a binary tree. 

\-Output intended for a txt file, in numeric form only.

\-Recursively uses \hyperlink{classsubpavings_1_1SPSnode_a3cc0c8bb64c854ef16ba03891f5945d6}{leaf\-Output\-Tabs()} to output information for each leaf node. \-Includes scaled \-C\-O\-P\-E\-R\-R and \-A\-I\-C contributions and changes if split. 
\begin{DoxyParams}{\-Parameters}
{\em big\-N} & is total data points, used by emps and height calculations \\
\hline
{\em os} & is the stream to send to \\
\hline
{\em prec} & is the precision used for printing, defaulting to 5 \\
\hline
\end{DoxyParams}


\-Definition at line 2425 of file spsnode.\-cpp.



\-References get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), leaf\-Output\-Tabs\-With\-E\-M\-Ps(), leaves\-Output\-Tabs\-With\-E\-M\-Ps(), and subpavings\-::\-S\-Pnode\-::parent.



\-Referenced by leaves\-Output\-Tabs\-With\-E\-M\-Ps(), subpavings\-::\-Adaptive\-Histogram\-::output\-Log(), and subpavings\-::\-Adaptive\-Histogram\-::output\-To\-Txt\-Tabs\-With\-E\-M\-Ps().


\begin{DoxyCode}
    {
        if (parent == NULL) { // root
            std::string headers = "node \t vol \t count \t EMP COPERR ";
            headers += "\t &change \t EMP AIC \t &change \t dimensions \n";
            os << headers;
        }

        // uses  member function leafOutputTabsWithEMPs to generate node output
        if (!(isEmpty()) && isLeaf()) { // this is a non-empty leaf
            leafOutputTabsWithEMPs(bigN, os, prec);
            return (os << "\n");

        }

        //recurse on the children
        if (getLeftChild()!=NULL) {
            getLeftChild()->leavesOutputTabsWithEMPs(bigN, os, prec);
        }

        if (getRightChild()!=NULL) {
            getRightChild()->leavesOutputTabsWithEMPs(bigN, os, prec);
        }

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a11c1e7c0e652b891c08dfefebd285904}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaves\-Output\-Tabs\-With\-Hist\-Height@{leaves\-Output\-Tabs\-With\-Hist\-Height}}
\index{leaves\-Output\-Tabs\-With\-Hist\-Height@{leaves\-Output\-Tabs\-With\-Hist\-Height}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaves\-Output\-Tabs\-With\-Hist\-Height}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaves\-Output\-Tabs\-With\-Hist\-Height} (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os, }
\item[{const int}]{prec}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a11c1e7c0e652b891c08dfefebd285904}


\-Output for for {\bfseries all leaves} of a binary tree. 

\-Output intended for a txt file, in numeric form only.

\-Recursively uses \hyperlink{classsubpavings_1_1SPSnode_aaf9ac8d98bda6e99c74b946d85c6bc61}{leaf\-Output\-Tabs\-With\-Hist\-Height()} to output information for each leaf node. \-Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points of this root. 
\begin{DoxyParams}{\-Parameters}
{\em os} & is the stream to send to \\
\hline
{\em prec} & is the precision used for printing, defaulting to 5 \\
\hline
\end{DoxyParams}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_adc55cda7856cfdd854051b891263d3bf}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2456 of file spsnode.\-cpp.



\-References counter.



\-Referenced by leaves\-Output\-Tabs\-With\-Hist\-Height().


\begin{DoxyCode}
    {
        leavesOutputTabsWithHistHeight(counter, os, prec);
        return (os);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a7f8027e04d883efdf7b627208775b989}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaves\-Output\-Tabs\-With\-Hist\-Height@{leaves\-Output\-Tabs\-With\-Hist\-Height}}
\index{leaves\-Output\-Tabs\-With\-Hist\-Height@{leaves\-Output\-Tabs\-With\-Hist\-Height}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaves\-Output\-Tabs\-With\-Hist\-Height}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaves\-Output\-Tabs\-With\-Hist\-Height} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{big\-N, }
\item[{std\-::ostream \&}]{os, }
\item[{const int}]{prec = {\ttfamily 5}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a7f8027e04d883efdf7b627208775b989}


\-Output for for {\bfseries all leaves} of a binary tree. 

\-Output intended for a txt file, in numeric form only.

\-Recursively uses \hyperlink{classsubpavings_1_1SPSnode_aaf9ac8d98bda6e99c74b946d85c6bc61}{leaf\-Output\-Tabs\-With\-Hist\-Height()} to output information for each leaf node. \-Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points of this root. 
\begin{DoxyParams}{\-Parameters}
{\em big\-N} & is total data points, used by emps and height calculations \\
\hline
{\em os} & is the stream to send to \\
\hline
{\em prec} & is the precision used for printing, defaulting to 5 \\
\hline
\end{DoxyParams}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a8419f16a2f0667bc190a4a9ed41121c1}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2466 of file spsnode.\-cpp.



\-References get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), leaf\-Output\-Tabs\-With\-Hist\-Height(), and leaves\-Output\-Tabs\-With\-Hist\-Height().


\begin{DoxyCode}
    {
        // uses  member function leafOutputTabs to generate node output
        if (!(isEmpty()) && isLeaf()) { // this is a non-empty leaf
            leafOutputTabsWithHistHeight(bigN, os, prec);
            return (os << "\n");

        }

        //recurse on the children
        if (getLeftChild()!=NULL) {
            getLeftChild()->leavesOutputTabsWithHistHeight(bigN, os, prec);
        }

        if (getRightChild()!=NULL) {
            getRightChild()->leavesOutputTabsWithHistHeight(bigN, os, prec);
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a24b8bd122c6509dd0bdb1d11b52edb7a}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps@{leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps}}
\index{leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps@{leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps} (
\begin{DoxyParamCaption}
\item[{const size\-\_\-t}]{big\-N, }
\item[{std\-::ostream \&}]{os, }
\item[{const int}]{prec = {\ttfamily 5}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a24b8bd122c6509dd0bdb1d11b52edb7a}


\-Output for for {\bfseries all leaves} of a binary tree. 

\-Output intended for a txt file, in numeric form only.

\-Recursively uses \hyperlink{classsubpavings_1_1SPSnode_ad64bd4af47589b21d9c8dde5135c3d0a}{leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps()} to output information for each leaf node. \-Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points n. 
\begin{DoxyParams}{\-Parameters}
{\em big\-N} & is total data points, used by emps and height calculations \\
\hline
{\em os} & is the stream to send to \\
\hline
{\em prec} & is the precision used for printing, defaulting to 5 \\
\hline
\end{DoxyParams}


\-Definition at line 2488 of file spsnode.\-cpp.



\-References get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), leaf\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps(), leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps(), and subpavings\-::\-S\-Pnode\-::parent.



\-Referenced by leaves\-Output\-Tabs\-With\-Hist\-Height\-And\-E\-M\-Ps().


\begin{DoxyCode}
    {
        if (parent == NULL) { // root
            std::string headers = "node \t vol \t count \t height ";
            headers += "\t EMP COPERR \t &change \t EMP AIC \t &change ";
            headers += "\t dimensions \n";
            os << headers;
        }

        // uses  member function leafOutputTabsWithEMPs to generate node output
        if (!(isEmpty()) && isLeaf()) { // this is a non-empty leaf
            leafOutputTabsWithHistHeightAndEMPs(bigN, os, prec);
            return (os << "\n");

        }

        //recurse on the children
        if (getLeftChild()!=NULL) {
            getLeftChild()->leavesOutputTabsWithHistHeightAndEMPs(bigN,
                                                                    os, prec);
        }

        if (getRightChild()!=NULL) {
            getRightChild()->leavesOutputTabsWithHistHeightAndEMPs(bigN,
                                                                    os, prec);
        }

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a69cbe84e4c59cd1369d3900d3ff05a01}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!make\-Empty\-Node@{make\-Empty\-Node}}
\index{make\-Empty\-Node@{make\-Empty\-Node}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{make\-Empty\-Node}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::make\-Empty\-Node} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_a69cbe84e4c59cd1369d3900d3ff05a01}


\-Clears the node's data collection and counter. 



\-Definition at line 1022 of file spsnode.\-cpp.



\-References counter, and data\-Itrs.


\begin{DoxyCode}
   { dataItrs.clear();
     counter = 0;
   }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ae1d11e62b133e13be6c14f7ff759f152}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Adopt\-Left@{node\-Adopt\-Left}}
\index{node\-Adopt\-Left@{node\-Adopt\-Left}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Adopt\-Left}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Adopt\-Left} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{l\-Child}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ae1d11e62b133e13be6c14f7ff759f152}


\-Builds a higher level of a tree from existing nodes. 

\-This adopts a left child rather than attempting to reunite two children into this. \begin{DoxyWarning}{\-Warning}
not thoroughly tested 
\end{DoxyWarning}


\-Definition at line 3000 of file spsnode.\-cpp.



\-References data\-Itrs, gather\-Data(), insert\-One\-Find(), subpavings\-::\-S\-Pnode\-::node\-Add\-Left(), subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, and set\-Splits().



\-Referenced by node\-Reunite().


\begin{DoxyCode}
    {
        // *this is the node which will become the parent

        // we have to collect all the data from the child,
        // and fire it into this to make sure that the stats
        // for this (this node) are correct

        NodeData tempContainer;
        gatherData(tempContainer, lChild);

        // reserve capacity in this
        dataItrs.reserve(tempContainer.size());

        NodeDataItr it;

        SPSnode* insertedInto = NULL;

        for (it = tempContainer.begin();
            it < tempContainer.end(); it++) {

            SplitNever sn; // dummy split decision maker
            insertedInto = insertOneFind(*it, ON_PARENT, sn);
            // insert with no splitting
            if (insertedInto == NULL) {
                std::cerr << "Check SPSnode::nodeAdoptLeft: "
                    << "data " << **it << " from node "
                    << "to be adopted rejected by new "
                    << "parent" << std::endl;
            }
        }

        // the stats for this should now be right
        // but the data is associated with its descendent nodes
        // so we need to clear the actual data
        dataItrs.clear();

        // point parent and child pointers in the right directions
        // nodeAddLeft() checks labels, hull size , present children
        nodeAddLeft(lChild);
        setSplits(); // set the split dimension and split value

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a4049a0078541b24d5451957f6f7dcd68}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Adopt\-Right@{node\-Adopt\-Right}}
\index{node\-Adopt\-Right@{node\-Adopt\-Right}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Adopt\-Right}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Adopt\-Right} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{r\-Child}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a4049a0078541b24d5451957f6f7dcd68}


\-Builds a higher level of a tree from existing nodes. 

\-This adopts a right child rather than attempting to reunite two children into this. \begin{DoxyWarning}{\-Warning}
\-Not thoroughly tested 
\end{DoxyWarning}


\-Definition at line 3048 of file spsnode.\-cpp.



\-References data\-Itrs, gather\-Data(), insert\-One\-Find(), subpavings\-::\-S\-Pnode\-::node\-Add\-Right(), subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, and set\-Splits().



\-Referenced by node\-Reunite().


\begin{DoxyCode}
    {
        //* this is the node which will become the parent

        // we have to collect all the data from the child,
        // and fire it into this to make sure that the stats
        // for this (this node) are correct
        NodeData tempContainer;
        gatherData(tempContainer, rChild);

        // reserve capacity in this
        dataItrs.reserve(tempContainer.size());

        NodeDataItr it;

        SPSnode* insertedInto = NULL;

        for (it = tempContainer.begin();
            it < tempContainer.end(); it++) {

            SplitNever sn; // dummy split decision maker
            insertedInto = insertOneFind(*it, ON_PARENT, sn);
            // insert with no splitting
            if (insertedInto == NULL) {
                std::cerr << "Check SPSnode::nodeAdoptRight: "
                    << "data " << **it << " from node to "
                    << "be adopted rejected by new parent"
                    << std::endl;
            }
        }

        // the stats for this should now be right
        // but the data is associated with its descendent nodes
        // so we need to clear the actual data
        dataItrs.clear();

        // point parent and child pointers in the right directions
        // nodeAddRight() checks labels, hull size, present children
        nodeAddRight(rChild);
        setSplits(); // set the split dimension and split value
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a918067afb150c053f7450fd18c6ecd22}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Contains@{node\-Contains}}
\index{node\-Contains@{node\-Contains}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Contains}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-S\-P\-Snode\-::node\-Contains} (
\begin{DoxyParamCaption}
\item[{const rvector \&}]{p, }
\item[{{\bf \-O\-P\-E\-R\-A\-T\-I\-O\-N\-S\-\_\-\-O\-N}}]{child\-Ind = {\ttfamily {\bf \-O\-N\-\_\-\-P\-A\-R\-E\-N\-T}}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a918067afb150c053f7450fd18c6ecd22}


\-Check if the box a node represents contains a datapoint p. 

\begin{DoxyNote}{\-Note}
virtual \-B\-O\-O\-L\-\_\-\-I\-N\-T\-E\-R\-V\-A\-L \hyperlink{classsubpavings_1_1SPnode_aa90c047beb6a8b6a4beb74342ad593a3}{sp\-Contains(const ivector\& z) const} is not redeclared so use base.

virtual \-B\-O\-O\-L\-\_\-\-I\-N\-T\-E\-R\-V\-A\-L \hyperlink{classsubpavings_1_1SPnode_a56f98ed5bc26b9b11dfce51f3e667e2b}{sp\-Contains(const rvector\& p) const} is not redeclared so use base.
\end{DoxyNote}

\begin{DoxyParams}{\-Parameters}
{\em p} & the value of the data point being tested for containment in the box represented by this node. \\
\hline
{\em child\-Ind} & indicates whether this should be considered to be a left child or a right child (ie where we need to take splitting dimension and value into account) or as a parent node (default).\\
\hline
\end{DoxyParams}
\-If a node is being considered as a child node (ie child\-Ind is \-O\-N\-\_\-\-R\-I\-G\-H\-T or \-O\-N\-\_\-\-L\-E\-F\-T) and actaully has a parent node, then is is assumed that the data point would have been in the box associated with the parent node, and the question now is just whether it falls into the left or right child. \-Thus no test for full containment of the data point in the box is carried out, and this method just checks whether the data point would have fallen from the parent into the left or right child.

\-If child\-Ind is \-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, or if the node has no parent node, then the method checks for full containment of the data point within the box associated with this node.

\-Note that the interval on the parent's split dimension of the right child's box is closed at the split value and the interval of the left child's box is open. \-A datapoint whose element in the split dimension is exactly the split value should be assessed to be in the right child's box but not the left child's box. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_aaefe6100d8c62dc84849cd2adb733ffb}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a803d11f31d86f0565dbe682a33099698}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2568 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Box(), get\-Parent(), get\-Split\-Dim(), get\-Split\-Value(), subpavings\-::\-O\-N\-\_\-\-L\-E\-F\-T, subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, subpavings\-::\-O\-N\-\_\-\-R\-I\-G\-H\-T, and subpavings\-::\-S\-Pnode\-::parent.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-Collator\-::get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample(), insert\-One\-Find(), and sps\-Contains().


\begin{DoxyCode}
  {
    bool retValue = false;
    
    // only check for total containment if this is a parent node
    // or to be treated as such
    if ((parent == NULL) || (childInd == ON_PARENT)) {
    
      // cast p to an ivector
      ivector pvec = _ivector(p);
    
      //find if p is in the box
      if (pvec <= getBox()) {
        retValue = true;
      }
    }
    // if not to be treated as a whole box, we assume it was in the parent
    // and only check ourselves with respect to the split dimension
    // and if this is a right child it can be anywhere 
    // but  this is a left child,
    // we need to check the split
    // find what dimension the parent was split on and what
    // the split value was
    // pvector must be strictly less than parentSplitValue
    // on the split dimension
    else if (parent != NULL) { // truly not a parent node
    
      int parentSplitDim = (getParent())->getSplitDim();
      real parentSplitValue = (getParent())->getSplitValue();
      
      bool strictlyLeft = (p[parentSplitDim] < parentSplitValue);

      if (childInd == ON_LEFT) { 
        retValue = strictlyLeft;
        }
      if (childInd == ON_RIGHT) { 
        retValue = !strictlyLeft; 
      }
    }
    
    return retValue;
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a799dd8e194518c3dd525ecba26072585}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Data\-Print@{node\-Data\-Print}}
\index{node\-Data\-Print@{node\-Data\-Print}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Data\-Print}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::node\-Data\-Print} (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a799dd8e194518c3dd525ecba26072585}


\-Print the data in a specified format. 

\-Replaces the format that the cxsc\-:\-:$<$$<$ operator produces for vectors. \-The format used here includes the box label and produces numeric tab-\/delimited data. \-The format for an n-\/dimensional real vector data point is\-:

label \mbox{[}tab\mbox{]} rvector\mbox{[}1\mbox{]} \mbox{[}tab\mbox{]} . . . \mbox{[}tab\mbox{]} rvector\mbox{[}n\mbox{]} 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a5868a7661363e2f3bd7d2e267c22ceb1}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 267 of file spsnode.\-cpp.



\-Referenced by node\-Print().


\begin{DoxyCode}
    {
        if (!dataItrs.empty()) {

            NodeDataItr dataItr;

            os << "Data is" << std::endl;
            for (dataItr = dataItrs.begin();
                dataItr!= dataItrs.end(); dataItr++) {

                BigDataItr bigIt = *dataItr;
                rvector theData = *bigIt;

                for (size_t i = 1; i < dimension + 1; i++) {
                    os << label; // print the label
                    os << "  " << theData[i]; // print data
                }   // end loop through data elements

                os << std::endl;

            } // end loop through data container
        } // end if counter > 0
        // if no data, ie counter = 0, then just return os unaltered

        return os;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_adf0575b58b84a0910a8d5b67b6ec0f48}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Expand@{node\-Expand}}
\index{node\-Expand@{node\-Expand}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Expand}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Expand} (
\begin{DoxyParamCaption}
\item[{int}]{comp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_adf0575b58b84a0910a8d5b67b6ec0f48}


\-Expand a leaf node. 

\-Expand a leaf node to have two children and pass data down to the children with no further splitting.

\-Uses node\-Expansion() and \hyperlink{classsubpavings_1_1SPSnode_adf3d76ca267b87c46d1fcb1ca3cecd84}{split\-Data()}.

\-Equivalent to bisecting a box in a regular subpaving. \-Makes two new sibling child nodes of this. 
\begin{DoxyParams}{\-Parameters}
{\em comp} & is the dimension on which to to bisect the\-Box. \\
\hline
\end{DoxyParams}


\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_ac27ee8ea1399ed0121ed970c8fd51543}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a94c33927011a8d2613d40ccf6ccfafc1}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2831 of file spsnode.\-cpp.



\-References node\-Expansion\-Only(), and split\-Data().


\begin{DoxyCode}
    {
        nodeExpansionOnly(comp);    // expand the node
        SplitNever sn;              // dummy split decision maker
        splitData(sn);            // split the data with no further splitting


    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a0728b0ec4deee17f6a729a97c8b5a560}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Expand@{node\-Expand}}
\index{node\-Expand@{node\-Expand}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Expand}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Expand} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{int}]{comp}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_a0728b0ec4deee17f6a729a97c8b5a560}


\-Expand a leaf node. 

\-Expand a leaf node to have two children and pass data down to the children, allowing for further splitting.


\begin{DoxyParams}{\-Parameters}
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em comp} & is the dimension on which to to bisect the\-Box. \\
\hline
\end{DoxyParams}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_acbad110f9ed41364774c9e2fea658594}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2842 of file spsnode.\-cpp.



\-References node\-Expansion\-Only(), and split\-Data().


\begin{DoxyCode}
    {
        nodeExpansionOnly(comp);    // expand the node
        // split the data, allowing for further splitting

        splitData(boolTest);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ae432186483a5ec950dab0eb00b08a9bc}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Expand@{node\-Expand}}
\index{node\-Expand@{node\-Expand}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Expand}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Expand} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ae432186483a5ec950dab0eb00b08a9bc}


\-Expand a leaf node. 

\-Expand a leaf node to have two children and pass data down to the children with no further splitting.

\-Finds the splitting dimension. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_a0540c55967e7f35843fac029b450ab55}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a0eb85efd74fa770f3259d6ba948b65b8}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2853 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Box(), and \-Max\-Diam().



\-Referenced by insert\-One\-Find(), and node\-Expand().


\begin{DoxyCode}
    {
        int maxdiamcomp; // variable to hold first longest dimension
        double temp = ::MaxDiam(getBox(), maxdiamcomp);
        nodeExpand(maxdiamcomp); // complete nodeExpand

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a19a54cd8f89112dbed3f43c2f405921f}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Expand@{node\-Expand}}
\index{node\-Expand@{node\-Expand}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Expand}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Expand} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_a19a54cd8f89112dbed3f43c2f405921f}


\-Expand a leaf node. 

\-Expand the leaf node to have two children and pass data down to the children, allowing for further splitting.

\-Finds the dimension to split on.


\begin{DoxyParams}{\-Parameters}
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
\end{DoxyParams}


\-Definition at line 2863 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Box(), \-Max\-Diam(), and node\-Expand().


\begin{DoxyCode}
    {
        int maxdiamcomp; // variable to hold first longest dimension
        double temp = ::MaxDiam(getBox(), maxdiamcomp);
        nodeExpand(boolTest, maxdiamcomp); // complete nodeExpand
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ac549870ef3b7994d9e87b952a012a7e9}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Expansion\-Only@{node\-Expansion\-Only}}
\index{node\-Expansion\-Only@{node\-Expansion\-Only}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Expansion\-Only}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Expansion\-Only} (
\begin{DoxyParamCaption}
\item[{int}]{comp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ac549870ef3b7994d9e87b952a012a7e9}


\-Expand the node with no reallocation of data. 

\-Bisect box, make two new nodes (one for each half box) and graft onto this node provided that this node is a leaf. \-Equivalent to bisecting a box in a regular subpaving. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a747a3c135503cbf1f1b349a5898cebc4}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 171 of file spsnode.\-cpp.



\-References subpavings\-::is\-Leaf(), \-Lower(), and \-Upper().



\-Referenced by node\-Expand().


\begin{DoxyCode}
    {
        try
        {
            // only do something if this SPSnode is a leaf
            if (isLeaf()) {
                // ivectors to become boxes for new children
                ivector lC, rC;

                // Call Lower() and Upper() to put the split
                // boxes into lC and rC respectively
                Lower(getBox(), lC, comp);
                Upper(getBox(), rC, comp);

                // when making new children, use constructor
                // that will give space indication (for data)
                // of the size of this node's dataItrs
                size_t space = dataItrs.size();

                nodeAddLeft(new SPSnode(lC,
                                        space, countsOnly, label));

                nodeAddRight(new SPSnode(rC,
                                        space, countsOnly, label));

                //name the new children
                getLeftChild()->setNodeName(nodeName + "L");
                getRightChild()->setNodeName(nodeName + "R");

                // store the split dimension in this
                splitDim = comp;

                // store the split value in this
                // the split value is the infinum of interval
                // of right child box for dimension split on
                splitValue = _double(Inf(
                    ((getRightChild())->getBox())[comp]));
            }
        }

        catch (bad_alloc&)
        {
            std::cerr << "Error allocating memory in "
                << "SPSnode::nodeExpansionOnly()" << std::endl;
            throw;
        }

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a5f5cc02f707a2b98f7a93543c71298b2}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Mean\-Print@{node\-Mean\-Print}}
\index{node\-Mean\-Print@{node\-Mean\-Print}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Mean\-Print}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::node\-Mean\-Print} (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a5f5cc02f707a2b98f7a93543c71298b2}


\-Print the mean in a specified format. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a768f9507517be618970d19874b1ff992}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 295 of file spsnode.\-cpp.



\-Referenced by node\-Print().


\begin{DoxyCode}
    {

        if ((counter > 0) && !countsOnly) {

            os << "Mean is ";

            // loop through the elements in the dpSums vector
            for (size_t i = 0; i< dimension; i++) {
                // default cxsc rounding of dotprecision
                // to rnd_next
                os << "  " << (rnd(dpSums[i])/(1.0*counter));

            }// end loop through the elements in dpSums

            os << std::endl;

        } // end if
        // if no data, ie counter = 0, or if we are only keeping counts
        // then just return os unaltered

        return os;

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aba02715cb75f803df7c3ffd1eaf027e8}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Print@{node\-Print}}
\index{node\-Print@{node\-Print}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Print}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::node\-Print} (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_aba02715cb75f803df7c3ffd1eaf027e8}


\-Output details of a specific node. 

\-This is intended for console output or output to a mixed alpha and numeric file. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_aaf14185437d50e955c5ea938dc6e7559}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a51715ef7b6e370006e914fee15061cfc}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 1995 of file spsnode.\-cpp.



\-References counter, taylor\-::\-Lb(), node\-Data\-Print(), node\-Mean\-Print(), node\-Var\-Covar\-Print(), subpavings\-::\-S\-Pnode\-::node\-Volume(), subpavings\-::\-S\-Pnode\-::the\-Box, and taylor\-::\-Ub().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::output\-Root\-To\-Txt().


\begin{DoxyCode}
    {
        // output for box in form:
        // box, volume, counter, mean, variance covariance, and data

        if(theBox != NULL) { // do nothing if there is no box

            ivector thisBox = *theBox; // copy theBox

            os << "Box is :";

            for (int i = Lb(thisBox); i <= Ub(thisBox) ; i++) {
                // c-xsc default output for intervals
                os << "  " << thisBox[i];
            }

            os << std::endl;
            os << "Box volume is " << nodeVolume() << std::endl;
            os << "Counter = " << counter << std::endl;

            nodeMeanPrint(os);
            nodeVarCovarPrint(os);
            nodeDataPrint(os);


            os << std::endl;
        }
        return os;

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a68cc1a1722c627a99dcefc3491847fb2}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Reabsorb\-Children@{node\-Reabsorb\-Children}}
\index{node\-Reabsorb\-Children@{node\-Reabsorb\-Children}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Reabsorb\-Children}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Reabsorb\-Children} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a68cc1a1722c627a99dcefc3491847fb2}


\-Reabsorbs both children of the node. 

\-Effectively reverses any split of the node.

\-Data associated with the children is pushed back up to this and the split\-Dim and split\-Value reset to leaf defaults.

\-Works even if the children are not leaves. 

\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_ab92c1accdfd155898e63e26a112b8e36}{subpavings\-::\-S\-Pnode}.



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_aed19a06dc479c2edc865243d2c131c30}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 2875 of file spsnode.\-cpp.



\-References data\-Itrs, gather\-Data(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::left\-Child, node\-Reabsorb\-Children(), subpavings\-::\-S\-Pnode\-::right\-Child, split\-Dim, and split\-Value.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::change\-State\-For\-Merge(), subpavings\-::\-Adaptive\-Histogram\-::merge\-Up(), node\-Reabsorb\-Children(), and subpavings\-::\-Adaptive\-Histogram\-::priority\-Merge().


\begin{DoxyCode}
    {
        // first recursively deal with the children of the children
        if (hasLCwithBox())
            getLeftChild()->nodeReabsorbChildren();
        if (hasRCwithBox())
            getRightChild()->nodeReabsorbChildren();

        if (hasLCwithBox()) {
            gatherData(dataItrs, getLeftChild());
            delete leftChild;
            leftChild = NULL;
        }

        if (hasRCwithBox()) {
            gatherData(dataItrs, getRightChild());
            delete rightChild;
            rightChild = NULL;
        }

        // reset splitDim and splitValue to their defaults
        splitDim = -1;
        splitValue = 0.0;

        leftChild = NULL;
        rightChild = NULL;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a61c584952df4fa77109cb4bb9b46f657}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Reunite@{node\-Reunite}}
\index{node\-Reunite@{node\-Reunite}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Reunite}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::node\-Reunite} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{l\-Child, }
\item[{{\bf \-S\-P\-Snode} $\ast$}]{r\-Child}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a61c584952df4fa77109cb4bb9b46f657}


\-Try to reunite nodes to form one leaf. 

\-Note that the nodes provided, l\-Child and r\-Child, are not the actual children of this, they are potential children which we are trying to either totally bring into this (if there are two of them) or to graft onto this if there is only one of them. \-This is typically a new, part-\/formed node whose formation can be completed by reuniting already two already-\/formed nodes into it or by adding on one child if only one is available. node\-Reunite is used in building a tree upwards (rather than in pruning leaves of formed tree from the bottom up).

\-If two potential children are provided and they are both leaves, it combines the two leaf siblings into this. \-If the potential children are not leaves or if only one potential child is provided, it grafts the potential child/children onto this as its child/children.

\-Data associated with the children is moved to the new parent and statistics recalculated.

\begin{DoxyWarning}{\-Warning}
node\-Reunite would not normally be used with \-S\-P\-Snodes but is in the base class and is reimplemented to try do it appropriately for this derived class should it be needed. \-This function is untested. 
\end{DoxyWarning}


\-Definition at line 2925 of file spsnode.\-cpp.



\-References data\-Itrs, gather\-Data(), insert\-One\-Find(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-S\-Pnode\-::label, node\-Adopt\-Left(), node\-Adopt\-Right(), subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, subpavings\-::\-S\-Pnode\-::recursive\-Rename(), and subpavings\-::\-S\-Pnode\-::the\-Box.


\begin{DoxyCode}
    {
        // redo the box, move the data up,

        // *this is the node which will become the parent

        // check that the labels match and exit if not
        if ((lChild->label != label ) || (rChild->label != label)) {
            throw SPnodeException("Labels do not match");
        }

        // if both subpavings are leaves and hull of boxes is x,
        // discard them: *this is a leaf
        if (lChild->isLeaf() && rChild->isLeaf()) {
            if (*theBox !=
                (*(lChild->theBox) | *(rChild->theBox))) {
                throw SPnodeException("Boxes to be reunited do not fit");
            }

            // we have to collect all the data from the children,
            // and fire it into this to make sure that the
            // stats for this (this node) are correct
            NodeData tempContainer;
            gatherData(tempContainer, lChild);
            gatherData(tempContainer, rChild);

            // reserve capacity in this
            dataItrs.reserve(tempContainer.size());

            NodeDataItr it;

            SPSnode* insertedInto = NULL;

            for (it = tempContainer.begin();
                it < tempContainer.end(); it++) {
                // insert with no splitting
                SplitNever sn;
                insertedInto = insertOneFind(*it, ON_PARENT, sn);
                if (insertedInto == NULL) {
                    std::cerr << "Check "
                        << "SPSnode::nodeReunite: "
                        << " data " << **it
                        << " from nodes to be adopted "
                        << "rejected by new parent"
                        << std::endl;
                }
            }

            // the stats for this should now be right
            // and this will be a leaf so the data
            // should stay associated with it

            //discard the two subpavings given
            delete lChild;
            delete rChild;

        }

        else {  // at least one of the children is not a leaf
            // this has to adopt them rather than reuniting them
            nodeAdoptRight(rChild);
            nodeAdoptLeft(lChild);
            recursiveRename(); // recursively rename child branches
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a03042a5084349960b1fd35396dc509a5}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!node\-Var\-Covar\-Print@{node\-Var\-Covar\-Print}}
\index{node\-Var\-Covar\-Print@{node\-Var\-Covar\-Print}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{node\-Var\-Covar\-Print}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream \& {\bf \-S\-P\-Snode\-::node\-Var\-Covar\-Print} (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a03042a5084349960b1fd35396dc509a5}


\-Print the variance-\/covariance in a specified format. 



\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a096bff1081ceb308590aac8f2f3ee660}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 321 of file spsnode.\-cpp.



\-Referenced by node\-Print().


\begin{DoxyCode}
    {
        if ((counter > 0) && !countsOnly) {

            RealVec varCovar;
            varCovar = getVarCovar(varCovar);

            /* element k in the vector representing the
            variance-covariance matrix corresponds to
            row k/n, (row 0 to n-1) and column k-row*n (col 0 to n-1)
            in a matrix view variance-covariance */

            os << "Variance Covariance is " << std::endl;

            // loop through the elements and print as matrix
            for (size_t i = 0; i < dimension; i++) {
                for (size_t j = 0; j < dimension; j++) {
                    os << "  " << varCovar[(i*dimension)+j];
                }
                os << std::endl;
            }
        }
        return os;

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a65971d98a726cba6cf111882f984de06}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!operator=@{operator=}}
\index{operator=@{operator=}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} \& \-S\-P\-Snode\-::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-P\-Snode} \&}]{rhs}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_a65971d98a726cba6cf111882f984de06}


\-Copy assignment operator. 



\-Definition at line 895 of file spsnode.\-cpp.



\-References counter, counts\-Only, data\-Itrs, subpavings\-::\-S\-Pnode\-::dimension, dp\-Sum\-Products, dp\-Sums, get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::label, subpavings\-::\-S\-Pnode\-::left\-Child, subpavings\-::\-S\-Pnode\-::node\-Add\-Left(), subpavings\-::\-S\-Pnode\-::node\-Add\-Right(), subpavings\-::\-S\-Pnode\-::node\-Name, subpavings\-::\-S\-Pnode\-::parent, subpavings\-::\-S\-Pnode\-::right\-Child, space\-Indication, split\-Dim, split\-Value, \-S\-P\-Snode(), and subpavings\-::\-S\-Pnode\-::the\-Box.


\begin{DoxyCode}
    {
        try {

            // delete the current children (deletes their children as well)
            if (leftChild != NULL) {
                delete getLeftChild();
                leftChild = NULL;
            }

            if (rightChild != NULL) {
                delete getRightChild();
                rightChild = NULL;
            }
            // and delete the current box
            if (theBox != NULL) {
                delete theBox;
                theBox = NULL;
            }

            parent=NULL;

            theBox=new ivector(*rhs.theBox);
            dimension = rhs.dimension;
            label = rhs.label;
            nodeName = rhs.nodeName;

            spaceIndication = rhs.spaceIndication;

            counter = rhs.counter;
            dpSums = rhs.dpSums;
            dpSumProducts = rhs.dpSumProducts;
            splitDim = rhs.splitDim;
            splitValue = rhs.splitValue;
            countsOnly = rhs.countsOnly;

            //reserve space
            dataItrs.reserve((rhs.dataItrs).size());
            //copy dataItrs from other to this
            dataItrs = rhs.dataItrs;

            //recursion on the children
            if (rhs.leftChild) {
                nodeAddLeft(new SPSnode(*(rhs.getLeftChild())));
            }
            else leftChild=NULL;

            if (rhs.rightChild) {
                nodeAddRight(new SPSnode(*(rhs.getRightChild())));
            }
            else rightChild=NULL;
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }

        return *this;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a8011280b8a3a0729c581a00f3bb031ff}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!recalculate\-Stats@{recalculate\-Stats}}
\index{recalculate\-Stats@{recalculate\-Stats}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{recalculate\-Stats}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::recalculate\-Stats} (
\begin{DoxyParamCaption}
\item[{rvector \&}]{newdata}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a8011280b8a3a0729c581a00f3bb031ff}


\-Recalculate summary statistics associated with node. 

\-Recalculates counter and sums (used for mean) and sumproducts (used for variance-\/covariance). 

\-Definition at line 74 of file spsnode.\-cpp.



\-Referenced by insert\-One\-Find().


\begin{DoxyCode}
    {
        
        counter++;  // update the counter

        if (!countsOnly) {

            recalculateSums(newdata); // update the sums

            recalculateSumProducts(newdata); // update the sumproducts
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ab49e57afe0939b41930e0cbb22c9ba8a}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!recalculate\-Sum\-Products@{recalculate\-Sum\-Products}}
\index{recalculate\-Sum\-Products@{recalculate\-Sum\-Products}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{recalculate\-Sum\-Products}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::recalculate\-Sum\-Products} (
\begin{DoxyParamCaption}
\item[{rvector \&}]{newdata}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ab49e57afe0939b41930e0cbb22c9ba8a}


\-Recalculate summary statistics associated with node. 

\-Recalculates sumproducts (used for variance-\/covariance). 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a3df955b69f0e3d73efd0ccc3026fe0e7}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 113 of file spsnode.\-cpp.


\begin{DoxyCode}
    {
        /* the sumproducts can be thought of as an nxn matrix,
        which is implemented here as a nxn element vector of
        dotprecision variables, using row-major order.
        Ie the m-th element (m = 0, . . . nxn-1) is in row floor(m/n)
        and column m-rowxn in the matrix configuration.
        Or, the sumproduct of elements i and j in an rvector,
        i,j = 0,...,n-1, is element m=(ixn+j) of the sumproducts
        vector. */

        if (dpSumProducts.empty()) {    //nothing there yet
            // reserve space for all elements
            dpSums.reserve(dimension*dimension);

            // for each dimnsn^2 of data, initialise element
            for (size_t i = 0; i< (dimension*dimension); i++) {
                dotprecision dp;
                dp = 0.0;
                dpSumProducts.push_back(dp);
            }
        }

        // make a dot precision variable out of the ith element
        // and jth element of the of the rvector of new data and
        // store in dpSumProducts.
        for (size_t i = 1; i < dimension + 1; i++) {
            // only need to do columns 1 to i because of symmetry
            for (size_t j = 1; j< i + 1; j++) {

                size_t index = (i-1)*dimension + (j-1);
                // rvectors indexed 1 to n
                accumulate(dpSumProducts[index],
                        newdata[i], newdata[j]);

                //if not on the diagonal of the matrix,
                // we can also fill in the symmetric element
                if (i!=j) {
                    size_t sym_index = (j-1)*dimension
                        + (i-1);
                    dpSumProducts[sym_index] =
                        dpSumProducts[index];
                } // end if
            }// end j-loop
        }// end i-loop

        // sumproducts has been updated for new datapoint
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_aa70c978a273b7266c75e7d617ae4d100}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!recalculate\-Sums@{recalculate\-Sums}}
\index{recalculate\-Sums@{recalculate\-Sums}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{recalculate\-Sums}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::recalculate\-Sums} (
\begin{DoxyParamCaption}
\item[{rvector \&}]{newdata}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_aa70c978a273b7266c75e7d617ae4d100}


\-Recalculate summary statistics associated with node. 

\-Recalculates sums (used for mean). 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a7590c8e3a8502b3b8a15bc2c4c494904}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 89 of file spsnode.\-cpp.


\begin{DoxyCode}
    {
        if (dpSums.empty()) {   //nothing in the sums yet
            // reserve space in dpSums for all elements of the mean
            dpSums.reserve(dimension);

            // for each dimnsn of data, initialise element
            for (size_t i = 0; i< dimension; i++) {
                dotprecision dp;
                dp = 0.0;
                dpSums.push_back(dp);
            }
        }

        // make a dot precision variable out of the ith element
        // of the rvector of new data and store in dpSums
        for (size_t i = 1; i< dimension + 1; i++) {
            // rvectors indexed 1 to n, vectors indexed 0 to n-1
            accumulate(dpSums[i-1], newdata[i], 1.0);
        }

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ad128b1715d294a65c905579ab43890d2}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!reshape\-To\-Union@{reshape\-To\-Union}}
\index{reshape\-To\-Union@{reshape\-To\-Union}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{reshape\-To\-Union}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::reshape\-To\-Union} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-Pnode} \&}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}virtual\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ad128b1715d294a65c905579ab43890d2}


\-Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of another tree. 

\-Throws a \hyperlink{classsubpavings_1_1NoBox__Error}{\-No\-Box\-\_\-\-Error} if this has no box or if {\itshape other\/} has no box.

\-Throws an \hyperlink{classsubpavings_1_1IncompatibleDimensions__Error}{\-Incompatible\-Dimensions\-\_\-\-Error} if boxes of this and {\itshape other\/} are not the same.

\-Throws an std\-::runtime\-\_\-error if {\itshape other\/} has an illegal state (see \hyperlink{classsubpavings_1_1SPSnode_a7cf5893a0c2bcfe03caf2865203e6678}{check\-Tree\-State\-Legal()}).


\begin{DoxyParams}{\-Parameters}
{\em other} & is the tree to make the union against. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-This has a box and that box is identical to the box of {\itshape other\/}. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
the tree rooted at this has shape that is the union of the shape of this before the operation and the shape of {\itshape other\/}. {\itshape other\/} is unchanged. 
\end{DoxyPostcond}


\-Reimplemented from \hyperlink{classsubpavings_1_1SPnode_a1113235b4bedd4a2849cc8e6dae719dc}{subpavings\-::\-S\-Pnode}.



\-Definition at line 2366 of file spsnode.\-cpp.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::reshape\-To\-Union().


\begin{DoxyCode}
{
  SPnode::reshapeToUnion(other);
  
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_afe32d323547d5169b03ed9058922ac9d}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!reshape\-To\-Union@{reshape\-To\-Union}}
\index{reshape\-To\-Union@{reshape\-To\-Union}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{reshape\-To\-Union}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::reshape\-To\-Union} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-Pnode} \&}]{other, }
\item[{size\-\_\-t}]{min\-Child\-Points}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_afe32d323547d5169b03ed9058922ac9d}


\-Reshape so that the tree rooted at this has shape that is as close as possible to the union of this shape and the shape of another tree. 

\-If {\itshape other\/} is more split than this, this will not exactly follow the shape of {\itshape other\/} if the resulting nodes would not splittable according to is\-Splittable\-Node(size\-\_\-t min\-Child\-Points). \-If any node cannot be split to follow the shape of {\itshape other\/} due to {\itshape min\-Child\-Points\/}, a message will be printed to std\-::cerr.

\-Throws a \hyperlink{classsubpavings_1_1NoBox__Error}{\-No\-Box\-\_\-\-Error} if this has no box or if {\itshape other\/} has no box.

\-Throws an \hyperlink{classsubpavings_1_1IncompatibleDimensions__Error}{\-Incompatible\-Dimensions\-\_\-\-Error} if boxes of this and {\itshape other\/} are not the same.

\-Throws an std\-::runtime\-\_\-error if {\itshape other\/} has an illegal state (see \hyperlink{classsubpavings_1_1SPSnode_a7cf5893a0c2bcfe03caf2865203e6678}{check\-Tree\-State\-Legal()}).


\begin{DoxyParams}{\-Parameters}
{\em other} & is the tree to make the union against. \\
\hline
{\em min\-Child\-Points} & is the minumum child points to use to check if this can be split in order to follow {\itshape other\/}. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-This has a box and that box is identical to the box of {\itshape other\/}. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
the tree rooted at this has shape that is the union of the shape of this before the operation and the shape of {\itshape other\/}. {\itshape other\/} is unchanged. 
\end{DoxyPostcond}


\-Definition at line 2372 of file spsnode.\-cpp.



\-References \-\_\-reshape\-To\-Union(), subpavings\-::\-S\-Pnode\-::check\-Tree\-State\-Legal(), subpavings\-::\-S\-Pnode\-::get\-Box(), subpavings\-::get\-Unique\-Filename(), and subpavings\-::\-S\-Pnode\-::is\-Empty().


\begin{DoxyCode}
{
  if (isEmpty() || other.isEmpty()) {
    throw NoBox_Error(
    "SPnode::reshapeToUnion(const SPnode&, size_t)");
  }
  if ( getBox() != other.getBox() )  {
    throw IncompatibleDimensions_Error(
    "SPnode::reshapeToUnion(const SPnode&, size_t)");
  }
  if ( !other.checkTreeStateLegal() )
    throw runtime_error(
    "SPnode::reshapeToUnion(const SPnode&, size_t) : other has illegal tree
       state");
  
  std::string baseErrorFilename("ReshapeErrors");
  std::string errorFilename = getUniqueFilename(baseErrorFilename);
  
  bool success = this->_reshapeToUnion(
          &other, minChildPoints, errorFilename);
  
  // if we returned success there should be no file with that name
  if(!success) {
    std::cerr << "\nCould not exactly reshape this to the union:"
      << " check " << errorFilename << " for errors\n" << endl;
  }
  
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a785e03fc466a6a1ea851f08338f8103d}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!set\-Splits@{set\-Splits}}
\index{set\-Splits@{set\-Splits}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{set\-Splits}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::set\-Splits} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a785e03fc466a6a1ea851f08338f8103d}


\-Set the split\-Dimension and \-Split\-Value when children grafted. 

\-Sets the split\-Dimension and \-Split\-Value for this node when children are grafted on. \-Called by node\-Adopt\-Left or node\-Adopt\-Right.

\begin{DoxyPostcond}{\-Postcondition}
this has split\-Dimension and \-Split\-Value corresponding to children. 
\end{DoxyPostcond}


\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a5d6459ebf84a81b4759a3dd6524df4cf}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 507 of file spsnode.\-cpp.



\-References taylor\-::\-Lb(), and taylor\-::\-Ub().



\-Referenced by node\-Adopt\-Left(), and node\-Adopt\-Right().


\begin{DoxyCode}
    {
        // set the split dimension and split value for this box
        // based on the children which have been added
        ivector childBox;
        bool alreadyDone = false;

        if (hasRCwithBox()) {
            childBox = getRightChild()->getBox();
        }
        else if (hasLCwithBox()) {
            childBox = getLeftChild()->getBox();
        }
        int pLb = Lb(*theBox); // parent box lower bound
        int dim = Ub(*theBox) - Lb(*theBox) + 1;
        int cLb = Lb(childBox); // child box lower bound (should be = pLb)

        if ( splitDim != -1 &&
            (splitValue == Inf(childBox[splitDim - pLb + cLb])
            || splitValue == Sup(childBox[splitDim - pLb + cLb])))
                alreadyDone = true;

        if (!alreadyDone) {
            int d = 1;
            splitDim = -1;
            while ((d <= dim) && (splitDim == -1)) {
                if (diam(childBox[d + cLb - 1]) < diam((*theBox)[d])) {
                    splitDim = d + pLb - 1; // the split dimension
                }
                d++;
            }
            // split value is bottom of right child box on dth dim
            if (hasRCwithBox()) {
                splitValue = Inf(childBox[splitDim - pLb + cLb]);
            }
            // else split value is top of left child box on dth dim
            else if (hasLCwithBox()) {
                splitValue = Sup(childBox[splitDim - pLb + cLb]);
            }
        }
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_adf3d76ca267b87c46d1fcb1ca3cecd84}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!split\-Data@{split\-Data}}
\index{split\-Data@{split\-Data}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{split\-Data}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::split\-Data} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_adf3d76ca267b87c46d1fcb1ca3cecd84}


\-Send the data associated with this down to children. 

\-Children may then be resplit using bool\-Test. 

\-Definition at line 223 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-O\-N\-\_\-\-L\-E\-F\-T, and subpavings\-::\-O\-N\-\_\-\-R\-I\-G\-H\-T.



\-Referenced by node\-Expand().


\begin{DoxyCode}
    {

        // check that both children exist
        if (!hasLCwithBox() || !hasRCwithBox()) {
            string msg = "Cannot split data when there are not two ";
            msg += " children";
            throw SPnodeException(msg);
        }

        NodeDataItr dataItr; // iterator

        //divvie the data up amongst the children
        for (dataItr = dataItrs.begin();
            dataItr!= dataItrs.end(); dataItr++) {
            BigDataItr newItr = *dataItr;

            //calls insertOneFind on the children of this node
            // so stats are not recalculated for this node itself
            SPSnode* reinsertedInto = NULL;

            if(rightChild!=NULL && !rightChild->isEmpty()) {

                reinsertedInto =
                    (getRightChild())->insertOneFind(
                    newItr, ON_RIGHT, boolTest);
            }

            // only try the left if it's not on the right
            if(reinsertedInto==NULL && leftChild!=NULL
            && !leftChild->isEmpty()) {

                reinsertedInto =
                    (getLeftChild())->insertOneFind(
                    newItr, ON_LEFT, boolTest);
            }

        }

        clearData();         //clear the data in this node
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a1ac36ca4768f69aab39ae45aaace5988}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!sps\-Contains@{sps\-Contains}}
\index{sps\-Contains@{sps\-Contains}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{sps\-Contains}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf \-S\-P\-Snode\-::sps\-Contains} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{z, }
\item[{int}]{count\-Box, }
\item[{int}]{count\-In\-Box}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1SPSnode_a1ac36ca4768f69aab39ae45aaace5988}


\-Get the number of points in any box. 


\begin{DoxyParams}{\-Parameters}
{\em z} & query box \\
\hline
{\em count\-Box} & \\
\hline
{\em count\-In\-Box} & \\
\hline
\end{DoxyParams}
\-Later. 

\-Definition at line 2613 of file spsnode.\-cpp.



\-References subpavings\-::\-B\-I\-\_\-\-F\-A\-L\-S\-E, subpavings\-::\-B\-I\-\_\-\-I\-N\-D\-E\-T, subpavings\-::\-B\-I\-\_\-\-T\-R\-U\-E, subpavings\-::\-S\-Pnode\-::get\-Box(), get\-Counter(), get\-Data(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-L\-Cwith\-Box(), subpavings\-::\-S\-Pnode\-::has\-R\-Cwith\-Box(), \-Intersection(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), node\-Contains(), subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, and sps\-Contains().



\-Referenced by main(), and sps\-Contains().


\begin{DoxyCode}
   {
      // Query box is z and box to be compared is theBox accessed by getBox()
      // z is assumed not to be empty
      // nb Intersection() gives error if unequal index sets passed
         
      BOOL_INTERVAL retValue = BI_FALSE; // for the return value
        
      // case of no intersection, i.e. the intersection of theBox and z is
      // empty 
        ivector r; // temporary ivector
         if (Intersection(r, z, getBox())==0){
            retValue = BI_FALSE;
            return countBox; 
         }        
  
         // case of isEmpty() being true
         if (isEmpty()){
         BOOL_INTERVAL retValue = BI_FALSE; // for the return value
         }
 
         // case of a non-empty leaf
         if (!isEmpty() && isLeaf()) {           
            ivector r; // temporary, to be passed to Intersection              
         
            if (z<getBox()) {
            // z is contained inside theBox but borders are not included
             
               // make z a SPSnode
               SPSnode queryNode(z, 1);
  
               // access data in theBox
               NodeData boxData = getData();
               NodeDataItr boxDataItr;
                 
               // check if queryNode contains data from theBox
               for(boxDataItr = boxData.begin(); boxDataItr != boxData.end(); 
      boxDataItr++){
                  BigDataItr bigIt = *boxDataItr; 
                  rvector theData = *bigIt;  // convert NodeData to rvector
                    
                  // if nodeContains is true, increment countInBox
                  if(queryNode.nodeContains(theData, ON_PARENT)){
                     countInBox += 1;
                  }
               }                             
                 
                // final count;
                countBox = countInBox;
                retValue = BI_TRUE;
            } 
          
            else if (z==getBox()) {
            // z fully covers theBox, including the borders
               countBox += getCounter();
               retValue = BI_TRUE;
            }
       
            else if (Intersection(r, z, getBox())) {
            // result is indeterminate if there is an intersection but z is not
                   
        // wholly in theBox"
                
               if (Inf(r) == Sup(r)){
                  retValue = BI_INDET;
               }
 
               else{
            // make z a SPSnode
            SPSnode queryNode(z, 1);
  
            // access data in theBox
            NodeData boxData = getData();
            NodeDataItr boxDataItr;
                 
            // check if queryNode contains data from theBox
            for(boxDataItr = boxData.begin(); boxDataItr != boxData.end(); 
      boxDataItr++){
              BigDataItr bigIt = *boxDataItr; 
              rvector theData = *bigIt;  // convert NodeData to rvector
                     
              // if nodeContains is true, increment countInBox
              if(queryNode.nodeContains(theData, ON_PARENT)){
                countInBox += 1;
              }
            }                             
                
            // final count;
            countBox += countInBox;
            retValue = BI_INDET;
               }
            }
 
            else {
          // Case that there is no intersection
          retValue = BI_FALSE;
            }
            
           return countBox;
         } // end (!isEmpty() && isLeaf())
          
         //case of an non-empty non-leaf
         if (!isEmpty() && !isLeaf()) {
            ivector Lz, Rz; // ivectors passed to Intersection()
            // will contain intersection after Intersection() call
 
            // to hold results of tests on left and right children
            BOOL_INTERVAL Ltest = BI_FALSE;
            BOOL_INTERVAL Rtest = BI_FALSE;
 
            // indicators for tested left and right sides
            bool LtestSuccess = false;
            bool RtestSuccess = false;

 //        cout << "    // Find if there is a leftChild with a box" << endl;
           if (hasLCwithBox() &&
               Intersection(Lz, z, getLeftChild()->getBox())) {
               // Lz contains intersctn of z & leftChild box
               // test Lz and left child node
               //Ltest = 
               countBox =  (getLeftChild()->spsContains(Lz, countBox, 
      countInBox));
               LtestSuccess = true;
            }
                  
   //    cout << "   // Find if there is a rightChild with a box" << endl;
           if (hasRCwithBox() &&
               Intersection(Rz, z, getRightChild()->getBox())) {
               // Rz contains intersctn of z & rightChild box 
               // test Rz and right child node
               //Rtest = 
               countBox =  getRightChild()->spsContains(Rz, countBox, 
      countInBox);
               RtestSuccess = true;
            }
        
 //          cout << "  // if both children tested " << endl;
           if (LtestSuccess && RtestSuccess) {
               //return value is the result of both tests
               // if the same or BI_INDET if diff
               Ltest==Rtest ?
               retValue = Ltest : retValue=BI_INDET;
            }
          
 //           cout << " // if has two children but neither was tested" << endl;
            // ie neither Intersection() returned true
            if (hasRCwithBox() && hasLCwithBox()
               && !LtestSuccess && !RtestSuccess) {
               retValue = BI_FALSE;
               // note that the AIA book has BI_TRUE here
               // but this can't be correct
            }
  
   //       cout << "  // if has two children but only right was tested" <<
       endl;
             // ie left Intersection() returned false
             if (hasRCwithBox() && hasLCwithBox()
                && !LtestSuccess && RtestSuccess) {
                retValue = Rtest;
                // return value result of test of right side
             }
            
     //   cout << "    // if has two children but only left was tested" <<
       endl;
             // ie right Intersection() returned false
             if (hasRCwithBox() && hasLCwithBox()
                 && LtestSuccess && !RtestSuccess) {
                 retValue = Ltest;
                 // return value result of test of left side
             }
           
 //    cout << "   // if has right child only and that child was tested" <<
       endl;
             // ie Intersection() returned true
             if (hasRCwithBox()
                 && !hasLCwithBox() && RtestSuccess) {
                 // if all of z contained in right child's box
                 if (Rz==z) {
                     retValue = Rtest;
                 }
                 // return false if Rtest false, else INDET
                 else {
                       Rtest==BI_FALSE ? retValue = BI_FALSE
                       : retValue = BI_INDET;
                 }
            }
            
 //    cout << "  // if has right child only and that child not tested" <<
       endl;
             // ie Intersection() returned false
             if (hasRCwithBox()
                 && !hasLCwithBox() && !RtestSuccess) {
                 retValue = BI_FALSE;
             }
             
 //    cout << "   // if has left child only and that child was tested" <<
       endl;
             // ie Intersection() returned true
             if (!hasRCwithBox() && hasLCwithBox()
                 && LtestSuccess) {
                 // if whole of z contained in left child's box
                 if (Lz==z) {
                     retValue = Ltest;
                 }
                 // return false if Ltest false, otherwise INDET
                 else {
                       Ltest==BI_FALSE ?
                       retValue = BI_FALSE :
                       retValue = BI_INDET;
                  }
             }
           
 //   cout << "   // if has left child only & that child was not tested" <<
       endl;
             // ie Intersection() returned false
             if (!hasRCwithBox() && hasLCwithBox()
                 && !LtestSuccess) {
                 retValue = BI_FALSE;
             }
 
           //  case no children covered by isLeaf() block above
         } // end of (!isEmpty() && !isLeaf())
 
     return countBox;
       
   } // end of spsContains for ivector
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_ac6259d2964d38acbb759c9f212853ef7}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!stripped\-Constructor@{stripped\-Constructor}}
\index{stripped\-Constructor@{stripped\-Constructor}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{stripped\-Constructor}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-S\-P\-Snode\-::stripped\-Constructor} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-P\-Snode} $\ast$const}]{other}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}\label{classsubpavings_1_1SPSnode_ac6259d2964d38acbb759c9f212853ef7}


\-Definition at line 960 of file spsnode.\-cpp.



\-References counts\-Only, subpavings\-::\-S\-Pnode\-::get\-Box(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::label, subpavings\-::\-S\-Pnode\-::node\-Add\-Left(), subpavings\-::\-S\-Pnode\-::node\-Add\-Right(), subpavings\-::\-S\-Pnode\-::node\-Name, split\-Dim, split\-Value, and \-S\-P\-Snode().



\-Referenced by union\-No\-Data().


\begin{DoxyCode}
    {
        SPSnode* newNode = NULL;
        try {
            if (other != NULL) {
                if (other->isEmpty())
                    newNode = new SPSnode;
                else {
                    ivector* newBox = new ivector(other->getBox());
                    newNode = new SPSnode(*newBox);
                    newNode->splitDim = other->splitDim;
                    newNode->splitValue = other->splitValue;
                }

                newNode->nodeName = other->nodeName;
                newNode->label = 0;
                newNode->countsOnly = true;

                if (other->getLeftChild() != NULL)
                    newNode->nodeAddLeft(strippedConstructor(other->getLeftChild
      ()));
                if (other->getRightChild() != NULL)
                    newNode->nodeAddRight(strippedConstructor(other->
      getRightChild()));
            }
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }

        return newNode;
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a8ce80cd650645f34e79fbc1d4beb2326}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!swap\-S\-P\-S@{swap\-S\-P\-S}}
\index{swap\-S\-P\-S@{swap\-S\-P\-S}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{swap\-S\-P\-S}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-S\-P\-Snode\-::swap\-S\-P\-S} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} \&}]{spn}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1SPSnode_a8ce80cd650645f34e79fbc1d4beb2326}


\-Swap this and another node. \-Swaps all the data members of this with the other node. 


\begin{DoxyParams}{\-Parameters}
{\em spn} & a reference to the node to swap with \\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{\-Postcondition}
this is identical,in terms of its data members, to spn before the swap, and spn is identical to this after the swap. 
\end{DoxyPostcond}


\-Definition at line 3191 of file spsnode.\-cpp.



\-References counter, counts\-Only, data\-Itrs, dp\-Sum\-Products, dp\-Sums, space\-Indication, split\-Dim, split\-Value, and subpavings\-::\-S\-Pnode\-::swap().


\begin{DoxyCode}
  { 
    /* theBox, parent, leftChild,
    rightChild and nodeName are inherited from base class */
    SPnode::swap(spn); // use the base version
    
    std::swap(spaceIndication, spn.spaceIndication);
    std::swap(counter, spn.counter);
    std::swap(dpSums, spn.dpSums);
    std::swap(dpSumProducts, spn.dpSumProducts);
    std::swap(dataItrs, spn.dataItrs);
    std::swap(splitDim, spn.splitDim);
    std::swap(splitValue, spn.splitValue);
    std::swap(countsOnly, spn.countsOnly);
    
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a6c28eccf9962c4b9010f2f04b0231d30}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!union\-No\-Data@{union\-No\-Data}}
\index{union\-No\-Data@{union\-No\-Data}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{union\-No\-Data}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-S\-P\-Snode\-::union\-No\-Data} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-P\-Snode} $\ast$const}]{lhs, }
\item[{const {\bf \-S\-P\-Snode} $\ast$const}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a6c28eccf9962c4b9010f2f04b0231d30}
\-Makes the non-\/minimal union of nodes with no data.

\-Calls itself recursively to adds two pavings together as the union of the two but discards the actual data.

\-Does not rename the nodes from root downwards.


\begin{DoxyParams}{\-Parameters}
{\em lhs} & pointer to root of first \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree operand. \\
\hline
{\em rhs} & pointer to root of second \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree operand. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
a pointer to root of a new \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree whose leaves are the union of the leaves of lhs, rhs and which has no data. 
\end{DoxyReturn}


\-Definition at line 554 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Box(), get\-Left\-Child(), get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::is\-Empty(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), and stripped\-Constructor().



\-Referenced by union\-Tree\-Structure().


\begin{DoxyCode}
    {
        SPSnode* newNode = NULL;

        bool done = false;  // indicator for done adding

        try {

            if (lhs == NULL && rhs == NULL) done = true; // we will return NULL

            // if the lhs is null or has no box, return a tree or node based on
       rhs
            if (!done && (lhs==NULL || ((lhs != NULL) && (lhs->isEmpty())))) {

                newNode = SPSnode::strippedConstructor(rhs);
                done = true;
            }

            // if the rhs is null or has no box, return a tree or node based on
       lhs
            if (!done && (rhs==NULL || ((rhs != NULL) && (rhs->isEmpty())))) {

                newNode = SPSnode::strippedConstructor(lhs);
                done = true;
            }

            // by now, if we are not done, both pavings are not null and both
       have boxes
            // we assume that the boxes are the same

            // we have to check who has children

            // if both are leaves we can just return a node based on say lhs
             // if only rhs is leaf, lhs is not a leaf, return a node based on
       lhs
            if (!done && rhs->isLeaf()) {
                newNode = SPSnode::strippedConstructor(lhs);
                done = true;
            }

            // if only lhs is leaf, rhs is not a leaf, return a node based on
       rhs
            if (!done && lhs->isLeaf() && !rhs->isLeaf()) {
                newNode = SPSnode::strippedConstructor(rhs);
                done = true;
            }

            // if neither are leaves
            if (!done && !lhs->isLeaf() && !rhs->isLeaf()) {
                // make a node based on one of them, and add on the results of
                // recursing on the children
                ivector* newPermBox = new ivector(lhs->getBox());
                newNode = new SPSnode(*newPermBox);
                newNode->nodeAdoptRight(unionNoData(lhs->getRightChild(),
                                                            rhs->getRightChild(
      )));
                newNode->nodeAdoptLeft(unionNoData(lhs->getLeftChild(),
                                                            rhs->getLeftChild()
      ));
            }
        }
        catch (bad_alloc& ba) {
            std::cerr << "Error allocating memory" << endl;
            const char* msg = ba.what();
            std::cerr << msg << std::endl;
            throw;
        }

        return newNode;

    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1SPSnode_a2dfb3087cff36fdf558bf75d5ee039c9}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!union\-Tree\-Structure@{union\-Tree\-Structure}}
\index{union\-Tree\-Structure@{union\-Tree\-Structure}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{union\-Tree\-Structure}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-S\-P\-Snode\-::union\-Tree\-Structure} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-P\-Snode} $\ast$const}]{lhs, }
\item[{const {\bf \-S\-P\-Snode} $\ast$const}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a2dfb3087cff36fdf558bf75d5ee039c9}
\-Makes the non-\/minimal union of two tree as a new tree with no data.

\-Adds two pavings together as the union of the two but discards the actual data. \-The tree manager should provide new data.

\-Renames nodes from new root downwards.


\begin{DoxyParams}{\-Parameters}
{\em lhs} & pointer to root of first \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree operand. \\
\hline
{\em rhs} & pointer to root of second \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree operand. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
a pointer to root of a new \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree whose leaves are the union of the leaves of lhs, rhs and which has no data. 
\end{DoxyReturn}


\-Definition at line 3160 of file spsnode.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Box(), subpavings\-::\-S\-Pnode\-::recursive\-Rename(), union\-No\-Data(), and subpavings\-::\-S\-Pnode\-Exception\-::what().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-::operator+().


\begin{DoxyCode}
    {
        SPSnode* newNode = NULL;

        if ((lhs != NULL) && (rhs != NULL) && (lhs->getBox() != rhs->getBox()))
        {
            throw SPnodeException("Union unequal subpavings");
        }
        else {
            try {

                newNode = unionNoData(lhs, rhs);
                newNode->recursiveRename();
            }
            catch (bad_alloc& a) {
                cerr << a.what() << endl;
                cerr << "Error allocating memory" << endl;
                throw;
            }
            catch (SPnodeException& e) {
                string msg(e.what());
                throw SPnodeException("Error in union: original error " + msg);
            }
        }

        return newNode;

    }
\end{DoxyCode}


\subsubsection{\-Member \-Data \-Documentation}
\hypertarget{classsubpavings_1_1SPSnode_a890b23bcab9091b420d88b99d16badc5}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!counter@{counter}}
\index{counter@{counter}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{counter}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf subpavings\-::\-S\-P\-Snode\-::counter}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a890b23bcab9091b420d88b99d16badc5}


\-A counter for how many data points are covered by the\-Box. 



\-Definition at line 316 of file spsnode.\-hpp.



\-Referenced by get\-Counter(), get\-E\-M\-P\-Contribution\-C\-O\-P\-E\-R\-R(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Largest\-Leaf\-Count(), get\-Largest\-Leaf\-Count(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaf\-Node\-Counts(), get\-Leaf\-Node\-Counts(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Left\-Count\-If\-Split(), get\-Log\-Lik(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Mean(), get\-Mean(), get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), get\-Merge\-Change\-Log\-Lik(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Min\-Child\-Count\-If\-Split(), get\-Min\-Child\-Count\-If\-Split(), get\-Min\-Child\-Count\-If\-Split\-N\-E\-W(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Root\-Counter(), get\-Root\-Counter(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Smallest\-Leaf\-Count(), get\-Smallest\-Leaf\-Count(), get\-Split\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), get\-Split\-Change\-Log\-Lik(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Sum\-Leaf\-Count\-Over\-Vol(), get\-Sum\-Leaf\-Count\-Over\-Vol(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Var\-Covar(), get\-Var\-Covar(), is\-Splittable\-Node(), subpavings\-::\-S\-P\-S\-Vnode\-::leaves\-Output\-Tabs\-With\-Hist\-Height(), leaves\-Output\-Tabs\-With\-Hist\-Height(), make\-Empty\-Node(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Print(), node\-Print(), subpavings\-::\-S\-P\-S\-Vnode\-::operator=(), operator=(), subpavings\-::\-S\-P\-S\-Vnode\-::\-S\-P\-S\-Vnode(), and swap\-S\-P\-S().

\hypertarget{classsubpavings_1_1SPSnode_a99af67614faaf93216ec0991e96ddb02}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!counts\-Only@{counts\-Only}}
\index{counts\-Only@{counts\-Only}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{counts\-Only}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-S\-P\-Snode\-::counts\-Only}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a99af67614faaf93216ec0991e96ddb02}


\-Determines the amount of statistical summary data in node. 

\-If true, only counts are maintained in the node. \-If false, counts and other statistics (sums, sumproducts) are also maintained.

\-Setting counts\-Only to false can help to conserve memory when means (from sums) and covariances (from sumproducts) will not be needed. 

\-Definition at line 418 of file spsnode.\-hpp.



\-Referenced by get\-Counts\-Only(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Mean(), get\-Mean(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Var\-Covar(), get\-Var\-Covar(), subpavings\-::\-S\-P\-S\-Vnode\-::operator=(), operator=(), subpavings\-::\-S\-P\-S\-Vnode\-::\-S\-P\-S\-Vnode(), subpavings\-::\-S\-P\-S\-Vnode\-::stripped\-Constructor(), stripped\-Constructor(), and swap\-S\-P\-S().

\hypertarget{classsubpavings_1_1SPSnode_a2d45b1e3b34a39d128143a0829f051f8}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!data\-Itrs@{data\-Itrs}}
\index{data\-Itrs@{data\-Itrs}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{data\-Itrs}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Node\-Data} {\bf subpavings\-::\-S\-P\-Snode\-::data\-Itrs}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a2d45b1e3b34a39d128143a0829f051f8}


\-A container for the association of data with a node. 

\-Data is associated with a node via this container of iterators. \-The iterators can, very loosely, in the sense in which they are used here, be thought of as pointers to a big data collection of all data points. \-Only leaf nodes can have anything in this container. \-However, not all leaf nodes will necessarily have something in this container\-: the container will be empty if no data points are covered by the box represented by a leaf node. 

\-Definition at line 393 of file spsnode.\-hpp.



\-Referenced by subpavings\-::\-S\-P\-S\-Vnode\-::clear\-Data(), clear\-Data(), subpavings\-::\-S\-P\-S\-Vnode\-::gather\-Data(), gather\-Data(), get\-Data(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Hellinger\-Dist(), get\-Hellinger\-Dist(), get\-Hellinger\-Dist1\-D(), get\-Left\-Count\-If\-Split(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Right\-Count\-If\-Split(), subpavings\-::\-S\-P\-S\-Vnode\-::insert\-One\-Find(), insert\-One\-Find(), make\-Empty\-Node(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Adopt\-Left(), node\-Adopt\-Left(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Adopt\-Right(), node\-Adopt\-Right(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Reabsorb\-Children(), node\-Reabsorb\-Children(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Reunite(), node\-Reunite(), subpavings\-::\-S\-P\-S\-Vnode\-::operator=(), operator=(), \-S\-P\-Snode(), subpavings\-::\-S\-P\-S\-Vnode\-::\-S\-P\-S\-Vnode(), and swap\-S\-P\-S().

\hypertarget{classsubpavings_1_1SPSnode_a7ff8f1c83a231af97c32808e0851dc78}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!dp\-Sum\-Products@{dp\-Sum\-Products}}
\index{dp\-Sum\-Products@{dp\-Sum\-Products}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{dp\-Sum\-Products}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Vec\-Dot\-Prec} {\bf subpavings\-::\-S\-P\-Snode\-::dp\-Sum\-Products}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a7ff8f1c83a231af97c32808e0851dc78}


\-A container representing the sumproduct matrix of the data points covered by the\-Box. 

\-The sumproducts matrix is used to obtain the sample variance-\/covariance matrix.

\-The for n-\/dimensional data the sample variance-\/covariance matrix is an nxn matrix where the element in row i, column j is the sample covariance between the ith-\/dimension and jth-\/dimension of the data, which is \mbox{[}sumproduct(i,j)-\/sum(i)sum(j)/counter\mbox{]}/(counter-\/1).

\-So by keeping the sum product and sums up to date, we can calculate a covariance on demand.

\-The sumproducts can be thought of as an nxn matrix where the element in row i, column j is the sum over all the datapoints associated with that box of the products of the ith element and jth element in the datapoints. ie for each datapoint, we take the product of the ith and jth elements and then sum the products over all the datapoints.

\-Data points are rvectors so each element is a real, and the the accumulation (sum) of products of reals is implemented here with a dotprecision accumulator.

\-The sumproduct matrix is stored here as a nxn element vector of dotprecision variables (where n is the dimensions of the rvectors or data points), using row-\/major order.

\-Ie the m-\/th element (m = 0, . . . nxn-\/1) is in row floor(m/n) and column m-\/rowxn in the matrix configuration.

\-Or, the sumproduct of elements i and j in an rvector, i,j = 0,...,n-\/1, is element m=(ixn+j) of the sumproducts vector. 

\-Definition at line 381 of file spsnode.\-hpp.



\-Referenced by subpavings\-::\-S\-P\-S\-Vnode\-::get\-Var\-Covar(), get\-Var\-Covar(), subpavings\-::\-S\-P\-S\-Vnode\-::operator=(), operator=(), subpavings\-::\-S\-P\-S\-Vnode\-::\-S\-P\-S\-Vnode(), and swap\-S\-P\-S().

\hypertarget{classsubpavings_1_1SPSnode_a1e5698e870376a507cd4a09bddc01643}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!dp\-Sums@{dp\-Sums}}
\index{dp\-Sums@{dp\-Sums}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{dp\-Sums}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Vec\-Dot\-Prec} {\bf subpavings\-::\-S\-P\-Snode\-::dp\-Sums}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a1e5698e870376a507cd4a09bddc01643}


\-A container representing the sum of the data points covered by the\-Box. 

\-The sums are used for calculating the mean and also the sample variance-\/covariance matrix for the data associated with a node.

cxsc\-::dotprecision accumulators are used to maintain the sum of the data in each dimension of the data because floating point arithmetic can result in inaccuracies during summation, especially in large boxes.

\-We could use \-Kahan summation instead with a lot more work. \-Kahan summation relies on adding a number of points in a sequence and recovering data lost in one summation during the next one. \-When we simply add two numbers, \-Kahan summation has no chance to recover the lost part. \-We would have to implement this by keeping the lost part, say having a vector of pairs, and trying to re-\/add the lost part each time. \-See \href{http://en.wikipedia.org/wiki/Kahan_summation_algorithm}{\tt http\-://en.\-wikipedia.\-org/wiki/\-Kahan\-\_\-summation\-\_\-algorithm} . \-The same may apply to arguments for using gsl\-\_\-mean using a simpler reccurence relation. \-Speed comparisons have not been performed on the three alternative possible implementations of the recursively computable sample sum or sample mean. \-However we get most relable and accurate sums using cxsc\-::dotprecision accumulators. 

\-Definition at line 344 of file spsnode.\-hpp.



\-Referenced by subpavings\-::\-S\-P\-S\-Vnode\-::get\-Mean(), get\-Mean(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Var\-Covar(), get\-Var\-Covar(), subpavings\-::\-S\-P\-S\-Vnode\-::operator=(), operator=(), subpavings\-::\-S\-P\-S\-Vnode\-::\-S\-P\-S\-Vnode(), and swap\-S\-P\-S().

\hypertarget{classsubpavings_1_1SPSnode_a4d836fd2b3cd074343475de6f9511c95}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!space\-Indication@{space\-Indication}}
\index{space\-Indication@{space\-Indication}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{space\-Indication}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf subpavings\-::\-S\-P\-Snode\-::space\-Indication}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a4d836fd2b3cd074343475de6f9511c95}


\-An indication of the maximum number of data points a node needs to carry. 

\-This is used for efficiency only to reserve vector space and a node can have more than this maximum number of data points associated with it. \-Defaults to default\-Max\-Pts. 

\-Reimplemented in \hyperlink{classsubpavings_1_1SPSVnode_a98a73d1c8dafe1d9248aeec76c8f74ef}{subpavings\-::\-S\-P\-S\-Vnode}.



\-Definition at line 297 of file spsnode.\-hpp.



\-Referenced by operator=(), \-S\-P\-Snode(), and swap\-S\-P\-S().

\hypertarget{classsubpavings_1_1SPSnode_afbda0af3b68cf12874faa64aa8a9b154}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!split\-Dim@{split\-Dim}}
\index{split\-Dim@{split\-Dim}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{split\-Dim}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf subpavings\-::\-S\-P\-Snode\-::split\-Dim}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_afbda0af3b68cf12874faa64aa8a9b154}


\-Dimension the node's box has been split along. 

\-This is needed to accurately divide data between a node's left and right children. \-Defaults to -\/1 if the node is a leaf. 

\-Definition at line 401 of file spsnode.\-hpp.



\-Referenced by get\-Split\-Dim(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Reabsorb\-Children(), node\-Reabsorb\-Children(), subpavings\-::\-S\-P\-S\-Vnode\-::operator=(), operator=(), subpavings\-::\-S\-P\-S\-Vnode\-::\-S\-P\-S\-Vnode(), subpavings\-::\-S\-P\-S\-Vnode\-::stripped\-Constructor(), stripped\-Constructor(), and swap\-S\-P\-S().

\hypertarget{classsubpavings_1_1SPSnode_a60ef987525bfd22dd0a5adadc141f0b6}{\index{subpavings\-::\-S\-P\-Snode@{subpavings\-::\-S\-P\-Snode}!split\-Value@{split\-Value}}
\index{split\-Value@{split\-Value}!subpavings::SPSnode@{subpavings\-::\-S\-P\-Snode}}
\paragraph[{split\-Value}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf subpavings\-::\-S\-P\-Snode\-::split\-Value}\hspace{0.3cm}{\ttfamily  \mbox{[}protected\mbox{]}}}}\label{classsubpavings_1_1SPSnode_a60ef987525bfd22dd0a5adadc141f0b6}


\-The value, on split dimension, where node's box was split. 

\-This is needed to accurately divide data between a node's left and right children. \-Defaults to 0.\-0 if the node is a leaf. 

\-Definition at line 408 of file spsnode.\-hpp.



\-Referenced by get\-Split\-Value(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Reabsorb\-Children(), node\-Reabsorb\-Children(), subpavings\-::\-S\-P\-S\-Vnode\-::operator=(), operator=(), subpavings\-::\-S\-P\-S\-Vnode\-::\-S\-P\-S\-Vnode(), subpavings\-::\-S\-P\-S\-Vnode\-::stripped\-Constructor(), stripped\-Constructor(), and swap\-S\-P\-S().



\-The documentation for this class was generated from the following files\-:\begin{DoxyCompactItemize}
\item 
\hyperlink{spsnode_8hpp}{spsnode.\-hpp}\item 
\hyperlink{spsnode_8cpp}{spsnode.\-cpp}\end{DoxyCompactItemize}
