\hypertarget{classsubpavings_1_1AdaptiveHistogram}{\subsection{subpavings\-:\-:\-Adaptive\-Histogram \-Class \-Reference}
\label{classsubpavings_1_1AdaptiveHistogram}\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}}
}


\-A wrapper or manager for an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} aka \-Stats\-Sub\-Paving in conjunction with massive amounts of sample data.  




{\ttfamily \#include $<$adaptivehistogram.\-hpp$>$}



\-Collaboration diagram for subpavings\-:\-:\-Adaptive\-Histogram\-:
\subsubsection*{\-Public \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram_aa863ff24ef4af6b084f515f702bbe09e}{\-Adaptive\-Histogram} ()
\begin{DoxyCompactList}\small\item\em \-Default constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram_a8155be0403adb23fe8c4232f95eb47f6}{\-Adaptive\-Histogram} (bool as)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram_a54d9dd37b5a2d71ee4e94f2154140b44}{\-Adaptive\-Histogram} (ivector \&v, bool as=false)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram_a512fa91574e1dbb992a6edcb77bf56c1}{\-Adaptive\-Histogram} (const \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&other)
\begin{DoxyCompactList}\small\item\em \-Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \& \hyperlink{classsubpavings_1_1AdaptiveHistogram_a3adb7a4fce51ec497ef30dea633249fd}{operator=} (const \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&rhs)
\begin{DoxyCompactList}\small\item\em \-Copy assignment operator. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \hyperlink{classsubpavings_1_1AdaptiveHistogram_a962f179df0a65d5f179930d00e65b70e}{operator+} (const \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&rhs)
\begin{DoxyCompactList}\small\item\em \-Overloaded addition operator. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram_aa11b3ed173c858fec6234c7e0b9d9829}{$\sim$\-Adaptive\-Histogram} ()
\begin{DoxyCompactList}\small\item\em \-Destructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1AdaptiveHistogram_aecbdfe366fa381c0b3f7a7b00447dedb}{get\-Sub\-Paving} () const 
\begin{DoxyCompactList}\small\item\em \-Return a pointer to the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} this manages. \end{DoxyCompactList}\item 
int \hyperlink{classsubpavings_1_1AdaptiveHistogram_adc2a97bb7f8fc3c543f90ba876515ca1}{get\-Label} () const 
\begin{DoxyCompactList}\small\item\em \-Return the label for this. \end{DoxyCompactList}\item 
rvector \hyperlink{classsubpavings_1_1AdaptiveHistogram_a95d9506c9ceea0359b99b0e36f1eff91}{get\-Root\-Paving\-Mean} () const 
\begin{DoxyCompactList}\small\item\em \-Gets the mean from the root box of the paving this manages. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_af2d57bb6e12f4a73169f2e496d6a641f}{\-Real\-Vec} \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2bbfcf884ee91c2457eb2e9d2b81e31f}{get\-Root\-Paving\-Var\-Covar} () const 
\begin{DoxyCompactList}\small\item\em \-Gets variance covariance vector from root box of rootpaving. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1AdaptiveHistogram_a7386f85d1182ae6e3f32766c4a208c11}{get\-Root\-Counter} () const 
\begin{DoxyCompactList}\small\item\em \-Gets count in the root paving. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1AdaptiveHistogram_ae4a71d928009eda0a6332f20fd951e35}{get\-Root\-Leaves} () const 
\begin{DoxyCompactList}\small\item\em \-Gets number of leaf nodes in the root paving. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_ac7f7cb4d5aea17c967afec84e1159f9b}{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol} () const 
\begin{DoxyCompactList}\small\item\em \-Gets the sum of leaf count over volume in root paving. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_afb0bda49b3a39ab8aa53737de810afec}{get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R} () const 
\begin{DoxyCompactList}\small\item\em get the \-E\-M\-P part of the \-C\-O\-P\-E\-R\-R score. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a71b9bb96936f8e5f6a298c6d1a382e0b}{get\-E\-M\-P\-Score\-A\-I\-C} () const 
\begin{DoxyCompactList}\small\item\em get the \-E\-M\-P part of the \-A\-I\-C score. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a94e90e67d767c5e0ad7b4378e0a72cad}{get\-Score\-C\-O\-P\-E\-R\-R} (const \hyperlink{classsubpavings_1_1PenObj}{\-Pen\-Obj} \&pen, bool verbose=false) const 
\begin{DoxyCompactList}\small\item\em get the \-C\-O\-P\-E\-R\-R score. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a8333360139bee06eb9c661b8a47cb4a3}{get\-Score\-A\-I\-C} (const \hyperlink{classsubpavings_1_1PenObj}{\-Pen\-Obj} \&pen, bool verbose=false) const 
\begin{DoxyCompactList}\small\item\em get \-A\-I\-C score. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_acb7aa3bb3a7b4d4691e9b5b9c9d4a765}{get\-P\-E\-N\-Value} (const \hyperlink{classsubpavings_1_1PenObj}{\-Pen\-Obj} \&pen, int delta\-Leaf=0) const 
\begin{DoxyCompactList}\small\item\em get the \-P\-E\-N value. \end{DoxyCompactList}\item 
double \hyperlink{classsubpavings_1_1AdaptiveHistogram_a0ef2d251d61753086a358bdd9bda057f}{get\-Min\-Vol} (double min\-Vol\-B) const 
\begin{DoxyCompactList}\small\item\em get the value of the minimum volume for a splittable node. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ae90ad88f52691280d18f4b6f2e3b7ad1}{get\-Hold\-All\-Stats} () const 
\begin{DoxyCompactList}\small\item\em get the value of hold\-All\-Stats field. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_aaf5eac63bd232e3e76f20a27587c8784}{has\-Sub\-Paving} () const 
\begin{DoxyCompactList}\small\item\em \-Get whether this has a subpaving to manage. \end{DoxyCompactList}\item 
cxsc\-::ivector \hyperlink{classsubpavings_1_1AdaptiveHistogram_a936a3426494278163afada104df26ecc}{get\-Root\-Box} () const 
\begin{DoxyCompactList}\small\item\em \-Get the box of the subpaving managed by this. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_aed8e75b2af342b9c1460431c223dca8e}{\-Int\-Vec} \hyperlink{classsubpavings_1_1AdaptiveHistogram_a70f9af80f0ee875d6dcbfd4cafb53813}{get\-Leaf\-Levels} () const 
\item 
std\-::string \hyperlink{classsubpavings_1_1AdaptiveHistogram_aca69edc461799f9d867d7eea6cb76f8e}{get\-Leaf\-Levels\-String} () const 
\item 
\hyperlink{namespacesubpavings_a612fc5639b45583b9fd33bd304354f81}{\-Size\-\_\-t\-Vec} \hyperlink{classsubpavings_1_1AdaptiveHistogram_aaffb116a24a6de03482a8bfd9625b07f}{get\-Leaf\-Counts} () const 
\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a8e1ee4de108b97c04c38ccb16c392e5f}{output\-Log} (const std\-::string \&s, const int i) const 
\begin{DoxyCompactList}\small\item\em \-Append current state of histogram to a txt log file. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_aafef86d6e4482aef11de75b83cfb4345}{insert\-One} (rvector newdata, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\begin{DoxyCompactList}\small\item\em \-Insert a single data point into \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a4c8d2603da121585e049548baca3c712}{priority\-Merge} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\begin{DoxyCompactList}\small\item\em \-Priority merge to reduce number of leaves in histogram. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a745b6edb93463e227edb9c9aa1dcb505}{merge\-Up} ()
\begin{DoxyCompactList}\small\item\em \-Merge a multileaf histogram up to just root box. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_afac8c0cb4ed44f27e7a3adf1855af676}{split\-To\-Shape} (std\-::string instruction)
\begin{DoxyCompactList}\small\item\em \-Split a histogram to a specified shape. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a733cc04938b2236087cbbe0384985c3d}{\-M\-C\-M\-C} (unsigned int loops, unsigned int burnin, unsigned int thinout, \hyperlink{classsubpavings_1_1MCMCProposal}{\-M\-C\-M\-C\-Proposal} \&proposal, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior, size\-\_\-t min\-Points=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\begin{DoxyCompactList}\small\item\em \-Outputting \-M\-C\-M\-C samples from histogram state space. \end{DoxyCompactList}\item 
std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \& \hyperlink{classsubpavings_1_1AdaptiveHistogram_aac9ce6681faa011b3c314ff400056dd9}{\-M\-C\-M\-Csamples} (std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&samples, unsigned int loops, unsigned int burnin, unsigned int thinout, \hyperlink{classsubpavings_1_1MCMCProposal}{\-M\-C\-M\-C\-Proposal} \&proposal, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior, size\-\_\-t min\-Points, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging)
\begin{DoxyCompactList}\small\item\em \-Generating \-M\-C\-M\-C samples from histogram state space. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a0163eb023d0db24e0d91864a38acd562}{public\-Output\-M\-C\-M\-C\-State\-Sample} (int ci, int i, bool confirm=false)
\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_af41faeb2742df1aaa5108f17dee54d71}{public\-Log\-M\-C\-M\-C\-Sample} (std\-::string s, int i)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2e95f7f1a9dab963a28a7d3a655e0e8f}{change\-M\-C\-M\-C\-State} (\hyperlink{namespacesubpavings_ae7645253328c3b5fc137829039d971e3}{\-S\-P\-Snode\-List} \&nodes, size\-\_\-t \&num\-Leaves, size\-\_\-t \&num\-Cherries, \hyperlink{classsubpavings_1_1MCMCProposal}{\-M\-C\-M\-C\-Proposal} \&proposal, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior, size\-\_\-t min\-Points, gsl\-\_\-rng $\ast$rgsl, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, std\-::string s, int i)
\begin{DoxyCompactList}\small\item\em \-Changes the state of this \-Adaptive \-Histogram using \-M\-C\-M\-C process. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a845c591145a1abc86d7d0e1d33c26e22}{output\-Graph\-Dot} () const 
\begin{DoxyCompactList}\small\item\em \-Make a .dot graph file from histogram structure. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a49a8ff01e1398420cd45642d5b1d3106}{output\-To\-Txt\-Tabs} (const std\-::string \&s, bool confirm=false) const 
\begin{DoxyCompactList}\small\item\em \-Output the subpaving managed by this to a txt file. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2fb89e060574b8c935191cd3afd91290}{output\-To\-Txt\-Tabs\-With\-E\-M\-Ps} (const std\-::string \&s, bool confirm=false) const 
\begin{DoxyCompactList}\small\item\em \-Output the subpaving managed by this to a txt file. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a35416eefb965755a846e1bb64c882439}{output\-Root\-To\-Txt} (const std\-::string \&s, bool confirm=false) const 
\begin{DoxyCompactList}\small\item\em \-Output details of full sample (from root) to txt tile. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a1cb13fa570de75efab3b9c4b862d200e}{reshape\-To\-Union} (const \hyperlink{classsubpavings_1_1PiecewiseConstantFunction}{\-Piecewise\-Constant\-Function} \&other)
\begin{DoxyCompactList}\small\item\em \-Change this so that the subpaving it manages is the union of this's subpaving and the subpaving of that of a \hyperlink{classsubpavings_1_1PiecewiseConstantFunction}{\-Piecewise\-Constant\-Function}. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a9e30e2969e3ad675b8659470200219d4}{reshape\-To\-Union} (const \hyperlink{classsubpavings_1_1PiecewiseConstantFunction}{\-Piecewise\-Constant\-Function} \&other, size\-\_\-t min\-Child\-Points)
\begin{DoxyCompactList}\small\item\em \-Change this so that the subpaving it manages is as close as possible to the union of this's subpaving and the subpaving of that of a \hyperlink{classsubpavings_1_1PiecewiseConstantFunction}{\-Piecewise\-Constant\-Function}. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a8f3844b0b56fb1aaa96c44558dd8e4a4}{make\-Empty} ()
\begin{DoxyCompactList}\small\item\em \-Clear the histogram's data and counters. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_aa0b81dd06668d2ce34e3fe983a2a2913}{find\-Density\-Region} (double cov, double weight\-P\-M, vector$<$ \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ $>$ \&cov\-Nodes, string cov\-File\-Name)
\begin{DoxyCompactList}\small\item\em \-Find the coverage of the boxes in an \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_aa73a46279c3f591d298a0180d99723a5}{output\-Log\-Plain} (const std\-::string \&s, const int i) const 
\begin{DoxyCompactList}\small\item\em \-Append current state of histogram to a txt log file. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a438e2252f954f0556fa2bd7c2e105dbe}{check\-Stop\-Crit} (double \-Stop\-Crit\-Current, double \-Stop\-Crit\-Previous, int \&\-Prev)
\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a809928eec642c22761a2f9b3b8061d47}{swap} (\hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&adh)
\begin{DoxyCompactList}\small\item\em \-Swap the contents of this and another histogram. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}{\bf \-Insert 1-\/d data from txt file into \-Adaptive\-Histogram object.}\par
{\em \-A group of overloaded versions of a functions which read in lines of data representing doubles or integers from a txt file.

\-Expects one integer or double per line. \-No input validation or checking. \-Rejects lines with input that cannot be converted to integer or double. \-Ignore any extra 'words' on the line (anything after first white space)

\-For example, a string \char`\"{}12.\-04 1.\-00005e-\/10 -\/30.\-0006\char`\"{} will be read as a 12.\-04. \-A string \char`\"{}30 abc 12.\-04.\-0006\char`\"{} will be read as 30, and a string \char`\"{}abc 30 12.\-04.\-0006\char`\"{} will be rejected.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to read data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A file with filename s in the same directory as \hyperlink{Exm__3__3_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main()} or with the filename incorporating directory location. 
\end{DoxyPrecond}

\begin{DoxyParams}{\-Parameters}
{\em headerlines} & is number of headerlines to skip before reading data. \-Defaults to 0. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false if txt file cannot be read, is empty, or if something failed in after data is read and when it is being inserted. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a11051ee818f2d6fb2631573e47ed73b8}{insert\-One\-Dim\-Data\-From\-Txt} (const std\-::string \&s, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_aef10187eeb8d449b8692c355960aefe0}{insert\-One\-Dim\-Data\-From\-Txt} (const std\-::string \&s, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Insert doubles in a txt file into \-Adaptive\-Histogram object.}\par
{\em \-A group of overloaded versions of a functions which read in lines of data representing doubles from a txt file.

\-Expects one integer or double per line. \-No input validation or checking. \-Can deal with doubles with no decimal point. \-Rejects lines with input that cannot be converted to double. \-Ignore any extra 'words' on the line (anything after first white space)

\-For example, a string \char`\"{}12.\-04 1.\-00005e-\/10 -\/30.\-0006\char`\"{} will be read as a 12.\-04. \-A string \char`\"{}30 abc 12.\-04.\-0006\char`\"{} will be read as 30, and a string \char`\"{}abc 30 12.\-04.\-0006\char`\"{} will be rejected.

\begin{DoxyRefDesc}{\-Deprecated}
\item[\hyperlink{deprecated__deprecated000001}{\-Deprecated}]\-Function kept for backwards compatibility, effectively replaced by insert\-One\-Dim\-Data\-From\-Txt.\end{DoxyRefDesc}



\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to read data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A file with filename s in the same directory as \hyperlink{Exm__3__3_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main()} or with the filename incorporating directory location. 
\end{DoxyPrecond}

\begin{DoxyParams}{\-Parameters}
{\em headerlines} & is number of headerlines to skip before reading data. \-Defaults to 0. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false if txt file cannot be read, is empty, or if something failed in after data is read and when it is being inserted. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a3705758c35dbfe8745a2e34c83b7f619}{insert\-Doubles\-From\-Txt} (const std\-::string \&s, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a3e03076ea91599538bcc69f47084f649}{insert\-Doubles\-From\-Txt} (const std\-::string \&s, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Insert rvectors in a txt file into \-Adaptive\-Histogram object.}\par
{\em \-A group of overloaded functions which read in lines of data representing rvectors from a txt file. \-The dimensions of the rvector are deduced from the input format and all the data then expected to have the same dimension. \-Any data not matching the expected dimensions, based on assessing the first valid line found, will be rejected. \-Expects one line per rvector with the elements separated by white space (space or tabs), with no non-\/numeric characters. \-Carries out some basic data checking through \hyperlink{namespacesubpavings_af62c725dd362922c15d45983e2d8f6cf}{check\-String()}. \-Input lines which do not pass are printed to standard output with an error message but the entire file will continue to be processed and valid lines converted to rvectors which are stored in the\-Data. \-Conversion to rvectors is via the cxsc\-::operator$<$$<$ which allows an rvector to be constructed from a stream.

\-Can read 1-\/d rvector data from doubles or floats but insists on a decimal point in each number (otherwise the number is rejected).

\-For example, a string \char`\"{}12.\-04 1.\-00005e-\/10 -\/30.\-0006\char`\"{} will be read as a 3-\/dimensional rvector, a string \char`\"{}-\/30.\-0006\char`\"{} will be read as a 1-\/dimensional rvector and a string \char`\"{}30\char`\"{} will be rejected.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to read data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em headerlines} & is number of headerlines to skip before reading data. \-Defaults to 0. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging) \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A file with filename s in the same directory as \hyperlink{Exm__3__3_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main()} or with the filename incorporating directory location. 
\end{DoxyPrecond}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false if txt file cannot be read, is empty, or contains no valid data, or if something failed after data is read and when it is being inserted. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_aff1b74eb52546adb9d7d64a84d739efe}{insert\-Rvectors\-From\-Txt} (const std\-::string \&s, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a5decf91161cbddd77c21e3b25dd12689}{insert\-Rvectors\-From\-Txt} (const std\-::string \&s, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Insert all rvectors from a container of rvectors.}\par
{\em 
\begin{DoxyParams}{\-Parameters}
{\em rvec} & is the container of rvectors to get data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false if there are no labeled points with the specified label in the \hyperlink{classRSSample}{\-R\-S\-Sample} object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ae19b382cf2c8f7f9b1d20883a7faf5c8}{insert\-From\-R\-Vec} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2b8604eb7b87dd03d09736a2f9e4b96a}{insert\-From\-R\-Vec} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Insert a set number of rvectors from a container.}\par
{\em \-The overloaded versions which take a random number generator as a parameter can be used to take successive samples from the same container. \-Otherwise the random number generator is created and destroyed during the scope of the function and repeating the identical function call will produce an identical sample from the container.


\begin{DoxyParams}{\-Parameters}
{\em samplesize} & the size of the sample to draw. \\
\hline
{\em gsl\-\_\-rng} & $\ast$ rgsl is a random number generator. \\
\hline
{\em seed} & is a seed for a random number generator. \\
\hline
{\em rvec} & the container to get data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false otherwise. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_adbfde654e0737aa2145d054a2c4a9a95}{insert\-Sample\-From\-R\-Vec} (size\-\_\-t samplesize, gsl\-\_\-rng $\ast$rgsl, const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a754142aca6681e39debd7167146a7e1c}{insert\-Sample\-From\-R\-Vec} (size\-\_\-t samplesize, int seed, const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_aeca515a5f969a1f368ba1fe0390aa047}{insert\-Sample\-From\-R\-Vec} (size\-\_\-t samplesize, const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2f6d7ee0d83ea148f57543f64905170d}{insert\-Sample\-From\-R\-Vec} (size\-\_\-t samplesize, gsl\-\_\-rng $\ast$rgsl, const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a8db299e8725f5170475a4c77524140dc}{insert\-Sample\-From\-R\-Vec} (size\-\_\-t samplesize, int seed, const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab889a33f8caa8fb44836f756c0be342d}{insert\-Sample\-From\-R\-Vec} (size\-\_\-t samplesize, const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Insert all rvectors from an \-R\-S\-Sample object.}\par
{\em \-Insert rvectors from the labeled point \-Samples of an \hyperlink{classRSSample}{\-R\-S\-Sample} object where the label for the point matches the label specified as a argument to the function.


\begin{DoxyParams}{\-Parameters}
{\em rss} & the \hyperlink{classRSSample}{\-R\-S\-Sample} object to get data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file. \\
\hline
{\em label} & the label for the labeled points in the rss.\-Samples that we want to use. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false if there are no labeled points with the specified label in the \hyperlink{classRSSample}{\-R\-S\-Sample} object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a6f049bec17097067ae9e2a7c9f42bd60}{insert\-From\-R\-S\-Sample} (const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a20ee07940112174415c391b4ed385ba1}{insert\-From\-R\-S\-Sample} (const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Insert a set number of rvectors from an \-R\-S\-Sample object.}\par
{\em \-Insert a set number of rvectors from the labeled point \-Samples of an \hyperlink{classRSSample}{\-R\-S\-Sample} object where the label for the point matches the label specified as a argument to the function. \-Sampling is random with replacement.

\-The overloaded versions which take a random number generator as a parameter can be used to take successive samples from the same \hyperlink{classRSSample}{\-R\-S\-Sample} object. \-Otherwise the random number generator is created and destroyed during the scope of the function and repeating the identical function call will produce an identical sample from the \hyperlink{classRSSample}{\-R\-S\-Sample} object.


\begin{DoxyParams}{\-Parameters}
{\em samplesize} & the size of the sample to draw. \\
\hline
{\em gsl\-\_\-rng} & $\ast$ rgsl is a random number generator. \\
\hline
{\em seed} & is a seed for a random number generator. \\
\hline
{\em rss} & the \hyperlink{classRSSample}{\-R\-S\-Sample} object to get data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em label} & is the label for the labeled points in the rss.\-Samples which we want to sample from. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false if there are no labeled points with the specified label in the \hyperlink{classRSSample}{\-R\-S\-Sample} object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2549a287bc001212ea1c6f7bbe42be62}{insert\-Sample\-From\-R\-S\-Sample} (size\-\_\-t samplesize, gsl\-\_\-rng $\ast$rgsl, const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab41e19cc570fa35d9c867413a7398edc}{insert\-Sample\-From\-R\-S\-Sample} (size\-\_\-t samplesize, int seed, const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a9468b46a614470017cc09cadd7699af8}{insert\-Sample\-From\-R\-S\-Sample} (size\-\_\-t samplesize, const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ad002844c2b0ef25eeb5fbc845fd8a000}{insert\-Sample\-From\-R\-S\-Sample} (size\-\_\-t samplesize, gsl\-\_\-rng $\ast$rgsl, const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a8437c7aa645e4edc21a5bc4ec02db5ef}{insert\-Sample\-From\-R\-S\-Sample} (size\-\_\-t samplesize, int seed, const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a78dd377090622826dd80734395fba635}{insert\-Sample\-From\-R\-S\-Sample} (size\-\_\-t samplesize, const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, int label=0)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf priority\-Split methods.}\par
{\em \-These methods takes a histogram and progressively split using a priority queue to determine which node to split first. \-Splitting continues until some criteria applying either to individual nodes or to the histogram as a whole is satisfied, or there are no more splittable nodes.

\-Nodes are not considered to be splittable if they satisfy two criteria\-: \-First, their volume is greater than the minimum volume specified for the histogram as a whole, min\-Vol\-B. \-Second if both prospective children would have at least the parameter min\-Child\-Points data points associated with them.

\-If more than one node is equally 'large', on the basis of the node comparison comp\-Test used, then a random choice is made between all equally large nodes to find the node which will be split.

\-The random number generator used for random selection between equally 'large' nodes uses a default seed to ensure that results can be replicated. \-If you are looking at distributions of results across mulitple histograms, supply the random number generator to the priority queue to ensure that each histogram will make different random choices.


\begin{DoxyParams}{\-Parameters}
{\em comp\-Test} & is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. \\
\hline
{\em he} & is an instance of a class which provides a function to determine when to stop splitting. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
{\em min\-Child\-Points} & is the minimum number of points any prospective child must have for a leaf node to be splittable. \\
\hline
{\em min\-Vol\-B} & is a multiplier applied to (log n)$^\wedge$2/n to give the the minimum volume for a splittable node. \-A node with volume $<$ min\-Vol\-B(log n)$^\wedge$2/n is not splittable. \-Important with \-A\-I\-C or \-C\-O\-P\-E\-R\-R. \\
\hline
{\em rgsl} & is a pointer to a gls random number generator. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if the priority split was successful, false otherwise. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2b60528af3d0f583b08284e11d4ff764}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, size\-\_\-t max\-Leaf\-Nodes)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a123e69c185cb450a05ecdc7101c71548}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a04219b243723859e2939216181cbaddc}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t max\-Leaf\-Nodes)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab28cddbe199adccec104b223f8848712}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_aea0d424449b7d93babef81d49bbbdb70}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ad6a946d5c729b0f49d78962680d5d659}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a630b400683794cd527173b18eb126f84}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2154185722cd1d4f61f65c7d84d77f2b}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Distribution-\/free \-Likelihood \-Estimation}\par
{\em 
\begin{DoxyParams}{\-Parameters}
{\em \-R\-Vec\-Data} & the observed data or \\
\hline
{\em \hyperlink{classRSSample}{\-R\-S\-Sample}} & the observed data \\
\hline
{\em dx} & is a user-\/defined dx -\/ see \-A\-H\-A\-B\-C meeting notes \\
\hline
{\em \-Weight\-Hist} & weight for the histogram in model 1 \\
\hline
{\em \-Weights\-P\-M} & weights for model 0 \\
\hline
{\em wt} & is the mass added to the histogram to ensure positive probability everywhere\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
(log)-\/likelihood estimate 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a513472c79b4a9337dcb5445be825a8f3}{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample} (\hyperlink{classRSSample}{\-R\-S\-Sample} \&lab\-Sampled\-Data, double dx, double wt)
\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogram_aca5143d5da261357d7f8d7eec45d1a5c}{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample} (\hyperlink{classRSSample}{\-R\-S\-Sample} \&lab\-Sampled\-Data, double dx, double wt, double \-Weight\-Hist, std\-::map$<$ rvector, double, std\-::less$<$ rvector $>$ $>$ \&\-Weights\-P\-M)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Get the \-I\-A\-E of a distribution}\par
{\em \-Get the integrated absolute error of the specified distribution. 
\begin{DoxyParams}{\-Parameters}
{\em distr} & is an integer that indicates which distribution is used. 1\-: bivariate gaussian distribution (not implemented yet) 2\-: \-Levy 2\-D distribution (not implemented yet) 3\-: \-Rosenbrock 2\-D distribution (not implemented yet) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
the integrated absolute error for this realization 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a28b0435b5ee65b27b2459d3dc3fc224d}{get\-I\-A\-E} (int distr)
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a368e5e9ed8cf0a3e82b30291c4a54d24}{get\-Fin\-Mix\-I\-A\-E} (\hyperlink{structFinMix}{\-Fin\-Mix} \&mixt)
\item 
cxsc\-::interval \hyperlink{classsubpavings_1_1AdaptiveHistogram_abf4e34e57ff3c76828457efaecbf4510}{get\-Fin\-Mix\-Interval\-I\-A\-E} (\hyperlink{structFinMix}{\-Fin\-Mix} \&mixt, double tol, int deg)
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2b0b0c19870f67a07704458237cf19d0}{get2\-D\-I\-A\-E} (\hyperlink{classtaylor_1_1dim2taylor}{taylor\-::dim2taylor}($\ast$testpnt)(\hyperlink{classtaylor_1_1dim2taylor__vector}{taylor\-::dim2taylor\-\_\-vector}, interval))
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogram_af7cf1131373c3e547a23d2db624ce8cf}{get\-Unif\-I\-A\-E} (\hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, double weight, std\-::vector$<$ int $>$ holes\-Loc)
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a3d403e99c1c471552303b2a7fd7e7d3e}{get\-Unif\-I\-A\-E} ()
\item 
cxsc\-::interval \hyperlink{classsubpavings_1_1AdaptiveHistogram_a2427c16c05dc17a5d7ecb1e58f0d35ca}{get\-Laplace\-Interval\-I\-A\-E} (double tol, int deg)
\item 
cxsc\-::interval \hyperlink{classsubpavings_1_1AdaptiveHistogram_aa595732ddb587933a166aee6cc0877f6}{get\-Lognormal\-Interval\-I\-A\-E} (double tol, int deg)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf priority\-Split and getting the states using index from a distr}\par
{\em \-Returns a \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode} from the \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object. }\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a1dffa971cfc56ec37449ce285a596365}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab3416e49bbb37e982e2e2f6a1ef13850}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a3eab9e09fee0aa81bd19bf170cf23aea}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_afee0931f38335b1d797680a0c9b6cfe5}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_af4e1c9c71ca8835f8ee3a78204f63d49}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a761f68d3b8f183d4fda926732fda70f9}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a8654a1a779b1c0e6d0dcec82f436efd6}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a36a5db0649767e9045cf985f52f985ca}{priority\-Split\-Get} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\hyperlink{CatalanCoeff_8hpp_ac525a0f6dc3802f95ee1ea51f9be6826}{\-States}, std\-::vector$<$ size\-\_\-t $>$ \&\-Sampled)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf priority\-Split and getting likelihood$\ast$prior (which is proportional}\par
{\em to posterior) }\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_afa5a767156398a6d29db12fcbf0a46c7}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a024499e93cb4ca592c78b860d09cef79}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a4c890ee5d86fc4cfd45c0ea2667b4a4f}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab4acf5596236ac6fa272cb3abe80bee8}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab38788117602e87f4e53a72b6c62747a}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab8e2052a043fc9969084719da4338678}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_af6cd725ab063a5c3af80d42315d99ddc}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a5e8e56baf547e75fe1701b455fa92efb}{priority\-Split\-M\-C\-M\-C} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, std\-::vector$<$ real $>$ \&\-Posterior, \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf priority\-Split\-With\-Total\-Var methods.}\par
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a6a4b39b06259e03b84b5131299334416}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a4c7ccb75b629b131c7a448579386c6a9}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a435e13db001d1b919489507b81cb49ad}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ae7e68baa3f16fafe3774df1f570aadcc}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\begin{DoxyCompactList}\small\item\em \-Returns the \-I\-A\-E between an \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object and a \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode}. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ae80f3d62957c9c70a2b7eed4b1e11810}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a508b13326647eaa46806ca7999d303f2}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a39888154b396a7eb5fd6be1ff200a414}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_acab027b9f4718b0ba077b142375a05cb}{priority\-Split\-With\-Total\-Var} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int \-Stop\-Val, std\-::vector$<$ \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} $>$ \&\-Hist\-At\-Valley, int sim\-Num)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf priority\-Split\-With\-Switches methods.}\par
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a75ca6c8d7a95525b76b098c8c6e20cf8}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a0cd2e3af29feaad65d4a0a36738dcc15}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a39ff221f6d3dad036ba6d4f5ec0ae819}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_aa1b1ab0c522e46bc4bd0ab45547dea6b}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a5299ade7c1d409621b2204a1986dabd8}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ad2ae1c64a519c1d5f32f81d39210b738}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_af9317b285f9a4f2753b1c9099347fe6f}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a6eb39e1e4524e415b8eff1ba4a4fc4b0}{priority\-Split\-With\-Switches} (const \hyperlink{classsubpavings_1_1NodeCompObj}{\-Node\-Comp\-Obj} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObj}{\-Hist\-Eval\-Obj} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t max\-Leaf\-Nodes, int remove\-Box)
\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{\-Private \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogram_a40e81bf270e245055b487e3f9fa28a7f}{\-Adaptive\-Histogram} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$spn, bool as)
\begin{DoxyCompactList}\small\item\em \-Private initialised constructor. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a929e006a5a2a0f40c68d77bc7dff70e7}{complete\-Data\-Insertion\-From\-Vec} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging)
\begin{DoxyCompactList}\small\item\em \-Complete insertion of data from a vector container. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab5d45e2f1966bd43a7bb8bf041ea29db}{have\-Made\-Paving} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const size\-\_\-t dim)
\begin{DoxyCompactList}\small\item\em \-Checks if we need to make root paving for the histogram object. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1AdaptiveHistogram_a0eaca3eebf10b3d251ed284f0317c593}{insert\-Data\-From\-Container} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging)
\begin{DoxyCompactList}\small\item\em \-Insert data from a container. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a6456652ee831cee0ec4184440cd84ec9}{recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R} () const 
\begin{DoxyCompactList}\small\item\em \-Recalculate the scaled \-E\-M\-P part of \-C\-O\-P\-E\-R\-R score. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_ab8a546d8d85be0ffac955f7886d5c7aa}{recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C} () const 
\begin{DoxyCompactList}\small\item\em \-Recalculate the unscaled \-E\-M\-P part of \-A\-I\-C score. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a71122bfe1d3dfad1f2b55585326334ac}{update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R} (dotprecision change) const 
\begin{DoxyCompactList}\small\item\em \-Update the scaled \-E\-M\-P part \-C\-O\-P\-E\-R\-R score given change. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a79fe01c35fba2bbdb1df5e8eb1d3a78b}{update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C} (dotprecision change) const 
\begin{DoxyCompactList}\small\item\em \-Update the the scaled \-E\-M\-P part \-A\-I\-C score given change. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_ad2360173a5963ecbca37e0a78ce98879}{output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R} (const std\-::string \&s) const 
\begin{DoxyCompactList}\small\item\em \-Add \-C\-O\-P\-E\-R\-R \-E\-M\-P score to log file. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a602b8b4081d3cae20308aa6644a83fa9}{output\-Log\-E\-M\-P\-A\-I\-C} (const std\-::string \&s) const 
\begin{DoxyCompactList}\small\item\em \-Add \-A\-I\-C \-E\-M\-P score to log file. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_ad847a4add7e72eac564daa44835dba5b}{output\-Log\-Start} (const std\-::string \&s) const 
\begin{DoxyCompactList}\small\item\em \-Opening line of a txt log file. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_adf589f52a0cd3e2371c288aa6bca7d37}{\-M\-C\-M\-C\-Start\-Log\-File} (std\-::string s, int i, const \hyperlink{classsubpavings_1_1MCMCProposal}{\-M\-C\-M\-C\-Proposal} \&proposal, const \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior)
\begin{DoxyCompactList}\small\item\em \-Put header in a log file for \-M\-C\-M\-C. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a4e7d34aea502906cb2230c0732d752b3}{output\-M\-C\-M\-C\-State\-Sample} (int i)
\begin{DoxyCompactList}\small\item\em \-Output the state of this histogram as an \-M\-C\-M\-C sample. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogram_a10fc830a1dd32fe83aa3846a6fb2af35}{\-M\-C\-M\-C\-Log\-Final\-State} (std\-::string s, int i)
\begin{DoxyCompactList}\small\item\em \-Capture the final state of this histogram after \-M\-C\-M\-C. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a89aa9c37916fcac47cf273f512bca019}{decision\-M\-C\-M\-C\-Split} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$target, const \hyperlink{classsubpavings_1_1MCMCProposal}{\-M\-C\-M\-C\-Proposal} \&proposal, const \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t num\-Leaves, size\-\_\-t num\-Cherries, size\-\_\-t min\-Points, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, const std\-::string \&s, int i) const 
\begin{DoxyCompactList}\small\item\em \-Determines whether to split a node to get a new \-M\-C\-M\-C state. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_ae2df56ec733843dffcc6af094637758d}{decision\-M\-C\-M\-C\-Merge} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$target, const \hyperlink{classsubpavings_1_1MCMCProposal}{\-M\-C\-M\-C\-Proposal} \&proposal, const \hyperlink{classsubpavings_1_1LogMCMCPrior}{\-Log\-M\-C\-M\-C\-Prior} \&log\-Prior, gsl\-\_\-rng $\ast$rgsl, size\-\_\-t num\-Leaves, size\-\_\-t num\-Cherries, size\-\_\-t min\-Points, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, const std\-::string \&s, int i) const 
\begin{DoxyCompactList}\small\item\em \-Determines whether to merge a node to get a new \-M\-C\-M\-C state. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a1544712de53718450f5f13fee5738a92}{change\-State\-For\-Split} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$target, \hyperlink{namespacesubpavings_ae7645253328c3b5fc137829039d971e3}{\-S\-P\-Snode\-List} \&nodes, size\-\_\-t \&num\-Leaves, size\-\_\-t \&num\-Cherries, size\-\_\-t min\-Points)
\begin{DoxyCompactList}\small\item\em \-Changes the state of this \-Adaptive \-Histogram by splitting a node. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a4ff31f6b6d944c0c1e71ae4e7586cc2a}{change\-State\-For\-Merge} (\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$target, \hyperlink{namespacesubpavings_ae7645253328c3b5fc137829039d971e3}{\-S\-P\-Snode\-List} \&nodes, size\-\_\-t \&num\-Leaves, size\-\_\-t \&num\-Cherries, size\-\_\-t min\-Points)
\begin{DoxyCompactList}\small\item\em \-Changes the state of this \-Adaptive \-Histogram by merging cherry. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Static \-Private \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
static ivector \hyperlink{classsubpavings_1_1AdaptiveHistogram_a4e40497a24ce0807235196e17ca21456}{make\-Box} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const size\-\_\-t dim)
\begin{DoxyCompactList}\small\item\em \-Make a box to contain all the data. \end{DoxyCompactList}\item 
static void \hyperlink{classsubpavings_1_1AdaptiveHistogram_aedb9ab3c2240403c63f2f5c1d0218350}{log\-M\-C\-M\-C\-Deltas} (std\-::string s, int i, real delta\-L, real delta\-P, real delta\-Q, real delta\-Pi, double rand\-Change)
\begin{DoxyCompactList}\small\item\em \-Send a collection of changes in \-M\-C\-M\-C probabilities to log file. \end{DoxyCompactList}\item 
static \hyperlink{namespacesubpavings_a984883a654b8d040041f722f8ead7dc2}{\-S\-P\-Snode\-List\-Itr} \hyperlink{classsubpavings_1_1AdaptiveHistogram_ae7f23176e9afea24c51c6a37cbcc4b0a}{propose\-Change\-M\-C\-M\-C\-State} (const \hyperlink{classsubpavings_1_1MCMCProposal}{\-M\-C\-M\-C\-Proposal} \&proposal, \hyperlink{namespacesubpavings_ae7645253328c3b5fc137829039d971e3}{\-S\-P\-Snode\-List} \&nodes, size\-\_\-t num\-Leaves, size\-\_\-t num\-Cherries, gsl\-\_\-rng $\ast$rgsl, bool \&have\-Node)
\begin{DoxyCompactList}\small\item\em \-Finds the node to target for change in \-M\-C\-M\-C on \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} trees. \end{DoxyCompactList}\item 
static bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a8a997f746bf62c847990542daf7c5a6a}{check\-Node\-Count\-For\-Split} (const \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$const spn, bool vol\-Checking, double min\-Vol, size\-\_\-t min\-Child\-Points)
\begin{DoxyCompactList}\small\item\em \-Method to do checking for whether a node is splittable. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Private \-Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} $\ast$ \hyperlink{classsubpavings_1_1AdaptiveHistogram_a88a104768020c02deb2a7df9e2b4cb3a}{root\-Paving}
\begin{DoxyCompactList}\small\item\em \-Pointer to the root node of the subpaving tree. \end{DoxyCompactList}\item 
ivector \hyperlink{classsubpavings_1_1AdaptiveHistogram_a5afac4246153fef0b383f6eb2e9d23a6}{root\-Box}
\begin{DoxyCompactList}\small\item\em \-The root box used to form the subpaving tree. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_aa79f33663da92502ce1a37f3fd1f3d85}{\-Big\-Data\-Collection} \hyperlink{classsubpavings_1_1AdaptiveHistogram_afb02d0a6fe2258620130b97b7901e214}{data\-Collection}
\begin{DoxyCompactList}\small\item\em \-A container for all sample data passed to this. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogram_a3f9319019a75ea477804d02762602d17}{hold\-All\-Stats}
\begin{DoxyCompactList}\small\item\em \-Controls whether all available statistics are maintained in the root\-Paving. \-If set to false (default) only counts are maintained. \end{DoxyCompactList}\item 
std\-::string \hyperlink{classsubpavings_1_1AdaptiveHistogram_a1211a42d1f428d73db9ba3c035239c59}{creation\-String}
\begin{DoxyCompactList}\small\item\em \-A string showing the order of creation of the root\-Paving. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1AdaptiveHistogram_acd3c0bacd5148b82188cc129b3a59e96}{scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}
\begin{DoxyCompactList}\small\item\em \-A value for the unscaled \-E\-M\-P part of \-C\-O\-P\-E\-R\-R score. \end{DoxyCompactList}\item 
dotprecision \hyperlink{classsubpavings_1_1AdaptiveHistogram_ad5748390a25f398475bb60575f0e9a89}{scaled\-E\-M\-P\-Sum\-A\-I\-C}
\begin{DoxyCompactList}\small\item\em \-A value for the unscaled \-E\-M\-P part of \-A\-I\-C score. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Static \-Private \-Attributes}
\begin{DoxyCompactItemize}
\item 
static const real \hyperlink{classsubpavings_1_1AdaptiveHistogram_a73e006381e43e152b7dbb63211a3ac09}{padding} = 0.\-000005
\begin{DoxyCompactList}\small\item\em a constant for padding a box if it is tailor-\/made for data. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{\-Detailed \-Description}
\-A wrapper or manager for an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} aka \-Stats\-Sub\-Paving in conjunction with massive amounts of sample data. 

\-Here sample data is multi-\/dimensional point-\/valued data in a cxsc\-::rvector container. \-The \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} class manages \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode } objects (\hyperlink{namespacesubpavings_ace6b16f0adf0db13eeb38e124d5328c6}{\-Stats\-Sub\-Pavings }) for the purpose of creating adaptive histograms from sample data and also manages the container for the sample data itself.

\-An \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} (a pointer to an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} is aliased as \-Stats\-Sub\-Paving) is a binary tree representation of a regular subpaving which can be used for processing statistical sample data. \-S\-P\-Snodes do not actually hold data, they only need to know where the data they are associated with is stored. \-The leaf nodes in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree controlled by an \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object have a vector of iterators into the \hyperlink{namespacesubpavings_aa79f33663da92502ce1a37f3fd1f3d85}{\-Big\-Data\-Collection}, a data\-Collection managed by that \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object.

\-The \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} class uses the \-C-\/\-X\-S\-C library class rvector for sample data points. rvectors can have 1 or many dimensions. 

\-Definition at line 76 of file adaptivehistogram.\-hpp.



\subsubsection{\-Constructor \& \-Destructor \-Documentation}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a40e81bf270e245055b487e3f9fa28a7f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-Adaptive\-Histogram@{\-Adaptive\-Histogram}}
\index{\-Adaptive\-Histogram@{\-Adaptive\-Histogram}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-Adaptive\-Histogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-::\-Adaptive\-Histogram} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{spn, }
\item[{bool}]{as}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a40e81bf270e245055b487e3f9fa28a7f}


\-Private initialised constructor. 

\-Initialised with pointer to subpaving and value for hold\-All\-Stats. 

\-Definition at line 100 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Box(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), root\-Box, and root\-Paving.


\begin{DoxyCode}
        : holdAllStats(as),
          scaledEMPSumCOPERR(0.0), scaledEMPSumAIC(0.0)
{
    if (NULL == spn) {
        throw HistException("Cannot use null SPSnode pointer in constructor");
    }
    rootPaving = spn;
    creationString = rootPaving->getNodeName();
    creationString += rootPaving->getChildNodeNames();

    rootBox = spn->getBox();

    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aa863ff24ef4af6b084f515f702bbe09e}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-Adaptive\-Histogram@{\-Adaptive\-Histogram}}
\index{\-Adaptive\-Histogram@{\-Adaptive\-Histogram}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-Adaptive\-Histogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-::\-Adaptive\-Histogram} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_aa863ff24ef4af6b084f515f702bbe09e}


\-Default constructor. 

\-By default, only counts are maintained in subpaving this manages, rather than all available stats. 

\-Definition at line 1019 of file adaptivehistogram.\-cpp.



\-References root\-Box, and root\-Paving.


\begin{DoxyCode}
        : holdAllStats(false), creationString(""),
          scaledEMPSumCOPERR(0.0), scaledEMPSumAIC(0.0)
{
    rootPaving = NULL;
    rootBox = ivector();    // ivector with length 1 and undefined elements


    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8155be0403adb23fe8c4232f95eb47f6}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-Adaptive\-Histogram@{\-Adaptive\-Histogram}}
\index{\-Adaptive\-Histogram@{\-Adaptive\-Histogram}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-Adaptive\-Histogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-::\-Adaptive\-Histogram} (
\begin{DoxyParamCaption}
\item[{bool}]{as}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a8155be0403adb23fe8c4232f95eb47f6}


\-Initialised constructor. 

\-Initialised with parameter controlling whether all available statistics be maintained in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} (true for all stats, false for counts only). 

\-Definition at line 1032 of file adaptivehistogram.\-cpp.



\-References root\-Box, and root\-Paving.


\begin{DoxyCode}
        : holdAllStats(as), creationString(""),
          scaledEMPSumCOPERR(0.0), scaledEMPSumAIC(0.0)
{
    rootPaving = NULL;
    rootBox = ivector();    // ivector with length 1 and undefined elements


    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a54d9dd37b5a2d71ee4e94f2154140b44}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-Adaptive\-Histogram@{\-Adaptive\-Histogram}}
\index{\-Adaptive\-Histogram@{\-Adaptive\-Histogram}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-Adaptive\-Histogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-::\-Adaptive\-Histogram} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{v, }
\item[{bool}]{as = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a54d9dd37b5a2d71ee4e94f2154140b44}


\-Initialised constructor. 

\-Initialised with domain box. \-By default, only counts are maintained as stats in the in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}.

\-Ideal constructor when the support domain of data is known a priori or has been transformed to a known domain but splitting criteria have not been determined a priori. 

\-Definition at line 1046 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), root\-Box, root\-Paving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
        : holdAllStats(as),
          scaledEMPSumCOPERR(0.0), scaledEMPSumAIC(0.0)
{
    try {
        rootPaving = new SPSnode(v, !as);
        creationString = rootPaving->getNodeName();

        rootBox = v;
    }
    catch (bad_alloc& ba) {
        string msg(ba.what());
        std::cerr << "Error allocating memory in constructor" << std::endl;
        throw HistException("Memory allocation error in constructor: " + msg);
    }
    catch (SPnodeException& spe) {
        string msg(spe.what());
        std:: cerr << "SPnodeExcepton in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Memory allocation error in constructor:" + msg);
    }
    catch (exception& e) {
        string msg(e.what());
        std:: cerr << "Error in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Memory allocation error in constructor:" + msg);
    }

    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a512fa91574e1dbb992a6edcb77bf56c1}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-Adaptive\-Histogram@{\-Adaptive\-Histogram}}
\index{\-Adaptive\-Histogram@{\-Adaptive\-Histogram}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-Adaptive\-Histogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-::\-Adaptive\-Histogram} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Adaptive\-Histogram} \&}]{other}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a512fa91574e1dbb992a6edcb77bf56c1}


\-Copy constructor. 



\-Definition at line 1079 of file adaptivehistogram.\-cpp.



\-References creation\-String, data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), root\-Paving, scaled\-E\-M\-P\-Sum\-A\-I\-C, scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
        : holdAllStats(other.holdAllStats), rootBox(other.rootBox)
{
    try {
        rootPaving = new SPSnode(*(other.rootPaving));
        creationString = rootPaving->getNodeName();
        creationString += rootPaving->getChildNodeNames();

        //copy dataCollection from other to this
        dataCollection = other.dataCollection;

        other.recalcScaledEMPSumAIC();
        other.recalcScaledEMPSumCOPERR();
        scaledEMPSumCOPERR = other.scaledEMPSumCOPERR;
        scaledEMPSumAIC = other.scaledEMPSumAIC;
    }
    catch (bad_alloc& ba) {
        string msg(ba.what());
        std::cerr << "Error allocating memory in constructor: original error "
                                            << msg << std:: endl;
        throw HistException("Memory allocation error in constructor: " + msg);
    }
    catch (SPnodeException& spe) {
        string msg(spe.what());
        std:: cerr << "SPnodeExcepton in constructor: original error "
                                            << msg << std::endl;
        throw HistException("SPnodeException in constructor: " + msg);
    }
    catch (exception& e) {
        string msg(e.what());
        std:: cerr << "Error in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Error in constructor: " + msg);
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aa11b3ed173c858fec6234c7e0b9d9829}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!$\sim$\-Adaptive\-Histogram@{$\sim$\-Adaptive\-Histogram}}
\index{$\sim$\-Adaptive\-Histogram@{$\sim$\-Adaptive\-Histogram}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{$\sim$\-Adaptive\-Histogram}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-::$\sim$\-Adaptive\-Histogram} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aa11b3ed173c858fec6234c7e0b9d9829}


\-Destructor. 



\-Definition at line 1209 of file adaptivehistogram.\-cpp.



\-References root\-Paving.


\begin{DoxyCode}
{
    delete rootPaving;
}
\end{DoxyCode}


\subsubsection{\-Member \-Function \-Documentation}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2e95f7f1a9dab963a28a7d3a655e0e8f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!change\-M\-C\-M\-C\-State@{change\-M\-C\-M\-C\-State}}
\index{change\-M\-C\-M\-C\-State@{change\-M\-C\-M\-C\-State}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{change\-M\-C\-M\-C\-State}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::change\-M\-C\-M\-C\-State} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode\-List} \&}]{nodes, }
\item[{size\-\_\-t \&}]{num\-Leaves, }
\item[{size\-\_\-t \&}]{num\-Cherries, }
\item[{{\bf \-M\-C\-M\-C\-Proposal} \&}]{proposal, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior, }
\item[{size\-\_\-t}]{min\-Points, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{std\-::string}]{s, }
\item[{int}]{i}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a2e95f7f1a9dab963a28a7d3a655e0e8f}


\-Changes the state of this \-Adaptive \-Histogram using \-M\-C\-M\-C process. 

\-This method proposes and probabilistically accepts a single-\/step change in the histogram state represented by this \-Adaptive \-Histogram, i.\-e a change in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by the histogram and representing the partion of the data space into histogram 'bins'. \-A single-\/step change in state is the change in state resulting from a single split of a leaf node or merge of a cherry node.

\-Proposals are made by selecting a leaf or cherry at random. \-If a cherry is chosen the proposed change in state is to merge the two leaf children of that cherry; if a leaf is chosen the proposal is to split (bisect) the leaf.

min\-Points $>$ 0 restricts the leaves which can be selected for change\-: if splitting a leaf would result in the children having less than min\-Points data points associated with them, the leaf cannot be selected for the proposed change unless that child leaf node has 0 points and its sibling has all the parent's points ($>$= min\-Points). \-The final condition allows a node to be split when all the data goes to just one child provided that the number of points in the node $>$= min\-Points so that the process can 'home in' on small peaks of data.. \-Note however that min\-Points has no effect on the cherries which can be proposed for merging. \-A leaf whose split would result in both children having at least min\-Points points in it, or where the split would give all the data to one child, is referred to as a 'splittable leaf'.

\-Thus the implementation of the \-M\-C\-M\-C algorithm for generating a new state in the chain needs to maintain separately the overall state of the tree and the set of {\bfseries splittable leaf nodes}.

\-The log-\/likelihood of a state given the data is given by sum over leaves of (counts in leaf x -\/ln(count in leaf / (n x vol of leaf))) where n is the total number of data points in the histogram.

\-The posterior distribution is proportional to the prior x likelihood.

\-The \-Metropolis-\/\-Hastings algorithm also requires a proposal density which depends on the current state m to generate a proposed state m'.

\-Q(m' $|$ m) is the transition probability from state m to state m'.

\-This proposal is accepted if u drawn from \-Uniform(0,1) is such that u $<$ (posterior probability of m' x \-Q(m $|$ m'))/(posterior probability of m x \-Q(m' $|$ m). \-In this implementation, natural logs are used to simplify calculation, ie a proposal is accepted if log(u) $<$ log \mbox{[}(posterior probability of m' x \-Q(m $|$ m'))/(posterior probability of m x \-Q(m' $|$ m)\mbox{]}.

\-If the proposal is accepted the state is changed to m', otherwise it stays at m.

\begin{DoxyPrecond}{\-Precondition}
an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree representing some histogram state, a container of pointers to the splittable leaf and cherry nodes of the tree in its current state, ordered with the leaves first followed by the cherries, the number of splittable leaf nodes and the number of cherry nodes. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree in some state which is either in the same state as the pre-\/state or in a new state reachable by a single-\/step change (i.\-e. through the split of one splittable leaf or the merge of one cherry of the pre-\/state), the container of splittable leaf and cherry nodes updated for any change in state, and the number of splittable leaves and cherries updated similarly.
\end{DoxyPostcond}
\begin{DoxyNote}{\-Note}
that the container of splittable leaf nodes and cherries is maintained separately from the overall state of the tree to save having to repeatedly assess whether a leaf can be split (given min\-Points). \-The number of splittable leaves and cherries is maintained for convenience to avoid repeatedly counting nodes of different types in the container.
\end{DoxyNote}

\begin{DoxyParams}{\-Parameters}
{\em nodes} & is a reference to a container of pointers to the leaf and cherry nodes of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}, which will be updated if the method results in change in tree state. \\
\hline
{\em num\-Leaves} & is a reference to a variable storing the number of leaves in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree, which will be updated if the method results in change in tree state. \\
\hline
{\em num\-Cherries} & is a reference to a variable storing the number of cherries in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree, which will be updated if the method results in a change in tree state. \\
\hline
{\em proposal} & is a reference to a proposal distribution object. \\
\hline
{\em log\-Prior} & is a reference to a log prior object. \\
\hline
{\em min\-Points} & is the minimum number of points allowed in a box. \\
\hline
{\em rgsl} & is a pointer to a uniform random number generator. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to log files (defaults to no logging). \-T\-X\-T gives logging to a txt file, \-T\-X\-T\-A\-N\-D\-G\-R\-A\-P\-H gives txt file logging and graphs. \\
\hline
{\em s} & is the name of the filename to send logging output to. \\
\hline
{\em i} & is an integer for keeping track of the index for this link in a \-Markov \-Chain. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if there has been a successful proposal and successful probabilistic acceptance/rejection of the change in state, false otherwise. 
\end{DoxyReturn}


\-Definition at line 3368 of file adaptivehistogram.\-cpp.



\-References change\-State\-For\-Merge(), change\-State\-For\-Split(), decision\-M\-C\-M\-C\-Merge(), decision\-M\-C\-M\-C\-Split(), subpavings\-::output\-File(), propose\-Change\-M\-C\-M\-C\-State(), subpavings\-::\-T\-X\-T, subpavings\-::\-T\-X\-T\-A\-N\-D\-G\-R\-A\-P\-H, subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().



\-Referenced by \-M\-C\-M\-Csamples().


\begin{DoxyCode}
{
    bool success = true; // start by assuming that all will be well...
    //bool success = false;
  
  //cout << "change mcmc state called for " << endl;
  //cout << "node list size: " << nodes.size() << endl;
  //cout << "#leaves: " << numLeaves << "\t" << "#cherries: " << numCherries <<
       endl;

    try {

      double rand = gsl_rng_uniform(rgsl);
        
        bool haveNode = false;

        // use proposal to fill the proposal probabilities

        // this changes haveNode as well
        //cout << "proposing" << endl;
        SPSnodeListItr it = proposeChangeMCMCState (proposal, nodes,
                                numLeaves, numCherries,
                                rgsl, haveNode);
      
      /*if (haveNode) 
      { 
        cout << "a node is proposed"  << (*it)->getNodeName() << endl;
      }
      else {cout << "nothing proposed. stay." << endl;}
      */
      
        // only do more if haveNode is true, which means that it points to
       something
        if (haveNode && (*it)->isLeaf()) {

            //grab the leaf
            SPSnode* target = *it; // don't change where it points until erased


            // leaf so we are splitting
            bool willSplit = decisionMCMCSplit(target, proposal, logPrior, rgsl
      ,
                            numLeaves, numCherries, minPoints,
                            logging, s, i);            

            if (willSplit) {
                // take the target out of the list
          //cout << "split and remove from list " << (*it)->getNodeName() <<
       endl;
               nodes.erase(it);

                // try to change the state according to the proposed split
                // nodes, numLeaves and numCherries are passed by reference
                success = changeStateForSplit(target, nodes,
                            numLeaves, numCherries, minPoints);
            } // end of willSplit

        } // end of isLeaf

        else if (haveNode && (*it)->isSubLeaf()) {

            // grab the cherry
            SPSnode* target = *it; // don't change where it points until
       deleted

            bool willMerge = decisionMCMCMerge(target, proposal, logPrior, rgsl
      ,
                            numLeaves, numCherries, minPoints, logging, s, i);

            if (willMerge) {
                // take the target out of the list of cherries
          //cout << "merge and remove from list " << (*it)->getNodeName() <<
       endl;
               nodes.erase(it);

               success = changeStateForMerge(target,
                            nodes, numLeaves, numCherries, minPoints);

            } // end willMerge
        } // end if cherry


        if (((logging == TXT) || (logging == TXTANDGRAPH)) && !haveNode) {

            std::string line = "No node grabbed (possible if proposal has fixed
       ";
            line += "probability of split): state stays the same";

            outputFile(s, line, true); // append to log file
        }

        if (success) {
            // is it worth doing this?  on balance I think yes
            success = (nodes.size() == (numLeaves+numCherries));
            //cout << "successful state change/stay." << endl;
        //cout << "---------------------------------" << endl;
        }
        
        else {
            throw HistException("Nodes muddled in changeMCMCstate");

        }
    }
    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory in MCMC.  Orginal error: "
                                     + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error  in MCMC.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException  in MCMC.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error  in MCMC.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return success;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a4ff31f6b6d944c0c1e71ae4e7586cc2a}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!change\-State\-For\-Merge@{change\-State\-For\-Merge}}
\index{change\-State\-For\-Merge@{change\-State\-For\-Merge}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{change\-State\-For\-Merge}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::change\-State\-For\-Merge} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{target, }
\item[{{\bf \-S\-P\-Snode\-List} \&}]{nodes, }
\item[{size\-\_\-t \&}]{num\-Leaves, }
\item[{size\-\_\-t \&}]{num\-Cherries, }
\item[{size\-\_\-t}]{min\-Points}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a4ff31f6b6d944c0c1e71ae4e7586cc2a}


\-Changes the state of this \-Adaptive \-Histogram by merging cherry. 

\-This method carries out a move to a new state in the histogram \-M\-C\-M\-C state chain by merging the target cherry node.

\begin{DoxyPrecond}{\-Precondition}
an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree representing some histogram state, a container of pointers to the splittable leaf and cherry nodes of the tree in its current state, ordered with the leaves first followed by the cherries, the number of splittable leaf nodes and the number of cherry nodes. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree changed as a result of the merge, the container of splittable leaf and cherry nodes updated for any change in state, and the number of splittable leaves and cherries updated similarly.
\end{DoxyPostcond}

\begin{DoxyParams}{\-Parameters}
{\em target} & is a pointer to the target node proposed for merging. \\
\hline
{\em nodes} & is a reference to a container of pointers to the splittable leaf and cherry nodes of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}, which will be updated by the method. \\
\hline
{\em num\-Leaves} & is a reference to a variable storing the number of splittable leaf nodes in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree, which will be updated by the method. \\
\hline
{\em num\-Cherries} & is a reference to a variable storing the number of cherries in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree, which will be updated by the method. \\
\hline
{\em min\-Points} & is the minimum number of points allowed in a box, which is needed to be able to tell which, if any, of the merged nodes children need to be taken out of the nodes container on the merge. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if has been a successful change in state, false otherwise. 
\end{DoxyReturn}


\-Definition at line 881 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), subpavings\-::\-S\-P\-Snode\-::get\-Min\-Child\-Count\-If\-Split(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), subpavings\-::\-S\-P\-Snode\-::get\-Parent(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-Leaf\-Sibling(), subpavings\-::\-S\-P\-Snode\-::node\-Reabsorb\-Children(), and root\-Paving.



\-Referenced by change\-M\-C\-M\-C\-State().


\begin{DoxyCode}
{
    bool success = true;

    size_t points = rootPaving->getCounter(); // need to recalculate COPERR EMP

    // accumulate the changes in scaled EMP sums that will result
    // from this expansion
    //updateScaledEMPSumCOPERR(target->getMergeChangeEMPCOPERR(points));
    //updateScaledEMPSumAIC(target->getMergeChangeEMPAIC());

    // subtract the child names from the creation string
    creationString += (" -(" + target->getChildNodeNames() + ")");

    // take the children out of the list of leaves if they are there
    // each child will only be in the list of leaves if splitting that child
    // would give children with at least the minimum number of data points
    // associated with them, or if the child itself has enough points but
    // and splitting would give one child with 0 points were minPoints > 0
    std::string lcName = target->getLeftChild()->getNodeName();
    std::string rcName = target->getRightChild()->getNodeName();
    int lcPos = 0;
    bool foundLeft = false;
    bool foundRight = false;

    SPSnodeListItr it;

    if ((target->getLeftChild()->getMinChildCountIfSplit() >= minPoints)
        || (minPoints > 0 && target->getLeftChild()->getCounter() >= minPoints
            && target->getLeftChild()->getMinChildCountIfSplit() == 0)) {
        std::string lcName = target->getLeftChild()->getNodeName();
        SPSnodeListItr it;
        // break out of loop if we find left child or get to cherries
        for (it=nodes.begin() ; it != nodes.end(); it++ ) {

            if ((*it)->isSubLeaf()) break;
            if ((*it)->getNodeName() == lcName) {
                nodes.erase(it); // can't keep using iterator now
                numLeaves--;
                foundLeft = true;
                break;
            }
            lcPos++;  // gives position at which lc was found
        }
    }
    else foundLeft = true;

    // now try to find right child - could be immediately after left
    if ((target->getRightChild()->getMinChildCountIfSplit() >= minPoints)
        || (minPoints > 0 && target->getRightChild()->getCounter() >= minPoints
            && target->getRightChild()->getMinChildCountIfSplit() == 0)) {

        if (foundLeft) {
            SPSnodeListItr git = nodes.begin();
            advance(git, lcPos);
            // break out of loop if we find right child or get to cherries
            for (it=git ; it != nodes.end(); it++ ) {

                if ((*it)->isSubLeaf()) break;
                if ((*it)->getNodeName() == rcName) {
                    nodes.erase(it);
                    numLeaves--;
                    foundRight = true;
                    break;
                }
            } // just in case right child was before left
            if (!foundRight) {
                // break out of loop if we find right child
                // or get to cherries
                for (it=nodes.begin() ; it != nodes.end(); it++ ) {
                    if ((*it)->isSubLeaf()) break;
                    if ((*it)->getNodeName() == rcName) {
                        nodes.erase(it);
                        numLeaves--;
                        foundRight = true;
                        break;
                    }
                }
            }
        }
    }
    else foundRight = true;

    success = foundRight;

    // merge the target
    target->nodeReabsorbChildren();
    numCherries--;

    // insert the new leaf ptr into the list at the beginning
    nodes.push_front(target);
    numLeaves++;

    // if sibling was a leaf, add parent to cherries, at end
    if(target->hasLeafSibling()) { // returns false if no parent
     
        nodes.push_back(target->getParent());
        numCherries++;
    }

    return success;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a1544712de53718450f5f13fee5738a92}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!change\-State\-For\-Split@{change\-State\-For\-Split}}
\index{change\-State\-For\-Split@{change\-State\-For\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{change\-State\-For\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::change\-State\-For\-Split} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{target, }
\item[{{\bf \-S\-P\-Snode\-List} \&}]{nodes, }
\item[{size\-\_\-t \&}]{num\-Leaves, }
\item[{size\-\_\-t \&}]{num\-Cherries, }
\item[{size\-\_\-t}]{min\-Points}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a1544712de53718450f5f13fee5738a92}


\-Changes the state of this \-Adaptive \-Histogram by splitting a node. 

\-This method carries out a move to a new state in the histogram \-M\-C\-M\-C state chain by splitting the target splittable leaf node.

min\-Points restricts the pointers to new leaves resulting from the split which can be put into the container of pointers to splittable leaves and cherry nodes. \-A pointer to a new leaf can only be put into the container if splitting that leaf would result in the children having less than min\-Points data points associated with them.

\begin{DoxyPrecond}{\-Precondition}
an \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree representing some histogram state, a container of pointers to the splittable leaf and cherry nodes of the tree in its current state, ordered with the leaves first followed by the cherries, the number of splittable leaf nodes and the number of cherry nodes. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree changed as a result of the split, the container of splittable leaf and cherry nodes updated for any change in state, and the number of splittable leaves and cherries updated similarly.
\end{DoxyPostcond}

\begin{DoxyParams}{\-Parameters}
{\em target} & is a pointer to the target node proposed for splitting. \\
\hline
{\em nodes} & is a reference to a container of pointers to the leaf and cherry nodes of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}, which will be updated by the method. \\
\hline
{\em num\-Leaves} & is a reference to a variable storing the number of splittable leaves in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree, which will be updated by the method. \\
\hline
{\em num\-Cherries} & is a reference to a variable storing the number of cherries in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree, which will be updated by the method. \\
\hline
{\em min\-Points} & is the minimum number of points allowed in a box. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if has been a successful change in state, false otherwise. 
\end{DoxyReturn}


\-Definition at line 804 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-Expand(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), subpavings\-::\-S\-P\-Snode\-::get\-Min\-Child\-Count\-If\-Split(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), subpavings\-::\-S\-P\-Snode\-::get\-Parent(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), subpavings\-::\-S\-Pnode\-::has\-Leaf\-Sibling(), and root\-Paving.



\-Referenced by change\-M\-C\-M\-C\-State().


\begin{DoxyCode}
{
    bool success = true;

    size_t points = rootPaving->getCounter(); // need to recalculate COPERR EMP

    // accumulate the changes in scaled EMP sums that will result
    // from this expansion
   // updateScaledEMPSumCOPERR(target->getSplitChangeEMPCOPERR(points));
   // updateScaledEMPSumAIC(target->getSplitChangeEMPAIC());

    // split the target and divvie up its data
    Expand(target);
    numLeaves--;

    // add the new child names to the creation string
    creationString += target->getChildNodeNames();

    // but only put the children into the container if they can be split, which
    // means if their children would have more than minPoints points in them
    // or if minPoints > 0 and right child has enough points and splitting it
       would
    // give all its points to one child, none to the other
    if ((target->getRightChild()->getMinChildCountIfSplit() >= minPoints)
        ||
        ((minPoints > 0) && (target->getRightChild()->getCounter() >= minPoints
      )
        && (target->getRightChild()->getMinChildCountIfSplit() == 0))
        ) {

        // insert the new children ptrs into the list at the beginning
        nodes.push_front(target->getRightChild());
        numLeaves++;
    }

    if ((target->getLeftChild()->getMinChildCountIfSplit() >= minPoints)
        ||
        ((minPoints > 0) && (target->getLeftChild()->getCounter() >= minPoints)
        && (target->getLeftChild()->getMinChildCountIfSplit() == 0))
        ) {
        // insert the new children ptrs into the list at the beginning
        nodes.push_front(target->getLeftChild());// left goes first
        numLeaves++;
    }

    // if sibling was a leaf, take parent out of cherries
    if(target->hasLeafSibling()) {

        // how to find parent? - search the cherries?
        bool foundParent = false;
        std::string nodeParent = target->getParent()->getNodeName();

        SPSnodeListItr git = nodes.begin();
        advance(git, numLeaves); // advance to the cherries
        // break out of loop if we find parent
        SPSnodeListItr it;
        for (it = git ; it != nodes.end(); it++ ) {
            if ((*it)->getNodeName() == nodeParent) {
                nodes.erase(it);
                numCherries--;
                foundParent = true;
                break;
            }
        }
        success = foundParent;

    }

    // put this node ptr into the cherries, ie at end of list
    nodes.push_back(target);

    numCherries++;

    return success;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8a997f746bf62c847990542daf7c5a6a}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!check\-Node\-Count\-For\-Split@{check\-Node\-Count\-For\-Split}}
\index{check\-Node\-Count\-For\-Split@{check\-Node\-Count\-For\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{check\-Node\-Count\-For\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::check\-Node\-Count\-For\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-P\-Snode} $\ast$const}]{spn, }
\item[{bool}]{vol\-Checking, }
\item[{double}]{min\-Vol, }
\item[{size\-\_\-t}]{min\-Child\-Points}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a8a997f746bf62c847990542daf7c5a6a}


\-Method to do checking for whether a node is splittable. 

\-Decides whether a node is splittable based on checking volume and number of points that would result in child nodes on split.

\-Node volume must be $>$=min\-Vol to split and \-If there is a min\-Child\-Points$>$0 specified, then either the node must have at least min\-Child\-Points and all the points go to one of the children (the other getting none) or the smallest number of points which would go to the either of the prospective new children must be $>$= min\-Child\-Points

\-Thus in general the method will only return true if the given node satisfies both the min\-Vol test and, if it were to be split, both children would have at least min\-Child\-Points data points, but if all the data points would go to one child (none) to the other, this is considered to also satisfy the min\-Child\-Points test.

\-If the node has already been split, the test will use the actual numbers of points in the children; if the node is a leaf (ie not split) then the test will consider the number of points that would go to the each child if it were to be split.


\begin{DoxyParams}{\-Parameters}
{\em spn} & is a pointer to the target node. \\
\hline
{\em vol\-Checking} & indicates whether volume is being checked \\
\hline
{\em min\-Vol} & is the minimum volume allowed to be tested for. \\
\hline
{\em min\-Child\-Points} & is the minimum number of points that there would be in the children if the node were to be split. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if has been a test conditions satisfied, false otherwise. 
\end{DoxyReturn}


\-Definition at line 986 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), subpavings\-::\-S\-P\-Snode\-::get\-Min\-Child\-Count\-If\-Split(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), and subpavings\-::\-S\-Pnode\-::node\-Volume().



\-Referenced by \-M\-C\-M\-Csamples(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), and priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
{
    bool retValue = false;
  
  size_t minChildCount = 0;
  size_t counter = spn->getCounter();
  if (spn->isLeaf()) minChildCount = spn->getMinChildCountIfSplit();
  else {
    size_t lcCount = spn->getLeftChild()->getCounter();
    size_t rcCount = counter - lcCount;
    minChildCount = (lcCount < rcCount ? lcCount : rcCount);
  }
  
  if ((!volChecking || (volChecking && (spn->nodeVolume() >= minVol)))
        && ((minChildPoints == 0)
            || (minChildPoints > 0
                &&
                ((counter >= minChildPoints) &&
                    ((minChildCount == 0)
                    ||
                    (minChildCount >= minChildPoints))
                ))
            )
        ) { retValue = true; }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a438e2252f954f0556fa2bd7c2e105dbe}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!check\-Stop\-Crit@{check\-Stop\-Crit}}
\index{check\-Stop\-Crit@{check\-Stop\-Crit}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{check\-Stop\-Crit}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::check\-Stop\-Crit} (
\begin{DoxyParamCaption}
\item[{double}]{\-Stop\-Crit\-Current, }
\item[{double}]{\-Stop\-Crit\-Previous, }
\item[{int \&}]{\-Prev}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a438e2252f954f0556fa2bd7c2e105dbe}
\-Check if we should stop splitting using total variation distance 

\-Definition at line 5762 of file adaptivehistogram.\-cpp.



\-Referenced by priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
{
  bool valley = false;
  //cout << "current: " << stopCritCurrent << "\t previous: " <<
       stopCritPrevious << endl;
  //cout << "Prev before checks: " << Prev << endl;
  
  // check if it is a local minimum
  if ( (stopCritCurrent > stopCritPrevious) && (Prev == 1) ) {
    //cout << "larger: " << (stopCritCurrent > stopCritPrevious) << "\t Prev: "
       << Prev << endl;
    //cout << "!!! Local minima previously !!! " << endl;
    Prev = 0;
    valley = true;
  }
  
  // check if stopCrit is decreasing
  else if (stopCritCurrent < stopCritPrevious) {
    Prev = 1;
    valley = false;
  }

  else { 
    valley = false; }

  //cout << "Prev after checks: " << Prev << endl;
  return valley;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a929e006a5a2a0f40c68d77bc7dff70e7}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!complete\-Data\-Insertion\-From\-Vec@{complete\-Data\-Insertion\-From\-Vec}}
\index{complete\-Data\-Insertion\-From\-Vec@{complete\-Data\-Insertion\-From\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{complete\-Data\-Insertion\-From\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::complete\-Data\-Insertion\-From\-Vec} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a929e006a5a2a0f40c68d77bc7dff70e7}


\-Complete insertion of data from a vector container. 

\-First checks if the box exists and makes it otherwise, then checks box dimensions against data dimensions if box already exists, and finally inserts the data.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em logging} & an enum controlling whether a log file is created for histogram creation process; set to \-T\-X\-T for logging to a txt file. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A container the\-Data containing at least one rvector. 

this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object may have an initialised \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} pointed to by root\-Paving, but root\-Paving can also be \-N\-U\-L\-L. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
\-If the root\-Paving was \-N\-U\-L\-L when the function was entered, then root\-Paving is pointed to a new \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} object whose root node has a box tailored to contain all the data read in. 

\-The data in the\-Data has been put into the \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}'s data\-Collection and also associated with root\-Paving's leaves via iterators to data\-Collection. 
\end{DoxyPostcond}
\begin{DoxyReturn}{\-Returns}
true if data successfully put into a data\-Collection and associated with the root\-Paving's leaves, false otherwise. 
\end{DoxyReturn}


\-Definition at line 119 of file adaptivehistogram.\-cpp.



\-References have\-Made\-Paving(), insert\-Data\-From\-Container(), taylor\-::\-Lb(), root\-Box, and taylor\-::\-Ub().



\-Referenced by insert\-From\-R\-S\-Sample(), insert\-From\-R\-Vec(), insert\-One\-Dim\-Data\-From\-Txt(), insert\-Rvectors\-From\-Txt(), insert\-Sample\-From\-R\-S\-Sample(), and insert\-Sample\-From\-R\-Vec().


\begin{DoxyCode}
{

    bool retValue = false;

    //find the data dimensions from the first datapoint
    int dataDim = Ub(*theData.begin()) - Lb(*theData.begin()) + 1;

    // ensure the paving exists
    bool hadToMakePaving = haveMadePaving(theData, dataDim);

    // if we did not make the paving we have to check data dimensions
    if (!hadToMakePaving) {
        if(dataDim != (Ub(rootBox) - Lb(rootBox)) + 1) {

            throw HistException("Dimensions of data do not match paving");
        }
    }

    // insert the data
    size_t dataCountInserted
            = insertDataFromContainer(theData, boolTest, logging);

    if (dataCountInserted > 0) {
        retValue = true;
        // switch on for more output during histogram creation "
        /*
        std::cout << "End of inserting data: " << dataCountInserted
            << " data points inserted to dataCollection "
            << std:: endl;
        std::cout << "and associated with the tree if "
            << "they fit into the root box" << std::endl;
        std::cout << "(check console output for possible records "
            << "of datapoints which did not fit)" << std::endl;
        */
        }

    if (dataCountInserted == 0) {
        throw HistException("No data inserted");

    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ae2df56ec733843dffcc6af094637758d}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!decision\-M\-C\-M\-C\-Merge@{decision\-M\-C\-M\-C\-Merge}}
\index{decision\-M\-C\-M\-C\-Merge@{decision\-M\-C\-M\-C\-Merge}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{decision\-M\-C\-M\-C\-Merge}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Merge} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{target, }
\item[{const {\bf \-M\-C\-M\-C\-Proposal} \&}]{proposal, }
\item[{const {\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{num\-Leaves, }
\item[{size\-\_\-t}]{num\-Cherries, }
\item[{size\-\_\-t}]{min\-Points, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{const std\-::string \&}]{s, }
\item[{int}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ae2df56ec733843dffcc6af094637758d}


\-Determines whether to merge a node to get a new \-M\-C\-M\-C state. 

\-This method probabilistically accepts or rejects a single-\/step change n the histogram state represented by this \-Adaptive \-Histogram resulting from merging the leaf children of a target cherry node back into the target.

\-Q(m' $|$ m) is the transition probability from state m to state m'.

\-This proposal is accepted if u drawn from \-Uniform(0,1) is such that u $<$ (posterior probability of m' x \-Q(m $|$ m'))/(posterior probability of m x \-Q(m' $|$ m). \-In this implementation, natural logs are used to simplify calculation, ie a proposal is accepted if log(u) $<$ log \mbox{[}(posterior probability of m' x \-Q(m $|$ m'))/(posterior probability of m x \-Q(m' $|$ m)\mbox{]}.


\begin{DoxyParams}{\-Parameters}
{\em target} & is a pointer to the target node proposed for merging. \\
\hline
{\em proposal} & is a reference to a proposal distribution object. \\
\hline
{\em log\-Prior} & is a reference to a log prior object. \\
\hline
{\em rgsl} & is a pointer to a uniform random number generator. \\
\hline
{\em num\-Leaves} & is the number of splittable leaf nodes in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree. \\
\hline
{\em num\-Cherries} & is the number of cherries in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree. \\
\hline
{\em min\-Points} & is the minimum number of points allowed in a box. \\
\hline
{\em logging} & an enum controlling whether decision making output is sent to the log file. \\
\hline
{\em s} & is the name of the filename to send logging output to. \\
\hline
{\em i} & is an integer for keeping track of the index for this link in a \-Markov \-Chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if the proposal is accepted (the target will be merged), false otherwise. 
\end{DoxyReturn}


\-Definition at line 725 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), subpavings\-::\-M\-C\-M\-C\-Proposal\-::get\-Log\-Q\-Ratio\-Merge\-Proposal(), subpavings\-::\-S\-P\-Snode\-::get\-Merge\-Change\-Log\-Lik(), subpavings\-::\-S\-P\-Snode\-::get\-Min\-Child\-Count\-If\-Split(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::\-S\-Pnode\-::has\-Leaf\-Sibling(), log\-M\-C\-M\-C\-Deltas(), subpavings\-::output\-File(), subpavings\-::\-T\-X\-T, and subpavings\-::\-T\-X\-T\-A\-N\-D\-G\-R\-A\-P\-H.



\-Referenced by change\-M\-C\-M\-C\-State().


\begin{DoxyCode}
{
    bool willMerge = false;

  //cout << "merge or not merge?" << endl;
  //cout << target->getLeftChild()->getCounter() << "\t" << 
  //target->getRightChild()->getCounter() << endl;

    // cherry so we are merging
    if ((logging == TXT) || (logging == TXTANDGRAPH))
        outputFile(s,"grabbing cherry " + target->getNodeName());

    // change in log likelihood on merge is getMergeChangeLogLik
    // for this node
    real deltaL = rnd(target->getMergeChangeLogLik());

    size_t realNumLeaves = getRootLeaves();

    real deltaP = logPrior(realNumLeaves - 2) - logPrior(realNumLeaves - 1);

    // posterior is proportional to likelihood * prior
    real deltaPi = deltaL + deltaP;

    // calculate the number of leaves and cherries after proposed merge
    // we have to take into account minPoints and the effect that this will
       have
    // had on whether the target's children are in the nodes container
    size_t newNumLeaves = numLeaves + 1; // current number of leaves plus
       target
    // but decrement newNumLeaves for each of the target's children that comes
    // out of the container
    if (target->getLeftChild()->getMinChildCountIfSplit() >= minPoints) {
        newNumLeaves--;
    }
    // the left child would also have been in the container if it had enough
    // points and all of them went to one child, the other getting nothing
    if ((minPoints > 0)
        && (target->getLeftChild()->getCounter() >= minPoints)
        && (target->getLeftChild()->getMinChildCountIfSplit() == 0)) {
            newNumLeaves--;
    }

    if (target->getRightChild()->getMinChildCountIfSplit() >= minPoints) {
        newNumLeaves--;
    }
    // the right child would also have been in the container if it had enough
    // points and all of them went to one child, the other getting nothing
    if ((minPoints > 0)
        && (target->getRightChild()->getCounter() >= minPoints)
        && (target->getRightChild()->getMinChildCountIfSplit() == 0)) {
            newNumLeaves--;
    }

    size_t newNumCherries = numCherries;
    if (!(target->hasLeafSibling())) { 
     
     //cout << "only remove cherry if it doesn't have a sibling leaf node" <<
       endl;
     newNumCherries = numCherries - 1; }

    // Using proposal distribution object
    real deltaQ = proposal.getLogQRatioMergeProposal(numLeaves, numCherries,
                                                newNumLeaves, newNumCherries);
    //get another random number
    double randChange = gsl_rng_uniform(rgsl);
    if (log(randChange) < deltaPi + deltaQ) willMerge = true;

    if ((logging == TXT) || (logging == TXTANDGRAPH)) {
        logMCMCDeltas(s, i, deltaL, deltaP, deltaQ, deltaPi, randChange);
        if (willMerge) outputFile(s, "Merging");
        else outputFile(s, "Not merging");
    }

    return willMerge;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a89aa9c37916fcac47cf273f512bca019}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!decision\-M\-C\-M\-C\-Split@{decision\-M\-C\-M\-C\-Split}}
\index{decision\-M\-C\-M\-C\-Split@{decision\-M\-C\-M\-C\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{decision\-M\-C\-M\-C\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::decision\-M\-C\-M\-C\-Split} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-Snode} $\ast$}]{target, }
\item[{const {\bf \-M\-C\-M\-C\-Proposal} \&}]{proposal, }
\item[{const {\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{num\-Leaves, }
\item[{size\-\_\-t}]{num\-Cherries, }
\item[{size\-\_\-t}]{min\-Points, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{const std\-::string \&}]{s, }
\item[{int}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a89aa9c37916fcac47cf273f512bca019}


\-Determines whether to split a node to get a new \-M\-C\-M\-C state. 

\-This method probabilistically accepts or rejects a single-\/step change in the histogram state represented by this \-Adaptive \-Histogram resulting from a single split of a target splittable leaf node.

\-Q(m' $|$ m) is the transition probability from state m to state m'.

\-This proposal is accepted if u drawn from \-Uniform(0,1) is such that u $<$ (posterior probability of m' x \-Q(m $|$ m'))/(posterior probability of m x \-Q(m' $|$ m). \-In this implementation, natural logs are used to simplify calculation, ie a proposal is accepted if log(u) $<$ log \mbox{[}(posterior probability of m' x \-Q(m $|$ m'))/(posterior probability of m x \-Q(m' $|$ m)\mbox{]}.


\begin{DoxyParams}{\-Parameters}
{\em target} & is a pointer to the target node proposed for splitting. \\
\hline
{\em proposal} & is a reference to a proposal distribution object. \\
\hline
{\em log\-Prior} & is a reference to a log prior object. \\
\hline
{\em rgsl} & is a pointer to a uniform random number generator. \\
\hline
{\em num\-Leaves} & is the number of splittable leaves in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree. \\
\hline
{\em num\-Cherries} & is the number of cherries inthe \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree. \\
\hline
{\em min\-Points} & is the minimum number of points allowed in a box. \\
\hline
{\em logging} & an enum controlling whether decision making output is sent to the log file. \\
\hline
{\em s} & is the name of the filename to send logging output to. \\
\hline
{\em i} & is an integer for keeping track of the index for this link in a \-Markov \-Chain \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if the proposal is accepted (the target will be split), false otherwise. 
\end{DoxyReturn}


\-Definition at line 630 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Childrens\-Left\-And\-Right\-Counts\-If\-Split(), subpavings\-::\-M\-C\-M\-C\-Proposal\-::get\-Log\-Q\-Ratio\-Split\-Proposal(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), get\-Root\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Split\-Change\-Log\-Lik(), subpavings\-::\-S\-Pnode\-::has\-Leaf\-Sibling(), log\-M\-C\-M\-C\-Deltas(), subpavings\-::output\-File(), subpavings\-::\-T\-X\-T, and subpavings\-::\-T\-X\-T\-A\-N\-D\-G\-R\-A\-P\-H.



\-Referenced by change\-M\-C\-M\-C\-State().


\begin{DoxyCode}
{
    bool willSplit = false;

  //cout << "split or not split with minpoints = " << minPoints << endl;
  
    if ((logging == TXT) || (logging == TXTANDGRAPH))
        outputFile(s, "grabbing leaf " + target->getNodeName());

    // change in contribution to log likelihood for this node on split
    real deltaL = rnd(target->getSplitChangeLogLik());

    size_t realNumLeaves = getRootLeaves(); // realNumLeaves is the number of 
                            //leaf nodes of the 'old' state

    // use the prior distribution object to find the change in prior
    // here realNumLeaves = #leaves in new state - 1 
    real deltaP = logPrior(realNumLeaves) - logPrior(realNumLeaves - 1);

    // posterior is proportional to likelihood * prior
    real deltaPi = deltaL + deltaP;

    // new numbers of leaves and cherries under proposal depends on minPoints
    // because this determines whether the new leaf children will go into the
    // nodes container
    size_t newNumLeaves = numLeaves - 1; // current number of leaves less this
    // increase the number of new leaves for each new child that can
    // go into the nodes container

    //childrensSpread will be a container of the number of points the children
    // of each child of target might have, in order
    // [0] = left child's left child count, [1] = left child's rght child
       count,
    // [2] = rght child's left child count, [3] = rght child's rght child
       count,
    Size_tVec childrensSpread;
    childrensSpread =
                target->getChildrensLeftAndRightCountsIfSplit(childrensSpread);

    if ((childrensSpread[2] >= minPoints) &&
    (childrensSpread[3] >= minPoints)) {
     //   cout << childrensSpread[2] << "\t" << childrensSpread[3] << endl;    
          
        newNumLeaves++;
    } // this will add one to the leaf numbers if minPoints == 0

    // we will also be prepared to put the right child into the container if
    // there is a minPoints > 0 but one of its
    // children would take all the points, the other getting none
    size_t rightChildCount = childrensSpread[2] + childrensSpread[3];
    if ((minPoints > 0) && (rightChildCount >= minPoints) &&
        ((childrensSpread[2] == 0) || (childrensSpread[3] == 0))) {
        //cout << rightChildCount << endl;
        newNumLeaves++;
    }

    if ((childrensSpread[0] >= minPoints) &&
    (childrensSpread[1] >= minPoints)) {
     
      //cout << childrensSpread[0] << "\t" << childrensSpread[1] << endl;
        newNumLeaves++;
    }  // this will add one to the leaf numbers if minPoints == 0

    // we would also be prepared to put the left child into the container if
    // there is a minPoints > 0 but one of its
    // children would take all the points, the other getting none
    size_t leftChildCount = childrensSpread[0] + childrensSpread[1];
    if ((minPoints > 0) && (leftChildCount >= minPoints) &&
        ((childrensSpread[0] == 0) || (childrensSpread[1] == 0))) {
        newNumLeaves++;
    }

    size_t newNumCherries = numCherries;
    if (!(target->hasLeafSibling())) newNumCherries = numCherries + 1;

    // Using proposal distribution object
    real deltaQ = proposal.getLogQRatioSplitProposal(numLeaves, numCherries,
                                                newNumLeaves, newNumCherries);
    //get another random number
    double randChange = gsl_rng_uniform(rgsl);
//  cout << log(randChange) << "\t" << (deltaPi + deltaQ) << endl;

    if (log(randChange) < deltaPi + deltaQ) { willSplit = true; }

    if ((logging == TXT) || (logging == TXTANDGRAPH)) { // log these values
        logMCMCDeltas(s, i, deltaL, deltaP, deltaQ, deltaPi, randChange);
        if (willSplit) outputFile(s, "Splitting");
        else outputFile(s, "Not splitting");
    }

    return willSplit;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aa0b81dd06668d2ce34e3fe983a2a2913}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!find\-Density\-Region@{find\-Density\-Region}}
\index{find\-Density\-Region@{find\-Density\-Region}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{find\-Density\-Region}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::find\-Density\-Region} (
\begin{DoxyParamCaption}
\item[{double}]{cov, }
\item[{double}]{weight\-P\-M, }
\item[{vector$<$ {\bf \-S\-P\-Snode} $\ast$ $>$ \&}]{cov\-Nodes, }
\item[{string}]{cov\-File\-Name}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aa0b81dd06668d2ce34e3fe983a2a2913}


\-Find the coverage of the boxes in an \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}. 



\-Definition at line 4629 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), get\-Root\-Counter(), get\-Sub\-Paving(), taylor\-::\-Lb(), and taylor\-::\-Ub().


\begin{DoxyCode}
{
  try {
      if ( (cov - weightPM) <= 0) {
        cout << cov << " percent of the mass are already covered by the point
       masses" << endl;
      }
      else {
        // put the leaves into a vector and sort it, smallest to largest
        SPSnodePtrs leaves;
        getSubPaving()->getLeaves(leaves);
        CompHeight compheight;
        //sort according to average height
        sort(leaves.begin(), leaves.end(), MyCompare(compheight));
        
        //start iterating from the largest
        SPSnodePtrs::reverse_iterator rit = leaves.rbegin();
        bool found = FALSE; //found the boxes that gives cov density region
        
        dotprecision totalCov;
        totalCov = 0.0;
        
        size_t totalN = getRootCounter();
        
        while (!found && rit < leaves.rend()) {
          //accumulate the height * box vo\l 
          accumulate(totalCov, (1.0*(*rit)->getCounter())/(1.0*totalN), 1); 

          //push back the node that fulfill the condition totalCov <= cov 
          //into the container covNodes
          if (totalCov <= (cov - weightPM) ) { 
            covNodes.push_back((*rit)); 
          } 
          
          // check that totalCov is at most cov
          if (totalCov >= (cov - weightPM) ) { found = TRUE; } // break out of
       loop
          ++rit;        
        } // end while 
      
      //output covNodes to .txt 
        ofstream os;
        os.open(covFileName.c_str());   
        SPSnodePtrsItr vit;
        for (vit = covNodes.begin(); vit < covNodes.end(); vit++) {
          ivector thisBox = (*vit)->getBox(); // copy theBox         
          double vol = (*vit)->nodeVolume();
          // output the nodeName, nodeVolume
          os << (*vit)->getNodeName();
          os << "\t" << vol;
          // followed by the height
          os << "\t" << (1.0*(*vit)->getCounter())/(1.0*totalN)/vol;
          // followed by intervals making up box using Inf & Sup
          // ie unlike cxsc output, there is no [  ] around them
          for (int i= Lb(thisBox); i <= Ub(thisBox) ; i++) {
             os << "\t" << Inf(thisBox[i]) << "\t" << Sup(thisBox[i]);
          }
          os << endl;
        }
        os << flush;
        os.close();
      } //end of going through the continuous part
    } // end of try     
  catch (exception& e) {
    throw HistException(
    "Error in AdaptiveHistogram::findDensityRegion :\n"
    + string( e.what() ) );
  }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2b0b0c19870f67a07704458237cf19d0}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get2\-D\-I\-A\-E@{get2\-D\-I\-A\-E}}
\index{get2\-D\-I\-A\-E@{get2\-D\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get2\-D\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get2\-D\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf taylor\-::dim2taylor}($\ast$)({\bf taylor\-::dim2taylor\-\_\-vector}, interval)}]{testpnt}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a2b0b0c19870f67a07704458237cf19d0}
\-Get the \-I\-A\-E of a bivariate gaussian/\-Levy 2\-D/\-Rosen 2\-D distribution.

\-Get the \-I\-A\-E for 2\-D distribution 

\-Definition at line 4597 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), integrate\-With\-Splitting(), and root\-Paving.



\-Referenced by get\-I\-A\-E().


\begin{DoxyCode}
{
  //number of points
  int n = rootPaving->getCounter();
   
  SPSnodePtrs leaves; // set up empty container for leaf node pointers
  SPSnodePtrsItr it; // and an iterator over the container
  (*this).getSubPaving()->getLeaves(leaves); // fill the container
  real tol=1e-6;
  int o=16;
  real result = 0; 
  for (it=leaves.begin(); it < leaves.end(); it++)
  { 
      //get domain
    ivector domain = (*it)->getBox();
    cout << "Get IAE for node " << domain << endl;
    //get fhat  
    cout << "fhat:" << endl;
     interval fhat = interval(real((*it)->getCounter()/
                             (((*it)->nodeVolume())*1.0*n))); 
     
     // get the integrated absolute error at this box
    interval resultInt = integrateWithSplitting(testpnt, fhat, domain, o, tol);
          
     //add the errors    
     result += Sup(resultInt);
   }
  //accounting for boundaries - will have to think about this later perhaps
  //accumulate(dpIAE,gsl_cdf_ugaussian_P(xlow[0]),1.0);
  //accumulate(dpIAE,gsl_cdf_ugaussian_Q(xupp[nLeaves-1]),1.0);
  return result;  
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a71b9bb96936f8e5f6a298c6d1a382e0b}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-E\-M\-P\-Score\-A\-I\-C@{get\-E\-M\-P\-Score\-A\-I\-C}}
\index{get\-E\-M\-P\-Score\-A\-I\-C@{get\-E\-M\-P\-Score\-A\-I\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-E\-M\-P\-Score\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-E\-M\-P\-Score\-A\-I\-C} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a71b9bb96936f8e5f6a298c6d1a382e0b}


get the \-E\-M\-P part of the \-A\-I\-C score. 



\-Definition at line 1272 of file adaptivehistogram.\-cpp.



\-References scaled\-E\-M\-P\-Sum\-A\-I\-C.



\-Referenced by main().


\begin{DoxyCode}
{
    //recalcScaledEMPSumAIC();
    // default cxsc rounding dotprecision rnd_next
    return rnd(scaledEMPSumAIC);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_afb0bda49b3a39ab8aa53737de810afec}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R@{get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R}}
\index{get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R@{get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_afb0bda49b3a39ab8aa53737de810afec}


get the \-E\-M\-P part of the \-C\-O\-P\-E\-R\-R score. 



\-Definition at line 1264 of file adaptivehistogram.\-cpp.



\-References scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R.



\-Referenced by main().


\begin{DoxyCode}
{
    //recalcScaledEMPSumCOPERR();
    // default cxsc rounding dotprecision rnd_next
    return rnd(scaledEMPSumCOPERR);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a513472c79b4a9337dcb5445be825a8f3}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample@{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample}}
\index{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample@{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf subpavings\-::\-Adaptive\-Histogram\-::get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{{\bf \-R\-S\-Sample} \&}]{lab\-Sampled\-Data, }
\item[{double}]{dx, }
\item[{double}]{wt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a513472c79b4a9337dcb5445be825a8f3}
\-Get the estimated log likelihood from \hyperlink{classRSSample}{\-R\-S\-Sample}. 

\-Definition at line 1629 of file adaptivehistogram.\-hpp.


\begin{DoxyCode}
  { double WeightHist = 1.0;
    std::map<rvector, double, std::less<rvector> > WeightsPM;
    return getEstLogLikelihoodFromRSSample(labSampledData,
                    dx, wt, WeightHist, WeightsPM); } 
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aca5143d5da261357d7f8d7eec45d1a5c}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample@{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample}}
\index{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample@{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{{\bf \-R\-S\-Sample} \&}]{lab\-Sampled\-Data, }
\item[{double}]{dx, }
\item[{double}]{wt, }
\item[{double}]{\-Weight\-Hist, }
\item[{std\-::map$<$ rvector, double, std\-::less$<$ rvector $>$ $>$ \&}]{\-Weights\-P\-M}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aca5143d5da261357d7f8d7eec45d1a5c}
\-Distribution-\/free \-Likelihood \-Estimation 

\-Definition at line 3650 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), get\-Root\-Counter(), get\-Sub\-Paving(), insert\-From\-R\-S\-Sample(), make\-Empty(), \-N(), and subpavings\-::\-N\-O\-L\-O\-G.


\begin{DoxyCode}
{
    dotprecision dpEstLogLik;
    dpEstLogLik = 0.0;
      
    //Get log-likelihoods for points in model 1, 
    //and points both in model 0 and 1
    
    //first multiply the box heights with the weight corresponding to the
    // histogram model
    vector<double> fhat; //container to store heights
    SPSnodePtrs leaves; // set up empty container for leaf node pointers
      SPSnodePtrsItr it; // and an iterator over the container
      getSubPaving()->getLeaves(leaves); // fill the container
      size_t N = getRootCounter();
    // add wt to the heights at each box
    for(it = leaves.begin(); it < leaves.end(); it++) {
      fhat.push_back(WeightHist*
      (((1-wt)*(*it)->getCounter()/(N*1.0)/(*it)->nodeVolume()) + wt));
    }
    
    
    // clear the current histogram's data and counters and 
    // insert new data into the histogram 
    AdaptiveHistogram tempHist = (*this);
    tempHist.makeEmpty(); 
    
    //cout << "insert from model 1" << endl;    
    // insert data from model 1 into the empty hist 
     bool hasData = false;
    hasData = tempHist.insertFromRSSample(labSampledData, NOLOG, 1);
    if (hasData) {
      //now get the estimated likelihood
      size_t pos = 0;
      SPSnodePtrs leavesTemp; // set up empty container for leaf node pointers
      tempHist.getSubPaving()->getLeaves(leavesTemp); // fill the container
      for(it = leavesTemp.begin(); it < leavesTemp.end(); it++) {
        if ((*it)->getCounter() != 0) {       
          //cout << fhat[pos] << "\t" << (*it)->getCounter() <<"\t" <<
       dx*fhat[pos] << "\t" << ((*it)->getCounter())*log(dx*fhat[pos]) << endl;
          accumulate(dpEstLogLik, ((*it)->getCounter())*log(dx*fhat[pos]), 1);
          //cout << dpEstLogLik << endl;
        }
        pos++; 
      }   
    } // end of if hasData for label 1
    
    //make tempHist empty again
    tempHist.makeEmpty();
    //insert data from model 0
    //cout << "inserting from model 0" << endl;
    hasData = false;
    hasData =tempHist.insertFromRSSample(labSampledData, NOLOG, 0);
     if (hasData) {
       size_t pos = 0;
      SPSnodePtrs leavesTemp; // set up empty container for leaf node pointers
      tempHist.getSubPaving()->getLeaves(leavesTemp); // fill the container
      for(it = leavesTemp.begin(); it < leavesTemp.end(); it++) {
        if ((*it)->getCounter() != 0) {       
          //get the node's data
          NodeData nodeData = (*it)->getData();
          //go through each data in node
          NodeDataItr dit;
          for (dit = nodeData.begin(); dit != nodeData.end(); dit++){
            BigDataItr bigIt = *dit; 
                  rvector theData = *bigIt;  // convert NodeData to rvector
            
            //get the EMF
             if ( WeightsPM[theData] != 0 ) {
            //the check for WeightsPM[theData] is needed because there 
            //may be point mass in the sampled data but not in the 
            //histogram that you are observing the data with
              //cout << (*it)->getCounter() << "\t" << (*bigIt) << endl;
              //cout << dx*fhat[pos] << "\t" << WeightsPM[theData] << endl; 
              accumulate(dpEstLogLik, log(dx*fhat[pos] + WeightsPM[theData]), 1
      );
              //cout << dpEstLogLik << endl;
            } // end of weight check
            else {
              //cout << (*it)->getCounter() << "\t" << (*bigIt) << endl;
              //cout << dx*fhat[pos] << endl; 
              accumulate(dpEstLogLik, log(dx*fhat[pos]), 1);
              //cout << dpEstLogLik << endl;
            }
          } // end of going through node's data     
        } // if counter < 0
        pos++; 
      } // end of iterating over leaves     
    } // end of if hasData for label 0   
        
    real estLogLik = rnd(dpEstLogLik);
    return estLogLik;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a368e5e9ed8cf0a3e82b30291c4a54d24}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Fin\-Mix\-I\-A\-E@{get\-Fin\-Mix\-I\-A\-E}}
\index{get\-Fin\-Mix\-I\-A\-E@{get\-Fin\-Mix\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Fin\-Mix\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-Fin\-Mix\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf \-Fin\-Mix} \&}]{mixt}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a368e5e9ed8cf0a3e82b30291c4a54d24}
\-Get the \-I\-A\-E for a finite gaussian mixture distribution.

\-Get the \-I\-A\-E for a finite mixture distribution 

\-Definition at line 3895 of file adaptivehistogram.\-cpp.



\-References dp\-I\-A\-E, dp\-I\-A\-E\-Boun, \-F(), \-Fin\-Mix\-::fhat, \-Fin\-Mix\-Abs(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), \-Nbin, and root\-Paving.


\begin{DoxyCode}
{
  cout << "GEtting IAE for Finite Mixture: " << endl; 

  //---------fill in containers for names, volumes and heights of leaves
  SPSnodePtrs leaves; // set up empty container for leaf node pointers
  SPSnodePtrsItr it; // and an iterator over the container
  (*this).getSubPaving()->getLeaves(leaves); // fill the container
  //a container for the counts
  IntVec counts;  // IntVec is a typedef for vector<int>
  //a container for the boxes
  vector<ivector> boxes; vector<ivector>::iterator itBoxes;
  //a container for the volumes
  vector<double> volumes;
  // a container for fhat
  vector<double> fhat; vector<double>::iterator itFhat;
  //number of points
  int n = rootPaving->getCounter();
            
  for(it = leaves.begin(); it < leaves.end(); it++) {
    // remember that it points to a pointer, so *it is still a ptr
    // get the counts in all the leaves
     counts.push_back((*it)->getCounter());
     // get the boxes from all the leaves
     boxes.push_back((*it)->getBox());
     // get the volumes of all the leaves
     volumes.push_back((*it)->nodeVolume());
     // get fhat for all leaves
     fhat.push_back(((*it)->getCounter())/((*it)->nodeVolume())/n);
  } // end of iterating through leaves 
  
  //----------------get the IAE-----------------------------------------------
  dotprecision dpIAE, dpIAEBoun;
  dpIAE = 0.0;
  int Nbin=counts.size();
  
  gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
  double result = 0.0;
  double error;
  gsl_function F;
  
  F.function = &FinMixAbs;
  F.params =  &mixt;
  
  for (int j=0; j< Nbin; j++){
    mixt.fhat = fhat[j];
    rvector xuppVec = Sup(boxes[j]);
    double xupp = _double(xuppVec[1]);
    rvector xlowVec = Inf(boxes[j]);
    double xlow = _double(xlowVec[1]);
    gsl_integration_qags(&F, xlow, xupp, 0, 1e-7, 1000, w, &result, &error);
    accumulate(dpIAE, result, 1.0);
  }
  
  /*
  // Accounting for the boundaries
  rvector xuppVec1 = Sup(boxes[Nbin-1]);
  double xupp1 = _double(xuppVec1[1]);
  rvector xlowVec1 = Inf(boxes[0]);
  double xlow1 = _double(xlowVec1[1]);
  dpIAEBoun = dpFinMixIAEBoun(xlow1, xupp1, mixt);
  dpIAE += dpIAEBoun;
  */
  
  // cast dot precision to real
  real FinMixIAE = rnd(dpIAE);
  
  // free the workspace
  gsl_integration_workspace_free (w);
  
  return FinMixIAE;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_abf4e34e57ff3c76828457efaecbf4510}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Fin\-Mix\-Interval\-I\-A\-E@{get\-Fin\-Mix\-Interval\-I\-A\-E}}
\index{get\-Fin\-Mix\-Interval\-I\-A\-E@{get\-Fin\-Mix\-Interval\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Fin\-Mix\-Interval\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}cxsc\-::interval {\bf \-Adaptive\-Histogram\-::get\-Fin\-Mix\-Interval\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf \-Fin\-Mix} \&}]{mixt, }
\item[{double}]{tol, }
\item[{int}]{deg}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_abf4e34e57ff3c76828457efaecbf4510}
\-Get the \-I\-A\-E for a finite gaussian mixture distribution using interval techniques. 

\-Definition at line 3970 of file adaptivehistogram.\-cpp.



\-References bisect(), get\-L1error(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), get\-Root\-Counter(), get\-Sub\-Paving(), \-Fin\-Mix\-::\-M, \-Fin\-Mix\-::\-S, and \-Fin\-Mix\-::\-W.



\-Referenced by main().


\begin{DoxyCode}
{
  interval totalArea(0.0); //initialize
  int n = getRootCounter();

  // need to iterate through the leaves
  SPSnodePtrs leaves; // set up empty container for leaf node pointers
  SPSnodePtrsItr it; // and an iterator over the container
  getSubPaving()->getLeaves(leaves); // fill the container
  
  // container is filled by reading leaves off tree from left to right
  for(it = leaves.begin(); it < leaves.end(); it++) {
    //cout << "-----------------" << endl;
    //a container for the roots at this leaf node
    vector<intervalw> rootVec;
    
    //get the height in this leaf node
    double fhat = (*it)->getCounter()/(*it)->nodeVolume()/n;
    //get the box of this leaf node
    ivector thisBox = (*it)->getBox();
    //cout << (*it)->getBox() << endl;
    
    //---------find the root at this domain
    // make an intervalw object using thisBox
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    intervalw thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    // find the root
    //cout << "finding roots at this node " << thisInt << endl;
    bisect(thisIntW, tol, fhat, rootVec, mixt.W, mixt.M, mixt.S); 

    //---------find the area at this domain and take the absolute value
    //if rootVec is empty, there are no roots - so we can integrate over
    //this domain
    if ((rootVec.size() == 0)) { 
      //cout << "no roots at " << thisInt << endl;
      //get the L1 error
      interval diffArea = getL1error(fhat, thisInt, deg, tol, mixt.W, mixt.M, 
      mixt.S);
      //add to totalArea
      totalArea += diffArea;
    } //end of rootVec is empty

    else { //if rootVec is not empty
      vector<intervalw> uniqueRootVec;
      // make the elements in vector unique
      for (int i = 0; i < (rootVec.size()); i++) {
        //cout << "root " << i << ": " << rootVec[i] << endl;
        //first insert into uniqueRootVec
        uniqueRootVec.push_back(rootVec[i]);
        //cout << i-1 << "\t" << i << "\t" << i+1 << endl;
        //now check for uniqueness
        if (((i-1) >= 0) && (i < rootVec.size())) {
          //cout << rootVec[i] << "\t" << rootVec[i-1] << endl;
          bool uniq = (subset(abs(rootVec[i] - rootVec[i-1]), intervalw(0, 1e-1
      0)));
          if ( uniq ) { 
            //cout << "this root has a duplicate" << endl;
            uniqueRootVec.pop_back(); }
        }
      }
      //cout << "==There are " << uniqueRootVec.size() << " unique root(s)=="
       << endl;

      // if there's only 1 root
      if (uniqueRootVec.size() == 1) {
        //cout << "there is only one root.." << endl;
        // is the root at the left or right boundary?
        if ( (abs(Inf(thisInt) - inf(rootVec[0])) < 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) < 1e-10) ) {
          //cout << "there's a root at the left/right boundary:" << rootVec[0]
       << endl;
          interval diffArea = getL1error(fhat, thisInt, deg, tol, mixt.W, mixt.M
      , mixt.S);
          totalArea += diffArea;
        }
        else { // the root is not at the boundaries
          //cout << "no root at the boundaries" << endl;
          //get the left sub-interval
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]
      ));
          //cout << "left interval: " << thisSubIntLeft << endl; 
          interval diffArea = getL1error(fhat, thisSubIntLeft, deg, tol, mixt.W
      , mixt.M, mixt.S);
          totalArea += diffArea;
          
          //get the right sub-interval
          //get the left sub-interval
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(
      thisInt));
          //cout << "right interval: " << thisSubIntRight << endl; 
          diffArea = getL1error(fhat, thisSubIntRight, deg, tol, mixt.W, mixt.M
      , mixt.S);
          totalArea += diffArea;
        }
      } // end of rootVec.size() == 1

        // if there is more than 1 root
      else {
        //cout << "let's have a look at all the roots:" << endl;
        //for (size_t i = 0; i < uniqueRootVec.size(); i++) {
          //cout << uniqueRootVec[i] << endl;
        //}

        //first check if the first root is at the boundary
        //cout << "check boundaries: " << Inf(thisInt) << "\t" <<
       inf(rootVec[0]) << endl;
        if ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) < 1e-10 ) {
          //cout << "there's a root at the leftmost boundary:" << endl;
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1
      ]));
          //cout << "0-th interval:" << thisSubIntFirst << endl; 
          interval diffArea = getL1error(fhat, thisSubIntFirst, deg, tol, mixt.W
      , mixt.M, mixt.S);
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            //cout << "the " << i+1 << "-th root is: " << rootVec[i+1] << endl;
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = getL1error(fhat, thisSubInt, deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
            else { //there are still more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << i+1 << "-th interval: " << thisSubInt << endl;
              interval diffArea = getL1error(fhat, thisSubInt, deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
          } // end of iterate through each root (excep the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast,deg, tol, mixt.W
      , mixt.M, mixt.S);
            totalArea += diffArea;
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast, deg, tol, mixt
      .W, mixt.M, mixt.S);
            totalArea += diffArea;
          } 
        } // end of if first root is the boundary
        
        else {
          //cout << "root not at boundary" << endl;
          //if it is not the boundary, make the first sub-interval
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          //cout << "0-th interval: " << thisSubIntFirst << endl; 
          interval diffArea = getL1error(fhat, thisSubIntFirst, deg, tol, mixt.W
      , mixt.M, mixt.S);
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              //cout << inf(rootVec[i]) << "\t" << Sup(thisInt) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << "the " << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = getL1error(fhat, thisSubInt,  deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
            else { //there are still more roots
              //cout << inf(rootVec[i]) << "\t" << sup(rootVec[i+1]) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << "the " << i+1 << "-th interval: " << thisSubInt <<
       endl;
              interval diffArea = getL1error(fhat, thisSubInt,  deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
          } // end of iterate through each root (except the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast,  deg, tol, 
      mixt.W, mixt.M, mixt.S);
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast,  deg, tol, 
      mixt.W, mixt.M, mixt.S);
            totalArea += diffArea;
          } 
        } // end of first root is not the boundary
      } // end of rootVec.size() > 1
    } // end of rootVec is not empty

  } // end of iterating through the leaf nodes
  
  //cout << "IAE: " << totalArea << endl;
  return totalArea;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ae90ad88f52691280d18f4b6f2e3b7ad1}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Hold\-All\-Stats@{get\-Hold\-All\-Stats}}
\index{get\-Hold\-All\-Stats@{get\-Hold\-All\-Stats}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Hold\-All\-Stats}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::get\-Hold\-All\-Stats} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_ae90ad88f52691280d18f4b6f2e3b7ad1}


get the value of hold\-All\-Stats field. 

\-This determines whether the histrogram's root\-Paving will maintain all available stats (true) or just the counts (false). 

\-Definition at line 1353 of file adaptivehistogram.\-cpp.



\-References hold\-All\-Stats.



\-Referenced by operator+().


\begin{DoxyCode}
{
    return holdAllStats;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a28b0435b5ee65b27b2459d3dc3fc224d}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-I\-A\-E@{get\-I\-A\-E}}
\index{get\-I\-A\-E@{get\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{int}]{distr}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a28b0435b5ee65b27b2459d3dc3fc224d}
\-Get the \-I\-A\-E of a distribution.

\-Get the \-I\-A\-E of the corresponding distribution based on function arguments. 

\-Definition at line 3748 of file adaptivehistogram.\-cpp.



\-References \-Bi\-G\-O\-P(), get2\-D\-I\-A\-E(), \-Levy\-O\-P(), and \-Rosen\-O\-P().



\-Referenced by main().


\begin{DoxyCode}
{
      real IAE = 0;
    taylor::dim2taylor (*testpnt)(taylor::dim2taylor_vector, interval);
    switch(distr)
    { 
         case 1: //bivariate gaussian mixtures
         testpnt = BiGOP;
      IAE = get2DIAE(testpnt);
      break;
      
      case 2: // Levy 2D
      testpnt = LevyOP;
      IAE = get2DIAE(testpnt);
      break;
      
      case 3: //Rosenbrock 2D
      testpnt = RosenOP;
      IAE = get2DIAE(testpnt);
      break;
    }   
    return IAE;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_adc2a97bb7f8fc3c543f90ba876515ca1}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Label@{get\-Label}}
\index{get\-Label@{get\-Label}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Label}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf \-Adaptive\-Histogram\-::get\-Label} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_adc2a97bb7f8fc3c543f90ba876515ca1}


\-Return the label for this. 



\-Definition at line 1220 of file adaptivehistogram.\-cpp.


\begin{DoxyCode}
{
  return 0; //this is temporarily for gat41 src
  //return label;
  }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2427c16c05dc17a5d7ecb1e58f0d35ca}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Laplace\-Interval\-I\-A\-E@{get\-Laplace\-Interval\-I\-A\-E}}
\index{get\-Laplace\-Interval\-I\-A\-E@{get\-Laplace\-Interval\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Laplace\-Interval\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}cxsc\-::interval {\bf \-Adaptive\-Histogram\-::get\-Laplace\-Interval\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{double}]{tol, }
\item[{int}]{deg}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a2427c16c05dc17a5d7ecb1e58f0d35ca}
\-Get the \-I\-A\-E for mapped function. \-Get the \-I\-A\-E for a laplace distribution with mu=0 and b=1 using interval techniques. 

\-Definition at line 4206 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), get\-Root\-Counter(), get\-Sub\-Paving(), \-Laplace\-Bisect(), and \-Laplace\-Get\-L1error().



\-Referenced by main().


\begin{DoxyCode}
{
  interval totalArea(0.0); //initialize
  int n = getRootCounter();

  // need to iterate through the leaves
  SPSnodePtrs leaves; // set up empty container for leaf node pointers
  SPSnodePtrsItr it; // and an iterator over the container
  getSubPaving()->getLeaves(leaves); // fill the container
  
  // container is filled by reading leaves off tree from left to right
  for(it = leaves.begin(); it < leaves.end(); it++) {
    cout << "-----------------" << endl;
    //a container for the roots at this leaf node
    vector<intervalw> rootVec;
    
    //get the height in this leaf node
    double fhat = (*it)->getCounter()/(*it)->nodeVolume()/n;
    //get the box of this leaf node
    ivector thisBox = (*it)->getBox();
    //cout << (*it)->getBox() << endl;
    
    //---------find the root at this domain
    // make an intervalw object using thisBox
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    intervalw thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    // find the root
    cout << "finding roots at this node " << thisInt << endl;
    cout << "bisection" << endl;
    LaplaceBisect(thisIntW, tol, fhat, rootVec); 

    cout << "get L1 error" << endl;
    //---------find the area at this domain and take the absolute value
    //if rootVec is empty, there are no roots - so we can integrate over
    //this domain
    if ((rootVec.size() == 0)) { 
      cout << "no roots at " << thisInt << endl;
      //get the L1 error
      interval diffArea = LaplaceGetL1error(fhat, thisInt, deg, tol);
      //add to totalArea
      totalArea += diffArea;
    } //end of rootVec is empty

    else { //if rootVec is not empty
      vector<intervalw> uniqueRootVec;
      // make the elements in vector unique
      for (int i = 0; i < (rootVec.size()); i++) {
        cout << "root " << i << ": " << rootVec[i] << endl;
        //first insert into uniqueRootVec
        uniqueRootVec.push_back(rootVec[i]);
        //cout << i-1 << "\t" << i << "\t" << i+1 << endl;
        //now check for uniqueness
        if (((i-1) >= 0) && (i < rootVec.size())) {
          //cout << rootVec[i] << "\t" << rootVec[i-1] << endl;
          bool uniq = (subset(abs(rootVec[i] - rootVec[i-1]), intervalw(0, 1e-1
      0)));
          if ( uniq ) { 
            //cout << "this root has a duplicate" << endl;
            uniqueRootVec.pop_back(); }
        }
      }
      cout << "==There are " << uniqueRootVec.size() << " unique root(s)==" << 
      endl;

      // if there's only 1 root
      if (uniqueRootVec.size() == 1) {
        cout << "there is only one root.." << endl;
        // is the root at the left or right boundary?
        if ( (abs(Inf(thisInt) - inf(rootVec[0])) < 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) < 1e-10) ) {
        cout << "there's a root at the left/right boundary:" << rootVec[0] << 
      endl;
          interval diffArea = LaplaceGetL1error(fhat, thisInt, deg, tol);
          totalArea += diffArea;
        }
        else { // the root is not at the boundaries
          cout << "no root at the boundaries" << endl;
          //get the left sub-interval
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]
      ));
          cout << "left interval: " << thisSubIntLeft << endl; 
          interval diffArea = LaplaceGetL1error(fhat, thisSubIntLeft, deg, tol)
      ;
          totalArea += diffArea;
          
          //get the right sub-interval
          //get the left sub-interval
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(
      thisInt));
          cout << "right interval: " << thisSubIntRight << endl; 
          diffArea = LaplaceGetL1error(fhat, thisSubIntRight, deg, tol);
          totalArea += diffArea;
        }
      } // end of rootVec.size() == 1

        // if there is more than 1 root
      else {
        cout << "let's have a look at all the roots:" << endl;
        for (size_t i = 0; i < uniqueRootVec.size(); i++) {
          cout << uniqueRootVec[i] << endl;
        }

        //first check if the first root is at the boundary
        //cout << "check boundaries: " << Inf(thisInt) << "\t" <<
       inf(rootVec[0]) << endl;
        if ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) < 1e-10 ) {
          //cout << "there's a root at the leftmost boundary:" << endl;
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1
      ]));
          //cout << "0-th interval:" << thisSubIntFirst << endl; 
          interval diffArea = LaplaceGetL1error(fhat, thisSubIntFirst, deg, tol
      );
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            //cout << "the " << i+1 << "-th root is: " << rootVec[i+1] << endl;
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = LaplaceGetL1error(fhat, thisSubInt, deg, tol)
      ;
              totalArea += diffArea;
            }
            else { //there are still more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << i+1 << "-th interval: " << thisSubInt << endl;
              interval diffArea = LaplaceGetL1error(fhat, thisSubInt, deg, tol)
      ;
              totalArea += diffArea;
            }
          } // end of iterate through each root (excep the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = LaplaceGetL1error(fhat, thisSubIntLast, deg, 
      tol);
            totalArea += diffArea;
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = LaplaceGetL1error(fhat, thisSubIntLast, deg, 
      tol);
            totalArea += diffArea;
          } 
        } // end of if first root is the boundary
        
        else {
          //cout << "root not at boundary" << endl;
          //if it is not the boundary, make the first sub-interval
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          //cout << "0-th interval: " << thisSubIntFirst << endl; 
          interval diffArea = LaplaceGetL1error(fhat, thisSubIntFirst, deg, tol
      );
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              //cout << inf(rootVec[i]) << "\t" << Sup(thisInt) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << "the " << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = LaplaceGetL1error(fhat, thisSubInt, deg, tol)
      ;
              totalArea += diffArea;
            }
            else { //there are still more roots
              //cout << inf(rootVec[i]) << "\t" << sup(rootVec[i+1]) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << "the " << i+1 << "-th interval: " << thisSubInt <<
       endl;
              interval diffArea = LaplaceGetL1error(fhat, thisSubInt, deg, tol)
      ;
              totalArea += diffArea;
            }
          } // end of iterate through each root (except the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = LaplaceGetL1error(fhat, thisSubIntLast, deg, 
      tol);
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = LaplaceGetL1error(fhat, thisSubIntLast, deg, 
      tol);
            totalArea += diffArea;
          } 
        } // end of first root is not the boundary
      } // end of rootVec.size() > 1
    } // end of rootVec is not empty

  } // end of iterating through the leaf nodes
  
  cout << "IAE: " << totalArea << endl;
  return totalArea;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aaffb116a24a6de03482a8bfd9625b07f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Leaf\-Counts@{get\-Leaf\-Counts}}
\index{get\-Leaf\-Counts@{get\-Leaf\-Counts}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Leaf\-Counts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Size\-\_\-t\-Vec} {\bf \-Adaptive\-Histogram\-::get\-Leaf\-Counts} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_aaffb116a24a6de03482a8bfd9625b07f}
\-Get a vector of the leaf node counts.

\begin{DoxyReturn}{\-Returns}
a vector of leaf counts, left to right order, 
\end{DoxyReturn}


\-Definition at line 3516 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Leaf\-Node\-Counts(), and root\-Paving.


\begin{DoxyCode}
{
    Size_tVec counts; // empty container
    if (NULL != rootPaving) {
        rootPaving->getLeafNodeCounts(counts);
        //levels has now been filled in
    }
    return counts;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a70f9af80f0ee875d6dcbfd4cafb53813}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Leaf\-Levels@{get\-Leaf\-Levels}}
\index{get\-Leaf\-Levels@{get\-Leaf\-Levels}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Leaf\-Levels}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Int\-Vec} {\bf \-Adaptive\-Histogram\-::get\-Leaf\-Levels} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a70f9af80f0ee875d6dcbfd4cafb53813}
\-Get a vector of the leaf node levels.

\-Root is level 0, next level down is 1, etc.

\begin{DoxyReturn}{\-Returns}
a vector of leaf levels, left to right order, 
\end{DoxyReturn}


\-Definition at line 3502 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Leaf\-Node\-Levels(), and root\-Paving.



\-Referenced by main().


\begin{DoxyCode}
{
    IntVec levels; // empty container

    if (NULL != rootPaving) {
        rootPaving->getLeafNodeLevels(0, levels);
        //levels has now been filled in
    }
    return levels;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aca69edc461799f9d867d7eea6cb76f8e}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Leaf\-Levels\-String@{get\-Leaf\-Levels\-String}}
\index{get\-Leaf\-Levels\-String@{get\-Leaf\-Levels\-String}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Leaf\-Levels\-String}]{\setlength{\rightskip}{0pt plus 5cm}std\-::string {\bf \-Adaptive\-Histogram\-::get\-Leaf\-Levels\-String} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_aca69edc461799f9d867d7eea6cb76f8e}
\-Get a string of the leaf node levels.

\-Root is level 0, next level down is 1, etc. \-Example return string \char`\"{}3,3,2,1\char`\"{}

\begin{DoxyReturn}{\-Returns}
a comma separated string of leaf levels, left to right order 
\end{DoxyReturn}


\-Definition at line 1376 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Leaf\-Node\-Levels\-String(), and root\-Paving.



\-Referenced by insert\-Data\-From\-Container(), insert\-One(), main(), \-M\-C\-M\-C\-Log\-Final\-State(), \-M\-C\-M\-Csamples(), priority\-Merge(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), and priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
{
    string retValue = "";
    if (NULL != rootPaving)
        retValue = rootPaving->getLeafNodeLevelsString();

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aa595732ddb587933a166aee6cc0877f6}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Lognormal\-Interval\-I\-A\-E@{get\-Lognormal\-Interval\-I\-A\-E}}
\index{get\-Lognormal\-Interval\-I\-A\-E@{get\-Lognormal\-Interval\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Lognormal\-Interval\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}cxsc\-::interval {\bf \-Adaptive\-Histogram\-::get\-Lognormal\-Interval\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{double}]{tol, }
\item[{int}]{deg}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aa595732ddb587933a166aee6cc0877f6}
\-Get the \-I\-A\-E for a laplace distribution with mu=0 and b=1 using interval techniques. 

\-Definition at line 4402 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), get\-Root\-Counter(), get\-Sub\-Paving(), \-Lognormal\-Bisect(), and \-Lognormal\-Get\-L1error().



\-Referenced by main().


\begin{DoxyCode}
{
  interval totalArea(0.0); //initialize
  int n = getRootCounter();

  // need to iterate through the leaves
  SPSnodePtrs leaves; // set up empty container for leaf node pointers
  SPSnodePtrsItr it; // and an iterator over the container
  getSubPaving()->getLeaves(leaves); // fill the container
  
  // container is filled by reading leaves off tree from left to right
  for(it = leaves.begin(); it < leaves.end(); it++) {
    //cout << "-----------------" << endl;
    //a container for the roots at this leaf node
    vector<intervalw> rootVec;
    
    //get the height in this leaf node
    double fhat = (*it)->getCounter()/(*it)->nodeVolume()/n;
    //get the box of this leaf node
    ivector thisBox = (*it)->getBox();
    //cout << (*it)->getBox() << endl;
    
    //---------find the root at this domain
    // make an intervalw object using thisBox
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    intervalw thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    // find the root
    //cout << "finding roots at this node " << thisInt << endl;
    LognormalBisect(thisIntW, tol, fhat, rootVec); 

    //---------find the area at this domain and take the absolute value
    //if rootVec is empty, there are no roots - so we can integrate over
    //this domain
    if ((rootVec.size() == 0)) { 
      //cout << "no roots at " << thisInt << endl;
      //get the L1 error
      interval diffArea = LognormalGetL1error(fhat, thisInt, deg, tol);
      //add to totalArea
      totalArea += diffArea;
    } //end of rootVec is empty

    else { //if rootVec is not empty
      vector<intervalw> uniqueRootVec;
      // make the elements in vector unique
      for (int i = 0; i < (rootVec.size()); i++) {
        //cout << "root " << i << ": " << rootVec[i] << endl;
        //first insert into uniqueRootVec
        uniqueRootVec.push_back(rootVec[i]);
        //cout << i-1 << "\t" << i << "\t" << i+1 << endl;
        //now check for uniqueness
        if (((i-1) >= 0) && (i < rootVec.size())) {
          //cout << rootVec[i] << "\t" << rootVec[i-1] << endl;
          bool uniq = (subset(abs(rootVec[i] - rootVec[i-1]), intervalw(0, 1e-1
      0)));
          if ( uniq ) { 
            //cout << "this root has a duplicate" << endl;
            uniqueRootVec.pop_back(); }
        }
      }
      //cout << "==There are " << uniqueRootVec.size() << " unique root(s)=="
       << endl;

      // if there's only 1 root
      if (uniqueRootVec.size() == 1) {
        //cout << "there is only one root.." << endl;
        // is the root at the left or right boundary?
        if ( (abs(Inf(thisInt) - inf(rootVec[0])) < 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) < 1e-10) ) {
          //cout << "there's a root at the left/right boundary:" << rootVec[0]
       << endl;
          interval diffArea = LognormalGetL1error(fhat, thisInt, deg, tol);
          totalArea += diffArea;
        }
        else { // the root is not at the boundaries
          //cout << "no root at the boundaries" << endl;
          //get the left sub-interval
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]
      ));
          //cout << "left interval: " << thisSubIntLeft << endl; 
          interval diffArea = LognormalGetL1error(fhat, thisSubIntLeft, deg, 
      tol);
          totalArea += diffArea;
          
          //get the right sub-interval
          //get the left sub-interval
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(
      thisInt));
          //cout << "right interval: " << thisSubIntRight << endl; 
          diffArea = LognormalGetL1error(fhat, thisSubIntRight, deg, tol);
          totalArea += diffArea;
        }
      } // end of rootVec.size() == 1

        // if there is more than 1 root
      else {
        //cout << "let's have a look at all the roots:" << endl;
        //for (size_t i = 0; i < uniqueRootVec.size(); i++) {
          //cout << uniqueRootVec[i] << endl;
        //}

        //first check if the first root is at the boundary
        //cout << "check boundaries: " << Inf(thisInt) << "\t" <<
       inf(rootVec[0]) << endl;
        if ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) < 1e-10 ) {
          //cout << "there's a root at the leftmost boundary:" << endl;
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1
      ]));
          //cout << "0-th interval:" << thisSubIntFirst << endl; 
          interval diffArea = LognormalGetL1error(fhat, thisSubIntFirst, deg, 
      tol);
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            //cout << "the " << i+1 << "-th root is: " << rootVec[i+1] << endl;
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = LognormalGetL1error(fhat, thisSubInt, deg, 
      tol);
              totalArea += diffArea;
            }
            else { //there are still more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << i+1 << "-th interval: " << thisSubInt << endl;
              interval diffArea = LognormalGetL1error(fhat, thisSubInt, deg, 
      tol);
              totalArea += diffArea;
            }
          } // end of iterate through each root (excep the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = LognormalGetL1error(fhat, thisSubIntLast, deg, 
      tol);
            totalArea += diffArea;
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = LognormalGetL1error(fhat, thisSubIntLast, deg, 
      tol);
            totalArea += diffArea;
          } 
        } // end of if first root is the boundary
        
        else {
          //cout << "root not at boundary" << endl;
          //if it is not the boundary, make the first sub-interval
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          //cout << "0-th interval: " << thisSubIntFirst << endl; 
          interval diffArea =LognormalGetL1error(fhat, thisSubIntFirst, deg, 
      tol);
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              //cout << inf(rootVec[i]) << "\t" << Sup(thisInt) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << "the " << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = LognormalGetL1error(fhat, thisSubInt, deg, 
      tol);
              totalArea += diffArea;
            }
            else { //there are still more roots
              //cout << inf(rootVec[i]) << "\t" << sup(rootVec[i+1]) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << "the " << i+1 << "-th interval: " << thisSubInt <<
       endl;
              interval diffArea = LognormalGetL1error(fhat, thisSubInt, deg, 
      tol);
              totalArea += diffArea;
            }
          } // end of iterate through each root (except the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea =LognormalGetL1error(fhat, thisSubIntLast, deg, 
      tol);
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = LognormalGetL1error(fhat, thisSubIntLast, deg, 
      tol);
            totalArea += diffArea;
          } 
        } // end of first root is not the boundary
      } // end of rootVec.size() > 1
    } // end of rootVec is not empty

  } // end of iterating through the leaf nodes
  
  //cout << "IAE: " << totalArea << endl;
  return totalArea;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a0ef2d251d61753086a358bdd9bda057f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Min\-Vol@{get\-Min\-Vol}}
\index{get\-Min\-Vol@{get\-Min\-Vol}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Min\-Vol}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf \-Adaptive\-Histogram\-::get\-Min\-Vol} (
\begin{DoxyParamCaption}
\item[{double}]{min\-Vol\-B}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a0ef2d251d61753086a358bdd9bda057f}


get the value of the minimum volume for a splittable node. 

\-Minimum volume = min\-Vol\-B $\ast$ (log n) $^\wedge$2/n where n is points in histogram. \-Minimum volume is used in \-C\-O\-P\-E\-R\-R or \-A\-I\-C priority queue splitting to limit which nodes can be split. 
\begin{DoxyParams}{\-Parameters}
{\em min\-Vol\-B} & the multiplier applied to log n) $^\wedge$2/n to find the minimum allowed node volume at which a node can be split (children will half the volume of the parent node). \\
\hline
\end{DoxyParams}


\-Definition at line 1339 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), and root\-Paving.



\-Referenced by priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), and priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
{
    double retValue = 0.0;

    if (NULL != rootPaving) {

        size_t counter = rootPaving->getCounter();
        retValue = minVolB;
       // retValue =  minVolB * log(1.0*counter)*log(1.0*counter)/counter;
    }
    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_acb7aa3bb3a7b4d4691e9b5b9c9d4a765}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-P\-E\-N\-Value@{get\-P\-E\-N\-Value}}
\index{get\-P\-E\-N\-Value@{get\-P\-E\-N\-Value}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-P\-E\-N\-Value}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-P\-E\-N\-Value} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Pen\-Obj} \&}]{pen, }
\item[{int}]{delta\-Leaf = {\ttfamily 0}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_acb7aa3bb3a7b4d4691e9b5b9c9d4a765}


get the \-P\-E\-N value. 

\-Get the value of the \-P\-E\-N given penalty function object pen.


\begin{DoxyParams}{\-Parameters}
{\em pen} & is the penalty function object \\
\hline
{\em delta\-Leaf} & the number of additional leaves (can be negative) to calulate the \-P\-E\-N with\-: allows changes in histogram shape to be evaluated. \\
\hline
\end{DoxyParams}


\-Definition at line 1256 of file adaptivehistogram.\-cpp.



\-Referenced by get\-Score\-A\-I\-C(), and get\-Score\-C\-O\-P\-E\-R\-R().


\begin{DoxyCode}
{
    return pen(this, deltaLeaf);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a936a3426494278163afada104df26ecc}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Root\-Box@{get\-Root\-Box}}
\index{get\-Root\-Box@{get\-Root\-Box}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Root\-Box}]{\setlength{\rightskip}{0pt plus 5cm}cxsc\-::ivector {\bf \-Adaptive\-Histogram\-::get\-Root\-Box} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a936a3426494278163afada104df26ecc}


\-Get the box of the subpaving managed by this. 

\begin{DoxyNote}{\-Note}
with the present constructors, it is impossible for this to have a subpaving but for the subpaving to have no box.
\end{DoxyNote}
\begin{DoxyReturn}{\-Returns}
copy of the box of the subpaving managed by this. 
\end{DoxyReturn}
\begin{DoxyPrecond}{\-Precondition}
\hyperlink{classsubpavings_1_1AdaptiveHistogram_aaf5eac63bd232e3e76f20a27587c8784}{has\-Sub\-Paving()} == true. 
\end{DoxyPrecond}


\-Definition at line 1366 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Box(), get\-Sub\-Paving(), and has\-Sub\-Paving().



\-Referenced by main().


\begin{DoxyCode}
{
  if (!hasSubPaving()) {
    throw NullSubpavingPointer_Error(
              "AdaptiveHistogram::getRootBox()");
  }
  return getSubPaving()->getBox();
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a7386f85d1182ae6e3f32766c4a208c11}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Root\-Counter@{get\-Root\-Counter}}
\index{get\-Root\-Counter@{get\-Root\-Counter}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Root\-Counter}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-Adaptive\-Histogram\-::get\-Root\-Counter} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a7386f85d1182ae6e3f32766c4a208c11}


\-Gets count in the root paving. 



\-Definition at line 1243 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), and root\-Paving.



\-Referenced by find\-Density\-Region(), get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample(), get\-Fin\-Mix\-Interval\-I\-A\-E(), get\-Laplace\-Interval\-I\-A\-E(), get\-Lognormal\-Interval\-I\-A\-E(), subpavings\-::\-Pen\-A\-I\-C2\-::operator()(), and subpavings\-::\-Pen\-A\-I\-C3\-::operator()().


\begin{DoxyCode}
{ return rootPaving->getCounter(); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ae4a71d928009eda0a6332f20fd951e35}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Root\-Leaves@{get\-Root\-Leaves}}
\index{get\-Root\-Leaves@{get\-Root\-Leaves}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Root\-Leaves}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-Adaptive\-Histogram\-::get\-Root\-Leaves} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_ae4a71d928009eda0a6332f20fd951e35}


\-Gets number of leaf nodes in the root paving. 



\-Definition at line 1247 of file adaptivehistogram.\-cpp.



\-References root\-Paving, and subpavings\-::sp\-Leaves().



\-Referenced by decision\-M\-C\-M\-C\-Merge(), decision\-M\-C\-M\-C\-Split(), main(), subpavings\-::\-Pen\-A\-I\-C1\-::operator()(), subpavings\-::\-Pen\-A\-I\-C2\-::operator()(), subpavings\-::\-Pen\-A\-I\-C3\-::operator()(), subpavings\-::\-Pen\-A\-I\-C4\-::operator()(), subpavings\-::\-Pen\-A\-I\-C5\-::operator()(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), and priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
{ return spLeaves(rootPaving); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a95d9506c9ceea0359b99b0e36f1eff91}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Root\-Paving\-Mean@{get\-Root\-Paving\-Mean}}
\index{get\-Root\-Paving\-Mean@{get\-Root\-Paving\-Mean}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Root\-Paving\-Mean}]{\setlength{\rightskip}{0pt plus 5cm}rvector {\bf \-Adaptive\-Histogram\-::get\-Root\-Paving\-Mean} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a95d9506c9ceea0359b99b0e36f1eff91}


\-Gets the mean from the root box of the paving this manages. 



\-Definition at line 1227 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Mean(), hold\-All\-Stats, and root\-Paving.



\-Referenced by main().


\begin{DoxyCode}
{
    if (!holdAllStats) std::cout << "Note, holdAllStats is false."
                << std::endl;
    return rootPaving->getMean();
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2bbfcf884ee91c2457eb2e9d2b81e31f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Root\-Paving\-Var\-Covar@{get\-Root\-Paving\-Var\-Covar}}
\index{get\-Root\-Paving\-Var\-Covar@{get\-Root\-Paving\-Var\-Covar}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Root\-Paving\-Var\-Covar}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Real\-Vec} {\bf \-Adaptive\-Histogram\-::get\-Root\-Paving\-Var\-Covar} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a2bbfcf884ee91c2457eb2e9d2b81e31f}


\-Gets variance covariance vector from root box of rootpaving. 



\-Definition at line 1235 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Var\-Covar(), hold\-All\-Stats, and root\-Paving.



\-Referenced by main().


\begin{DoxyCode}
{
    if (!holdAllStats) std::cout << "Note, holdAllStats is false."
            << std::endl;
    return rootPaving->getVarCovar();
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ac7f7cb4d5aea17c967afec84e1159f9b}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Root\-Sum\-Leaf\-Count\-Over\-Vol@{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol}}
\index{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol@{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-Root\-Sum\-Leaf\-Count\-Over\-Vol} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_ac7f7cb4d5aea17c967afec84e1159f9b}


\-Gets the sum of leaf count over volume in root paving. 



\-Definition at line 1251 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Sum\-Leaf\-Count\-Over\-Vol(), and root\-Paving.



\-Referenced by subpavings\-::\-Pen\-A\-I\-C2\-::operator()(), and subpavings\-::\-Pen\-A\-I\-C3\-::operator()().


\begin{DoxyCode}
{ return rootPaving->getSumLeafCountOverVol(); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8333360139bee06eb9c661b8a47cb4a3}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Score\-A\-I\-C@{get\-Score\-A\-I\-C}}
\index{get\-Score\-A\-I\-C@{get\-Score\-A\-I\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Score\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-Score\-A\-I\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Pen\-Obj} \&}]{pen, }
\item[{bool}]{verbose = {\ttfamily false}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a8333360139bee06eb9c661b8a47cb4a3}


get \-A\-I\-C score. 


\begin{DoxyParams}{\-Parameters}
{\em pen} & is the penalty function object \\
\hline
{\em verbose} & option\-: true for extra console output (default false) \\
\hline
\end{DoxyParams}


\-Definition at line 1311 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-P\-E\-N\-Value(), root\-Paving, and scaled\-E\-M\-P\-Sum\-A\-I\-C.



\-Referenced by main().


\begin{DoxyCode}
{
    dotprecision temptotal = scaledEMPSumAIC;

    if (NULL != rootPaving) {

        size_t counter = rootPaving->getCounter();

        if (verbose) {
            std::cout << "AIC EMP is " <<
                        rnd(scaledEMPSumAIC) << std::endl;
            std::cout << "AIC penalty is " << getPENValue(pen, 0) << std::endl;
            std::cout << "Total AIC score is " <<
                        rnd(scaledEMPSumAIC) + getPENValue(pen, 0) << std::endl
      ;

        }

        // getPENValue(pen, 0) gives value of PEN under pen
        accumulate(temptotal, getPENValue(pen, 0), 1.0);
        // temptotal now holds scaledEMPSumAIC + PEN)
    }

    // default cxsc rounding dotprecision rnd_next
    return rnd(temptotal);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a94e90e67d767c5e0ad7b4378e0a72cad}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Score\-C\-O\-P\-E\-R\-R@{get\-Score\-C\-O\-P\-E\-R\-R}}
\index{get\-Score\-C\-O\-P\-E\-R\-R@{get\-Score\-C\-O\-P\-E\-R\-R}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Score\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-Score\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Pen\-Obj} \&}]{pen, }
\item[{bool}]{verbose = {\ttfamily false}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a94e90e67d767c5e0ad7b4378e0a72cad}


get the \-C\-O\-P\-E\-R\-R score. 


\begin{DoxyParams}{\-Parameters}
{\em pen} & is the penalty function object \\
\hline
{\em verbose} & option\-: true for extra console output (default false) \\
\hline
\end{DoxyParams}


\-Definition at line 1282 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-P\-E\-N\-Value(), root\-Paving, and scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R.



\-Referenced by main().


\begin{DoxyCode}
{
    dotprecision temptotal = scaledEMPSumCOPERR;

    if (NULL != rootPaving) {

        size_t counter = rootPaving->getCounter();

        if (verbose) {
            std::cout << "COPERR EMP is " <<
                        rnd(scaledEMPSumCOPERR) << std::endl;
            std::cout << "COPERR penalty is " << getPENValue(pen, 0) << 
      std::endl;
            std::cout << "Total COPERR score is " <<
                        rnd(scaledEMPSumCOPERR) + getPENValue(pen, 0) << 
      std::endl;

        }

       // getPENValue(pen, 0) gives value of PEN under pen
        accumulate(temptotal, getPENValue(pen), 1.0);
        // temptotal now holds scaledEMPSumCOPERR + PEN)
    }

    // default cxsc rounding dotprecision rnd_next
    return rnd(temptotal);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aecbdfe366fa381c0b3f7a7b00447dedb}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Sub\-Paving@{get\-Sub\-Paving}}
\index{get\-Sub\-Paving@{get\-Sub\-Paving}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Sub\-Paving}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode} $\ast$ {\bf \-Adaptive\-Histogram\-::get\-Sub\-Paving} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_aecbdfe366fa381c0b3f7a7b00447dedb}


\-Return a pointer to the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} this manages. 



\-Definition at line 1216 of file adaptivehistogram.\-cpp.



\-References root\-Paving.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-Collator\-::\-Adaptive\-Histogram\-Collator(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::add\-Negation\-To\-Collation(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::add\-To\-Collation(), do\-M\-C\-M\-C\-G\-R\-Auto(), find\-Density\-Region(), get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample(), get\-Fin\-Mix\-Interval\-I\-A\-E(), get\-Laplace\-Interval\-I\-A\-E(), get\-Lognormal\-Interval\-I\-A\-E(), get\-Root\-Box(), get\-Unif\-I\-A\-E(), has\-Sub\-Paving(), main(), make\-Empty(), \-M\-C\-M\-Csamples(), subpavings\-::\-Crit\-Leaves\-\_\-\-G\-T\-E\-::operator()(), subpavings\-::\-Pen\-Leaves\-::operator()(), subpavings\-::\-Crit\-Leaves\-\_\-\-L\-T\-E\-::operator()(), subpavings\-::\-Crit\-Smallest\-Count\-\_\-\-L\-T\-E\-::operator()(), subpavings\-::\-Crit\-Largest\-Count\-\_\-\-L\-T\-E\-::operator()(), subpavings\-::\-Crit\-Smallest\-Vol\-\_\-\-L\-T\-E\-::operator()(), subpavings\-::\-Crit\-Largest\-Vol\-\_\-\-L\-T\-E\-::operator()(), subpavings\-::\-Crit\-C\-O\-P\-E\-R\-R\-Change\-\_\-\-G\-T\-E\-::operator()(), subpavings\-::\-Crit\-A\-I\-C\-Change\-\_\-\-G\-T\-E\-::operator()(), subpavings\-::\-Crit\-C\-O\-P\-E\-R\-R\-Merge\-Change\-\_\-\-G\-T\-E\-::operator()(), subpavings\-::\-Crit\-A\-I\-C\-Merge\-Change\-\_\-\-G\-T\-E\-::operator()(), subpavings\-::operator$<$$<$(), output\-Log(), output\-Log\-Plain(), output\-Root\-To\-Txt(), output\-To\-Txt\-Tabs(), output\-To\-Txt\-Tabs\-With\-E\-M\-Ps(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Total\-Var(), and reshape\-To\-Union().


\begin{DoxyCode}
{return rootPaving;}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_af7cf1131373c3e547a23d2db624ce8cf}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Unif\-I\-A\-E@{get\-Unif\-I\-A\-E}}
\index{get\-Unif\-I\-A\-E@{get\-Unif\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Unif\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-Unif\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{double}]{weight, }
\item[{std\-::vector$<$ int $>$}]{holes\-Loc}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_af7cf1131373c3e547a23d2db624ce8cf}
\-Get the \-I\-A\-E for a uniform mixture distribution.

\-Get the \-I\-A\-E for a unform mixture 

\-Definition at line 3774 of file adaptivehistogram.\-cpp.



\-References dp\-I\-A\-E, subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Root\-Counter(), get\-Sub\-Paving(), \-Intersection(), and \-Volume().



\-Referenced by main().


\begin{DoxyCode}
{
   // get the true height, f of the corresponding box in myPart
  SPSnodePtrs trueLeaves;
  SPSnodePtrsItr trueIt;
  //AdaptiveHistogram * adhPtr;
  //adhPtr = &myPart;
  (myPart).getSubPaving()->getLeaves(trueLeaves);

  // setting up containers for the leaves
  SPSnodePtrs leaves;
  SPSnodePtrsItr it;
  (*this).getSubPaving()->getLeaves(leaves); // fill the container

  double trueF; //true density
  ivector temp;
  
  dotprecision dpIAE;    // use type dotprecision for summation  
  dpIAE=0.0;

  int n = getSubPaving()->getRootCounter();
  //go through all the leaves in this
  for(it = leaves.begin(); it < leaves.end(); it++) {
    ivector thisBox = (*it)->getBox();
    //cout << "====checking " << (*it)->getBox() << endl;
      
    // get the height of this leaf
    double fhat = (*it)->getCounter()/(n*1.0)/(*it)->nodeVolume(); 
    
    //cout << "fhat for box " << ":" << fhat << endl;

    size_t L = 0;
    for (trueIt = trueLeaves.begin(); trueIt < trueLeaves.end(); trueIt++) {
      //cout << "----True leaf: " << (*trueIt)->getBox() << "\t" << endl;
      ivector trueBox = (*trueIt)->getBox();

      if (  holesLoc[L] == 0 ) { trueF = 0; }
      else { trueF = weight/((*trueIt)->nodeVolume()); }
      //cout << "pdf: " << trueF << "------" << endl;
      
      // if this is contained in trueBox
      if ( (*it)->getBox() <= (*trueIt)->getBox() || (*it)->getBox() == 
      (*trueIt)->getBox() ) {
        //use the volume of this
        real r = ((*it)->nodeVolume())*(fhat - trueF);
        //cout << "r: " << r << "\t" << abs(r) << endl;
        accumulate(dpIAE, abs(r), 1.0);
        //can move on to next leaf rather than iterating thru all trueBoxes
        //think about this later
      } //end of if this box is in trueBox
      
      // if this contains trueBox
      else if ((*trueIt)->getBox() <= (*it)->getBox()) {
        //use the volume of trueBox
        real r = ((*trueIt)->nodeVolume())*(fhat - trueF);
        //cout << "r: " << r << "\t" << abs(r) << endl;
        accumulate(dpIAE, abs(r), 1.0);
      } //end of if trueBox is in this box
      
      // if this is partially contained in trueBox 
      else if   (Intersection(temp, thisBox, trueBox)) {
        if (Inf(temp) != Sup(temp)){
          double volume = Volume(temp);
          real r = volume*(fhat - trueF);
          //cout << "r: " << r << "\t" << abs(r) << endl;
          accumulate(dpIAE, abs(r), 1.0);
        }
      }
      L++;
    } // end of going through trueBoxes
  } // end of going through thisBoxes
  
   //cast dotprecision to real
   real unifIAE = rnd(dpIAE);
   //cout << "IAE: " << unifIAE << endl;
  return unifIAE;                             

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a3d403e99c1c471552303b2a7fd7e7d3e}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!get\-Unif\-I\-A\-E@{get\-Unif\-I\-A\-E}}
\index{get\-Unif\-I\-A\-E@{get\-Unif\-I\-A\-E}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{get\-Unif\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-::get\-Unif\-I\-A\-E} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a3d403e99c1c471552303b2a7fd7e7d3e}
\-Get the \-I\-A\-E for a uniform distribution.

\-Get the \-I\-A\-E for the unform distribution 

\-Definition at line 3854 of file adaptivehistogram.\-cpp.



\-References dp\-I\-A\-E, f(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), and root\-Paving.


\begin{DoxyCode}
{
    //-------setting up containers-------------------------------
  SPSnodePtrs leaves; // set up empty container for leaf node pointers
   SPSnodePtrsItr it; // and an iterator over the container
   (*this).getSubPaving()->getLeaves(leaves); // fill the container   
  int nSample = rootPaving->getCounter(); // get total number of training 
                                           // data
   dotprecision dpIAE;    // use type dotprecision for summation  
   dpIAE=0.0;
  double f = 1;
   //go through all the leaves in this
   for(it = leaves.begin(); it < leaves.end(); it++) {
      // get the height of this leaf
      //cout << (*it)->getCounter() << "\t" << (*it)->nodeVolume() << endl;
      double fhat = (((*it)->getCounter())*1.0)/((*it)->nodeVolume())/
                   (nSample*1.0);

      //now calculate the IAE
    if ((f - fhat) < 0.0){
      real r = ((*it)->nodeVolume())*(fhat - f);
      //cout << "r: " << r << endl;
      accumulate(dpIAE, r, 1.0);
    }

    else if ((f - fhat) > 0.0){
      real r = ((*it)->nodeVolume())*(f - fhat);
      //cout << "r: " << r << endl;
      accumulate(dpIAE, r, 1.0);
    }

  } // end of going through all the leaves in this

   //cast dotprecision to real
   real unifIAE = rnd(dpIAE);
  return unifIAE;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aaf5eac63bd232e3e76f20a27587c8784}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!has\-Sub\-Paving@{has\-Sub\-Paving}}
\index{has\-Sub\-Paving@{has\-Sub\-Paving}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{has\-Sub\-Paving}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::has\-Sub\-Paving} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_aaf5eac63bd232e3e76f20a27587c8784}


\-Get whether this has a subpaving to manage. 

\begin{DoxyNote}{\-Note}
with the present constructors, it is impossible for this to have a subpaving but for the subpaving to have no box.
\end{DoxyNote}
\begin{DoxyReturn}{\-Returns}
true if this has a subpaving to manage. false otherwise. 
\end{DoxyReturn}


\-Definition at line 1360 of file adaptivehistogram.\-cpp.



\-References get\-Sub\-Paving().



\-Referenced by get\-Root\-Box(), and reshape\-To\-Union().


\begin{DoxyCode}
{
    return ( getSubPaving() != NULL );
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab5d45e2f1966bd43a7bb8bf041ea29db}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!have\-Made\-Paving@{have\-Made\-Paving}}
\index{have\-Made\-Paving@{have\-Made\-Paving}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{have\-Made\-Paving}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::have\-Made\-Paving} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const size\-\_\-t}]{dim}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ab5d45e2f1966bd43a7bb8bf041ea29db}


\-Checks if we need to make root paving for the histogram object. 

\-Points root\-P\-Aving to a new \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} if root\-Paving is \-N\-U\-L\-L, with the box of the root node matching the dimensions of the data as given in function argument and tailored to fit the data in the\-Data.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data. \\
\hline
{\em dim} & the dimensions of the data. \\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{\-Postcondition}
if return value is true, root\-Paving points to a new \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} and a new ivector has been assigned to root\-Box, and the root\-Box ivector is the box of the root node of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} to which root\-Paving points. 
\end{DoxyPostcond}
\begin{DoxyReturn}{\-Returns}
true if function needed to make a new \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode}, false if root\-Paving already pointed to an \-S\-P\-S node. 
\end{DoxyReturn}


\-Definition at line 171 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), hold\-All\-Stats, subpavings\-::is\-Empty(), make\-Box(), root\-Box, and root\-Paving.



\-Referenced by complete\-Data\-Insertion\-From\-Vec().


\begin{DoxyCode}
{

    bool retValue = false;

    try {

        // check if we need to make the paving on the basis of the data
        if (isEmpty(rootPaving)) {

            rootBox = makeBox(theData, dim);

            // point rootPaving to a new SPSnode with box myBox
            // and also pass in the not value of holdAllStats which controls
            // whether all available statistics are maintained in the
            // rootPaving (true) or just counts (false)
            rootPaving = new SPSnode(rootBox, !holdAllStats);
            creationString = rootPaving->getNodeName();

            retValue = true;
        }
    }

    catch (bad_alloc& e)
    {
        const char* msg = e.what();
        std::cerr << msg << std::endl;
        std::cerr << "Error allocating memory in "
            << "AdaptiveHistogram::haveMadePaving()"
            << std::endl;
        throw;
    }

    return retValue;
    // end of making the subpaving if there was not one
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a0eaca3eebf10b3d251ed284f0317c593}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Data\-From\-Container@{insert\-Data\-From\-Container}}
\index{insert\-Data\-From\-Container@{insert\-Data\-From\-Container}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Data\-From\-Container}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-Adaptive\-Histogram\-::insert\-Data\-From\-Container} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a0eaca3eebf10b3d251ed284f0317c593}


\-Insert data from a container. 

\-Attempts to insert data from a container the\-Data into this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object's data\-Collection and to associate the data with the leaves of the subpaving tree pointed to by this's root\-Paving. \-Data in the\-Data which falls outside the boundaries of the root\-Box will not be inserted and a message will be printed to standard output.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data. \\
\hline
{\em logging} & an enum controlling whether a log file is created for histogram creation process; set to \-T\-X\-T for logging to a txt file. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A container the\-Data containing at least one rvector. 

this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object must have a root\-Paving pointing to an initialised \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode}; this \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} may already have data associated with it. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
\-The data in the\-Data which is within the boundaries of the root\-Box has been put into the \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}'s data\-Collection and also associated with root\-Paving's leaves via iterators to data\-Collection. 
\end{DoxyPostcond}
\begin{DoxyReturn}{\-Returns}
number of datapoints for which insertion has been attempted. 
\end{DoxyReturn}


\-Definition at line 271 of file adaptivehistogram.\-cpp.



\-References creation\-String, data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), get\-Leaf\-Levels\-String(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-P\-Snode\-::insert\-One\-Find(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, subpavings\-::output\-File(), output\-Log(), output\-Log\-Start(), recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), and root\-Paving.



\-Referenced by complete\-Data\-Insertion\-From\-Vec().


\begin{DoxyCode}
{
    size_t counter = 0;    // to count the input

    // for logging output to keep track of splits if necessary
    int i = 0;
    std::string baseFileName = "";
    std::string s = "";

    // if we are splitting as we go and logging, set up a log file
    if ((logging != NOLOG) && (boolTest() == true)) {
        baseFileName = "splitOutput";
        s = getUniqueFilename(baseFileName);
        outputLogStart(s);
        // log the current state of the histogram
        outputLog(s, i);
        i++;
    }

    RVecDataCItr cit;

    // feed the data to myHist
    for(cit = theData.begin(); cit < theData.end(); cit++) {

        // put it into dataCollection
        BigDataItr it = dataCollection.end();
        it = dataCollection.insert(it, *cit);

        SPSnode* insertedInto = NULL;

        // try inserting
        insertedInto =
                rootPaving->insertOneFind(it,ON_PARENT, boolTest);

        //insertOneFind returns either NULL if no insert possible
        // or a pointer to the node the data goes to before that node
        // is split (it could be split more than once)
        if (NULL == insertedInto) { // failed to insert
            std::cout << "Failed to insert point "
                << *cit << std::endl;
            std::cout << "Root node of subpaving has box "
                << rootPaving << std::endl;
        }
        // successful insertion, and we are splitting as we go
        else if (boolTest() == true) {
            std::string newNames = insertedInto->getChildNodeNames();

            if(newNames.length() > 0) { // there are new nodes
                //add the new child names if any
                creationString += newNames;

                if (logging) { // log the current state of the histogram
                    outputLog(s, i);
                    i++;
                }
            }
       }

        counter++;
    }

    if (counter > 0) { // data inserted
        //recalculate the scaled EMP sum values;
        recalcScaledEMPSumCOPERR();
        recalcScaledEMPSumAIC();

        if ((logging != NOLOG) && (boolTest() == true))  {
            // add leaf node levels string to log
            outputFile(s, getLeafLevelsString());
        }
    }

    return counter;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a3705758c35dbfe8745a2e34c83b7f619}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Doubles\-From\-Txt@{insert\-Doubles\-From\-Txt}}
\index{insert\-Doubles\-From\-Txt@{insert\-Doubles\-From\-Txt}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Doubles\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Doubles\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a3705758c35dbfe8745a2e34c83b7f619}
\-All rvectors are associated with the root paving, no splitting. 

\-Definition at line 837 of file adaptivehistogram.\-hpp.



\-References insert\-One\-Dim\-Data\-From\-Txt().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertOneDimDataFromTxt(s, sn, headerlines, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a3e03076ea91599538bcc69f47084f649}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Doubles\-From\-Txt@{insert\-Doubles\-From\-Txt}}
\index{insert\-Doubles\-From\-Txt@{insert\-Doubles\-From\-Txt}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Doubles\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Doubles\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a3e03076ea91599538bcc69f47084f649}
\-Adaptive splitting with each data point inserted. 

\-Definition at line 846 of file adaptivehistogram.\-hpp.



\-References insert\-One\-Dim\-Data\-From\-Txt().


\begin{DoxyCode}
    {
        return insertOneDimDataFromTxt(s, boolTest, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a6f049bec17097067ae9e2a7c9f42bd60}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-From\-R\-S\-Sample@{insert\-From\-R\-S\-Sample}}
\index{insert\-From\-R\-S\-Sample@{insert\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a6f049bec17097067ae9e2a7c9f42bd60}
\-All rvectors are associated with the root paving, no splitting. 

\-Definition at line 1023 of file adaptivehistogram.\-hpp.



\-Referenced by do\-M\-C\-M\-C\-G\-R\-Auto(), get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample(), and main().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertFromRSSample(rss, sn, logging, label);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a20ee07940112174415c391b4ed385ba1}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-From\-R\-S\-Sample@{insert\-From\-R\-S\-Sample}}
\index{insert\-From\-R\-S\-Sample@{insert\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a20ee07940112174415c391b4ed385ba1}
\-Adaptive splitting with each data point inserted. 

\-Definition at line 1817 of file adaptivehistogram.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::get\-Rvectors\-From\-R\-S\-Sample(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    try {
        RVecData myDataRvectors; // container for the rvectors we take in

        // try to get data from rss.Samples and check how many data points
       found
        size_t numberFound = getRvectorsFromRSSample(myDataRvectors, rss, label
      );

        if (numberFound > 0) {
            /*
            // confirm the amount of data taken from the RSSample
            std::cout << "End of taking data from RSSample: "
                << numberFound << " data points with label "
                << label << " found" << std::endl;
            */
            // complete the data insertion
            retValue = completeDataInsertionFromVec(myDataRvectors,
                                                    boolTest, logging);

        }
    }
    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ae19b382cf2c8f7f9b1d20883a7faf5c8}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-From\-R\-Vec@{insert\-From\-R\-Vec}}
\index{insert\-From\-R\-Vec@{insert\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ae19b382cf2c8f7f9b1d20883a7faf5c8}
\-All rvectors are associated with the root paving, no splitting. 

\-Definition at line 925 of file adaptivehistogram.\-hpp.



\-Referenced by do\-M\-C\-M\-C\-G\-R\-Auto(), main(), and operator+().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertFromRVec(rvec, sn, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2b8604eb7b87dd03d09736a2f9e4b96a}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-From\-R\-Vec@{insert\-From\-R\-Vec}}
\index{insert\-From\-R\-Vec@{insert\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a2b8604eb7b87dd03d09736a2f9e4b96a}
\-Adaptive splitting with each data point inserted. 

\-Definition at line 1568 of file adaptivehistogram.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::get\-Rvectors\-From\-R\-Vec(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    try {

        RVecData myDataRvectors; // container for the rvectors we take in

        size_t numberFound = 0;

        if (rvec.empty()) { // no data points to get
            throw HistException("No data to insert");
        }

        else { // there is data to get

            // get data from the container and check how many data points found
            size_t numberFound = getRvectorsFromRVec(myDataRvectors, rvec);


            if (numberFound > 0) {
                /*
                // confirm the amount of data taken from the container
                std::cout << "End of taking data from container of rvectors: "
                    << numberFound << " data points found" << std::endl;
                */
                // complete the data insertion
                retValue = completeDataInsertionFromVec(myDataRvectors,
                                                        boolTest, logging);
            }
        }
    }
    catch (bad_alloc& ba) {
         string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aafef86d6e4482aef11de75b83cfb4345}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-One@{insert\-One}}
\index{insert\-One@{insert\-One}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-One}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::insert\-One} (
\begin{DoxyParamCaption}
\item[{rvector}]{newdata, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aafef86d6e4482aef11de75b83cfb4345}


\-Insert a single data point into \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object. 

\-A method which attempts to insert a datapoint into this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object's data\-Collection and associate the datapoint with one of the leaves of the tree pointed to by this's root\-Paving. \-If the datapoint falls outside the boundaries of the root\-Box it will not be inserted and a message will be printed to standard output.


\begin{DoxyParams}{\-Parameters}
{\em newdata} & the datapoint to be inserted, an rvector. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging).\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object must have a root\-Paving pointing to an initialised \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode}; this \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} may already have data associated with it. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
\-If the datapoint is within the boundaries of the root\-Box it will have been put into the \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}'s data\-Collection and also associated with one of the root\-Paving's leaves via an iterator to data\-Collection. 
\end{DoxyPostcond}


\-Definition at line 1387 of file adaptivehistogram.\-cpp.



\-References creation\-String, data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), get\-Leaf\-Levels\-String(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-P\-Snode\-::insert\-One\-Find(), subpavings\-::is\-Empty(), taylor\-::\-Lb(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, subpavings\-::output\-File(), output\-Log(), output\-Log\-Start(), recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), root\-Box, root\-Paving, and taylor\-::\-Ub().


\begin{DoxyCode}
{
    // make sure we have a paving and then try inserting
    if (isEmpty(rootPaving)) {
        throw HistException("Trying to insert to empty or NULL node");
    }

    // check the dimensions
    if((Ub(newData)-Lb(newData)) != (Ub(rootBox) - Lb(rootBox))) {
        throw HistException("Dimensions of data do not match paving");

    }

    // for logging output to keep track of splits
    int i = 0;
    std::string baseFileName = "";
    std::string s = "";

    if (logging != NOLOG) {
        baseFileName = "splitOutput";
        s = getUniqueFilename(baseFileName);
        outputLogStart(s);
        // log the current state of the histogram
        outputLog(s, i);
        i++;
    }


    BigDataItr it = dataCollection.end();
    it = dataCollection.insert(it, newData);

    SPSnode* insertedInto = NULL;

    // try inserting
    insertedInto = rootPaving->insertOneFind(it, ON_PARENT,
                                            boolTest);

    if (insertedInto==NULL) { // failed to insert
        std::cout << "Failed to insert point " << newData << std::endl;
        std::cout << "Root node of subpaving has box " << rootPaving
            << std::endl;
    }
    else { // insertion succeeded

        std::string newNames = insertedInto->getChildNodeNames();

        if(newNames.length() > 0) { // there are new nodes
            //add the new child names if any
            creationString += newNames;
            if (logging != NOLOG) {
                // log the current state of the histogram
                outputLog(s, i);
                i++;
            }
        }

        //recalculate the scaled EMP sum values;
        recalcScaledEMPSumCOPERR();
        recalcScaledEMPSumAIC();
    }
    if (logging != NOLOG) {
        // add leaf node levels string to log
        outputFile(s, getLeafLevelsString());
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a11051ee818f2d6fb2631573e47ed73b8}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-One\-Dim\-Data\-From\-Txt@{insert\-One\-Dim\-Data\-From\-Txt}}
\index{insert\-One\-Dim\-Data\-From\-Txt@{insert\-One\-Dim\-Data\-From\-Txt}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-One\-Dim\-Data\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-One\-Dim\-Data\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a11051ee818f2d6fb2631573e47ed73b8}
\-All data is associated with the root paving, no splitting. 

\-Definition at line 787 of file adaptivehistogram.\-hpp.



\-Referenced by insert\-Doubles\-From\-Txt().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertOneDimDataFromTxt(s, sn, headerlines, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aef10187eeb8d449b8692c355960aefe0}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-One\-Dim\-Data\-From\-Txt@{insert\-One\-Dim\-Data\-From\-Txt}}
\index{insert\-One\-Dim\-Data\-From\-Txt@{insert\-One\-Dim\-Data\-From\-Txt}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-One\-Dim\-Data\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-One\-Dim\-Data\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aef10187eeb8d449b8692c355960aefe0}
\-Adaptive splitting with each data point inserted. 

\-Definition at line 1458 of file adaptivehistogram.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::read\-One\-Dim\-Data\-From\-Txt(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    try {
        RVecData myDataRvectors; // container for the rvectors we take in

        // try to read in the file
        retValue = readOneDimDataFromTxt(myDataRvectors, s, headerlines);

        if (retValue) {
            // complete the data insertion
            retValue = completeDataInsertionFromVec(myDataRvectors,
                                                    boolTest, logging);
        }
    }
    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: " + 
      oldmsg;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        throw HistException(msg);
    }
    // recalc of EMP sums takes place further down

    return retValue;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aff1b74eb52546adb9d7d64a84d739efe}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}}
\index{insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Rvectors\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Rvectors\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_aff1b74eb52546adb9d7d64a84d739efe}
\-All rvectors are associated with the root paving, no spliting. 

\-Definition at line 895 of file adaptivehistogram.\-hpp.



\-Referenced by main().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertRvectorsFromTxt(s, sn, headerlines, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a5decf91161cbddd77c21e3b25dd12689}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}}
\index{insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Rvectors\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-Rvectors\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a5decf91161cbddd77c21e3b25dd12689}
\-Adaptive splitting with each data point inserted. 

\-Definition at line 1517 of file adaptivehistogram.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::read\-Rvectors\-From\-Txt(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    try {
        RVecData myDataRvectors; // container for the rvectors we take in

        // try to read in the file
        retValue = readRvectorsFromTxt(myDataRvectors, s, headerlines);

        if (retValue) {
            retValue = completeDataInsertionFromVec(myDataRvectors,
                                                    boolTest, logging);
        }
    }
    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2549a287bc001212ea1c6f7bbe42be62}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}}
\index{insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a2549a287bc001212ea1c6f7bbe42be62}
\-All rvectors are associated with the root paving, no spliting, random number generator supplied. 

\-Definition at line 1066 of file adaptivehistogram.\-hpp.



\-Referenced by insert\-Sample\-From\-R\-S\-Sample().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertSampleFromRSSample(samplesize, rgsl, rss, sn,
                                        logging, label);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab41e19cc570fa35d9c867413a7398edc}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}}
\index{insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{int}]{seed, }
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ab41e19cc570fa35d9c867413a7398edc}
\-All rvectors are associated with the root paving, no spliting, seed for creating a random number generator supplied. 

\-Definition at line 1075 of file adaptivehistogram.\-hpp.



\-References insert\-Sample\-From\-R\-S\-Sample().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertSampleFromRSSample(samplesize, seed, rss, sn,
                                        logging, label);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a9468b46a614470017cc09cadd7699af8}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}}
\index{insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a9468b46a614470017cc09cadd7699af8}
\-All rvectors are associated with the root paving, no spliting, no random number generator supplied, default will be created. 

\-Definition at line 1084 of file adaptivehistogram.\-hpp.



\-References insert\-Sample\-From\-R\-S\-Sample().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertSampleFromRSSample(samplesize, rss, sn,
                                        logging, label);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ad002844c2b0ef25eeb5fbc845fd8a000}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}}
\index{insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_ad002844c2b0ef25eeb5fbc845fd8a000}
\-Adaptive splitting with each data point inserted, random number generator supplied. 

\-Definition at line 1875 of file adaptivehistogram.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::get\-Sample\-Rvectors\-From\-R\-S\-Sample(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    try {

        RVecData myDataRvectors; // container for the rvectors we take in

        // try to sample data from rss.Samples and check how many data points
       found
        size_t numberTaken = getSampleRvectorsFromRSSample(myDataRvectors,
                                rgsl, samplesize, rss, label);

        if (numberTaken > 0) {
            /* switch on for more output during histogram creation
            // confirm the amount of data taken from the RSSample
            std::cout << "End of taking sample from data from RSSample: "
                << numberTaken << " data points used for sample" << std::endl;
            */

            retValue = completeDataInsertionFromVec(myDataRvectors,
                                                    boolTest, logging);
        }
    }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8437c7aa645e4edc21a5bc4ec02db5ef}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}}
\index{insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{int}]{seed, }
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a8437c7aa645e4edc21a5bc4ec02db5ef}
\-Adaptive splitting with each data point inserted, seed for creating random number generator supplied. 

\-Definition at line 1934 of file adaptivehistogram.\-cpp.



\-References insert\-Sample\-From\-R\-S\-Sample(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    gsl_rng * rgsl = NULL;

    try {

        const gsl_rng_type * tgsl;

        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed
        gsl_rng_set (rgsl, seed); // change the seed

        retValue = insertSampleFromRSSample(samplesize, rgsl, rss, boolTest,
                logging, label);

        gsl_rng_free(rgsl); // free the random number generator
    }
    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a78dd377090622826dd80734395fba635}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}}
\index{insert\-Sample\-From\-R\-S\-Sample@{insert\-Sample\-From\-R\-S\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-S\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-S\-Sample} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{int}]{label = {\ttfamily 0}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a78dd377090622826dd80734395fba635}
\-Adaptive splitting with each data point inserted, no random number generator supplied, default will be created. 

\-Definition at line 1995 of file adaptivehistogram.\-cpp.



\-References insert\-Sample\-From\-R\-S\-Sample(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    gsl_rng * rgsl = NULL;

    try {

        const gsl_rng_type * tgsl;

        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        retValue = insertSampleFromRSSample(samplesize, rgsl, rss, boolTest,
                logging, label);

        gsl_rng_free(rgsl); // free the random number generator
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_adbfde654e0737aa2145d054a2c4a9a95}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}}
\index{insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_adbfde654e0737aa2145d054a2c4a9a95}
\-All rvectors are associated with the root paving, no splitting, random number generator supplied. 

\-Definition at line 959 of file adaptivehistogram.\-hpp.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-Collator\-::collate\-From\-R\-Vec(), and insert\-Sample\-From\-R\-Vec().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertSampleFromRVec(samplesize, rgsl, rvec,
                                    sn, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a754142aca6681e39debd7167146a7e1c}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}}
\index{insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{int}]{seed, }
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a754142aca6681e39debd7167146a7e1c}
\-All rvectors are associated with the root paving, no splitting, seed for creating a random number generator supplied. 

\-Definition at line 969 of file adaptivehistogram.\-hpp.



\-References insert\-Sample\-From\-R\-Vec().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertSampleFromRVec(samplesize, seed, rvec,
                                    sn, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aeca515a5f969a1f368ba1fe0390aa047}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}}
\index{insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_aeca515a5f969a1f368ba1fe0390aa047}
\-All rvectors are associated with the root paving, no splitting, no random number generator supplied, default will be created. 

\-Definition at line 978 of file adaptivehistogram.\-hpp.



\-References insert\-Sample\-From\-R\-Vec().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertSampleFromRVec(samplesize, rvec, sn, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2f6d7ee0d83ea148f57543f64905170d}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}}
\index{insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a2f6d7ee0d83ea148f57543f64905170d}
\-Adaptive splitting with each data point inserted, random number generator supplied. 

\-Definition at line 1635 of file adaptivehistogram.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::get\-Sample\-Rvectors\-From\-R\-Vec(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    try {

        RVecData myDataRvectors; // container for the rvectors we take in

        // try to sample data from the container, check how many data points
       found
        size_t numberTaken = getSampleRvectorsFromRVec(myDataRvectors,
                                rgsl, samplesize, rvec);

        // complete the data insertion
        if (numberTaken > 0) {
            /*  Switch on for more output
            // confirm the amount of data taken from the RSSample
            std::cout << "End of taking sample from data from the container: "
            << numberTaken << " data points used for sample" << std::endl;
            */
            retValue = completeDataInsertionFromVec(myDataRvectors,
                                                    boolTest, logging);
        }
    }
    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }


    return retValue;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8db299e8725f5170475a4c77524140dc}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}}
\index{insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{int}]{seed, }
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a8db299e8725f5170475a4c77524140dc}
\-Adaptive splitting with each data point inserted, seed for creating random number generator supplied. 

\-Definition at line 1694 of file adaptivehistogram.\-cpp.



\-References insert\-Sample\-From\-R\-Vec(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    gsl_rng * rgsl = NULL;

    try {

        const gsl_rng_type * tgsl;

        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed
        gsl_rng_set (rgsl, seed); // change the seed

        retValue = insertSampleFromRVec(samplesize, rgsl, rvec, boolTest,
            logging);

        gsl_rng_free(rgsl); // free the random number generator

    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }


    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab889a33f8caa8fb44836f756c0be342d}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}}
\index{insert\-Sample\-From\-R\-Vec@{insert\-Sample\-From\-R\-Vec}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{insert\-Sample\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::insert\-Sample\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{size\-\_\-t}]{samplesize, }
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_ab889a33f8caa8fb44836f756c0be342d}
\-Adaptive splitting with each data point inserted, no random number generator supplied, default will be created. 

\-Definition at line 1758 of file adaptivehistogram.\-cpp.



\-References insert\-Sample\-From\-R\-Vec(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    gsl_rng * rgsl = NULL;

    try {

        const gsl_rng_type * tgsl;

        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        retValue = insertSampleFromRVec(samplesize, rgsl, rvec, boolTest,
                logging);

        gsl_rng_free(rgsl); // free the random number generator
    }
    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aedb9ab3c2240403c63f2f5c1d0218350}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!log\-M\-C\-M\-C\-Deltas@{log\-M\-C\-M\-C\-Deltas}}
\index{log\-M\-C\-M\-C\-Deltas@{log\-M\-C\-M\-C\-Deltas}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{log\-M\-C\-M\-C\-Deltas}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::log\-M\-C\-M\-C\-Deltas} (
\begin{DoxyParamCaption}
\item[{std\-::string}]{s, }
\item[{int}]{i, }
\item[{real}]{delta\-L, }
\item[{real}]{delta\-P, }
\item[{real}]{delta\-Q, }
\item[{real}]{delta\-Pi, }
\item[{double}]{rand\-Change}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_aedb9ab3c2240403c63f2f5c1d0218350}


\-Send a collection of changes in \-M\-C\-M\-C probabilities to log file. 

\-The probabilities being logged are the changes in the components of the probability of acceptance of a proposed state under \-M\-C\-M\-C


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em i} & is a number indicating the state number in a chain or series of changes in state. \\
\hline
{\em delta\-L} & is the log change in likelihood. \\
\hline
{\em delta\-P} & is the log change in prior probability. \\
\hline
{\em delta\-Q} & is the log change in transition probability. \\
\hline
{\em delta\-Pi} & is the log change in posterior probability. \\
\hline
{\em rand\-Change} & is the draw from the \-Uniform (0,1) distribution which is compared to the changes in combined posterior and transition probabilities to determine whether the proposed change takes place \\
\hline
\end{DoxyParams}


\-Definition at line 423 of file adaptivehistogram.\-cpp.



\-References subpavings\-::output\-File(), and subpavings\-::try\-Exp().



\-Referenced by decision\-M\-C\-M\-C\-Merge(), and decision\-M\-C\-M\-C\-Split().


\begin{DoxyCode}
{
    RealVec vals;
    vals.push_back(deltaL);
    vals.push_back(deltaP);
    vals.push_back(deltaQ);
    vals.push_back(deltaPi+deltaQ);
    vals.push_back(log(randChange));
    vals.push_back(tryExp(deltaL));
    vals.push_back(tryExp(deltaP));
    vals.push_back(tryExp(deltaQ));
    vals.push_back(tryExp(deltaPi+deltaQ));
    vals.push_back(randChange);
    outputFile(s, vals, i);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a4e40497a24ce0807235196e17ca21456}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!make\-Box@{make\-Box}}
\index{make\-Box@{make\-Box}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{make\-Box}]{\setlength{\rightskip}{0pt plus 5cm}ivector {\bf \-Adaptive\-Histogram\-::make\-Box} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const size\-\_\-t}]{dim}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a4e40497a24ce0807235196e17ca21456}


\-Make a box to contain all the data. 

\-Used if a box has not already been provided. \-Makes a box tailored to contain all of the data. \-So all the data has to be available for input.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data \\
\hline
{\em dim} & the dimensions of the data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
an ivector same dimensions as the data and to fit all the data including an allowance for padding. 
\end{DoxyReturn}


\-Definition at line 213 of file adaptivehistogram.\-cpp.



\-References padding.



\-Referenced by have\-Made\-Paving().


\begin{DoxyCode}
{
    // set up a vector of maxes
    vector<real> maxs;

    // give maxs starting values from the first element in the rvectors
    rvector first = *theData.begin();

    for (size_t i = 1; i <=dim; i++) {
        maxs.push_back(first[i]);
    }

    // make mins the same as maxes to start with
    vector<real> mins = maxs;

    RVecDataCItr cit;

    // go over the rest of the container
    for(cit = theData.begin()+1; cit < theData.end(); cit++) {
        for (size_t i = 1; i <= dim; i++) {
            real r = (*cit)[i];
            // vectors indexed 0 - n-1, rvectors ndexed 1 - n
            if(r < mins[i-1]) {
                mins[i-1] = r;
            }
            if(r > maxs[i-1]) {
                maxs[i-1] = r;
            }
        } // end going through rvector elements
    } // end going through rvectors

    ivector retVal(dim);    // set up an ivector to become the return value

    // and make each interval the (min, max) of the corresponding elements
    // of the rvectors -/+ some padding

    std::cout << "A box is being made for the data.  "
        << "The box is " << std::endl;  // standard output message

    // make intervals and make them elements of the ivector
    for (size_t i = 1; i <=dim; i++) {
        interval myInterval(mins[i-1]-padding, maxs[i-1]+padding);
        std::cout << myInterval << "  ";    // output
        retVal[i]=myInterval;
    }
    std::cout << std::endl;

    return retVal;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8f3844b0b56fb1aaa96c44558dd8e4a4}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!make\-Empty@{make\-Empty}}
\index{make\-Empty@{make\-Empty}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{make\-Empty}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::make\-Empty} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a8f3844b0b56fb1aaa96c44558dd8e4a4}


\-Clear the histogram's data and counters. 

\-Clear the histogram's data and counter 

\-Definition at line 3638 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), and get\-Sub\-Paving().



\-Referenced by get\-Est\-Log\-Likelihood\-From\-R\-S\-Sample().


\begin{DoxyCode}
{
  SPSnodePtrs leaves; // set up empty container for leaf node pointers
  SPSnodePtrsItr it; // and an iterator over the container
   getSubPaving()->getLeaves(leaves); // fill the container
   for(it = leaves.begin(); it < leaves.end(); it++) {
    (*it)->makeEmptyNode();
  }
} 
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a733cc04938b2236087cbbe0384985c3d}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-M\-C\-M\-C@{\-M\-C\-M\-C}}
\index{\-M\-C\-M\-C@{\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{unsigned int}]{loops, }
\item[{unsigned int}]{burnin, }
\item[{unsigned int}]{thinout, }
\item[{{\bf \-M\-C\-M\-C\-Proposal} \&}]{proposal, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior, }
\item[{size\-\_\-t}]{min\-Points = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a733cc04938b2236087cbbe0384985c3d}


\-Outputting \-M\-C\-M\-C samples from histogram state space. 

\-The leaves of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree represent the partition of the data space (the root box of the tree). \-A histogram state is a particular partition of the root box which will be represented by a particular tree number and disposition of nodes of the tree.

\-The \-Markov-\/\-Chain \-Monte \-Carlo process considers possible histogram states, given data, as a probability distribution. \-In this implementation the the \-Metropolis-\/\-Hastings algorithm is used on the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \-Adaptive \-Histogram to generate samples from the histogram state probability density.

\-M\-C\-M\-C requires a prior distribution over the state space and a likelihood of being in a particular state given the data, from which can be found (up to proportionality) a posterior distribution proportional to the likelihood x prior.

\-A change in state can take place by either splitting a leaf node (bisecting the box represesented by that leaf and sending the data associated with the box down to the two new children) or absorbing two sibling leaf nodes back into their parent so that that parent becomes a leaf of the tree. \-The parent node of two sibling leaf nodes is referred to as a 'cherry' and the reabsorbtion of the sibling leaf children of a cherry is referred to as 'merging' a cherry.

min\-Points restricts the possible states by not allowing the chain to include a state where a leaf node has less than min\-Points data points associated with it, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points $>$= min\-Points. \-The final condition allows a node to be split when all the data goes to just one child provided that the number of points in the node $>$= min\-Points so that the process can 'home in' on small peaks of data.

\-When min\-Points $>$ 0, proposals are effectively drawn from set of leaf and cherry nodes which does not include any leaf which, if split, would have a child whose number of points is $<$ min\-Points, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points $>$= min\-Points. \-Thus the implementation needs to distinguish between the overall state of the tree and the set of {\bfseries splittable leaf nodes}.

\-The method can collate thinned out samples from the chain of states generated from the \-Markov \-Chain process and average them, outputting txt file represenations of the collation and the average.

\-The method can log the process, including the components of the calculation for each change in state and .dot graphs for each state in the chain.


\begin{DoxyParams}{\-Parameters}
{\em loops} & how many states in the chain to generate altogether, (ie including burnin). \\
\hline
{\em burnin} & how many states to consider as burnin, ie the number of changes in state required for the process to forget its starting state. \\
\hline
{\em thinout} & what step size to use in sampling for averaging. \-If thinout $>$ 0, an average histogram is created by collating the first state in the chain after burnin states together with samples taken from the chain with thinout stepsize. \-Txt and .dot file representions of the sampling process and the collation and the average are output. \\
\hline
{\em proposal} & is a reference to the proposal distribution object. \\
\hline
{\em log\-Prior} & is a reference to the prior distribution object. \\
\hline
{\em min\-Points} & is the minimum number of points to allow in a box represented by a leaf in the \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} tree (defaults to 0). \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to log files (defaults to no logging). \-T\-X\-T gives logging to a txt file, \-T\-X\-T\-A\-N\-D\-G\-R\-A\-P\-H gives txt file logging and graphs, \-L\-O\-G\-S\-A\-M\-P\-L\-E\-S does a txt log file for samples only, \-L\-O\-G\-A\-N\-D\-G\-R\-A\-P\-H\-S\-A\-M\-P\-L\-E\-S does a txt log file and dot graphs for samples only \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if \-M\-C\-M\-C successfully carried out for required number of states in the chain (loops through the \-M\-C\-M\-C routine), false otherwise. 
\end{DoxyReturn}


\-Definition at line 3044 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-Adaptive\-Histogram\-Collator\-::add\-To\-Collation(), \-M\-C\-M\-Csamples(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::output\-Average\-To\-Txt\-Tabs(), output\-M\-C\-M\-C\-State\-Sample(), and subpavings\-::\-Adaptive\-Histogram\-Collator\-::output\-To\-Txt\-Tabs().



\-Referenced by main().


\begin{DoxyCode}
{
  try {

    bool thinning = (thinout > 0);

    std::vector < AdaptiveHistogram > samples;
    
    samples = MCMCsamples(samples, 
            loops, burnin,
            thinout,
            proposal, logPrior,
            minPoints, logging);
    
    bool good = true;
    
    if (thinning && ( loops > 0)
        && ( samples.size() < (loops - burnin)/thinout + 1) ) {
      good = false;
    }
    else if (thinning) {
      
      // make a collation object, empty at present
      AdaptiveHistogramCollator coll;

      for (size_t i = 0; i < samples.size(); ++i) {
        // output and collate the sample state;
        (samples[i]).outputMCMCStateSample(i);
        coll.addToCollation(samples[i]);
      }
    
        std::string collFileName = "CollatorMCMC.txt";
            coll.outputToTxtTabs(collFileName); // output the collation to file

            //  Average the sampled histograms
            std::string avFileName = "AverageMCMC.txt";     // provide a
       filename

            coll.outputAverageToTxtTabs(avFileName);  // output the average to
       file
        }

    return good;
        
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error  in MCMC:\n " + oldmsg;
        throw HistException(msg);
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a10fc830a1dd32fe83aa3846a6fb2af35}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-M\-C\-M\-C\-Log\-Final\-State@{\-M\-C\-M\-C\-Log\-Final\-State}}
\index{\-M\-C\-M\-C\-Log\-Final\-State@{\-M\-C\-M\-C\-Log\-Final\-State}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-M\-C\-M\-C\-Log\-Final\-State}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::\-M\-C\-M\-C\-Log\-Final\-State} (
\begin{DoxyParamCaption}
\item[{std\-::string}]{s, }
\item[{int}]{i}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a10fc830a1dd32fe83aa3846a6fb2af35}


\-Capture the final state of this histogram after \-M\-C\-M\-C. 


\begin{DoxyParams}{\-Parameters}
{\em s} & is the name of the file to log the final state to. \\
\hline
{\em i} & is a number indicating the state number in a chain or series of changes in state. \\
\hline
\end{DoxyParams}


\-Definition at line 484 of file adaptivehistogram.\-cpp.



\-References get\-Leaf\-Levels\-String(), subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), and output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R().



\-Referenced by \-M\-C\-M\-Csamples().


\begin{DoxyCode}
{
    outputLog(s, i);
    // output AIC score information
    outputLogEMPAIC(s);
    // output COPERR score information
    outputLogEMPCOPERR(s);
    // log the leaf levels line
    outputFile(s, getLeafLevelsString());

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aac9ce6681faa011b3c314ff400056dd9}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-M\-C\-M\-Csamples@{\-M\-C\-M\-Csamples}}
\index{\-M\-C\-M\-Csamples@{\-M\-C\-M\-Csamples}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-M\-C\-M\-Csamples}]{\setlength{\rightskip}{0pt plus 5cm}std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \& {\bf \-Adaptive\-Histogram\-::\-M\-C\-M\-Csamples} (
\begin{DoxyParamCaption}
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{samples, }
\item[{unsigned int}]{loops, }
\item[{unsigned int}]{burnin, }
\item[{unsigned int}]{thinout, }
\item[{{\bf \-M\-C\-M\-C\-Proposal} \&}]{proposal, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior, }
\item[{size\-\_\-t}]{min\-Points, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aac9ce6681faa011b3c314ff400056dd9}


\-Generating \-M\-C\-M\-C samples from histogram state space. 

\-The leaves of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree represent the partition of the data space (the root box of the tree). \-A histogram state is a particular partition of the root box which will be represented by a particular tree number and disposition of nodes of the tree.

\-The \-Markov-\/\-Chain \-Monte \-Carlo process considers possible histogram states, given data, as a probability distribution. \-In this implementation the the \-Metropolis-\/\-Hastings algorithm is used on the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \-Adaptive \-Histogram to generate samples from the histogram state probability density.

\-M\-C\-M\-C requires a prior distribution over the state space and a likelihood of being in a particular state given the data, from which can be found (up to proportionality) a posterior distribution proportional to the likelihood x prior.

\-A change in state can take place by either splitting a leaf node (bisecting the box represesented by that leaf and sending the data associated with the box down to the two new children) or absorbing two sibling leaf nodes back into their parent so that that parent becomes a leaf of the tree. \-The parent node of two sibling leaf nodes is referred to as a 'cherry' and the reabsorbtion of the sibling leaf children of a cherry is referred to as 'merging' a cherry.

min\-Points restricts the possible states by not allowing the chain to include a state where a leaf node has less than min\-Points data points associated with it, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points $>$= min\-Points. \-The final condition allows a node to be split when all the data goes to just one child provided that the number of points in the node $>$= min\-Points so that the process can 'home in' on small peaks of data.

\-When min\-Points $>$ 0, proposals are effectively drawn from set of leaf and cherry nodes which does not include any leaf which, if split, would have a child whose number of points is $<$ min\-Points, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points $>$= min\-Points. \-Thus the implementation needs to distinguish between the overall state of the tree and the set of {\bfseries splittable leaf nodes}.

\-The method can collate thinned out samples from the chain of states generated from the \-Markov \-Chain process and average them, outputting txt file represenations of the collation and the average.

\-The method can log the process, including the components of the calculation for each change in state and .dot graphs for each state in the chain.


\begin{DoxyParams}{\-Parameters}
{\em samples} & is a reference to a container to add \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} samples to. \\
\hline
{\em loops} & how many states in the chain to generate altogether, (ie including burnin). \\
\hline
{\em burnin} & how many states to consider as burnin, ie the number of changes in state required for the process to forget its starting state. \\
\hline
{\em thinout} & what step size to use in sampling for averaging. \-If thinout $>$ 0, samples are the first state in the chain after burnin states together with samples taken from the chain with thinout stepsize. \\
\hline
{\em proposal} & is a reference to the proposal distribution object. \\
\hline
{\em log\-Prior} & is a reference to the prior distribution object. \\
\hline
{\em min\-Points} & is the minimum number of points to allow in a box represented by a leaf in the \hyperlink{classsubpavings_1_1SPnode}{\-S\-Pnode} tree (defaults to 0). \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to log files (defaults to no logging). \-T\-X\-T gives logging to a txt file, \-T\-X\-T\-A\-N\-D\-G\-R\-A\-P\-H gives txt file logging and graphs, \-L\-O\-G\-S\-A\-M\-P\-L\-E\-S does a txt log file for samples only, \-L\-O\-G\-A\-N\-D\-G\-R\-A\-P\-H\-S\-A\-M\-P\-L\-E\-S does a txt log file and dot graphs for samples only \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
the reference to the container of samples if \-M\-C\-M\-C successfully carried out for required number of states in the chain empty container otherwise. 
\end{DoxyReturn}


\-Definition at line 3102 of file adaptivehistogram.\-cpp.



\-References change\-M\-C\-M\-C\-State(), check\-Node\-Count\-For\-Split(), get\-Leaf\-Levels\-String(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Sub\-Leaves(), get\-Sub\-Paving(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-L\-O\-G\-A\-N\-D\-G\-R\-A\-P\-H\-S\-A\-M\-P\-L\-E\-S, subpavings\-::\-L\-O\-G\-S\-A\-M\-P\-L\-E\-S, subpavings\-::make\-Dot\-Image(), \-M\-C\-M\-C\-Log\-Final\-State(), \-M\-C\-M\-C\-Start\-Log\-File(), subpavings\-::output\-File(), output\-Graph\-Dot(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), subpavings\-::\-T\-X\-T, and subpavings\-::\-T\-X\-T\-A\-N\-D\-G\-R\-A\-P\-H.



\-Referenced by main(), and \-M\-C\-M\-C().


\begin{DoxyCode}
{
  
    gsl_rng * rgsl = NULL;

    try {
    
    bool cancontinue = false;

    if (NULL == getSubPaving()) {
      throw HistException("No root paving for MCMC histogram");
    }
    
    if (burnin > loops) {
      throw HistException("burnin > loops");
    }
    
    bool thinning = (thinout > 0);
  
    if (thinning) {
      samples.reserve(samples.size() + (loops - burnin)/thinout + 1);
    }

        // for logging
        int i = 0;
        std::string s = "";
        std::string dot = "";
        if ((logging == TXT) || (logging == TXTANDGRAPH)
                || (logging == LOGSAMPLES) || (logging == LOGANDGRAPHSAMPLES)
        || thinning) {

            // pass to log output to keep track of splits
            std::string baseFileName = "MCMCOutput";
            s = getUniqueFilename(baseFileName);

            if (logging == TXTANDGRAPH) {

                // for dot graph
                baseFileName = "graph";
                std::string suffix = ".dot";
                dot = getUniqueFilename(baseFileName, suffix);
                outputFile(dot, "digraph G {"); // opening line
            }
        }

        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        // check input parameters
        if (loops - burnin < 0) {
            std::cerr << "Try again: number of loops is less than burnin"
                    <<std::endl;
        }
        else if (thinout > 0 && ((loops-burnin)/thinout < 1)) {
            std::cerr << "Try again: thinout value means no samples will be
       taken"
                    <<std::endl;
        }
        else cancontinue = true;

        // set up a container for the leaf children
        SPSnodePtrs leafVec;
        // set up a container for the subleaf children
        SPSnodePtrs cherryVec;
        SPSnodeList nodes;
         //lists better than vectors for random access removal
        size_t numLeaves = 0;
        size_t numCherries = 0;

        if (cancontinue) {

            // fill the container with the leaf children
            getSubPaving()->getLeaves(leafVec);

            // fill the container with the subleaf children
            getSubPaving()->getSubLeaves(cherryVec);

            numCherries = cherryVec.size();

            if (!leafVec.empty()) {
                // but only put into the container the leaves which, if split,
                // would have at least minPoints data points associated with
       them

                SPSnodePtrsItr lit;
                for (lit = leafVec.begin(); lit < leafVec.end(); lit++) {
                    if (checkNodeCountForSplit((*lit), false, 0.0, minPoints))
                    {
                        // leaf can go into container
                        nodes.push_back(*lit);
                        numLeaves++;
                    }
                }
            }

            // no need to check on cherries - they can all go in
            if (numCherries > 0)
                nodes.insert(nodes.end(), cherryVec.begin(),cherryVec.end());

            if (nodes.size() == 0) {
                cancontinue = false;
                std::cerr << "No changeable nodes given minPoints = "
                            << minPoints << ". Sorry, aborting MCMC." << 
      std::endl;
            }
        }

        bool goodLoop = cancontinue;

        if (cancontinue && ((logging == TXT) || (logging == TXTANDGRAPH)
                                            || thinning)) {

            MCMCStartLogFile(s, i, proposal, logPrior);
        }

        i++;

        std::string stateNow = "";
        std::string stateAfter = "";

        // make a collation object, empty at present
        //AdaptiveHistogramCollator coll;

        // loop from here conditional on good loop and cancontinue
        while (goodLoop && (loops > 0) ) {

            // capture state now
            stateNow = "\"" + getLeafLevelsString() + "\"";
            loops--;

            // changeMCMCState updates nodes, numLeaves, numCherries, i
            goodLoop = changeMCMCState(nodes, numLeaves, numCherries, proposal,
                        logPrior, minPoints, rgsl, logging, s, i);

            if (goodLoop) {
                if ((logging == TXT) || (logging == TXTANDGRAPH)) {
                    // log the current state of the histogram
                    outputLog(s, i);
                    outputLogEMPAIC(s);
                }

                if (i >= burnin && (logging == TXTANDGRAPH)) {
                    // capture state after split or merge to graph file

                    stateAfter = "\"" + getLeafLevelsString() + "\"";
                    std::string line = "\t " + stateNow + " -> " + stateAfter +
       ";";
                    outputFile(dot, line);

                    outputGraphDot(); // and make a graph of current state
                }

                if ((numLeaves == 0 && numCherries == 0)) {
                    throw HistException("No more leaves or cherries in MCMC");

                }

                // if we are taking samples take the sample here
                if (goodLoop && thinning && (i >= burnin) &&
                        ((i-burnin)%thinout == 0)) {

                    // output and collate the sample state;
                    //outputMCMCStateSample(i);
                    
                    //coll.addToCollation(*this);
          samples.push_back(*this);
          
                    if (logging == LOGSAMPLES || logging == LOGANDGRAPHSAMPLES)
       {
                        // log this sample to log file
                        outputLog(s, i);
                        outputLogEMPAIC(s); // add AIC scores
                    }
                    if (logging == LOGANDGRAPHSAMPLES) outputGraphDot();

                }
            }

            i++;
            // back into loop
        }
        // finished loop
        cancontinue = goodLoop;

        if (cancontinue && ((logging == TXT) || (logging == TXTANDGRAPH))) {
            i--; // this histogram is full state from last pass
            // To add final state of histogram to log file
            MCMCLogFinalState(s, i);
            if (logging == TXTANDGRAPH) {
                // close the dot graph of the changes process
                outputFile(dot, "}"); // closing line

                // make the graph image
                makeDotImage(dot);
            }
        }

    /*
        if (cancontinue && thinning) {
            std::string collFileName = "CollatorMCMC.txt";
            coll.outputToTxtTabs(collFileName); // output the collation to file

            //  Average the sampled histograms
            std::string avFileName = "AverageMCMC.txt";     // provide a
       filename

            coll.outputAverageToTxtTabs(avFileName);  // output the average to
       file
        }
    */
        // free the random number generator
        
        gsl_rng_free (rgsl);
        
        if (!cancontinue) { //empty out the samples if loop failed
      std::vector< AdaptiveHistogram > tmp;
      tmp.swap(samples);
    }
        
        return samples;
    }
    
    catch (exception& e) {
    try {
      if (NULL != rgsl) gsl_rng_free(rgsl); 
      // free the random number generator
    }
    catch (exception& ee) {} // catch and swallow
    
        throw HistException("Error  in MCMCsamples:\n" 
              + string(e.what()));
    }

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_adf589f52a0cd3e2371c288aa6bca7d37}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!\-M\-C\-M\-C\-Start\-Log\-File@{\-M\-C\-M\-C\-Start\-Log\-File}}
\index{\-M\-C\-M\-C\-Start\-Log\-File@{\-M\-C\-M\-C\-Start\-Log\-File}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{\-M\-C\-M\-C\-Start\-Log\-File}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::\-M\-C\-M\-C\-Start\-Log\-File} (
\begin{DoxyParamCaption}
\item[{std\-::string}]{s, }
\item[{int}]{i, }
\item[{const {\bf \-M\-C\-M\-C\-Proposal} \&}]{proposal, }
\item[{const {\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_adf589f52a0cd3e2371c288aa6bca7d37}


\-Put header in a log file for \-M\-C\-M\-C. 


\begin{DoxyParams}{\-Parameters}
{\em s} & is the name of the file to log the final state to. \\
\hline
{\em i} & is a number indicating the state number in a chain or series of changes in state. \\
\hline
{\em proposal} & a reference to a proposal function object. \\
\hline
{\em log\-Prior} & a reference to a log prior function object. \\
\hline
\end{DoxyParams}


\-Definition at line 444 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-Log\-M\-C\-M\-C\-Prior\-::get\-Name(), subpavings\-::\-M\-C\-M\-C\-Proposal\-::get\-Name(), subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R(), and output\-Log\-Start().



\-Referenced by \-M\-C\-M\-Csamples().


\begin{DoxyCode}
{
    // Start log file with filename and timestamp
    outputLogStart(s);
    // put in the name of the proposal and prior
    std::string line = "Prior is " + logPrior.getName();
    line += ", proposal is " + proposal.getName();
    outputFile(s, line);
    // log the current state of the histogram
    outputLog(s, i);
    // output AIC score information
    outputLogEMPAIC(s);
    // output COPERR score information
    outputLogEMPCOPERR(s);
    std::string headers = "deltaL \t deltaP \t deltaQ \t deltaPi&Q \t ln(rand)"
      ;
    headers += "\t ratioL \t ratioP \t ratioQ \t ratioPi&Q \t rand";
    outputFile(s, headers);

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a745b6edb93463e227edb9c9aa1dcb505}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!merge\-Up@{merge\-Up}}
\index{merge\-Up@{merge\-Up}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{merge\-Up}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::merge\-Up} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a745b6edb93463e227edb9c9aa1dcb505}


\-Merge a multileaf histogram up to just root box. 

\-No prioritistion, just brute force 

\-Definition at line 2875 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Parent(), subpavings\-::\-S\-P\-Snode\-::get\-Sub\-Leaves(), subpavings\-::\-S\-Pnode\-::has\-Leaf\-Sibling(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-S\-P\-Snode\-::node\-Reabsorb\-Children(), recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), root\-Paving, subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool cancontinue = false;

    if (NULL == rootPaving) {
        throw HistException("No root paving for mergeUp");

    }

    try {

        if (rootPaving->isLeaf()) {
            cancontinue = false;
            std::cerr << "Nothing to be done - root paving is already a leaf "
                    << std::endl;
        }
        else cancontinue = true;

        SPSnodePtrs subleaves;

        if (cancontinue) {
            rootPaving->getSubLeaves(subleaves); // subleaves contains the
       subleaves
            cancontinue = (subleaves.size()>0);
        }

        if(!cancontinue) {
            throw HistException("Error in mergeUp getting subleaves, aborting
       merge");
        }

        bool canmerge = cancontinue;

        // merge until there is only one leaf
        while (canmerge) {

            SPSnode* target = *(subleaves.rbegin ()); // the last in the vector

            // subtract the child names from the creation string
                creationString += (" -(" + target->getChildNodeNames() + ")");

            // merge the biggest one
            target->nodeReabsorbChildren();
            SPSnodePtrsItr it = subleaves.end();
            it--;
            subleaves.erase(it, subleaves.end());// take the last out of the
       vector

            // if target had a leaf sibling, target's parent is now a cherry
            // and should be inserted into the multiset
            if (target->hasLeafSibling()) {

                subleaves.push_back(target->getParent());
           }

            canmerge = (subleaves.size()>0);
        }

        if(!canmerge) {
            std::cerr << "Merged to root" << std::endl;
        }

        // EMPSums are not adjusted during the merging process
        recalcScaledEMPSumAIC();
        recalcScaledEMPSumCOPERR();
    }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory in mergeUp.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in mergeUp.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in mergeUp.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in mergeUp.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a962f179df0a65d5f179930d00e65b70e}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!operator+@{operator+}}
\index{operator+@{operator+}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{operator+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram} \-Adaptive\-Histogram\-::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf \-Adaptive\-Histogram} \&}]{rhs}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a962f179df0a65d5f179930d00e65b70e}


\-Overloaded addition operator. 

\-Makes a new histogram by adding this and rhs together. \-The subpaving will be the union of the subpavings of this and rhs. \-Data is reinserted into the new histogram so that the counts in each box of the subpaving are exactly right for that subpaving. \-This is in contrast to the way that the \hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator} works (divides a count evenly in two when apportioning it between bisected boxes). hold\-All\-Stats will be set to the logical and of the values for this and rhs. 

\-Definition at line 1166 of file adaptivehistogram.\-cpp.



\-References data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Box(), get\-Hold\-All\-Stats(), insert\-From\-R\-Vec(), taylor\-::\-Lb(), subpavings\-::\-N\-O\-L\-O\-G, root\-Paving, taylor\-::\-Ub(), and subpavings\-::\-S\-P\-Snode\-::union\-Tree\-Structure().


\begin{DoxyCode}
{
    if (((NULL != rootPaving) && (NULL != rhs.rootPaving)) &&
    ((Ub(rootPaving->getBox()) != Ub(rhs.rootPaving->getBox()))
    || (Lb(rootPaving->getBox()) != Lb(rhs.rootPaving->getBox()))))
        throw HistException("Added histograms have unequal dimensions");

    SPSnode* newRoot = NULL;

    try {


        newRoot = SPSnode::unionTreeStructure(rootPaving,
                                            rhs.rootPaving);
    }
    catch (bad_alloc& ba) {
        string msg(ba.what());
        std::cerr << "Error allocating memory in constructor: original error "
                                    << msg << std::endl;
        throw HistException("Memory allocation rrror in constructor: " + msg);
    }

    bool hold = (getHoldAllStats() && rhs.getHoldAllStats());

    AdaptiveHistogram newHist(newRoot, hold);

    // put all the data from the two histograms into this one.
    RVecData allData;

    allData.reserve( dataCollection.size() + rhs.dataCollection.size() );
    // copy from this dataCollection into allData;
    allData.assign(dataCollection.begin(), dataCollection.end());
    allData.insert(allData.end(), rhs.dataCollection.begin(),
            rhs.dataCollection.end());

    // and put the data into the histogram
    newHist.insertFromRVec(allData, NOLOG);

    return newHist;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a3adb7a4fce51ec497ef30dea633249fd}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!operator=@{operator=}}
\index{operator=@{operator=}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram} \& \-Adaptive\-Histogram\-::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf \-Adaptive\-Histogram} \&}]{rhs}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a3adb7a4fce51ec497ef30dea633249fd}


\-Copy assignment operator. 



\-Definition at line 1119 of file adaptivehistogram.\-cpp.



\-References creation\-String, data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), hold\-All\-Stats, recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), root\-Box, root\-Paving, scaled\-E\-M\-P\-Sum\-A\-I\-C, scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
{
    try {

        // we have to make sure we delete the current paving
        if (NULL != rootPaving) {
            delete rootPaving;
            rootPaving = NULL;
        }

        if (NULL != rhs.rootPaving) {
            rootPaving = new SPSnode(*(rhs.rootPaving));
            creationString = rootPaving->getNodeName();
            creationString += rootPaving->getChildNodeNames();

            //copy dataCollection from other to this
            dataCollection = rhs.dataCollection;

            rhs.recalcScaledEMPSumAIC();
            rhs.recalcScaledEMPSumCOPERR();
            scaledEMPSumCOPERR = rhs.scaledEMPSumCOPERR;
            scaledEMPSumAIC = rhs.scaledEMPSumAIC;
            holdAllStats = rhs.holdAllStats;
        }
        rootBox = rhs.rootBox;
        return *this;
    }
    catch (bad_alloc& ba) {
        std::cerr << "Error allocating memory in constructor" << std::endl;
        throw HistException("Error in constructor");
    }
    catch (SPnodeException& spe) {
        string msg(spe.what());
        std:: cerr << "SPnodeExcepton in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Error in constructor");
    }
    catch (exception& e) {
        string msg(e.what());
        std:: cerr << "Error in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Error in constructor");
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a845c591145a1abc86d7d0e1d33c26e22}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-Graph\-Dot@{output\-Graph\-Dot}}
\index{output\-Graph\-Dot@{output\-Graph\-Dot}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-Graph\-Dot}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::output\-Graph\-Dot} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a845c591145a1abc86d7d0e1d33c26e22}


\-Make a .dot graph file from histogram structure. 

\-Makes a simple .dot graph from the histogram using node names and the .png image for this graph.

\begin{DoxyPrecond}{\-Precondition}
a constructed histogram 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
a .dot file and a .png in the same directory as the program creating it was run in. 
\end{DoxyPostcond}


\-Definition at line 3528 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::output\-Graph\-Dot(), and root\-Paving.



\-Referenced by main(), and \-M\-C\-M\-Csamples().


\begin{DoxyCode}
{
    bool success = false;

    if (NULL != rootPaving) {
        success = rootPaving->outputGraphDot();

    }
    else {
        std::cerr << "Sorry, you can't make a graph without a root paving"
                << std::endl;
    }
    return success;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8e1ee4de108b97c04c38ccb16c392e5f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-Log@{output\-Log}}
\index{output\-Log@{output\-Log}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-Log}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-Log} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const int}]{i}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a8e1ee4de108b97c04c38ccb16c392e5f}


\-Append current state of histogram to a txt log file. 

\-Format is a tab-\/delimited file of numeric data. \-Output includes node contributions to unscaled \-E\-M\-P under \-C\-O\-P\-E\-R\-R and \-A\-I\-C and the changes in \-E\-M\-P that would result from splitting the node.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em i} & the number of pass (ie, 0, 1, 2, 3 etc) in process \\
\hline
\end{DoxyParams}


\-Definition at line 383 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Sub\-Paving(), subpavings\-::\-S\-P\-Snode\-::leaves\-Output\-Tabs\-With\-E\-M\-Ps(), and root\-Paving.



\-Referenced by insert\-Data\-From\-Container(), insert\-One(), \-M\-C\-M\-C\-Log\-Final\-State(), \-M\-C\-M\-Csamples(), \-M\-C\-M\-C\-Start\-Log\-File(), priority\-Merge(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), priority\-Split\-With\-Total\-Var(), and public\-Log\-M\-C\-M\-C\-Sample().


\begin{DoxyCode}
{
    // To add output of the AdaptiveHistogram object to file
    ofstream os(s.c_str(), ios::app);         // append
    if (os.is_open()) {
        size_t n = rootPaving->getCounter();

        os << std::endl;
        os << "Pass " << i << std::endl; // numbering
        os << creationString << std::endl; // creation string so far
        getSubPaving()->leavesOutputTabsWithEMPs(n, os); // the output
        os.close();
    }
    else {
        std::cerr << "Error: could not open file named "
            << s << std::endl << std::endl;
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a602b8b4081d3cae20308aa6644a83fa9}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-Log\-E\-M\-P\-A\-I\-C@{output\-Log\-E\-M\-P\-A\-I\-C}}
\index{output\-Log\-E\-M\-P\-A\-I\-C@{output\-Log\-E\-M\-P\-A\-I\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-Log\-E\-M\-P\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-Log\-E\-M\-P\-A\-I\-C} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a602b8b4081d3cae20308aa6644a83fa9}


\-Add \-A\-I\-C \-E\-M\-P score to log file. 

\-Tab delimited 
\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
\end{DoxyParams}


\-Definition at line 518 of file adaptivehistogram.\-cpp.



\-References scaled\-E\-M\-P\-Sum\-A\-I\-C.



\-Referenced by \-M\-C\-M\-C\-Log\-Final\-State(), \-M\-C\-M\-Csamples(), \-M\-C\-M\-C\-Start\-Log\-File(), priority\-Merge(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), priority\-Split\-With\-Total\-Var(), and public\-Log\-M\-C\-M\-C\-Sample().


\begin{DoxyCode}
{
    // To add output of the AdaptiveHistogram object to file
    ofstream os(s.c_str(), ios::app);         // append

    if (os.is_open()) {
        real emp = rnd(scaledEMPSumAIC);
        os << std::endl << "AIC EMP is \t" << emp;
        os.close();
    }
    else {
        std::cerr << "Error: could not open file named "
            << s << std::endl << std::endl;
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ad2360173a5963ecbca37e0a78ce98879}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R@{output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R}}
\index{output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R@{output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ad2360173a5963ecbca37e0a78ce98879}


\-Add \-C\-O\-P\-E\-R\-R \-E\-M\-P score to log file. 

\-Tab delimited 
\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
\end{DoxyParams}


\-Definition at line 500 of file adaptivehistogram.\-cpp.



\-References scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R.



\-Referenced by \-M\-C\-M\-C\-Log\-Final\-State(), and \-M\-C\-M\-C\-Start\-Log\-File().


\begin{DoxyCode}
{
    // To add output of the AdaptiveHistogram object to file
    ofstream os(s.c_str(), ios::app);         // append
    if (os.is_open()) {

        real emp = rnd(scaledEMPSumCOPERR);
        os << std::endl << "COPERR EMP is \t" << emp;
        os.close();
    }
    else {
        std::cerr << "Error: could not open file named "
            << s << std::endl << std::endl;
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aa73a46279c3f591d298a0180d99723a5}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-Log\-Plain@{output\-Log\-Plain}}
\index{output\-Log\-Plain@{output\-Log\-Plain}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-Log\-Plain}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-Log\-Plain} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const int}]{i}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_aa73a46279c3f591d298a0180d99723a5}


\-Append current state of histogram to a txt log file. 

\-Format is a tab-\/delimited file of numeric data. \-Output is plain\-: just vols, counters, and boxes.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em i} & the number of pass (ie, 0, 1, 2, 3 etc) in process \\
\hline
\end{DoxyParams}


\-Definition at line 4703 of file adaptivehistogram.\-cpp.



\-References get\-Sub\-Paving(), and subpavings\-::\-S\-P\-Snode\-::leaves\-Output\-Tabs().


\begin{DoxyCode}
{
    // To add output of the AdaptiveHistogram object to file
    ofstream os(s.c_str(), ios::app);         // append
    if (os.is_open()) {
        os << std::endl;
        os << "Pass " << i << std::endl; // numbering
        getSubPaving()->leavesOutputTabs(os); // the output
        os.close();
    }
    else {
        std::cerr << "Error: could not open file named "
            << s << std::endl << std::endl;
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ad847a4add7e72eac564daa44835dba5b}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-Log\-Start@{output\-Log\-Start}}
\index{output\-Log\-Start@{output\-Log\-Start}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-Log\-Start}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-Log\-Start} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ad847a4add7e72eac564daa44835dba5b}


\-Opening line of a txt log file. 

\-Starts the log file with file name and date and time 
\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
\end{DoxyParams}


\-Definition at line 404 of file adaptivehistogram.\-cpp.



\-Referenced by insert\-Data\-From\-Container(), insert\-One(), \-M\-C\-M\-C\-Start\-Log\-File(), priority\-Merge(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), and priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
{
    // Make a string with filename and timestamp to start log file
    time_t rawtime;
    struct tm * timeinfo;
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    ofstream os(s.c_str());         // replace data
    if (os.is_open()) {
        os << "File " << s << " created " <<  asctime (timeinfo) << std::endl;
        os.close();
    }
    else {
        std::cerr << "Error: could not open file named "
            << s << std::endl << std::endl;
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a4e7d34aea502906cb2230c0732d752b3}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-M\-C\-M\-C\-State\-Sample@{output\-M\-C\-M\-C\-State\-Sample}}
\index{output\-M\-C\-M\-C\-State\-Sample@{output\-M\-C\-M\-C\-State\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-M\-C\-M\-C\-State\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-M\-C\-M\-C\-State\-Sample} (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a4e7d34aea502906cb2230c0732d752b3}


\-Output the state of this histogram as an \-M\-C\-M\-C sample. 


\begin{DoxyParams}{\-Parameters}
{\em i} & is a number indicating the state number in a chain or series of changes in state. \\
\hline
\end{DoxyParams}


\-Definition at line 466 of file adaptivehistogram.\-cpp.



\-References output\-To\-Txt\-Tabs().



\-Referenced by \-M\-C\-M\-C().


\begin{DoxyCode}
{
    // create a name for the file to output
    std::string sampleFileName = "MCMCSample";
    //convert i to a string
    std::ostringstream stm;
    stm << i;

    // add the stringed i to the filename
    sampleFileName += stm.str();
    sampleFileName += ".txt"; // and finish the filename

    // To realize a file output
    outputToTxtTabs(sampleFileName);

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a35416eefb965755a846e1bb64c882439}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-Root\-To\-Txt@{output\-Root\-To\-Txt}}
\index{output\-Root\-To\-Txt@{output\-Root\-To\-Txt}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-Root\-To\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-Root\-To\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{bool}]{confirm = {\ttfamily false}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a35416eefb965755a846e1bb64c882439}


\-Output details of full sample (from root) to txt tile. 

\-Format is a mixture of alpha and numeric data.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em confirm} & is a boolean controlling whether confirmation goes to console output (defaults to false). \\
\hline
\end{DoxyParams}


\-Definition at line 3595 of file adaptivehistogram.\-cpp.



\-References get\-Sub\-Paving(), subpavings\-::\-S\-P\-Snode\-::node\-Print(), and root\-Paving.


\begin{DoxyCode}
{
    if (NULL != rootPaving) {

        // To generate a file output of root node of the AdaptiveHistogram
        ofstream os(s.c_str());         // Filename, c-string version
        getSubPaving()->nodePrint(os); // the output
        if (confirm)
            std::cout << "Details of the root paving of the AdaptiveHistogram "
                << "has been written to " << s << std::endl << std::endl;
    }

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a49a8ff01e1398420cd45642d5b1d3106}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-To\-Txt\-Tabs@{output\-To\-Txt\-Tabs}}
\index{output\-To\-Txt\-Tabs@{output\-To\-Txt\-Tabs}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-To\-Txt\-Tabs}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-To\-Txt\-Tabs} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{bool}]{confirm = {\ttfamily false}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a49a8ff01e1398420cd45642d5b1d3106}


\-Output the subpaving managed by this to a txt file. 

\-Format is a tab-\/delimited file of numeric data starting with node\-Name, then the node box volume, then the node counter, then the description of the node box as a tab-\/delimited list of interval upper and lower bounds.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em confirm} & is a boolean controlling whether confirmation goes to console output (defaults to false). \\
\hline
\end{DoxyParams}


\-Definition at line 3546 of file adaptivehistogram.\-cpp.



\-References get\-Sub\-Paving(), subpavings\-::\-S\-P\-Snode\-::leaves\-Output\-Tabs(), and root\-Paving.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-Collator\-::collate\-From\-R\-Vec(), main(), output\-M\-C\-M\-C\-State\-Sample(), and public\-Output\-M\-C\-M\-C\-State\-Sample().


\begin{DoxyCode}
{
    if (NULL != rootPaving) {

        // To generate a file output of the AdaptiveHistogram object
        ofstream os(s.c_str());         // Filename, c-string version
        if (os.is_open()) {

            getSubPaving()->leavesOutputTabs(os); // the output
            if (confirm)
                std::cout << "The output of the AdaptiveHistogram "
                    << "has been written to " << s << std::endl << std::endl;
        }
        else {
            std::cerr << "Error: could not open file named "
                << s << std::endl << std::endl;
        }
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2fb89e060574b8c935191cd3afd91290}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!output\-To\-Txt\-Tabs\-With\-E\-M\-Ps@{output\-To\-Txt\-Tabs\-With\-E\-M\-Ps}}
\index{output\-To\-Txt\-Tabs\-With\-E\-M\-Ps@{output\-To\-Txt\-Tabs\-With\-E\-M\-Ps}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{output\-To\-Txt\-Tabs\-With\-E\-M\-Ps}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::output\-To\-Txt\-Tabs\-With\-E\-M\-Ps} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{bool}]{confirm = {\ttfamily false}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogram_a2fb89e060574b8c935191cd3afd91290}


\-Output the subpaving managed by this to a txt file. 

\-Format is a tab-\/delimited file of numeric data starting with node\-Name, then the node box volume, then the node counter, then node contribution to \-E\-M\-P under \-C\-O\-P\-E\-R\-R, the change that would result in the \-E\-M\-P under \-C\-O\-P\-E\-R\-R if the node were split, the node contribution to \-E\-M\-P under \-A\-I\-C, the change that would result in the \-E\-M\-P under \-A\-I\-C if the node were split, and then the node box as a tab-\/delimited list of interval upper and lower bounds.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em confirm} & is a boolean controlling whether confirmation goes to console output (defaults to false). \\
\hline
\end{DoxyParams}


\-Definition at line 3571 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Sub\-Paving(), subpavings\-::\-S\-P\-Snode\-::leaves\-Output\-Tabs\-With\-E\-M\-Ps(), and root\-Paving.



\-Referenced by main().


\begin{DoxyCode}
{
    if (NULL != rootPaving) {

        // To generate a file output of the AdaptiveHistogram object
        ofstream os(s.c_str());         // Filename, c-string version
        if (os.is_open()) {
            size_t n = rootPaving->getCounter();
            getSubPaving()->leavesOutputTabsWithEMPs(n, os); // the output
            if (confirm)
                std::cout << "The output of the AdaptiveHistogram with scaled
       EMPs "
                    << "has been written to " << s << std::endl << std::endl;
        }
        else {
            std::cerr << "Error: could not open file named "
                << s << std::endl << std::endl;
        }
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a4c8d2603da121585e049548baca3c712}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Merge@{priority\-Merge}}
\index{priority\-Merge@{priority\-Merge}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Merge}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Merge} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a4c8d2603da121585e049548baca3c712}


\-Priority merge to reduce number of leaves in histogram. 

\-This method takes a histogram where where all the data is associated with multiple nodes and progressively merges the children of sub-\/terminal leaves using a priority queue to determine which node to merge first. \-Merging continues until some criteria applying either to individual nodes or to the histogram as a whole is satisfied, or the histogram only has one bin.

\-If more than one node is equally 'small', on the basis of the node comparison comp\-Test used, then a random choice is made between all equally small nodes to find the node which will be merged.


\begin{DoxyParams}{\-Parameters}
{\em comp\-Test} & is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. \\
\hline
{\em he} & is an instance of a class which provides a function to determine when to stop merging. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if the priority merge was successful, false otherwise. 
\end{DoxyReturn}


\-Definition at line 2698 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Leaf\-Levels\-String(), subpavings\-::\-S\-P\-Snode\-::get\-Merge\-Change\-E\-M\-P\-A\-I\-C(), subpavings\-::\-S\-P\-Snode\-::get\-Merge\-Change\-E\-M\-P\-C\-O\-P\-E\-R\-R(), subpavings\-::\-S\-P\-Snode\-::get\-Parent(), subpavings\-::\-S\-P\-Snode\-::get\-Sub\-Leaves(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-Pnode\-::has\-Leaf\-Sibling(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-S\-P\-Snode\-::node\-Reabsorb\-Children(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), output\-Log\-Start(), root\-Paving, update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().



\-Referenced by main().


\begin{DoxyCode}
{
    bool cancontinue = false;

    if (NULL == rootPaving) {
            throw HistException("No root paving for priorityMerge");
    }

    gsl_rng * rgsl = NULL;

    try {
        size_t n = 0; // number of points in histogram

        int i = 0;
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqMergeOutput";
            s = getUniqueFilename(baseFileName);
        }

        if (rootPaving->isLeaf()) {
            cancontinue = false;
            std::cerr << "Error in priorityMerge: trying to do "
                << "priority merge where the rootPaving "
                << "has no children" << std::endl;
        }
        else cancontinue = true;

        // a multiset for the queue (key values are not necessarily unique)
        multiset<SPSnode*, MyCompare> pq((MyCompare(compTest)));

        if (cancontinue) {
            n = rootPaving->getCounter(); // number of points in histogram

            if (logging != NOLOG) {
                 // Start log file with filename and timestamp
                outputLogStart(s);
                // log the current state of the histogram
                outputLog(s, i);
                outputLogEMPAIC(s); // add AIC scores
                i++;
            }

            SPSnodePtrs subleaves;
            rootPaving->getSubLeaves(subleaves);

            // insert a copy of the current set of subleaves into the multiset
            pq.insert(subleaves.begin(), subleaves.end());

            cancontinue = (pq.size()>0);
        }

        if(!cancontinue) {
            throw HistException("Error in priority merging, aborting merge");
        }

        bool canmerge = cancontinue;

        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        // merge until the HistEvalObj he () operator returns true
        while (canmerge && !he(this)) {

            SPSnode* smallest = *(pq.begin ()); // the first smallest in the
       set

            // find if there are any more equal to smallest around
            multiset<SPSnode*, MyCompare>::iterator mit;
            pair<multiset<SPSnode*, MyCompare>::iterator,
                multiset<SPSnode*, MyCompare>::iterator> equalSmallest;

            equalSmallest = pq.equal_range(smallest); // everything that =
       smallest
            size_t numberSmallest = pq.count(smallest); // number of =smallest

            if (numberSmallest > 1) {
                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                // random selection of the =largest node to chose
                for (mit=equalSmallest.first; mit!=equalSmallest.second; ++mit)
       {
                    sum += 1.0/(1.0*numberSmallest);
                    if (rand < sum) {
                        break;
                    }
                }
            }
            else mit = pq.begin ();

            SPSnode* chosenSmallest = *(mit); // the chosen smallest in the set

            updateScaledEMPSumCOPERR(chosenSmallest->getMergeChangeEMPCOPERR(n)
      );
            updateScaledEMPSumAIC(chosenSmallest->getMergeChangeEMPAIC());

            // subtract the child names from the creation string
            creationString += (" -(" + chosenSmallest->getChildNodeNames() + ")
      ");

            // merge the biggest one
            chosenSmallest->nodeReabsorbChildren();
            pq.erase(mit);// take the iterator to chosen smallest out of the
       set

            // if smallest had a leaf sibling, smallest's parent is now a
       cherry
            // and should be inserted into the multiset
            if (chosenSmallest->hasLeafSibling()) {

                pq.insert(chosenSmallest->getParent());
           }

            canmerge = (pq.size()>0);

            if (logging != NOLOG) {
                // To add current state of histogram to log file
                outputLog(s, i);
                outputLogEMPAIC(s); // add AIC scores
                i++;
            }
        }

        if(!canmerge) {
            std::cout << "No more subleaves left to merge" << std::endl;
        }

        if (cancontinue && (logging != NOLOG)) {
            // log the leaf levels line
            outputFile(s, getLeafLevelsString());
        }

        // EMPSums will have been adjusted during the merging process
        if (NULL != rgsl) gsl_rng_free(rgsl);
    }
    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority merge.  Orginal
       error: "
                                     + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error  in priority merge.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException  in priority merge.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error  in priority merge.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }


    return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2b60528af3d0f583b08284e11d4ff764}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a2b60528af3d0f583b08284e11d4ff764}
\-Only min\-Child\-Points supplied, no minvol\-B, no random number generator. 

\-Definition at line 1150 of file adaptivehistogram.\-hpp.



\-References priority\-Split().



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-Collator\-::collate\-From\-R\-Vec(), do\-M\-C\-M\-C\-G\-R\-Auto(), main(), and priority\-Split().


\begin{DoxyCode}
    { return prioritySplit(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a123e69c185cb450a05ecdc7101c71548}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a123e69c185cb450a05ecdc7101c71548}
\-Only min\-Vol\-B supplied, no min\-Child\-Points, no random number generator. 

\-Definition at line 1157 of file adaptivehistogram.\-hpp.



\-References priority\-Split().



\-Referenced by priority\-Split().


\begin{DoxyCode}
    { return prioritySplit(compTest, he, logging, 0, minVolB, maxLeafNodes); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a04219b243723859e2939216181cbaddc}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a04219b243723859e2939216181cbaddc}
\-Neither min\-Vol\-B nor min\-Child\-Points supplied, no random number generator. 

\-Definition at line 1163 of file adaptivehistogram.\-hpp.



\-References priority\-Split().



\-Referenced by priority\-Split().


\begin{DoxyCode}
    { return prioritySplit(compTest, he, logging, 0, 0.0, maxLeafNodes); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab28cddbe199adccec104b223f8848712}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_ab28cddbe199adccec104b223f8848712}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Definition at line 2062 of file adaptivehistogram.\-cpp.



\-References priority\-Split(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    gsl_rng * rgsl = NULL;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        retValue = prioritySplit(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes
      );
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority split.  Orginal
       error: "
                                     + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aea0d424449b7d93babef81d49bbbdb70}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_aea0d424449b7d93babef81d49bbbdb70}
\-With random number generator. \-Only min\-Child\-Points supplied, no minvol\-B. 

\-Definition at line 1173 of file adaptivehistogram.\-hpp.



\-References priority\-Split().



\-Referenced by priority\-Split().


\begin{DoxyCode}
    { return prioritySplit(compTest, he, logging, minChildPoints, 0.0, rgsl,
                    maxLeafNodes); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ad6a946d5c729b0f49d78962680d5d659}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ad6a946d5c729b0f49d78962680d5d659}
\-With random number generator. \-Only min\-Vol\-B supplied, no min\-Child\-Points. 

\-Definition at line 1181 of file adaptivehistogram.\-hpp.



\-References priority\-Split().



\-Referenced by priority\-Split().


\begin{DoxyCode}
    { return prioritySplit(compTest, he, logging, 0, minVolB, rgsl, 
      maxLeafNodes); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a630b400683794cd527173b18eb126f84}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a630b400683794cd527173b18eb126f84}
\-With random number generator. \-Neither min\-Vol\-B nor min\-Child\-Points supplied. 

\-Definition at line 1187 of file adaptivehistogram.\-hpp.



\-References priority\-Split().



\-Referenced by priority\-Split().


\begin{DoxyCode}
    { return prioritySplit(compTest, he, logging, 0, 0.0, rgsl, maxLeafNodes); 
      }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a2154185722cd1d4f61f65c7d84d77f2b}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a2154185722cd1d4f61f65c7d84d77f2b}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 2127 of file adaptivehistogram.\-cpp.



\-References check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Leaf\-Levels\-String(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), get\-Min\-Vol(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), output\-Log\-Start(), root\-Paving, subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{    
    //cout << minChildPoints << endl;
    //cout << minVolB << endl;
    //cout << maxLeafNodes << endl;
    
    bool cancontinue = false;
    bool TooManyLeaves = false;
    
    if (NULL == rootPaving) {
            throw HistException("No root paving for prioritySplit");
    }

    try {

        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        size_t n; // for number of points in histogram

        int i = 0;
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }

        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
           volChecking = true;
        }

        // a multiset for the queue (key values are not necessarily unique)
        multiset<SPSnode*, MyCompare> pq((MyCompare(compTest)));

        n = rootPaving->getCounter(); // number of points in histogram

        if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);
            // log the current state of the histogram
            outputLog(s, i);
            outputLogEMPAIC(s); // add AIC scores
            i++;
        }

        // put nodes into the starting set IF they meet minVol test AND IF
       either
        // there are enough points in the whole node
                // and minChildCountIfSplit is 0 (ie all points go to one
       child)
        // or the minChildCountIfSplit test passed

        if (rootPaving->isLeaf()) {
            // check to insert a copy of the rootPaving pointer into the set
            if (checkNodeCountForSplit(rootPaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootPaving);
            }
        }
        else { // root is not a leaf
            SPSnodePtrs leaves;
            rootPaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSnodePtrsItr sit;
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

        cancontinue = (!pq.empty());
      
        bool bigEnough = cancontinue;
       TooManyLeaves = (getRootLeaves() > maxLeafNodes);

        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }

      
        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out
        while (bigEnough && !he(this) && !TooManyLeaves) {
            
            SPSnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSnode* chosenLargest;
            
            // find if there are any more equal to largest around
            multiset<SPSnode*, MyCompare>::iterator mit;
            pair<multiset<SPSnode*, MyCompare>::iterator,
                multiset<SPSnode*, MyCompare>::iterator> equalLargest;

            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {

                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {

                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }

            else {

                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }

            // accumulate the changes in scaled EMP sums that will result
            // from this expansion
            //
      updateScaledEMPSumCOPERR(chosenLargest->getSplitChangeEMPCOPERR(n));
            //updateScaledEMPSumAIC(chosenLargest->getSplitChangeEMPAIC());

            // split the biggest one and divvie up its data

          // cout << "chosenLargest: " << chosenLargest->getNodeName() << "\t"
       << chosenLargest->getCounter() << endl;
           
           Expand(chosenLargest);

           
           //cout << getLeafLevelsString() << endl;

            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

            // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed

            if (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new left child into the multiset
                
                pq.insert(chosenLargest->getLeftChild());
            }

            if (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new right child into the multiset
               
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file
                outputLog(s, i);
                outputLogEMPAIC(s); // add AIC scores
                i++;
            }

            bigEnough = (!pq.empty());
            if (!bigEnough)
                std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
        
        
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      
  }
         
         
        if (cancontinue && (logging != NOLOG)) {
            // log the leaf levels line
            outputFile(s, getLeafLevelsString());

        }

        // EMPSums will have been adjusted during the splitting process
   }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory iin priority split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a1dffa971cfc56ec37449ce285a596365}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a1dffa971cfc56ec37449ce285a596365}
\-Only min\-Child\-Points supplied, no minvol\-B, no random number generator. 

\-Definition at line 1707 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-Get().



\-Referenced by priority\-Split\-Get().


\begin{DoxyCode}
    { return prioritySplitGet(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes, States, Sampled); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab3416e49bbb37e982e2e2f6a1ef13850}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ab3416e49bbb37e982e2e2f6a1ef13850}
\-Only min\-Vol\-B supplied, no min\-Child\-Points, no random number generator. 

\-Definition at line 1716 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-Get().



\-Referenced by priority\-Split\-Get().


\begin{DoxyCode}
    { return prioritySplitGet(compTest, he, logging, 0, minVolB, maxLeafNodes, 
                     States, Sampled); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a3eab9e09fee0aa81bd19bf170cf23aea}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a3eab9e09fee0aa81bd19bf170cf23aea}
\-Neither min\-Vol\-B nor min\-Child\-Points supplied, no random number generator. 

\-Definition at line 1725 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-Get().



\-Referenced by priority\-Split\-Get().


\begin{DoxyCode}
    { return prioritySplitGet(compTest, he, logging, 0, 0.0, maxLeafNodes,
                     States, Sampled); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_afee0931f38335b1d797680a0c9b6cfe5}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_afee0931f38335b1d797680a0c9b6cfe5}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Definition at line 5455 of file adaptivehistogram.\-cpp.



\-References priority\-Split\-Get(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;
    gsl_rng * rgsl = NULL;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        retValue = prioritySplitGet(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes
      ,
                                    States, Sampled);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority split.  Orginal
       error: "
                                     + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_af4e1c9c71ca8835f8ee3a78204f63d49}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_af4e1c9c71ca8835f8ee3a78204f63d49}
\-With random number generator. \-Only min\-Child\-Points supplied, no minvol\-B. 

\-Definition at line 1740 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-Get().



\-Referenced by priority\-Split\-Get().


\begin{DoxyCode}
    { return prioritySplitGet(compTest, he, logging, minChildPoints, 0.0, rgsl,
                    maxLeafNodes, States, Sampled); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a761f68d3b8f183d4fda926732fda70f9}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a761f68d3b8f183d4fda926732fda70f9}
\-With random number generator. \-Only min\-Vol\-B supplied, no min\-Child\-Points. 

\-Definition at line 1750 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-Get().



\-Referenced by priority\-Split\-Get().


\begin{DoxyCode}
    { return prioritySplitGet(compTest, he, logging, 0, minVolB, rgsl, 
      maxLeafNodes, 
                     States, Sampled); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a8654a1a779b1c0e6d0dcec82f436efd6}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a8654a1a779b1c0e6d0dcec82f436efd6}
\-With random number generator. \-Neither min\-Vol\-B nor min\-Child\-Points supplied. 

\-Definition at line 1759 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-Get().



\-Referenced by priority\-Split\-Get().


\begin{DoxyCode}
    { return prioritySplitGet(compTest, he, logging, 0, 0.0, rgsl, maxLeafNodes
      , 
                      States, Sampled); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a36a5db0649767e9045cf985f52f985ca}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-Get@{priority\-Split\-Get}}
\index{priority\-Split\-Get@{priority\-Split\-Get}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-Get}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-Get} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-States, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{\-Sampled}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a36a5db0649767e9045cf985f52f985ca}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 5519 of file adaptivehistogram.\-cpp.



\-References check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Leaf\-Levels\-String(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), get\-Min\-Vol(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), output\-Log\-Start(), root\-Paving, subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{   
    bool cancontinue = false;
    bool TooManyLeaves = false;
    
    int removeBox = 0;
    
    if (NULL == rootPaving) {
            throw HistException("No root paving for prioritySplit");
    }

    try {

        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        size_t n; // for number of points in histogram

        int i = 0;
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }

        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
           volChecking = true;
        }

        // a multiset for the queue (key values are not necessarily unique)
        multiset<SPSnode*, MyCompare> pq((MyCompare(compTest)));

        n = rootPaving->getCounter(); // number of points in histogram

        if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);
            // log the current state of the histogram
            outputLog(s, i);
            outputLogEMPAIC(s); // add AIC scores
            i++;
        }

        // put nodes into the starting set IF they meet minVol test AND IF
       either
        // there are enough points in the whole node
                // and minChildCountIfSplit is 0 (ie all points go to one
       child)
        // or the minChildCountIfSplit test passed

        if (rootPaving->isLeaf()) {
            // check to insert a copy of the rootPaving pointer into the set
            if (checkNodeCountForSplit(rootPaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootPaving);
            }
        }
        else { // root is not a leaf
            SPSnodePtrs leaves;
            rootPaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSnodePtrsItr sit;
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

      cancontinue = (!pq.empty());
        
        bool bigEnough = cancontinue;
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);

        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }

        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out
        while (bigEnough && !he(this) && !TooManyLeaves) {
            
            SPSnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSnode* chosenLargest;
            
            // find if there are any more equal to largest around
            multiset<SPSnode*, MyCompare>::iterator mit;
            pair<multiset<SPSnode*, MyCompare>::iterator,
                multiset<SPSnode*, MyCompare>::iterator> equalLargest;

            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {

                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {

                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }

            else {

                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }

            // accumulate the changes in scaled EMP sums that will result
            // from this expansion
            //
      updateScaledEMPSumCOPERR(chosenLargest->getSplitChangeEMPCOPERR(n));
            //updateScaledEMPSumAIC(chosenLargest->getSplitChangeEMPAIC());

        // collect the needed states here
        if ( getRootLeaves() == (Sampled[0]+1) ) {
          States.push_back(*this);
        }
        else if ( getRootLeaves() == (Sampled[1]+1) ) {
          States.push_back(*this);
          break;
        }

            // split the biggest one and divide up its data
             Expand(chosenLargest);

            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

            // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed

            if (((chosenLargest->getLeftChild())->getCounter() > removeBox) &&
             checkNodeCountForSplit(chosenLargest->getLeftChild(),
                  volChecking, minVol, minChildPoints)) {
                // insert the new left child into the multiset
                
                pq.insert(chosenLargest->getLeftChild());
            }

            if ( ((chosenLargest->getRightChild())->getCounter() > removeBox) 
      &&
                 checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new right child into the multiset
               
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file
                outputLog(s, i);
                outputLogEMPAIC(s); // add AIC scores
                i++;
            }

            bigEnough = (!pq.empty());
            if (!bigEnough)
                std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
        
        
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      
      }
          

          
          if (cancontinue && (logging != NOLOG)) {
            // log the leaf levels line
            outputFile(s, getLeafLevelsString());
          }

          // EMPSums will have been adjusted during the splitting process
   }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory iin priority split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_afa5a767156398a6d29db12fcbf0a46c7}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_afa5a767156398a6d29db12fcbf0a46c7}
\-Only min\-Child\-Points supplied, no minvol\-B, no random number generator. 

\-Definition at line 1781 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-M\-C\-M\-C().



\-Referenced by main(), and priority\-Split\-M\-C\-M\-C().


\begin{DoxyCode}
    { return prioritySplitMCMC(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes, Posterior, logPrior); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a024499e93cb4ca592c78b860d09cef79}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a024499e93cb4ca592c78b860d09cef79}
\-Only min\-Vol\-B supplied, no min\-Child\-Points, no random number generator. 

\-Definition at line 1789 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-M\-C\-M\-C().



\-Referenced by priority\-Split\-M\-C\-M\-C().


\begin{DoxyCode}
    { return prioritySplitMCMC(compTest, he, logging, 0, minVolB, maxLeafNodes,
       
    Posterior, logPrior); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a4c890ee5d86fc4cfd45c0ea2667b4a4f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a4c890ee5d86fc4cfd45c0ea2667b4a4f}
\-Neither min\-Vol\-B nor min\-Child\-Points supplied, no random number generator. 

\-Definition at line 1797 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-M\-C\-M\-C().



\-Referenced by priority\-Split\-M\-C\-M\-C().


\begin{DoxyCode}
    { return prioritySplitMCMC(compTest, he, logging, 0, 0.0, maxLeafNodes, 
      Posterior,
    logPrior); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab4acf5596236ac6fa272cb3abe80bee8}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_ab4acf5596236ac6fa272cb3abe80bee8}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Definition at line 5117 of file adaptivehistogram.\-cpp.



\-References priority\-Split\-M\-C\-M\-C(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;
    gsl_rng * rgsl = NULL;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        retValue = prioritySplitMCMC(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes
      ,
                                    Posterior, logPrior);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority split.  Orginal
       error: "
                                     + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab38788117602e87f4e53a72b6c62747a}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ab38788117602e87f4e53a72b6c62747a}
\-With random number generator. \-Only min\-Child\-Points supplied, no minvol\-B. 

\-Definition at line 1810 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-M\-C\-M\-C().



\-Referenced by priority\-Split\-M\-C\-M\-C().


\begin{DoxyCode}
    { return prioritySplitMCMC(compTest, he, logging, minChildPoints, 0.0, rgsl
      ,
                    maxLeafNodes, Posterior, logPrior); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab8e2052a043fc9969084719da4338678}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ab8e2052a043fc9969084719da4338678}
\-With random number generator. \-Only min\-Vol\-B supplied, no min\-Child\-Points. 

\-Definition at line 1819 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-M\-C\-M\-C().



\-Referenced by priority\-Split\-M\-C\-M\-C().


\begin{DoxyCode}
    { return prioritySplitMCMC(compTest, he, logging, 0, minVolB, rgsl, 
      maxLeafNodes, 
    Posterior, logPrior); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_af6cd725ab063a5c3af80d42315d99ddc}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_af6cd725ab063a5c3af80d42315d99ddc}
\-With random number generator. \-Neither min\-Vol\-B nor min\-Child\-Points supplied. 

\-Definition at line 1827 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-M\-C\-M\-C().



\-Referenced by priority\-Split\-M\-C\-M\-C().


\begin{DoxyCode}
    { return prioritySplitMCMC(compTest, he, logging, 0, 0.0, rgsl, 
      maxLeafNodes, 
    Posterior, logPrior); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a5e8e56baf547e75fe1701b455fa92efb}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}}
\index{priority\-Split\-M\-C\-M\-C@{priority\-Split\-M\-C\-M\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-M\-C\-M\-C}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-M\-C\-M\-C} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{std\-::vector$<$ real $>$ \&}]{\-Posterior, }
\item[{{\bf \-Log\-M\-C\-M\-C\-Prior} \&}]{log\-Prior}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a5e8e56baf547e75fe1701b455fa92efb}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 5181 of file adaptivehistogram.\-cpp.



\-References check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Leaf\-Levels\-String(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), subpavings\-::\-S\-P\-Snode\-::get\-Log\-Lik(), get\-Min\-Vol(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), get\-Root\-Leaves(), get\-Sub\-Paving(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), output\-Log\-Start(), root\-Paving, subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{   
    bool cancontinue = false;
    bool TooManyLeaves = false;
    
    real deltaL = 0;
    real deltaP = 0;
    int removeBox = 0;
    
    if (NULL == rootPaving) {
            throw HistException("No root paving for prioritySplit");
    }

    try {

        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        size_t n; // for number of points in histogram

        int i = 0;
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }

        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
           volChecking = true;
        }

        // a multiset for the queue (key values are not necessarily unique)
        multiset<SPSnode*, MyCompare> pq((MyCompare(compTest)));

        n = rootPaving->getCounter(); // number of points in histogram

        if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);
            // log the current state of the histogram
            outputLog(s, i);
            outputLogEMPAIC(s); // add AIC scores
            i++;
        }

        // put nodes into the starting set IF they meet minVol test AND IF
       either
        // there are enough points in the whole node
                // and minChildCountIfSplit is 0 (ie all points go to one
       child)
        // or the minChildCountIfSplit test passed

        if (rootPaving->isLeaf()) {
            // check to insert a copy of the rootPaving pointer into the set
            if (checkNodeCountForSplit(rootPaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootPaving);
            }
        }
        else { // root is not a leaf
            SPSnodePtrs leaves;
            rootPaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSnodePtrsItr sit;
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

      // get the log-likelihood
      SPSnodePtrs leaves; // set up empty container for leaf node pointers
      SPSnodePtrsItr it; // and an iterator over the container
      getSubPaving()->getLeaves(leaves); // fill the container
        for(it = leaves.begin(); it < leaves.end(); it++) {
        //cout << (*it)->getNodeName() << "\t" << (*it)->getCounter() << endl; 
        deltaL += (*it)->getLogLik(n);
      }

      // use the prior distribution object to find the prior 
      deltaP = logPrior(getRootLeaves()-1);
      // posterior is proportional to likelihood * prior
      real deltaPi = deltaL + deltaP;
      // push back into vector
      Posterior.push_back(deltaPi);

      cancontinue = (!pq.empty());
        
        bool bigEnough = cancontinue;
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);

        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }

        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out
        while (bigEnough && !he(this) && !TooManyLeaves) {
            
            SPSnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSnode* chosenLargest;
            
            // find if there are any more equal to largest around
            multiset<SPSnode*, MyCompare>::iterator mit;
            pair<multiset<SPSnode*, MyCompare>::iterator,
                multiset<SPSnode*, MyCompare>::iterator> equalLargest;

            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {

                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {

                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }

            else {

                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }

            // accumulate the changes in scaled EMP sums that will result
            // from this expansion
            //
      updateScaledEMPSumCOPERR(chosenLargest->getSplitChangeEMPCOPERR(n));
            //updateScaledEMPSumAIC(chosenLargest->getSplitChangeEMPAIC());

            // split the biggest one and divide up its data
             Expand(chosenLargest);
             
        // get the log-likelihood for the children node 
        real changeL = chosenLargest->getLeftChild()->getLogLik(n);
        changeL += chosenLargest->getRightChild()->getLogLik(n);

        // compute the likelihood * prior to get posterior
        size_t realNumLeaves = getRootLeaves(); 
        
        //cout << "---------------------------------------" << endl;
        //cout << "Number of leaves " << realNumLeaves << endl;

        // log likelihood
        deltaL = deltaL - chosenLargest->getLogLik(n) + changeL; 

        // use the prior distribution object to find the prior 
        deltaP = logPrior(realNumLeaves-1);
        
        //cout << deltaL << "\t" << deltaP << endl;
        
        // posterior is proportional to likelihood * prior
        real deltaPi = deltaL + deltaP;
        
        // push back into vector
        Posterior.push_back(deltaPi);

            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

            // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed

            if (((chosenLargest->getLeftChild())->getCounter() > removeBox) &&
             checkNodeCountForSplit(chosenLargest->getLeftChild(),
                  volChecking, minVol, minChildPoints)) {
                // insert the new left child into the multiset
                
                pq.insert(chosenLargest->getLeftChild());
            }

            if ( ((chosenLargest->getRightChild())->getCounter() > removeBox) 
      &&
                 checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new right child into the multiset
               
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file
                outputLog(s, i);
                outputLogEMPAIC(s); // add AIC scores
                i++;
            }

            bigEnough = (!pq.empty());
            if (!bigEnough)
                std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
        
        
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      
      }
          

          
          if (cancontinue && (logging != NOLOG)) {
            // log the leaf levels line
            outputFile(s, getLeafLevelsString());
          }

          // EMPSums will have been adjusted during the splitting process
   }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory iin priority split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a75ca6c8d7a95525b76b098c8c6e20cf8}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a75ca6c8d7a95525b76b098c8c6e20cf8}
\-Only min\-Child\-Points supplied, no minvol\-B, no random number generator. 

\-Definition at line 1913 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Switches().



\-Referenced by main(), and priority\-Split\-With\-Switches().


\begin{DoxyCode}
    { return prioritySplitWithSwitches(compTest, he, logging, minChildPoints, 0
      .0, 
                    maxLeafNodes, removeBox); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a0cd2e3af29feaad65d4a0a36738dcc15}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a0cd2e3af29feaad65d4a0a36738dcc15}
\-Only min\-Vol\-B supplied, no min\-Child\-Points, no random number generator. 

\-Definition at line 1920 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Switches().



\-Referenced by priority\-Split\-With\-Switches().


\begin{DoxyCode}
    { return prioritySplitWithSwitches(compTest, he, logging, 0, minVolB, 
              maxLeafNodes, removeBox); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a39ff221f6d3dad036ba6d4f5ec0ae819}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a39ff221f6d3dad036ba6d4f5ec0ae819}
\-Neither min\-Vol\-B nor min\-Child\-Points supplied, no random number generator. 

\-Definition at line 1927 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Switches().



\-Referenced by priority\-Split\-With\-Switches().


\begin{DoxyCode}
    { return prioritySplitWithSwitches(compTest, he, logging, 0, 0.0, 
                maxLeafNodes, removeBox); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_aa1b1ab0c522e46bc4bd0ab45547dea6b}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_aa1b1ab0c522e46bc4bd0ab45547dea6b}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Definition at line 2369 of file adaptivehistogram.\-cpp.



\-References priority\-Split\-With\-Switches(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    gsl_rng * rgsl = NULL;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        retValue = prioritySplitWithSwitches(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes
      ,
                        removeBox);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority split.  Orginal
       error: "
                                     + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a5299ade7c1d409621b2204a1986dabd8}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a5299ade7c1d409621b2204a1986dabd8}
\-With random number generator. \-Only min\-Child\-Points supplied, no minvol\-B. 

\-Definition at line 1938 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Switches().



\-Referenced by priority\-Split\-With\-Switches().


\begin{DoxyCode}
    { return prioritySplitWithSwitches(compTest, he, logging, minChildPoints, 0
      .0, rgsl,
                    maxLeafNodes, removeBox); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ad2ae1c64a519c1d5f32f81d39210b738}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ad2ae1c64a519c1d5f32f81d39210b738}
\-With random number generator. \-Only min\-Vol\-B supplied, no min\-Child\-Points. 

\-Definition at line 1946 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Switches().



\-Referenced by priority\-Split\-With\-Switches().


\begin{DoxyCode}
    { return prioritySplitWithSwitches(compTest, he, logging, 0, minVolB, rgsl,
       
                maxLeafNodes, removeBox); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_af9317b285f9a4f2753b1c9099347fe6f}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_af9317b285f9a4f2753b1c9099347fe6f}
\-With random number generator. \-Neither min\-Vol\-B nor min\-Child\-Points supplied. 

\-Definition at line 1954 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Switches().



\-Referenced by priority\-Split\-With\-Switches().


\begin{DoxyCode}
    { return prioritySplitWithSwitches(compTest, he, logging, 0, 0.0, rgsl, 
            maxLeafNodes, removeBox); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a6eb39e1e4524e415b8eff1ba4a4fc4b0}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}}
\index{priority\-Split\-With\-Switches@{priority\-Split\-With\-Switches}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Switches}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-With\-Switches} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{remove\-Box}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a6eb39e1e4524e415b8eff1ba4a4fc4b0}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 2435 of file adaptivehistogram.\-cpp.



\-References check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Leaf\-Levels\-String(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), get\-Min\-Vol(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), output\-Log\-Start(), root\-Paving, subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{    
    //cout << minChildPoints << endl;
    //cout << minVolB << endl;
    //cout << maxLeafNodes << endl;

    
    bool cancontinue = false;
    bool TooManyLeaves = false;
    
    if (NULL == rootPaving) {
            throw HistException("No root paving for prioritySplit");
    }

    try {

        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        size_t n; // for number of points in histogram

        int i = 0;
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }

        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
           volChecking = true;
        }

        // a multiset for the queue (key values are not necessarily unique)
        multiset<SPSnode*, MyCompare> pq((MyCompare(compTest)));

        n = rootPaving->getCounter(); // number of points in histogram

        if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);
            // log the current state of the histogram
            outputLog(s, i);
            outputLogEMPAIC(s); // add AIC scores
            i++;
        }

        // put nodes into the starting set IF they meet minVol test AND IF
       either
        // there are enough points in the whole node
                // and minChildCountIfSplit is 0 (ie all points go to one
       child)
        // or the minChildCountIfSplit test passed

        if (rootPaving->isLeaf()) {
            // check to insert a copy of the rootPaving pointer into the set
            if (checkNodeCountForSplit(rootPaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootPaving);
            }
        }
        else { // root is not a leaf
            SPSnodePtrs leaves;
            rootPaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSnodePtrsItr sit;
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

        cancontinue = (!pq.empty());
      
        bool bigEnough = cancontinue;
       TooManyLeaves = (getRootLeaves() > maxLeafNodes);

        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }

      
        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out
        
        size_t temp = 0;
        
        while (bigEnough && !he(this) && !TooManyLeaves) {
            
            SPSnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSnode* chosenLargest;
            
            // find if there are any more equal to largest around
            multiset<SPSnode*, MyCompare>::iterator mit;
            pair<multiset<SPSnode*, MyCompare>::iterator,
                multiset<SPSnode*, MyCompare>::iterator> equalLargest;

            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {

                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {

                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }

            else {

                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }

            // accumulate the changes in scaled EMP sums that will result
            // from this expansion
            //
      updateScaledEMPSumCOPERR(chosenLargest->getSplitChangeEMPCOPERR(n));
            //updateScaledEMPSumAIC(chosenLargest->getSplitChangeEMPAIC());

            // split the biggest one and divvie up its data
        //cout << "===============" << endl;
        
        //cout << "chosenLargest: " << chosenLargest->getNodeName() << 
        //"\t" << chosenLargest->getBox() << "\t"
        //<< chosenLargest->getHellingerDist1D() << endl;
          
        //rvector diffMean = chosenLargest->getMean() -
       chosenLargest->getUniformMean();
        //cout << "mean differences: " << diffMean[1] << endl;

        //RealVec unifCovar = chosenLargest->getUniformVarCovar();
        //RealVec Covar = chosenLargest->getVarCovar();
        //cout << "variance difference: " << Covar[0] - unifCovar[0] << endl;
        
        Expand(chosenLargest);

        /*
        string fileName = "QueueHist";
        ostringstream stm;
        stm << temp;
        fileName += stm.str();
        fileName += ".txt";
        outputToTxtTabs(fileName);
        cout << "===============" << endl;
        */
        temp++;
         
            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();
            
            // only insert the children into the queue if they have more than
       or
            // equal to removeBox number of points. If true, then
               // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed
            
            if ( ((chosenLargest->getLeftChild())->getCounter() > removeBox) 
            && (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new left child into the multiset
                pq.insert(chosenLargest->getLeftChild());
            }

            if ( ((chosenLargest->getRightChild())->getCounter() > removeBox) 
            && (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new right child into the multiset
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file
                outputLog(s, i);
                outputLogEMPAIC(s); // add AIC scores
                i++;
            }

            bigEnough = (!pq.empty());
            if (!bigEnough)
                std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
        
        
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      
  }
         
         
        if (cancontinue && (logging != NOLOG)) {
            // log the leaf levels line
            outputFile(s, getLeafLevelsString());

        }

        // EMPSums will have been adjusted during the splitting process
   }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory iin priority split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a6a4b39b06259e03b84b5131299334416}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a6a4b39b06259e03b84b5131299334416}
\-Only min\-Child\-Points supplied, no minvol\-B, no random number generator. 

\-Definition at line 1846 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Total\-Var().



\-Referenced by main(), and priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
    { return prioritySplitWithTotalVar(compTest, he, logging, minChildPoints, 0
      .0, 
                    maxLeafNodes, StopVal, HistAtValley, simNum); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a4c7ccb75b629b131c7a448579386c6a9}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a4c7ccb75b629b131c7a448579386c6a9}
\-Only min\-Vol\-B supplied, no min\-Child\-Points, no random number generator. 

\-Definition at line 1854 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Total\-Var().



\-Referenced by priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
    { return prioritySplitWithTotalVar(compTest, he, logging, 0, minVolB, 
              maxLeafNodes, StopVal, HistAtValley, simNum); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a435e13db001d1b919489507b81cb49ad}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a435e13db001d1b919489507b81cb49ad}
\-Neither min\-Vol\-B nor min\-Child\-Points supplied, no random number generator. 

\-Definition at line 1862 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Total\-Var().



\-Referenced by priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
    { return prioritySplitWithTotalVar(compTest, he, logging, 0, 0.0, 
                maxLeafNodes, StopVal, HistAtValley, simNum); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ae7e68baa3f16fafe3774df1f570aadcc}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_ae7e68baa3f16fafe3774df1f570aadcc}


\-Returns the \-I\-A\-E between an \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object and a \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode}. 

min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Definition at line 4760 of file adaptivehistogram.\-cpp.



\-References priority\-Split\-With\-Total\-Var(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    gsl_rng * rgsl = NULL;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        retValue = prioritySplitWithTotalVar(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes
      , 
                                    StopVal, HistAtValley, simNum);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority split.  Orginal
       error: "
                                     + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ae80f3d62957c9c70a2b7eed4b1e11810}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ae80f3d62957c9c70a2b7eed4b1e11810}
\-With random number generator. \-Only min\-Child\-Points supplied, no minvol\-B. 

\-Definition at line 1875 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Total\-Var().



\-Referenced by priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
    { return prioritySplitWithTotalVar(compTest, he, logging, minChildPoints, 0
      .0, rgsl,
                    maxLeafNodes, StopVal, HistAtValley, simNum); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a508b13326647eaa46806ca7999d303f2}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a508b13326647eaa46806ca7999d303f2}
\-With random number generator. \-Only min\-Vol\-B supplied, no min\-Child\-Points. 

\-Definition at line 1884 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Total\-Var().



\-Referenced by priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
    { return prioritySplitWithTotalVar(compTest, he, logging, 0, minVolB, rgsl,
       
                maxLeafNodes, StopVal, HistAtValley, simNum); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a39888154b396a7eb5fd6be1ff200a414}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a39888154b396a7eb5fd6be1ff200a414}
\-With random number generator. \-Neither min\-Vol\-B nor min\-Child\-Points supplied. 

\-Definition at line 1893 of file adaptivehistogram.\-hpp.



\-References priority\-Split\-With\-Total\-Var().



\-Referenced by priority\-Split\-With\-Total\-Var().


\begin{DoxyCode}
    { return prioritySplitWithTotalVar(compTest, he, logging, 0, 0.0, rgsl, 
            maxLeafNodes, StopVal, HistAtValley, simNum); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_acab027b9f4718b0ba077b142375a05cb}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}}
\index{priority\-Split\-With\-Total\-Var@{priority\-Split\-With\-Total\-Var}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{priority\-Split\-With\-Total\-Var}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::priority\-Split\-With\-Total\-Var} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{\-Stop\-Val, }
\item[{std\-::vector$<$ {\bf \-Adaptive\-Histogram} $>$ \&}]{\-Hist\-At\-Valley, }
\item[{int}]{sim\-Num}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_acab027b9f4718b0ba077b142375a05cb}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 4828 of file adaptivehistogram.\-cpp.



\-References check\-Node\-Count\-For\-Split(), check\-Stop\-Crit(), creation\-String, subpavings\-::\-Expand(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Leaf\-Levels\-String(), subpavings\-::\-S\-P\-Snode\-::get\-Leaves(), subpavings\-::\-S\-P\-Snode\-::get\-Left\-Child(), get\-Min\-Vol(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), subpavings\-::\-S\-P\-Snode\-::get\-Right\-Child(), get\-Root\-Leaves(), get\-Sub\-Paving(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::output\-File(), output\-Log(), output\-Log\-E\-M\-P\-A\-I\-C(), output\-Log\-Start(), root\-Paving, subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{    
    bool cancontinue = false;
    bool TooManyLeaves = false;
    bool shouldStop = false;
    int flagStop = 0;
    vector<double> TotalVarDist;
    int Prev = 1;
    AdaptiveHistogram probValley;
    size_t split = 0;
    
    if (NULL == rootPaving) {
            throw HistException("No root paving for prioritySplit");
    }

    try {
        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        size_t n; // for number of points in histogram

        int i = 0;
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }

        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
           volChecking = true;
        }

        // a multiset for the queue (key values are not necessarily unique)
        multiset<SPSnode*, MyCompare> pq((MyCompare(compTest)));

        n = rootPaving->getCounter(); // number of points in histogram

        if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);
            // log the current state of the histogram
            outputLog(s, i);
            outputLogEMPAIC(s); // add AIC scores
            i++;
        }

        // put nodes into the starting set IF they meet minVol test AND IF
       either
        // there are enough points in the whole node
                // and minChildCountIfSplit is 0 (ie all points go to one
       child)
        // or the minChildCountIfSplit test passed

        if (rootPaving->isLeaf()) {
            // check to insert a copy of the rootPaving pointer into the set
            if (checkNodeCountForSplit(rootPaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootPaving);
            }
        }
        else { // root is not a leaf
            SPSnodePtrs leaves;
            rootPaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSnodePtrsItr sit;
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

        cancontinue = (!pq.empty());
      
        bool bigEnough = cancontinue;
       TooManyLeaves = (getRootLeaves() > maxLeafNodes);

        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }

        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out
        while (bigEnough && !he(this) && !TooManyLeaves) {
            
            SPSnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSnode* chosenLargest;
            
            // find if there are any more equal to largest around
            multiset<SPSnode*, MyCompare>::iterator mit;
            pair<multiset<SPSnode*, MyCompare>::iterator,
                multiset<SPSnode*, MyCompare>::iterator> equalLargest;

            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {

                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {

                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }

            else {

                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }

            // accumulate the changes in scaled EMP sums that will result
            // from this expansion
            //
      updateScaledEMPSumCOPERR(chosenLargest->getSplitChangeEMPCOPERR(n));
            //updateScaledEMPSumAIC(chosenLargest->getSplitChangeEMPAIC());

            // split the biggest one and divide up its data
           cout << "===============" << endl;
           cout << "chosenLArgest: " << chosenLargest->getNodeName() << "\t" <<
       chosenLargest->getCounter() << endl;
           Expand(chosenLargest);
           cout << "===============" << endl;
           
            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

            // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed

            if (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new left child into the multiset
                
                pq.insert(chosenLargest->getLeftChild());
            }

            if (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new right child into the multiset
               
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file
                outputLog(s, i);
                outputLogEMPAIC(s); // add AIC scores
                i++;
            }


        // get the total variation distance
        SPSnodePtrs leaves;
        SPSnodePtrsItr leavesIt;
        getSubPaving()->getLeaves(leaves);

        double totalVarDist = 0;
        double FUnif = 1.0/leaves.size()*1.0;
        for (leavesIt = leaves.begin(); leavesIt < leaves.end(); leavesIt++) {
          double leafVol = (*leavesIt)->nodeVolume();
          //get the total variation distance
          //calculate \mu_n - \mu
               double fhat = ((*leavesIt)->getCounter())/leafVol/n;
               double diffMu = fabs(fhat*leafVol - FUnif);
               //cout << "previous: " << totalVarDist << "\t current: " <<
       diffMu << endl;
          totalVarDist += diffMu;
          //totalVarDist = (diffMu > totalVarDist) ? diffMu : totalVarDist; 
        }
        split++;
        TotalVarDist.push_back(totalVarDist);
        //cout << "---------Split " << split << ": " << totalVarDist <<
       "--------------" << endl;

        if (split == 1) { probValley = *this; } // keep the second state

        // start the checks after 1 split
        if ( split > 1 ) {
          // use the total var distance as stopping criteria
          size_t vecSize = TotalVarDist.size();
          shouldStop = checkStopCrit(TotalVarDist[vecSize-1], TotalVarDist[
      vecSize-2], Prev);
          if (shouldStop) { 
            flagStop++; 
            HistAtValley.push_back(probValley); //keep this histogram
          }
          if (flagStop == StopVal) { 
            cout << "Stopping criteria met. There are " << StopVal << "
       valleys." << endl;
            break; 
          }
          if (Prev == 1) // keep this histogram if prev = 1 
            { probValley = *this; }
        }
        
            bigEnough = (!pq.empty());
            if (!bigEnough)
                std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;

        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }  
      } // end of while loop

      //output the total variation distance for plotting purposes
      ofstream oss;         // ofstream object
      oss << scientific;  // set formatting for input to oss
      oss.precision(5);
      std::ostringstream stm;
      stm << simNum;
      string FileName = "PQTotalVariationOutput";
      FileName += stm.str();
      FileName += ".txt";
      oss.open(FileName.c_str());
      for (size_t j=0; j < TotalVarDist.size(); j++) {
        oss << TotalVarDist[j] << endl;
      }
      oss << flush;
      oss.close();
      cout << "Total variation distance output to " << FileName << endl;

      if (cancontinue && (logging != NOLOG)) {
            // log the leaf levels line
            outputFile(s, getLeafLevelsString());
      }

        // EMPSums will have been adjusted during the splitting process
   }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory iin priority split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority split.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ae7f23176e9afea24c51c6a37cbcc4b0a}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!propose\-Change\-M\-C\-M\-C\-State@{propose\-Change\-M\-C\-M\-C\-State}}
\index{propose\-Change\-M\-C\-M\-C\-State@{propose\-Change\-M\-C\-M\-C\-State}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{propose\-Change\-M\-C\-M\-C\-State}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode\-List\-Itr} {\bf \-Adaptive\-Histogram\-::propose\-Change\-M\-C\-M\-C\-State} (
\begin{DoxyParamCaption}
\item[{const {\bf \-M\-C\-M\-C\-Proposal} \&}]{proposal, }
\item[{{\bf \-S\-P\-Snode\-List} \&}]{nodes, }
\item[{size\-\_\-t}]{num\-Leaves, }
\item[{size\-\_\-t}]{num\-Cherries, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool \&}]{have\-Node}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ae7f23176e9afea24c51c6a37cbcc4b0a}


\-Finds the node to target for change in \-M\-C\-M\-C on \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} trees. 

\-This method changes the value of the bool have\-Node and returns an iterator into a container of \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} pointers. \-If, after the method has completed, have\-Node is positive, then the iterator points to a pointer to a node proposed for change (split or merge) under \-M\-C\-M\-C on the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree.

\-Proposals are made by selecting a splittable leaf or cherry at random. \-If a cherry is chosen the proposed change in state is to merge the two leaf children of that cherry; if a splittable leaf is chosen the proposal is to split (bisect) the leaf.

\begin{DoxyPrecond}{\-Precondition}
have\-Node is false. 
\end{DoxyPrecond}

\begin{DoxyParams}{\-Parameters}
{\em proposal} & is a reference to a proposal distribution object. \\
\hline
{\em nodes} & is a reference to a container of pointers to the splittable leaf and cherry nodes of the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}, which will be updated if the method results in change in tree state. \\
\hline
{\em num\-Leaves} & is the number of splittable leaves in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree. in tree state. \\
\hline
{\em num\-Cherries} & is the number of cherries in the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} tree. in tree state. \\
\hline
{\em rgsl} & is a pointer to a uniform random number generator. \\
\hline
{\em have\-Node} & is reference to a boolean which can be changes in the function, which indicates whether a proposal node is found. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
an iterator to a container of pointers to \-S\-P\-Snodes. 
\end{DoxyReturn}
\begin{DoxyPostcond}{\-Postcondition}
have\-Node will have been changed to true if a node has been found for the proposal using the probabilities under proposal. 
\end{DoxyPostcond}


\-Definition at line 538 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-M\-C\-M\-C\-Proposal\-::fill\-Node\-Proposal\-Probs().



\-Referenced by change\-M\-C\-M\-C\-State().


\begin{DoxyCode}
{
    //cout << "---> calling propose change" << endl;
    
    SPSnodeListItr it;

    RealVec probs;
    RealVecItr pit;

    // fillNodeProposalProbs returns the sum of the probabilities and
    // also fills in probs
    // the sum of the probabilities may be < 1 if for instance we fix the
    // probability of a split or merge in advance
    real psum = proposal.fillNodeProposalProbs(numLeaves, numCherries, probs);

    // check we got back the right number of probabilites
    if (!nodes.empty() && nodes.size() == probs.size()) {

        // pick a node at random  by drawing a random number in [0,1)
        double rand = gsl_rng_uniform(rgsl);
       
        if ((numLeaves > 0) && (numCherries > 0)) {
            
          //  cout << "----> cherry and leaf " << endl;
            
            pit = probs.begin();
            it = nodes.begin();
            real sum = 0.0;

            for (pit = probs.begin(); pit < probs.end(); pit++) {

                    sum += *pit;
                    if (rand < sum) {
                        haveNode = true;
                        break;
                    }
                    it++; // using this to point to nodes relies on having got
                            // the right number of probabilities to match nodes
             }
        }
        // if we only have leaves (which should mean one leaf, no cherries)
        // then we'll only pick a leaf if rand < psum
        if ((numLeaves > 0) && (numCherries == 0) && (rand < psum)) {
            
            
            pit = probs.begin();
            it = nodes.begin();
            real sum = 0.0;

            for (pit = probs.begin(); pit < probs.end(); pit++) {
                    
                    sum += *pit;
                    if (rand < sum) {
                        haveNode = true;
                       break;
                    }
                    it++; // using this to point to nodes relies on having got
                            // the right number of probabilities to match nodes
            }
        }
        // if we only have cherries
        // then we'll only pick a cherry if rand >= 1-psum
        if ((numLeaves == 0) && (numCherries > 0) && (rand >= 1.0-psum)) {
            
            pit = probs.begin();
            it = nodes.begin();
            real sum = 1.0-psum; // note that sum starts at 1-psum

            for (pit = probs.begin(); pit < probs.end(); pit++) {
         
                   
                    sum += *pit;
                    if (rand < sum) {
                        haveNode = true;
                        break;
                    }
                    it++; // using this to point to nodes relies on having got
                            // the right number of probabilities to match nodes
                   
            }
        }
        // it iterator should now point to the node we want to target
        //else we've not taken a node

    }

    return it;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_af41faeb2742df1aaa5108f17dee54d71}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!public\-Log\-M\-C\-M\-C\-Sample@{public\-Log\-M\-C\-M\-C\-Sample}}
\index{public\-Log\-M\-C\-M\-C\-Sample@{public\-Log\-M\-C\-M\-C\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{public\-Log\-M\-C\-M\-C\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::public\-Log\-M\-C\-M\-C\-Sample} (
\begin{DoxyParamCaption}
\item[{std\-::string}]{s, }
\item[{int}]{i}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_af41faeb2742df1aaa5108f17dee54d71}


\-Definition at line 3354 of file adaptivehistogram.\-cpp.



\-References output\-Log(), and output\-Log\-E\-M\-P\-A\-I\-C().


\begin{DoxyCode}
{
    outputLog(s, i);
    outputLogEMPAIC(s); // add AIC scores
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a0163eb023d0db24e0d91864a38acd562}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!public\-Output\-M\-C\-M\-C\-State\-Sample@{public\-Output\-M\-C\-M\-C\-State\-Sample}}
\index{public\-Output\-M\-C\-M\-C\-State\-Sample@{public\-Output\-M\-C\-M\-C\-State\-Sample}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{public\-Output\-M\-C\-M\-C\-State\-Sample}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::public\-Output\-M\-C\-M\-C\-State\-Sample} (
\begin{DoxyParamCaption}
\item[{int}]{ci, }
\item[{int}]{i, }
\item[{bool}]{confirm = {\ttfamily false}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a0163eb023d0db24e0d91864a38acd562}


\-Definition at line 3341 of file adaptivehistogram.\-cpp.



\-References output\-To\-Txt\-Tabs().


\begin{DoxyCode}
{
    // create a name for the file to output
    std::ostringstream stm;
    stm << "MCMC_" << ci << "_Sample" << i << ".txt";

    string sampleFileName = stm.str();

    // To realize a file output
    outputToTxtTabs(sampleFileName, confirm);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_ab8a546d8d85be0ffac955f7886d5c7aa}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C@{recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C}}
\index{recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C@{recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ab8a546d8d85be0ffac955f7886d5c7aa}


\-Recalculate the unscaled \-E\-M\-P part of \-A\-I\-C score. 

\-Uses whole histogram. 

\-Definition at line 358 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-Snode\-::get\-E\-M\-P\-Sum\-A\-I\-C(), root\-Paving, and scaled\-E\-M\-P\-Sum\-A\-I\-C.



\-Referenced by \-Adaptive\-Histogram(), insert\-Data\-From\-Container(), insert\-One(), merge\-Up(), and operator=().


\begin{DoxyCode}
{
    // use the scaled EMP Sum from the root node's getEMPSumCOPERR()
    scaledEMPSumAIC = rootPaving->getEMPSumAIC(
                        rootPaving->getCounter());
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a6456652ee831cee0ec4184440cd84ec9}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}}
\index{recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a6456652ee831cee0ec4184440cd84ec9}


\-Recalculate the scaled \-E\-M\-P part of \-C\-O\-P\-E\-R\-R score. 

\-Uses whole histogram 

\-Definition at line 350 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-Snode\-::get\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), root\-Paving, and scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R.



\-Referenced by \-Adaptive\-Histogram(), insert\-Data\-From\-Container(), insert\-One(), merge\-Up(), and operator=().


\begin{DoxyCode}
{
    // use the scaled EMP Sum from the root node's getEMPSumCOPERR()
    scaledEMPSumCOPERR = rootPaving->getEMPSumCOPERR(
                        rootPaving->getCounter());
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a1cb13fa570de75efab3b9c4b862d200e}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!reshape\-To\-Union@{reshape\-To\-Union}}
\index{reshape\-To\-Union@{reshape\-To\-Union}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{reshape\-To\-Union}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::reshape\-To\-Union} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Piecewise\-Constant\-Function} \&}]{other}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a1cb13fa570de75efab3b9c4b862d200e}


\-Change this so that the subpaving it manages is the union of this's subpaving and the subpaving of that of a \hyperlink{classsubpavings_1_1PiecewiseConstantFunction}{\-Piecewise\-Constant\-Function}. 

\-Throws a \-Null\-Subpavings\-\_\-\-Error if the subpaving that this manages is a \-N\-U\-L\-L pointer or if the subpaving managed by {\itshape other\/} is a \-N\-U\-L\-L pointer.

\-Throws a \hyperlink{classsubpavings_1_1NoBox__Error}{\-No\-Box\-\_\-\-Error} if the subpaving of this has no box or if the subpaving of {\itshape other\/} has no box.

\-Throws an \hyperlink{classsubpavings_1_1IncompatibleDimensions__Error}{\-Incompatible\-Dimensions\-\_\-\-Error} if the subpaving boxes of this and {\itshape other\/} are not identical.

\-There will be no change in this if the subpaving of  is everywhere less split than the subpaving of this.


\begin{DoxyParams}{\-Parameters}
{\em other} & is the \-Piecewise\-Constant\-Function to make the union against. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-Both this and {\itshape other\/} have subpavings with boxes to manage. 

\-The boxes of the subpavings of this and {\itshape other\/} are the same. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
the subpaving managed by this has the shape that is the union of its shape before the operation and the shape of the subpaving managed by {\itshape other\/}. {\itshape other\/} is unchanged. 
\end{DoxyPostcond}


\-Definition at line 3611 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-Piecewise\-Constant\-Function\-::get\-Copy\-Sub\-Paving(), get\-Sub\-Paving(), subpavings\-::\-Piecewise\-Constant\-Function\-::has\-Sub\-Paving(), has\-Sub\-Paving(), and subpavings\-::\-S\-P\-Snode\-::reshape\-To\-Union().


\begin{DoxyCode}
{
  if ( !hasSubPaving() || !other.hasSubPaving() ) {
    throw NullSubpavingPointer_Error(
        "AdaptiveHistogram::reshapeToUnion(const PiecewiseConstantFunction&)");
  }
  
  getSubPaving()->reshapeToUnion(other.getCopySubPaving());
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a9e30e2969e3ad675b8659470200219d4}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!reshape\-To\-Union@{reshape\-To\-Union}}
\index{reshape\-To\-Union@{reshape\-To\-Union}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{reshape\-To\-Union}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::reshape\-To\-Union} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Piecewise\-Constant\-Function} \&}]{other, }
\item[{size\-\_\-t}]{min\-Child\-Points}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a9e30e2969e3ad675b8659470200219d4}


\-Change this so that the subpaving it manages is as close as possible to the union of this's subpaving and the subpaving of that of a \hyperlink{classsubpavings_1_1PiecewiseConstantFunction}{\-Piecewise\-Constant\-Function}. 

\-If {\itshape other\/} has a subpaving that is more split than the subpaving managed by this at any node, this will not exactly follow the shape of {\itshape other\/} if the resulting nodes would not splittable according to \-S\-P\-Snode\-::is\-Splittable\-Node(size\-\_\-t min\-Child\-Points). \-If any node cannot be split to follow the shape of {\itshape other\/} due to {\itshape min\-Child\-Points\/}, a message will be printed to std\-::cerr.

\-Throws a \-Null\-Subpavings\-\_\-\-Error if the subpaving that this manages is a \-N\-U\-L\-L pointer or if the subpaving managed by {\itshape other\/} is a \-N\-U\-L\-L pointer.

\-Throws a \hyperlink{classsubpavings_1_1NoBox__Error}{\-No\-Box\-\_\-\-Error} if the subpaving of this has no box or if the subpaving of {\itshape other\/} has no box.

\-Throws an \hyperlink{classsubpavings_1_1IncompatibleDimensions__Error}{\-Incompatible\-Dimensions\-\_\-\-Error} if the subpaving boxes of this and {\itshape other\/} are not identical.

\-There will be no change in this if the subpaving of  is everywhere less split than the subpaving of this.


\begin{DoxyParams}{\-Parameters}
{\em other} & is the \-Piecewise\-Constant\-Function to make the union against. \\
\hline
{\em min\-Child\-Points} & is the minumum child points to use to check if this can be split in order to follow {\itshape other\/}. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-Both this and {\itshape other\/} have subpavings with boxes to manage. 

\-The boxes of the subpavings of this and {\itshape other\/} are the same. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
the subpaving managed by this has the shape that is as close as possible to the union of its shape before the operation and the shape of the subpaving managed by {\itshape other\/}, given {\itshape min\-Child\-Points\/}. {\itshape other\/} is unchanged. 
\end{DoxyPostcond}


\-Definition at line 3622 of file adaptivehistogram.\-cpp.



\-References subpavings\-::\-Piecewise\-Constant\-Function\-::get\-Copy\-Sub\-Paving(), get\-Sub\-Paving(), subpavings\-::\-Piecewise\-Constant\-Function\-::has\-Sub\-Paving(), has\-Sub\-Paving(), and subpavings\-::\-S\-P\-Snode\-::reshape\-To\-Union().


\begin{DoxyCode}
{
  if ( !hasSubPaving() || !other.hasSubPaving() ) {
    throw NullSubpavingPointer_Error(
    "AdaptiveHistogram::reshapeToUnion(const PiecewiseConstantFunction&,
       size_t)");
  }
  
  getSubPaving()->reshapeToUnion(other.getCopySubPaving(), minChildPoints);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_afac8c0cb4ed44f27e7a3adf1855af676}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!split\-To\-Shape@{split\-To\-Shape}}
\index{split\-To\-Shape@{split\-To\-Shape}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{split\-To\-Shape}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-::split\-To\-Shape} (
\begin{DoxyParamCaption}
\item[{std\-::string}]{instruction}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_afac8c0cb4ed44f27e7a3adf1855af676}


\-Split a histogram to a specified shape. 


\begin{DoxyParams}{\-Parameters}
{\em instruction} & specifies the required shape, eg \char`\"{}3, 3. 2, 1\char`\"{} \\
\hline
\end{DoxyParams}


\-Definition at line 2971 of file adaptivehistogram.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), root\-Paving, subpavings\-::\-S\-Pnode\-::split\-Root\-To\-Shape(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().



\-Referenced by do\-M\-C\-M\-C\-G\-R\-Auto(), and main().


\begin{DoxyCode}
{
    bool success = false;

    // checks:  is there a root paving, is the string properly formed?
    if (NULL == rootPaving) {
        throw HistException("No root paving for splitToShape");
    }

   if (instruction.length() == 0) {
      throw HistException("No instruction");
    }

    std::string legal(", 0123456789");
    if (instruction.find_first_not_of(legal) != std::string::npos) {
        throw HistException("Illegal character in instruction");
    }

    try { // all seems to be okay, we can start spliting the root paving
        // specify what to look for as numbers or decimal point or + or -

       success = rootPaving->splitRootToShape(instruction);

        if (success) {
            // update the creation string
            creationString = rootPaving->getNodeName()
                + rootPaving->getChildNodeNames();
        }
        else {
            std::cerr << std::endl;
            std::cerr << "Your instruction does not describe a proper tree.";
            std::cerr << "  Please check your instruction and try again."
            << std::endl;
       }
    }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory in splitToShape.  Orginal error: 
      "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in splitToShape.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in splitToShape.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in splitToShape.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return success;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a809928eec642c22761a2f9b3b8061d47}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!swap@{swap}}
\index{swap@{swap}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{swap}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::swap} (
\begin{DoxyParamCaption}
\item[{{\bf \-Adaptive\-Histogram} \&}]{adh}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogram_a809928eec642c22761a2f9b3b8061d47}


\-Swap the contents of this and another histogram. 

\begin{DoxyPostcond}{\-Postcondition}
\-After the swap {\itshape adh\/} will manage the subpaving that this used to manage, and this will manage the subpaving that {\itshape adh\/} used to managed, and the values of the other data members of this and {\itshape adh\/} will also be swapped. 
\end{DoxyPostcond}


\-Definition at line 5790 of file adaptivehistogram.\-cpp.



\-References creation\-String, data\-Collection, hold\-All\-Stats, root\-Paving, scaled\-E\-M\-P\-Sum\-A\-I\-C, and scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R.


\begin{DoxyCode}
{
  //std::swap(label, adh.label);
  std::swap(dataCollection, adh.dataCollection); // use stl specialisation of
       swap
    std::swap(holdAllStats, adh.holdAllStats);
  std::swap(creationString, adh.creationString);
    
  // cxsc don't seem to have a swap for dot precisions
    dotprecision tempCOPERR(adh.scaledEMPSumCOPERR);
  adh.scaledEMPSumCOPERR = scaledEMPSumCOPERR;
  scaledEMPSumCOPERR = tempCOPERR;
  
  dotprecision tempAIC(adh.scaledEMPSumAIC);
  adh.scaledEMPSumAIC = scaledEMPSumAIC;
  scaledEMPSumAIC = tempAIC;
  
  std::swap(rootPaving, adh.rootPaving); // just swap the pointers
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a79fe01c35fba2bbdb1df5e8eb1d3a78b}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C@{update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C}}
\index{update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C@{update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C} (
\begin{DoxyParamCaption}
\item[{dotprecision}]{change}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a79fe01c35fba2bbdb1df5e8eb1d3a78b}


\-Update the the scaled \-E\-M\-P part \-A\-I\-C score given change. 



\-Definition at line 372 of file adaptivehistogram.\-cpp.



\-References scaled\-E\-M\-P\-Sum\-A\-I\-C.



\-Referenced by priority\-Merge().


\begin{DoxyCode}
{
    scaledEMPSumAIC = scaledEMPSumAIC + change;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a71122bfe1d3dfad1f2b55585326334ac}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}}
\index{update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-::update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R} (
\begin{DoxyParamCaption}
\item[{dotprecision}]{change}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a71122bfe1d3dfad1f2b55585326334ac}


\-Update the scaled \-E\-M\-P part \-C\-O\-P\-E\-R\-R score given change. 



\-Definition at line 366 of file adaptivehistogram.\-cpp.



\-References scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R.



\-Referenced by priority\-Merge().


\begin{DoxyCode}
{
    scaledEMPSumCOPERR = scaledEMPSumCOPERR + change;
}
\end{DoxyCode}


\subsubsection{\-Member \-Data \-Documentation}
\hypertarget{classsubpavings_1_1AdaptiveHistogram_a1211a42d1f428d73db9ba3c035239c59}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!creation\-String@{creation\-String}}
\index{creation\-String@{creation\-String}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{creation\-String}]{\setlength{\rightskip}{0pt plus 5cm}std\-::string {\bf subpavings\-::\-Adaptive\-Histogram\-::creation\-String}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a1211a42d1f428d73db9ba3c035239c59}


\-A string showing the order of creation of the root\-Paving. 



\-Definition at line 113 of file adaptivehistogram.\-hpp.



\-Referenced by \-Adaptive\-Histogram(), change\-State\-For\-Merge(), change\-State\-For\-Split(), have\-Made\-Paving(), insert\-Data\-From\-Container(), insert\-One(), merge\-Up(), operator=(), output\-Log(), priority\-Merge(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), priority\-Split\-With\-Total\-Var(), split\-To\-Shape(), and swap().

\hypertarget{classsubpavings_1_1AdaptiveHistogram_afb02d0a6fe2258620130b97b7901e214}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!data\-Collection@{data\-Collection}}
\index{data\-Collection@{data\-Collection}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{data\-Collection}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Big\-Data\-Collection} {\bf subpavings\-::\-Adaptive\-Histogram\-::data\-Collection}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_afb02d0a6fe2258620130b97b7901e214}


\-A container for all sample data passed to this. 

\-The sample that has come in thus far. 

\-Definition at line 104 of file adaptivehistogram.\-hpp.



\-Referenced by \-Adaptive\-Histogram(), insert\-Data\-From\-Container(), insert\-One(), operator+(), operator=(), and swap().

\hypertarget{classsubpavings_1_1AdaptiveHistogram_a3f9319019a75ea477804d02762602d17}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!hold\-All\-Stats@{hold\-All\-Stats}}
\index{hold\-All\-Stats@{hold\-All\-Stats}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{hold\-All\-Stats}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-::hold\-All\-Stats}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a3f9319019a75ea477804d02762602d17}


\-Controls whether all available statistics are maintained in the root\-Paving. \-If set to false (default) only counts are maintained. 



\-Definition at line 109 of file adaptivehistogram.\-hpp.



\-Referenced by get\-Hold\-All\-Stats(), get\-Root\-Paving\-Mean(), get\-Root\-Paving\-Var\-Covar(), have\-Made\-Paving(), operator=(), and swap().

\hypertarget{classsubpavings_1_1AdaptiveHistogram_a73e006381e43e152b7dbb63211a3ac09}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!padding@{padding}}
\index{padding@{padding}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{padding}]{\setlength{\rightskip}{0pt plus 5cm}const real {\bf \-Adaptive\-Histogram\-::padding} = 0.\-000005\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a73e006381e43e152b7dbb63211a3ac09}


a constant for padding a box if it is tailor-\/made for data. 

\-The padding if the size of the root box is obtained from the min and max of the data that is fully fed in. 

\-Definition at line 84 of file adaptivehistogram.\-hpp.



\-Referenced by make\-Box().

\hypertarget{classsubpavings_1_1AdaptiveHistogram_a5afac4246153fef0b383f6eb2e9d23a6}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!root\-Box@{root\-Box}}
\index{root\-Box@{root\-Box}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{root\-Box}]{\setlength{\rightskip}{0pt plus 5cm}ivector {\bf subpavings\-::\-Adaptive\-Histogram\-::root\-Box}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a5afac4246153fef0b383f6eb2e9d23a6}


\-The root box used to form the subpaving tree. 

\-We may not need this, at present it gets passed to the \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} constructor. 

\-Definition at line 98 of file adaptivehistogram.\-hpp.



\-Referenced by \-Adaptive\-Histogram(), complete\-Data\-Insertion\-From\-Vec(), have\-Made\-Paving(), insert\-One(), and operator=().

\hypertarget{classsubpavings_1_1AdaptiveHistogram_a88a104768020c02deb2a7df9e2b4cb3a}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!root\-Paving@{root\-Paving}}
\index{root\-Paving@{root\-Paving}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{root\-Paving}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-Snode}$\ast$ {\bf subpavings\-::\-Adaptive\-Histogram\-::root\-Paving}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_a88a104768020c02deb2a7df9e2b4cb3a}


\-Pointer to the root node of the subpaving tree. 

\-An \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} is a binary tree representation of a subpaving, designed for processing statistical data. 

\-Definition at line 91 of file adaptivehistogram.\-hpp.



\-Referenced by \-Adaptive\-Histogram(), change\-State\-For\-Merge(), change\-State\-For\-Split(), get2\-D\-I\-A\-E(), get\-Fin\-Mix\-I\-A\-E(), get\-Leaf\-Counts(), get\-Leaf\-Levels(), get\-Leaf\-Levels\-String(), get\-Min\-Vol(), get\-Root\-Counter(), get\-Root\-Leaves(), get\-Root\-Paving\-Mean(), get\-Root\-Paving\-Var\-Covar(), get\-Root\-Sum\-Leaf\-Count\-Over\-Vol(), get\-Score\-A\-I\-C(), get\-Score\-C\-O\-P\-E\-R\-R(), get\-Sub\-Paving(), get\-Unif\-I\-A\-E(), have\-Made\-Paving(), insert\-Data\-From\-Container(), insert\-One(), merge\-Up(), operator+(), operator=(), output\-Graph\-Dot(), output\-Log(), output\-Root\-To\-Txt(), output\-To\-Txt\-Tabs(), output\-To\-Txt\-Tabs\-With\-E\-M\-Ps(), priority\-Merge(), priority\-Split(), priority\-Split\-Get(), priority\-Split\-M\-C\-M\-C(), priority\-Split\-With\-Switches(), priority\-Split\-With\-Total\-Var(), recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), split\-To\-Shape(), swap(), and $\sim$\-Adaptive\-Histogram().

\hypertarget{classsubpavings_1_1AdaptiveHistogram_ad5748390a25f398475bb60575f0e9a89}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!scaled\-E\-M\-P\-Sum\-A\-I\-C@{scaled\-E\-M\-P\-Sum\-A\-I\-C}}
\index{scaled\-E\-M\-P\-Sum\-A\-I\-C@{scaled\-E\-M\-P\-Sum\-A\-I\-C}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{scaled\-E\-M\-P\-Sum\-A\-I\-C}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf subpavings\-::\-Adaptive\-Histogram\-::scaled\-E\-M\-P\-Sum\-A\-I\-C}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_ad5748390a25f398475bb60575f0e9a89}


\-A value for the unscaled \-E\-M\-P part of \-A\-I\-C score. 

pi for a histogram is c $\ast$ e(-\/1/t $\ast$ energy) energy is \-E\-M\-P + \-P\-E\-N

\-Under \-A\-I\-C, \-E\-M\-P is
\begin{DoxyItemize}
\item 1 x sum over leaves of (counts in leaf x -\/ln(count in leaf / (n x vol of leaf))) where n is the total number of data points in the histogram
\end{DoxyItemize}

scaled\-E\-M\-P\-Sum\-A\-I\-C will default to zero until set by some method of the object.

\-Dotprecision accumulator used to mitigate rounding errors in calculations. 

\-Definition at line 148 of file adaptivehistogram.\-hpp.



\-Referenced by \-Adaptive\-Histogram(), get\-E\-M\-P\-Score\-A\-I\-C(), get\-Score\-A\-I\-C(), operator=(), output\-Log\-E\-M\-P\-A\-I\-C(), recalc\-Scaled\-E\-M\-P\-Sum\-A\-I\-C(), swap(), and update\-Scaled\-E\-M\-P\-Sum\-A\-I\-C().

\hypertarget{classsubpavings_1_1AdaptiveHistogram_acd3c0bacd5148b82188cc129b3a59e96}{\index{subpavings\-::\-Adaptive\-Histogram@{subpavings\-::\-Adaptive\-Histogram}!scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}}
\index{scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R@{scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}!subpavings::AdaptiveHistogram@{subpavings\-::\-Adaptive\-Histogram}}
\paragraph[{scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}]{\setlength{\rightskip}{0pt plus 5cm}dotprecision {\bf subpavings\-::\-Adaptive\-Histogram\-::scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R}\hspace{0.3cm}{\ttfamily  \mbox{[}mutable, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogram_acd3c0bacd5148b82188cc129b3a59e96}


\-A value for the unscaled \-E\-M\-P part of \-C\-O\-P\-E\-R\-R score. 

pi for a histogram is c $\ast$ e(-\/1/t $\ast$ energy) energy is \-E\-M\-P + \-P\-E\-N

\-Under \-C\-O\-P\-E\-R\-R scoring, \-E\-M\-P is -\/1/n$^\wedge$2 x sum over leaves of (counts in leaf squared / volume of leaf) where n is the total number of data points in the histogram

\-Scaling means multiplying this unscaled \-Emp sum term by 1/n$^\wedge$2

scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R will default to zero until set by some method of the object.

\-Dotprecision accumulator used to mitigate rounding errors in calculations. 

\-Definition at line 131 of file adaptivehistogram.\-hpp.



\-Referenced by \-Adaptive\-Histogram(), get\-E\-M\-P\-Score\-C\-O\-P\-E\-R\-R(), get\-Score\-C\-O\-P\-E\-R\-R(), operator=(), output\-Log\-E\-M\-P\-C\-O\-P\-E\-R\-R(), recalc\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R(), swap(), and update\-Scaled\-E\-M\-P\-Sum\-C\-O\-P\-E\-R\-R().



\-The documentation for this class was generated from the following files\-:\begin{DoxyCompactItemize}
\item 
\hyperlink{adaptivehistogram_8hpp}{adaptivehistogram.\-hpp}\item 
\hyperlink{adaptivehistogram_8cpp}{adaptivehistogram.\-cpp}\end{DoxyCompactItemize}
