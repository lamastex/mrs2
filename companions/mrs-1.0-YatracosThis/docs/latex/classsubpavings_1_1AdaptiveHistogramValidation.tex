\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation}{\subsection{subpavings\-:\-:\-Adaptive\-Histogram\-Validation \-Class \-Reference}
\label{classsubpavings_1_1AdaptiveHistogramValidation}\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
}


\-A wrapper or manager for an \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} aka \-Stats\-Sub\-Paving\-Val in conjunction with massive amounts of sample data.  




{\ttfamily \#include $<$adaptivehistogramvalidation.\-hpp$>$}



\-Collaboration diagram for subpavings\-:\-:\-Adaptive\-Histogram\-Validation\-:
\subsubsection*{\-Public \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ae0f0cb633c516b90444862c87eef424c}{\-Adaptive\-Histogram\-Validation} ()
\begin{DoxyCompactList}\small\item\em \-Default constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a07760421ee7a7bdf1d38cf29a1ebf5c8}{\-Adaptive\-Histogram\-Validation} (bool as)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a3ef9f2889ef3bde29457990c210094e9}{\-Adaptive\-Histogram\-Validation} (ivector \&v, bool as=false)
\begin{DoxyCompactList}\small\item\em \-Initialised constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a899983cbb878e24d4e3d7e54601b7dd2}{\-Adaptive\-Histogram\-Validation} (const \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&other)
\begin{DoxyCompactList}\small\item\em \-Copy constructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \& \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_aba8d900d6f696824de3e6cb5bb99e794}{operator=} (const \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&rhs)
\begin{DoxyCompactList}\small\item\em \-Copy assignment operator. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ad3d12ca5330306b377001a4064599430}{operator+} (const \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&rhs)
\begin{DoxyCompactList}\small\item\em \-Overloaded addition operator. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a26664847dd161cb938bddb579946b018}{$\sim$\-Adaptive\-Histogram\-Validation} ()
\begin{DoxyCompactList}\small\item\em \-Destructor. \end{DoxyCompactList}\item 
\hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} $\ast$ \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a6449b127c16423141cbed8f193cfcf59}{get\-Sub\-Paving} () const 
\begin{DoxyCompactList}\small\item\em \-Return a pointer to the \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} this manages. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a23a25c2169c94e019859f8efc2657c1b}{get\-Root\-Vcounter} () const 
\begin{DoxyCompactList}\small\item\em \-Gets count in the rootpaving in the root paving. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_abba9be0456a1228037dd40e7353d2169}{get\-Root\-Leaves} () const 
\begin{DoxyCompactList}\small\item\em \-Gets number of leaf nodes in the root paving. \end{DoxyCompactList}\item 
real \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a22ac33f1952cfb6b605193cddab42bae}{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol} () const 
\begin{DoxyCompactList}\small\item\em \-Gets the sum of leaf count over volume in root paving. \end{DoxyCompactList}\item 
double \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a8d94391339b619f6f3aefb89ca761e99}{get\-Min\-Vol} (double min\-Vol\-B) const 
\begin{DoxyCompactList}\small\item\em get the value of the minimum volume for a splittable node. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_abfd3760f709336024357625903d9f2e9}{get\-Hold\-All\-Stats} () const 
\begin{DoxyCompactList}\small\item\em get the value of hold\-All\-Stats field. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_aed8e75b2af342b9c1460431c223dca8e}{\-Int\-Vec} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ab9672c3fe9ee4ced96a1ad03ee12c1c9}{get\-Leaf\-Levels} () const 
\item 
std\-::string \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_acba6350d62c4aa8c1d9de5589c039543}{get\-Leaf\-Levels\-String} () const 
\item 
\hyperlink{namespacesubpavings_a612fc5639b45583b9fd33bd304354f81}{\-Size\-\_\-t\-Vec} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a234fc6618948f692ea2458cedb4fed8f}{get\-Leaf\-Counts} () const 
\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a75453f853b530cd3e2a7afccf25e39d0}{output\-Log} (const std\-::string \&s, const int i) const 
\begin{DoxyCompactList}\small\item\em \-Append current state of histogram to a txt log file. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a30cd1199dfab7883a8191e501d372613}{merge\-Up} ()
\begin{DoxyCompactList}\small\item\em \-Merge a multileaf histogram up to just root box. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a7498bdc1663c857052e5bc147bf086f7}{split\-To\-Shape} (std\-::string instruction)
\begin{DoxyCompactList}\small\item\em \-Split a histogram to a specified shape. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a0286278b4e489ed8809dcb60d136dce7}{output\-Graph\-Dot} () const 
\begin{DoxyCompactList}\small\item\em \-Make a .dot graph file from histogram structure. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ac7ad1cd4a9403ae91083dc0ef2356a24}{output\-To\-Txt\-Tabs} (const std\-::string \&s, bool confirm=false) const 
\begin{DoxyCompactList}\small\item\em \-Output the subpaving managed by this to a txt file. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a78d5c3ad5e31fc438e0c4cac65e73313}{output\-Root\-To\-Txt} (const std\-::string \&s, bool confirm=false) const 
\begin{DoxyCompactList}\small\item\em \-Output details of full sample (from root) to txt tile. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}{\bf \-Insert rvectors in a txt file into \-Adaptive\-Histogram object.}\par
{\em \-A group of overloaded functions which read in lines of data representing rvectors from a txt file. \-The dimensions of the rvector are deduced from the input format and all the data then expected to have the same dimension. \-Any data not matching the expected dimensions, based on assessing the first valid line found, will be rejected. \-Expects one line per rvector with the elements separated by white space (space or tabs), with no non-\/numeric characters. \-Carries out some basic data checking through \hyperlink{namespacesubpavings_af62c725dd362922c15d45983e2d8f6cf}{check\-String()}. \-Input lines which do not pass are printed to standard output with an error message but the entire file will continue to be processed and valid lines converted to rvectors which are stored in the\-Data. \-Conversion to rvectors is via the cxsc\-::operator$<$$<$ which allows an rvector to be constructed from a stream.

\-Can read 1-\/d rvector data from doubles or floats but insists on a decimal point in each number (otherwise the number is rejected).

\-For example, a string \char`\"{}12.\-04 1.\-00005e-\/10 -\/30.\-0006\char`\"{} will be read as a 3-\/dimensional rvector, a string \char`\"{}-\/30.\-0006\char`\"{} will be read as a 1-\/dimensional rvector and a string \char`\"{}30\char`\"{} will be rejected.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to read data from. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em headerlines} & is number of headerlines to skip before reading data. \-Defaults to 0. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging) \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A file with filename s in the same directory as \hyperlink{Exm__3__3_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main()} or with the filename incorporating directory location. 
\end{DoxyPrecond}
\begin{DoxyReturn}{\-Returns}
true if at least some data inserted, false if txt file cannot be read, is empty, or contains no valid data, or if something failed after data is read and when it is being inserted. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a1c8f4b1ea86038de1e1d780f227f9b28}{insert\-Rvectors\-From\-Txt} (const std\-::string \&s, std\-::vector$<$ size\-\_\-t $>$ \&num\-Nodes, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ad8df8dae6a879dc00975edfe4a0cc3b6}{insert\-Rvectors\-From\-Txt} (const std\-::string \&s, std\-::vector$<$ size\-\_\-t $>$ \&num\-Nodes, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, const std\-::size\-\_\-t headerlines=0, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Insert all rvectors from a container of rvectors.}\par
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_aa0d5d92e0474bfc0574340b34268dd39}{insert\-From\-R\-Vec} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a6817e38bd1c2749a711f702c70dd16b5}{insert\-From\-R\-Vec\-For\-Hold\-Out} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&rvec, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, int hold\-Out\-Count, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging=\hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737}{\-N\-O\-L\-O\-G})
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ace1a6eca888d6251a7e3db5d1c59bf2b}{insert\-From\-R\-S\-Sample\-For\-Hold\-Out} (const \hyperlink{classRSSample}{\-R\-S\-Sample} \&rss, int label, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, int hold\-Out\-Count, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Data splitting method to obtain the \char`\"{}best\char`\"{} estimate.}\par
{\em \-Implementation of the data splitting method based on \-Devroye and \-Lugosi, 2001, p. 98.

\-This takes a histogram and progressively split using a priority queue to determine which node to split first. \-The current histogram is added into an \hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator } object. \-The \-Yatracos set as defined in \-Devroye and \-Lugosi, 2001 is obtained and stored in a list of pointers to sets of \hyperlink{classsubpavings_1_1CollatorSPnode}{subpavings\-::\-Collator\-S\-Pnode}. \-The corresponding delta value is obtained by taking the difference of the empirical measure of the training data and the empirical measure of the validation data.

\-Splitting continues until some criteria applying either to individual nodes or to the histogram as a whole is satisfied, or there are no more splittable nodes, or if some criteria in relation to the delta value is satisfied.

\-Nodes are not considered to be splittable if they satisfy two criteria\-: \-First, their volume is greater than the minimum volume specified for the histogram as a whole, min\-Vol\-B. \-Second if both prospective children would have at least the parameter min\-Child\-Points data points associated with them.

\-If more than one node is equally 'large', on the basis of the node comparison comp\-Test used, then a random choice is made between all equally large nodes to find the node which will be split.

\-The random number generator used for random selection between equally 'large' nodes uses a default seed to ensure that results can be replicated. \-If you are looking at distributions of results across mulitple histograms, supply the random number generator to the priority queue to ensure that each histogram will make different random choices.


\begin{DoxyParams}{\-Parameters}
{\em comp\-Test} & is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. \\
\hline
{\em he} & is an instance of a class which provides a function to determine when to stop splitting. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
{\em min\-Child\-Points} & is the minimum number of points any prospective child must have for a leaf node to be splittable. \\
\hline
{\em min\-Vol\-B} & is a multiplier applied to (log n)$^\wedge$2/n to give the the minimum volume for a splittable node. \-A node with volume $<$ min\-Vol\-B(log n)$^\wedge$2/n is not splittable. \-Important with \-A\-I\-C or \-C\-O\-P\-E\-R\-R. \\
\hline
{\em rgsl} & is a pointer to a gls random number generator. \\
\hline
{\em tol} & is the tolerance for the stopping criteria. \\
\hline
{\em distr} & is an integer that indicates what distribution is being used to calculate the integrated absolute error (\-I\-A\-E) for simulation purposes. \-If 0, there will be no calculations for the \-I\-A\-E. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
coll an \hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator } object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramVCollator}{\-Adaptive\-Histogram\-V\-Collator} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a261b3220218fe58d08713381aa7b0b44}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, int distr, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes)
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramVCollator}{\-Adaptive\-Histogram\-V\-Collator} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ad076189eb2565d34b8f4998eb7330827}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, int distr, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Data splitting method to obtain the \char`\"{}best\char`\"{} estimate for uniform}\par
{\em mixtures.

\-The implementation is the same as above except that the \-I\-A\-E calculations are for uniform mixtures.


\begin{DoxyParams}{\-Parameters}
{\em comp\-Test} & is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. \\
\hline
{\em he} & is an instance of a class which provides a function to determine when to stop splitting. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
{\em min\-Child\-Points} & is the minimum number of points any prospective child must have for a leaf node to be splittable. \\
\hline
{\em min\-Vol\-B} & is a multiplier applied to (log n)$^\wedge$2/n to give the the minimum volume for a splittable node. \-A node with volume $<$ min\-Vol\-B(log n)$^\wedge$2/n is not splittable. \-Important with \-A\-I\-C or \-C\-O\-P\-E\-R\-R. \\
\hline
{\em rgsl} & is a pointer to a gls random number generator. \\
\hline
{\em tol} & is the tolerance for the stopping criteria. \\
\hline
{\em my\-Part} & is a reference to to \-Stats\-Sub\-Paving that is split into a uniform mixture. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
coll an \hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator } object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a63938649a46bb4a5ed5d432606b02427}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, double weight, std\-::vector$<$ int $>$ holes\-Loc, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opt\-Hist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ae982e9b5ffc50d9893a557a09bfc89af}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, double weight, std\-::vector$<$ int $>$ holes\-Loc, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opt\-Hist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_aabc3d1996ec2e9e1e227f6012c0c8f06}{priority\-Split\-And\-Estimate\-With\-Switch} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, double weight, std\-::vector$<$ int $>$ holes\-Loc, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opthist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ae2684877f0996eea6f6593f1be2ab38a}{priority\-Split\-And\-Estimate\-With\-Switch} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, double weight, std\-::vector$<$ int $>$ holes\-Loc, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opthist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ae94f662a33afa791de400341ad98cff7}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode} \&node\-Est, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opt\-Hist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a831814eaa200ac0fb42b5b600ec785c3}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode} \&node\-Est, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opt\-Hist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ae20e1507aad418b0d5aee31882b738ea}{priority\-Split\-And\-Estimate\-With\-Switch} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode} \&node\-Est, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opt\-Hist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ad3f8cf7cf11ce1214abd2559bea54393}{priority\-Split\-And\-Estimate\-With\-Switch} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode} \&node\-Est, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opt\-Hist)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Data splitting method to obtain the \char`\"{}best\char`\"{} estimate for finite}\par
{\em mixtures.

\-The implementation is the same as above except that the \-I\-A\-E calculations are for finite mixtures.


\begin{DoxyParams}{\-Parameters}
{\em comp\-Test} & is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. \\
\hline
{\em he} & is an instance of a class which provides a function to determine when to stop splitting. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
{\em min\-Child\-Points} & is the minimum number of points any prospective child must have for a leaf node to be splittable. \\
\hline
{\em min\-Vol\-B} & is a multiplier applied to (log n)$^\wedge$2/n to give the the minimum volume for a splittable node. \-A node with volume $<$ min\-Vol\-B(log n)$^\wedge$2/n is not splittable. \-Important with \-A\-I\-C or \-C\-O\-P\-E\-R\-R. \\
\hline
{\em rgsl} & is a pointer to a gls random number generator. \\
\hline
{\em tol} & is the tolerance for the stopping criteria. \\
\hline
{\em my\-Part} & is a reference to to \-Stats\-Sub\-Paving that is split into a uniform mixture. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
coll an \hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator } object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a46ff8e128b5d734c3839871c465bcf46}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, \hyperlink{structFinMix}{\-Fin\-Mix} \&mixt, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, double tol, int deg, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opthist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a990028dc08bc4780df6a04f78b4ec644}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, \hyperlink{structFinMix}{\-Fin\-Mix} \&mixt, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, double tol, int deg, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opthist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a8f39563ed08722fbe6be55474681abd5}{priority\-Split\-And\-Estimate\-With\-Switch} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, \hyperlink{structFinMix}{\-Fin\-Mix} \&mixt, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, double tol, int deg, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opthist)
\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a6bd25ba3a874dee64a2fd93984542f39}{priority\-Split\-And\-Estimate\-With\-Switch} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, \hyperlink{structFinMix}{\-Fin\-Mix} \&mixt, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, int max\-Check, double tol, int deg, \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} \&opthist)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Data splitting method to obtain the \char`\"{}best\char`\"{} estimate. \-Samples}\par
{\em drawn from \hyperlink{classsubpavings_1_1MappedSPnode}{\-Mapped\-S\-Pnode} function estimations.

\-The implementation is the same as above except that the \-I\-A\-E calculations are for uniform mixtures.


\begin{DoxyParams}{\-Parameters}
{\em comp\-Test} & is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. \\
\hline
{\em he} & is an instance of a class which provides a function to determine when to stop splitting. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
{\em min\-Child\-Points} & is the minimum number of points any prospective child must have for a leaf node to be splittable. \\
\hline
{\em min\-Vol\-B} & is a multiplier applied to (log n)$^\wedge$2/n to give the the minimum volume for a splittable node. \-A node with volume $<$ min\-Vol\-B(log n)$^\wedge$2/n is not splittable. \-Important with \-A\-I\-C or \-C\-O\-P\-E\-R\-R. \\
\hline
{\em rgsl} & is a pointer to a gls random number generator. \\
\hline
{\em stop\-Crit} & is a bool to indicate if the splits are to stop when some criteria is met. \\
\hline
{\em method,\-:} & 1. \-Yatracos; 2\-: \-Scheffe \\
\hline
{\em hist} & is the hist-\/th simulation \\
\hline
{\em max\-Leaf\-Nodes} & is the maximum number of leaves allowed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
coll an \hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator } object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramVCollator}{\-Adaptive\-Histogram\-V\-Collator} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_aeb61aa929e6edebe98d6d4fbb10a6adb}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, bool stop\-Crit, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode} \&node\-Est)
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramVCollator}{\-Adaptive\-Histogram\-V\-Collator} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ab38050780c66024e0c278789b37e25ed}{priority\-Split\-And\-Estimate} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, bool stop\-Crit, int method, size\-\_\-t hist, size\-\_\-t max\-Leaf\-Nodes, \hyperlink{classsubpavings_1_1RealMappedSPnode}{\-Real\-Mapped\-S\-Pnode} \&node\-Est)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-A heuristic data splitting method to obtain the \char`\"{}best\char`\"{} estimate}\par
{\em for uniform mixtures.

\-The implementation is similar same as above but instead of making pairwise comparisons at each split, we instead do a process of elimination and do pairwise comparisons.

\-Note\-: this method is used if wanting to calculat \-I\-A\-E for uniform mixtures.


\begin{DoxyParams}{\-Parameters}
{\em comp\-Test} & is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. \\
\hline
{\em he} & is an instance of a class which provides a function to determine when to stop splitting. \\
\hline
{\em logging} & an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). \\
\hline
{\em min\-Child\-Points} & is the minimum number of points any prospective child must have for a leaf node to be splittable. \\
\hline
{\em min\-Vol\-B} & is a multiplier applied to (log n)$^\wedge$2/n to give the the minimum volume for a splittable node. \-A node with volume $<$ min\-Vol\-B(log n)$^\wedge$2/n is not splittable. \-Important with \-A\-I\-C or \-C\-O\-P\-E\-R\-R. \\
\hline
{\em rgsl} & is a pointer to a gls random number generator. \\
\hline
{\em tol} & is the tolerance for the stopping criteria. \\
\hline
{\em my\-Part} & is a reference to to \-Stats\-Sub\-Paving that is split into a uniform mixture. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
coll an \hyperlink{classsubpavings_1_1AdaptiveHistogramCollator}{\-Adaptive\-Histogram\-Collator } object. 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramVCollator}{\-Adaptive\-Histogram\-V\-Collator} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a86feeca7ad74bc1c9ebc35f2ef0dd5e6}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, long double tol, \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, size\-\_\-t max\-Leaf\-Nodes)
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramVCollator}{\-Adaptive\-Histogram\-V\-Collator} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a9a558b6a13ad7019acd893f0edbb107b}{priority\-Split} (const \hyperlink{classsubpavings_1_1NodeCompObjVal}{\-Node\-Comp\-Obj\-Val} \&comp\-Test, const \hyperlink{classsubpavings_1_1HistEvalObjVal}{\-Hist\-Eval\-Obj\-Val} \&he, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t min\-Child\-Points, double min\-Vol\-B, gsl\-\_\-rng $\ast$rgsl, long double tol, \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, size\-\_\-t max\-Leaf\-Nodes)
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf \-Get the \-I\-A\-E of a distribution}\par
{\em \-Get the integrated absolute error of the specified distribution. 
\begin{DoxyParams}{\-Parameters}
{\em distr} & is an integer that indicates which distribution is used. 1\-: bivariate gaussian distribution (not implemented yet) 2\-: \-Levy 2\-D distribution (not implemented yet) 3\-: \-Rosenbrock 2\-D distribution (not implemented yet) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
the integrated absolute error for this realization 
\end{DoxyReturn}
}\begin{DoxyCompactItemize}
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ae599e0bbb226dc0610c4ec25845533d8}{get\-I\-A\-E} (int distr)
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a034c61becd57f5d282435f5881950035}{get\-Fin\-Mix\-I\-A\-E} (\hyperlink{structFinMix}{\-Fin\-Mix} \&mixt)
\item 
cxsc\-::interval \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_aa8b89b93450dea8e464eac31d67c78d1}{get\-Fin\-Mix\-Interval\-I\-A\-E} (\hyperlink{structFinMix}{\-Fin\-Mix} \&mixt, double tol, int deg, bool full)
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ab032205bb13623930c84ff142f565ac5}{get2\-D\-I\-A\-E} (\hyperlink{classtaylor_1_1dim2taylor}{taylor\-::dim2taylor}($\ast$testpnt)(\hyperlink{classtaylor_1_1dim2taylor__vector}{taylor\-::dim2taylor\-\_\-vector}, interval))
\item 
cxsc\-::real \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_aa54b166c50901dc9ec2976bb4a5df916}{get\-Unif\-I\-A\-E} (\hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} \&my\-Part, double weight, vector$<$ int $>$ holes\-Loc, bool full)
\end{DoxyCompactItemize}
\end{Indent}
\subsubsection*{\-Private \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a7bebcc83720d315cbbb8c8ab85d7a945}{\-Adaptive\-Histogram\-Validation} (\hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} $\ast$spn, bool as)
\begin{DoxyCompactList}\small\item\em \-Private initialised constructor. \-Initialised with pointer to subpaving and value for hold\-All\-Stats. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_acf7246052d9032f41a4f237f1b5207d9}{complete\-Data\-Insertion\-From\-Vec} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t hold\-Out\-Count, std\-::vector$<$ size\-\_\-t $>$ \&num\-Nodes)
\begin{DoxyCompactList}\small\item\em \-Complete insertion of training and validation data from a vector container. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a7b6e78d7a069536dd096e81c6e3d8e1f}{have\-Made\-Paving} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const size\-\_\-t dim)
\begin{DoxyCompactList}\small\item\em \-Checks if we need to make root paving for the histogram object. \end{DoxyCompactList}\item 
size\-\_\-t \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ac57fa83d1ec2fc1e9cf1565c9cc07f91}{insert\-Data\-From\-Container} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const \hyperlink{classsubpavings_1_1SplitDecisionObj}{\-Split\-Decision\-Obj} \&bool\-Test, \hyperlink{namespacesubpavings_aef8e51096b59ecaf1a1e9b2ee24b6089}{\-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L} logging, size\-\_\-t hold\-Out\-Count, std\-::vector$<$ size\-\_\-t $>$ \&num\-Nodes)
\begin{DoxyCompactList}\small\item\em \-Insert training and validation data from a container. \end{DoxyCompactList}\item 
void \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a34f7487fd92886151634c00e8e75cca5}{output\-Log\-Start} (const std\-::string \&s) const 
\begin{DoxyCompactList}\small\item\em \-Opening line of a txt log file. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Static \-Private \-Member \-Functions}
\begin{DoxyCompactItemize}
\item 
static ivector \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_abaa0f3ffd23bccd07a2c4a4b9a60e579}{make\-Box} (const \hyperlink{namespacesubpavings_a30e15e24c8d81a2160d7422ef3c39d68}{\-R\-Vec\-Data} \&the\-Data, const size\-\_\-t dim)
\begin{DoxyCompactList}\small\item\em \-Make a box to contain all the data. \end{DoxyCompactList}\item 
static bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_ae63a7462ea0b3f0fc11ff45eff208cd0}{check\-Node\-Count\-For\-Split} (const \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} $\ast$const spn, bool vol\-Checking, double min\-Vol, size\-\_\-t min\-Child\-Points)
\begin{DoxyCompactList}\small\item\em \-Method to do checking for whether to split a node. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Private \-Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} $\ast$ \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a811e21423987027452237cabf38c008c}{root\-Vpaving}
\begin{DoxyCompactList}\small\item\em \-Pointer to the root node of the subpaving tree. \end{DoxyCompactList}\item 
ivector \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_aa8a961766f97013134d73f1735f3516c}{root\-Box}
\begin{DoxyCompactList}\small\item\em \-The root box used to form the subpaving tree. \end{DoxyCompactList}\item 
\hyperlink{namespacesubpavings_aa79f33663da92502ce1a37f3fd1f3d85}{\-Big\-Data\-Collection} \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_acae18e51a5026807492d2109702c3c93}{data\-Collection}
\begin{DoxyCompactList}\small\item\em \-A container for all sample data passed to this. \end{DoxyCompactList}\item 
bool \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a4de24d08db784df2fdb619ba2c1f62fd}{hold\-All\-Stats}
\begin{DoxyCompactList}\small\item\em \-Controls whether all available statistics are maintained in the root\-Paving. \-If set to false (default) only counts are maintained. \end{DoxyCompactList}\item 
std\-::string \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a7d46cc6c04481f9579e9f5238ccea8b2}{creation\-String}
\begin{DoxyCompactList}\small\item\em \-A string showing the order of creation of the root\-Paving. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsubsection*{\-Static \-Private \-Attributes}
\begin{DoxyCompactItemize}
\item 
static const real \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation_a0039bec0f033c35a5477375cb54eb8ea}{padding} = 0.\-000005
\begin{DoxyCompactList}\small\item\em a constant for padding a box if it is tailor-\/made for data. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsubsection{\-Detailed \-Description}
\-A wrapper or manager for an \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} aka \-Stats\-Sub\-Paving\-Val in conjunction with massive amounts of sample data. 

\-Here sample data is multi-\/dimensional point-\/valued data in a cxsc\-::rvector container. \-The \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} class manages \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode } objects (\hyperlink{namespacesubpavings_ace6b16f0adf0db13eeb38e124d5328c6}{\-Stats\-Sub\-Pavings }) for the purpose of creating adaptive histograms from sample data and also manages the container for the sample data itself.

\-An \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} (a pointer to an \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} is aliased as \-Stats\-Sub\-Paving) is a binary tree representation of a regular subpaving which can be used for processing statistical sample data. \-S\-P\-S\-Vnodes do not actually hold data, they only need to know where the data they are associated with is stored. \-The leaf nodes in the \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} tree controlled by an \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} object have a vector of iterators into the \hyperlink{namespacesubpavings_aa79f33663da92502ce1a37f3fd1f3d85}{\-Big\-Data\-Collection}, a data\-Collection managed by that \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} object.

\-The \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} class uses the \-C-\/\-X\-S\-C library class rvector for sample data points. rvectors can have 1 or many dimensions. 

\-Definition at line 82 of file adaptivehistogramvalidation.\-hpp.



\subsubsection{\-Constructor \& \-Destructor \-Documentation}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a7bebcc83720d315cbbb8c8ab85d7a945}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}}
\index{\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{\-Adaptive\-Histogram\-Validation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation\-::\-Adaptive\-Histogram\-Validation} (
\begin{DoxyParamCaption}
\item[{{\bf \-S\-P\-S\-Vnode} $\ast$}]{spn, }
\item[{bool}]{as}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a7bebcc83720d315cbbb8c8ab85d7a945}


\-Private initialised constructor. \-Initialised with pointer to subpaving and value for hold\-All\-Stats. 



\-Definition at line 98 of file adaptivehistogramvalidation.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Box(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), root\-Box, and root\-Vpaving.


\begin{DoxyCode}
        : holdAllStats(as)
{
    if (NULL == spn) {
        throw HistException("Cannot use null SPSVnode pointer in constructor");
    }
    rootVpaving = spn;
    creationString = rootVpaving->getNodeName();
    creationString += rootVpaving->getChildNodeNames();

    rootBox = spn->getBox();

    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ae0f0cb633c516b90444862c87eef424c}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}}
\index{\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{\-Adaptive\-Histogram\-Validation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation\-::\-Adaptive\-Histogram\-Validation} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ae0f0cb633c516b90444862c87eef424c}


\-Default constructor. 

\-By default, only counts are maintained in subpaving this manages, rather than all available stats. 

\-Definition at line 402 of file adaptivehistogramvalidation.\-cpp.



\-References root\-Box, and root\-Vpaving.


\begin{DoxyCode}
        : holdAllStats(false), creationString("")
{
    rootVpaving = NULL;
    rootBox = ivector();    // ivector with length 1 and undefined elements


    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a07760421ee7a7bdf1d38cf29a1ebf5c8}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}}
\index{\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{\-Adaptive\-Histogram\-Validation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation\-::\-Adaptive\-Histogram\-Validation} (
\begin{DoxyParamCaption}
\item[{bool}]{as}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a07760421ee7a7bdf1d38cf29a1ebf5c8}


\-Initialised constructor. 

\-Initialised with parameter controlling whether all available statistics be maintained in the \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} (true for all stats, false for counts only). 

\-Definition at line 414 of file adaptivehistogramvalidation.\-cpp.



\-References root\-Box, and root\-Vpaving.


\begin{DoxyCode}
        : holdAllStats(as), creationString("")
{
    rootVpaving = NULL;
    rootBox = ivector();    // ivector with length 1 and undefined elements


    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a3ef9f2889ef3bde29457990c210094e9}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}}
\index{\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{\-Adaptive\-Histogram\-Validation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation\-::\-Adaptive\-Histogram\-Validation} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{v, }
\item[{bool}]{as = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}explicit\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a3ef9f2889ef3bde29457990c210094e9}


\-Initialised constructor. 

\-Initialised with domain box. \-By default, only counts are maintained as stats in the in the \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} tree managed by this \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation}.

\-Ideal constructor when the support domain of data is known a priori or has been transformed to a known domain but splitting criteria have not been determined a priori. 

\-Definition at line 427 of file adaptivehistogramvalidation.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), root\-Box, root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
        : holdAllStats(as)
{
    try {
        rootVpaving = new SPSVnode(v, !as);
        creationString = rootVpaving->getNodeName();

        rootBox = v;
    }
    catch (bad_alloc& ba) {
        string msg(ba.what());
        std::cerr << "Error allocating memory in constructor" << std::endl;
        throw HistException("Memory allocation error in constructor: " + msg);
    }
    catch (SPnodeException& spe) {
        string msg(spe.what());
        std:: cerr << "SPnodeExcepton in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Memory allocation error in constructor:" + msg);
    }
    catch (exception& e) {
        string msg(e.what());
        std:: cerr << "Error in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Memory allocation error in constructor:" + msg);
    }

    // nothing happens to dataCollection when object is constructed
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a899983cbb878e24d4e3d7e54601b7dd2}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}}
\index{\-Adaptive\-Histogram\-Validation@{\-Adaptive\-Histogram\-Validation}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{\-Adaptive\-Histogram\-Validation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation\-::\-Adaptive\-Histogram\-Validation} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Adaptive\-Histogram\-Validation} \&}]{other}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a899983cbb878e24d4e3d7e54601b7dd2}


\-Copy constructor. 



\-Definition at line 458 of file adaptivehistogramvalidation.\-cpp.



\-References creation\-String, data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
        : rootBox(other.rootBox), holdAllStats(other.holdAllStats) 
{
    try {
       // cout << "calling copy constructor" << endl;
      rootVpaving = new SPSVnode(*(other.rootVpaving));
        creationString = rootVpaving->getNodeName();
        creationString += rootVpaving->getChildNodeNames();

        //copy dataCollection from other to this
        dataCollection = other.dataCollection;

    }
    catch (bad_alloc& ba) {
        string msg(ba.what());
        std::cerr << "Error allocating memory in constructor: original error "
                                            << msg << std:: endl;
        throw HistException("Memory allocation error in constructor: " + msg);
    }
    catch (SPnodeException& spe) {
        string msg(spe.what());
        std:: cerr << "SPnodeExcepton in constructor: original error "
                                            << msg << std::endl;
        throw HistException("SPnodeException in constructor: " + msg);
    }
    catch (exception& e) {
        string msg(e.what());
        std:: cerr << "Error in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Error in constructor: " + msg);
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a26664847dd161cb938bddb579946b018}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!$\sim$\-Adaptive\-Histogram\-Validation@{$\sim$\-Adaptive\-Histogram\-Validation}}
\index{$\sim$\-Adaptive\-Histogram\-Validation@{$\sim$\-Adaptive\-Histogram\-Validation}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{$\sim$\-Adaptive\-Histogram\-Validation}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation\-::$\sim$\-Adaptive\-Histogram\-Validation} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a26664847dd161cb938bddb579946b018}


\-Destructor. 



\-Definition at line 536 of file adaptivehistogramvalidation.\-cpp.



\-References root\-Vpaving.


\begin{DoxyCode}
{
    delete rootVpaving;
}
\end{DoxyCode}


\subsubsection{\-Member \-Function \-Documentation}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ae63a7462ea0b3f0fc11ff45eff208cd0}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!check\-Node\-Count\-For\-Split@{check\-Node\-Count\-For\-Split}}
\index{check\-Node\-Count\-For\-Split@{check\-Node\-Count\-For\-Split}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{check\-Node\-Count\-For\-Split}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::check\-Node\-Count\-For\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-S\-P\-S\-Vnode} $\ast$const}]{spn, }
\item[{bool}]{vol\-Checking, }
\item[{double}]{min\-Vol, }
\item[{size\-\_\-t}]{min\-Child\-Points}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ae63a7462ea0b3f0fc11ff45eff208cd0}


\-Method to do checking for whether to split a node. 

\-Used in priority\-Split.

\-Decides whether to split node based on checking volume and number of points that would result in child nodes.

\-Node volume must be $>$=min\-Vol to split and \-If there is a min\-Child\-Points$>$0 specified, then either the node must have at least min\-Child\-Points and all the points go to one of the children (the other getting none) or the smallest number of points which would go to the either of the prospective new children must be $>$= min\-Child\-Points

\-Thus in general the method will only return true if the given node satisfies both the min\-Vol test and, if it were to be split, both children would have at least min\-Child\-Points data points, but if all the data points would go to one child (none) to the other, this is considered to also satisfy the min\-Child\-Points test.


\begin{DoxyParams}{\-Parameters}
{\em spn} & is a pointer to the target node. \\
\hline
{\em vol\-Checking} & indicates whether volume is being checked \\
\hline
{\em min\-Vol} & is the minimum volume allowed to be tested for. \\
\hline
{\em min\-Child\-Points} & is the minimum number of points that there would be in the children if the node were to be split. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
true if has been a test conditions satisfied, false otherwise. 
\end{DoxyReturn}


\-Definition at line 378 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Min\-Child\-Count\-If\-Split(), and subpavings\-::\-S\-Pnode\-::node\-Volume().



\-Referenced by priority\-Split\-And\-Estimate(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{
    bool retValue = false;

    if ((!volChecking || (volChecking && (spn->nodeVolume() >= minVol)))
        && ((minChildPoints == 0)
            || (minChildPoints > 0
                &&
                ((spn->getCounter() >= minChildPoints) &&
                    ((spn->getMinChildCountIfSplit() == 0)
                    ||
                    (spn->getMinChildCountIfSplit() >= minChildPoints))
                ))
            )
        ) { retValue = true; }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_acf7246052d9032f41a4f237f1b5207d9}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!complete\-Data\-Insertion\-From\-Vec@{complete\-Data\-Insertion\-From\-Vec}}
\index{complete\-Data\-Insertion\-From\-Vec@{complete\-Data\-Insertion\-From\-Vec}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{complete\-Data\-Insertion\-From\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::complete\-Data\-Insertion\-From\-Vec} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{hold\-Out\-Count, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{num\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_acf7246052d9032f41a4f237f1b5207d9}


\-Complete insertion of training and validation data from a vector container. 

\-First checks if the box exists and makes it otherwise, then checks box dimensions against data dimensions if box already exists, and finally inserts the data. \-A boolean bool\-Val indicates if the data should be in the training or validation set.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function operator determining whether to split a node when a data point arrives. \\
\hline
{\em logging} & an enum controlling whether a log file is created for histogram creation process; set to \-T\-X\-T for logging to a txt file. \\
\hline
{\em bool\-Val} & a boolean to indicate if the data point should be in the validation set (true) or not (false). \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A container the\-Data containing at least one rvector. 

this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object may have an initialised \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} pointed to by root\-Paving, but root\-Paving can also be \-N\-U\-L\-L. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
\-If the root\-Paving was \-N\-U\-L\-L when the function was entered, then root\-Paving is pointed to a new \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} object whose root node has a box tailored to contain all the data read in. 

\-The data in the\-Data has been put into the \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}'s data\-Collection and also associated with root\-Paving's leaves via iterators to data\-Collection. 
\end{DoxyPostcond}
\begin{DoxyReturn}{\-Returns}
true if data successfully put into a data\-Collection and associated with the root\-Paving's leaves, false otherwise. 
\end{DoxyReturn}


\-Definition at line 116 of file adaptivehistogramvalidation.\-cpp.



\-References have\-Made\-Paving(), insert\-Data\-From\-Container(), taylor\-::\-Lb(), root\-Box, and taylor\-::\-Ub().



\-Referenced by insert\-From\-R\-S\-Sample\-For\-Hold\-Out(), insert\-From\-R\-Vec(), insert\-From\-R\-Vec\-For\-Hold\-Out(), and insert\-Rvectors\-From\-Txt().


\begin{DoxyCode}
{

    bool retValue = false;

    //find the data dimensions from the first datapoint
    int dataDim = Ub(*theData.begin()) - Lb(*theData.begin()) + 1;

    // ensure the paving exists
    bool hadToMakePaving = haveMadePaving(theData, dataDim);

    // if we did not make the paving we have to check data dimensions
    if (!hadToMakePaving) {
        if(dataDim != (Ub(rootBox) - Lb(rootBox)) + 1) {

            throw HistException("Dimensions of data do not match paving");
        }
    }

    // insert the data
  //  std::cout << "calling insertData..." << endl;
    size_t dataCountInserted
            = insertDataFromContainer(theData, boolTest, logging, holdOutCount,
                                  numNodes);

    if (dataCountInserted > 0) {
        retValue = true;
        // switch on for more output during histogram creation "
        /*
        std::cout << "End of inserting data: " << dataCountInserted
            << " data points inserted to dataCollection "
            << std:: endl;
        std::cout << "and associated with the tree if "
            << "they fit into the root box" << std::endl;
        std::cout << "(check console output for possible records "
            << "of datapoints which did not fit)" << std::endl;
        */
        }

    if (dataCountInserted == 0) {
        throw HistException("No data inserted");

    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ab032205bb13623930c84ff142f565ac5}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get2\-D\-I\-A\-E@{get2\-D\-I\-A\-E}}
\index{get2\-D\-I\-A\-E@{get2\-D\-I\-A\-E}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get2\-D\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-Validation\-::get2\-D\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf taylor\-::dim2taylor}($\ast$)({\bf taylor\-::dim2taylor\-\_\-vector}, interval)}]{testpnt}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ab032205bb13623930c84ff142f565ac5}
\-Get the \-I\-A\-E of a bivariate gaussian/\-Levy 2\-D/\-Rosen 2\-D distribution.

\-Get the \-I\-A\-E for a finite mixture distribution 

\-Definition at line 3601 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), integrate\-With\-Splitting(), and root\-Vpaving.



\-Referenced by get\-I\-A\-E().


\begin{DoxyCode}
{
  //number of points
  int n = rootVpaving->getCounter();
   
  SPSVnodePtrs leaves; // set up empty container for leaf node pointers
  SPSVnodePtrsItr it; // and an iterator over the container
  (*this).getSubPaving()->getLeaves(leaves); // fill the container

  // set up for taylor integration
 // taylor::dim2taylor (*testpnt)(taylor::dim2taylor_vector, interval);
  real tol=1e-6;
  int o=16;
 // testpnt=BiGOP;

  real result = 0; 
  for (it=leaves.begin(); it < leaves.end(); it++)
  { 
    //get fhat  
     interval fhat = interval(real((*it)->getCounter()/
                             (((*it)->nodeVolume())*1.0*n))); 
     
    //get domain
    ivector domain = (*it)->getBox();
     // get the integrated absolute error at this box
    interval resultInt = integrateWithSplitting(testpnt, fhat, domain, o, tol);
          
     //add the errors    
     result += Sup(resultInt);
   }
  //accounting for boundaries - will have to think about this later perhaps
  //accumulate(dpIAE,gsl_cdf_ugaussian_P(xlow[0]),1.0);
  //accumulate(dpIAE,gsl_cdf_ugaussian_Q(xupp[nLeaves-1]),1.0);
  return result;  
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a034c61becd57f5d282435f5881950035}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Fin\-Mix\-I\-A\-E@{get\-Fin\-Mix\-I\-A\-E}}
\index{get\-Fin\-Mix\-I\-A\-E@{get\-Fin\-Mix\-I\-A\-E}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Fin\-Mix\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-Validation\-::get\-Fin\-Mix\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf \-Fin\-Mix} \&}]{mixt}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a034c61becd57f5d282435f5881950035}
\-Get the \-I\-A\-E for a finite gaussian mixture distribution.

\-Get the \-I\-A\-E for a finite mixture distribution 

\-Definition at line 3530 of file adaptivehistogramvalidation.\-cpp.



\-References dp\-I\-A\-E, dp\-I\-A\-E\-Boun, \-F(), \-Fin\-Mix\-::fhat, \-Fin\-Mix\-Abs(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), \-Nbin, and root\-Vpaving.


\begin{DoxyCode}
{
  //---------fill in containers for names, volumes and heights of leaves
  SPSVnodePtrs leaves; // set up empty container for leaf node pointers
  SPSVnodePtrsItr it; // and an iterator over the container
  (*this).getSubPaving()->getLeaves(leaves); // fill the container
  //a container for the counts
  IntVec counts;  // IntVec is a typedef for vector<int>
  //a container for the boxes
  vector<ivector> boxes; vector<ivector>::iterator itBoxes;
  //a container for the volumes
  vector<double> volumes;
  // a container for fhat
  vector<double> fhat; vector<double>::iterator itFhat;
  //number of points
  int n = rootVpaving->getCounter();
            
  for(it = leaves.begin(); it < leaves.end(); it++) {
    // remember that it points to a pointer, so *it is still a ptr
    // get the counts in all the leaves
     counts.push_back((*it)->getCounter());
     // get the boxes from all the leaves
     boxes.push_back((*it)->getBox());
     // get the volumes of all the leaves
     volumes.push_back((*it)->nodeVolume());
     // get fhat for all leaves
     fhat.push_back(((*it)->getCounter())/((*it)->nodeVolume())/n);
  } // end of iterating through leaves 
  
  //----------------get the IAE-----------------------------------------------
  dotprecision dpIAE, dpIAEBoun;
  dpIAE = 0.0;
  int Nbin=counts.size();
  
  gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
  double result = 0.0;
  double error;
  gsl_function F;
  
  F.function = &FinMixAbs;
  F.params =  &mixt;
  
  for (int j=0; j< Nbin; j++){
    mixt.fhat = fhat[j];
    rvector xuppVec = Sup(boxes[j]);
    double xupp = _double(xuppVec[1]);
    rvector xlowVec = Inf(boxes[j]);
    double xlow = _double(xlowVec[1]);
    gsl_integration_qags(&F, xlow, xupp, 0, 1e-7, 1000, w, &result, &error);
    accumulate(dpIAE, result, 1.0);
  }
  
/*  // Accounting for the boundaries
  rvector xuppVec1 = Sup(boxes[Nbin-1]);
  double xupp1 = _double(xuppVec1[1]);
  rvector xlowVec1 = Inf(boxes[0]);
  double xlow1 = _double(xlowVec1[1]);
  dpIAEBoun = dpFinMixIAEBoun(xlow1, xupp1, Weight, Mean, Sigma);
  dpIAE += dpIAEBoun;
*/  
  // cast dot precision to real
  real FinMixIAE = rnd(dpIAE);
  
  // free the workspace
  gsl_integration_workspace_free (w);
  
  return FinMixIAE;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_aa8b89b93450dea8e464eac31d67c78d1}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Fin\-Mix\-Interval\-I\-A\-E@{get\-Fin\-Mix\-Interval\-I\-A\-E}}
\index{get\-Fin\-Mix\-Interval\-I\-A\-E@{get\-Fin\-Mix\-Interval\-I\-A\-E}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Fin\-Mix\-Interval\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}cxsc\-::interval {\bf \-Adaptive\-Histogram\-Validation\-::get\-Fin\-Mix\-Interval\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf \-Fin\-Mix} \&}]{mixt, }
\item[{double}]{tol, }
\item[{int}]{deg, }
\item[{bool}]{full}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_aa8b89b93450dea8e464eac31d67c78d1}
\-Get the \-I\-A\-E for a finite gaussian mixture distribution. 

\-Definition at line 3711 of file adaptivehistogramvalidation.\-cpp.



\-References bisect(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-L1error(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaves(), get\-Sub\-Paving(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Vcounter(), \-Fin\-Mix\-::\-M, \-N(), root\-Vpaving, \-Fin\-Mix\-::\-S, and \-Fin\-Mix\-::\-W.



\-Referenced by priority\-Split\-And\-Estimate(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{
  //cout << "get finmix interval IAE" << endl;
  
  interval totalArea(0.0); //initialize
  int n = rootVpaving->getCounter();
  int N = n + rootVpaving->getVcounter();
  
  // need to iterate through the leaves
  SPSVnodePtrs leaves; // set up empty container for leaf node pointers
  SPSVnodePtrsItr it; // and an iterator over the container
  getSubPaving()->getLeaves(leaves); // fill the container
  
  // container is filled by reading leaves off tree from left to right
  for(it = leaves.begin(); it < leaves.end(); it++) {
    //cout << "-----IAE for " << (*it)->getNodeName() << endl;
    //a container for the roots at this leaf node
    vector<intervalw> rootVec;
    
    //get the height in this leaf node
    double fhat;
    if ( full == 0 ) { 
      fhat = (*it)->getCounter()/(*it)->nodeVolume()/n;
      //cout << (*it)->getCounter() << "\t" << (*it)->nodeVolume() <<"\t" <<
       fhat << endl;
    }
    else {
      size_t totalCount = (*it)->getCounter() + (*it)->getVcounter();
      fhat = totalCount/(*it)->nodeVolume()/N;
    }

    //get the box of this leaf node
    ivector thisBox = (*it)->getBox();
    //cout << (*it)->getBox() << endl;
    
    //---------find the root at this domain
    // make an intervalw object using thisBox
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    intervalw thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    // find the root
    //cout << "finding roots at this node " << thisInt << endl;
    bisect(thisIntW, tol, fhat, rootVec, mixt.W, mixt.M, mixt.S); 

    //---------find the area at this domain and take the absolute value
    //if rootVec is empty, there are no roots - so we can integrate over
    //this domain
    if ((rootVec.size() == 0)) { 
      //cout << "no roots at " << thisInt << endl;
      //get the L1 error
      interval diffArea = getL1error(fhat, thisInt, deg, tol, mixt.W, mixt.M, 
      mixt.S);
      //add to totalArea
      totalArea += diffArea;
    } //end of rootVec is empty

    else { //if rootVec is not empty
      vector<intervalw> uniqueRootVec;
      // make the elements in vector unique
      for (int i = 0; i < (rootVec.size()); i++) {
        //cout << "root " << i << ": " << rootVec[i] << endl;
        //first insert into uniqueRootVec
        uniqueRootVec.push_back(rootVec[i]);
        //cout << i-1 << "\t" << i << "\t" << i+1 << endl;
        //now check for uniqueness
        if (((i-1) >= 0) && (i < rootVec.size())) {
          //cout << rootVec[i] << "\t" << rootVec[i-1] << endl;
          bool uniq = (subset(abs(rootVec[i] - rootVec[i-1]), intervalw(0, 1e-1
      0)));
          if ( uniq ) { 
            //cout << "this root has a duplicate" << endl;
            uniqueRootVec.pop_back(); }
        }
      }
      //cout << "==There are " << uniqueRootVec.size() << " unique root(s)=="
       << endl;
      
      // if there's only 1 root
      if (uniqueRootVec.size() == 1) {
        //cout << "there is only one root.." << endl;
        // is the root at the left or right boundary?
        if ( (abs(Inf(thisInt) - inf(rootVec[0])) < 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) < 1e-10) ) {
          //cout << "there's a root at the left/right boundary:" << rootVec[0]
       << endl;
          interval diffArea = getL1error(fhat, thisInt, deg, tol, mixt.W, mixt.M
      , mixt.S);
          totalArea += diffArea;
        }
        else { // the root is not at the boundaries
          //cout << "no root at the boundaries" << endl;
          //get the left sub-interval
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]
      ));
          //cout << "left interval: " << thisSubIntLeft << endl; 
          interval diffArea = getL1error(fhat, thisSubIntLeft, deg, tol, mixt.W
      , mixt.M, mixt.S);
          totalArea += diffArea;
          
          //get the right sub-interval
          //get the left sub-interval
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(
      thisInt));
          //cout << "right interval: " << thisSubIntRight << endl; 
          diffArea = getL1error(fhat, thisSubIntRight, deg, tol, mixt.W, mixt.M
      , mixt.S);
          totalArea += diffArea;
        }
      } // end of rootVec.size() == 1

        // if there is more than 1 root
      else {
        //cout << "let's have a look at all the roots:" << endl;
        //for (size_t i = 0; i < uniqueRootVec.size(); i++) {
          //cout << uniqueRootVec[i] << endl;
        //}

        //first check if the first root is at the boundary
        //cout << "check boundaries: " << Inf(thisInt) << "\t" <<
       inf(rootVec[0]) << endl;
        if ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) < 1e-10 ) {
          //cout << "there's a root at the leftmost boundary:" << endl;
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1
      ]));
          //cout << "0-th interval:" << thisSubIntFirst << endl; 
          interval diffArea = getL1error(fhat, thisSubIntFirst, deg, tol, mixt.W
      , mixt.M, mixt.S);
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            //cout << "the " << i+1 << "-th root is: " << rootVec[i+1] << endl;
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = getL1error(fhat, thisSubInt, deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
            else { //there are still more roots
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << i+1 << "-th interval: " << thisSubInt << endl;
              interval diffArea = getL1error(fhat, thisSubInt, deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
          } // end of iterate through each root (excep the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast,deg, tol, mixt.W
      , mixt.M, mixt.S);
            totalArea += diffArea;
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast, deg, tol, mixt
      .W, mixt.M, mixt.S);
            totalArea += diffArea;
          } 
        } // end of if first root is the boundary
        
        else {
          //cout << "root not at boundary" << endl;
          //if it is not the boundary, make the first sub-interval
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          //cout << "0-th interval: " << thisSubIntFirst << endl; 
          interval diffArea = getL1error(fhat, thisSubIntFirst, deg, tol, mixt.W
      , mixt.M, mixt.S);
          totalArea += diffArea;
          
          // now iterate through each root (except the first and last) and 
          // get the sub-itnervals
          //cout << "iterating through each root" << endl;
          for (size_t i = 0; i < (uniqueRootVec.size() - 1); i++) {
            if ( (i+1) > uniqueRootVec.size() ) { // already no more roots
              //cout << inf(rootVec[i]) << "\t" << Sup(thisInt) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt
      ));
              //cout << "the " << i << "-th interval: " << thisSubInt << endl;
              interval diffArea = getL1error(fhat, thisSubInt,  deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
            else { //there are still more roots
              //cout << inf(rootVec[i]) << "\t" << sup(rootVec[i+1]) << endl;
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(
      uniqueRootVec[i+1]));
              //cout << "the " << i+1 << "-th interval: " << thisSubInt <<
       endl;
              interval diffArea = getL1error(fhat, thisSubInt,  deg, tol, mixt.W
      , mixt.M, mixt.S);
              totalArea += diffArea;
            }
          } // end of iterate through each root (except the first and last)
          
          // now check if the last root is at the boundary
          if ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) <
       1e-10 ) {
            //cout << "there's a root at the rightmost boundary:" << endl;
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-2]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast,  deg, tol, 
      mixt.W, mixt.M, mixt.S);
          }
          else { //the last root is not at the boundary
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.
      size()-1]), Sup(thisInt));
            //cout << "last interval: " << thisSubIntLast << endl; 
            interval diffArea = getL1error(fhat, thisSubIntLast,  deg, tol, 
      mixt.W, mixt.M, mixt.S);
            totalArea += diffArea;
          } 
        } // end of first root is not the boundary
      } // end of rootVec.size() > 1
    } // end of rootVec is not empty
  } // end of iterating through the leaf nodes
  
  //cout << "IAE: " << totalArea << endl;
  return totalArea;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_abfd3760f709336024357625903d9f2e9}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Hold\-All\-Stats@{get\-Hold\-All\-Stats}}
\index{get\-Hold\-All\-Stats@{get\-Hold\-All\-Stats}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Hold\-All\-Stats}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::get\-Hold\-All\-Stats} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_abfd3760f709336024357625903d9f2e9}


get the value of hold\-All\-Stats field. 

\-This determines whether the histrogram's root\-Paving will maintain all available stats (true) or just the counts (false). 

\-Definition at line 573 of file adaptivehistogramvalidation.\-cpp.



\-References hold\-All\-Stats.


\begin{DoxyCode}
{
    return holdAllStats;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ae599e0bbb226dc0610c4ec25845533d8}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-I\-A\-E@{get\-I\-A\-E}}
\index{get\-I\-A\-E@{get\-I\-A\-E}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-Validation\-::get\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{int}]{distr}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ae599e0bbb226dc0610c4ec25845533d8}
\-Get the \-I\-A\-E of a distribution.

\-Get the \-I\-A\-E of the corresponding distribution based on function arguments. 

\-Definition at line 3408 of file adaptivehistogramvalidation.\-cpp.



\-References \-Bi\-G\-O\-P(), get2\-D\-I\-A\-E(), \-Levy\-O\-P(), and \-Rosen\-O\-P().


\begin{DoxyCode}
{
      real IAE = 0;
    taylor::dim2taylor (*testpnt)(taylor::dim2taylor_vector, interval);
    switch(distr)
    { 
         
      case 1: //bivariate gaussian mixtures
         testpnt = BiGOP;
      IAE = get2DIAE(testpnt);
      break;
      
      case 2: // Levy 2D
      testpnt = LevyOP;
      IAE = get2DIAE(testpnt);
      break;
      
      case 3: //Rosenbrock 2D
      testpnt = RosenOP;
      IAE = get2DIAE(testpnt);
      break;
    }   
    return IAE;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a234fc6618948f692ea2458cedb4fed8f}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Leaf\-Counts@{get\-Leaf\-Counts}}
\index{get\-Leaf\-Counts@{get\-Leaf\-Counts}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Leaf\-Counts}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Size\-\_\-t\-Vec} {\bf \-Adaptive\-Histogram\-Validation\-::get\-Leaf\-Counts} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a234fc6618948f692ea2458cedb4fed8f}
\-Get a vector of the leaf node counts.

\begin{DoxyReturn}{\-Returns}
a vector of leaf counts, left to right order, 
\end{DoxyReturn}


\-Definition at line 3337 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaf\-Node\-Counts(), and root\-Vpaving.


\begin{DoxyCode}
{
    Size_tVec counts; // empty container
    if (NULL != rootVpaving) {
        rootVpaving->getLeafNodeCounts(counts);
        //levels has now been filled in
    }
    return counts;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ab9672c3fe9ee4ced96a1ad03ee12c1c9}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Leaf\-Levels@{get\-Leaf\-Levels}}
\index{get\-Leaf\-Levels@{get\-Leaf\-Levels}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Leaf\-Levels}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Int\-Vec} {\bf \-Adaptive\-Histogram\-Validation\-::get\-Leaf\-Levels} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ab9672c3fe9ee4ced96a1ad03ee12c1c9}
\-Get a vector of the leaf node levels.

\-Root is level 0, next level down is 1, etc.

\begin{DoxyReturn}{\-Returns}
a vector of leaf levels, left to right order, 
\end{DoxyReturn}


\-Definition at line 3323 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Leaf\-Node\-Levels(), and root\-Vpaving.


\begin{DoxyCode}
{
    IntVec levels; // empty container

    if (NULL != rootVpaving) {
        rootVpaving->getLeafNodeLevels(0, levels);
        //levels has now been filled in
    }
    return levels;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_acba6350d62c4aa8c1d9de5589c039543}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Leaf\-Levels\-String@{get\-Leaf\-Levels\-String}}
\index{get\-Leaf\-Levels\-String@{get\-Leaf\-Levels\-String}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Leaf\-Levels\-String}]{\setlength{\rightskip}{0pt plus 5cm}std\-::string {\bf \-Adaptive\-Histogram\-Validation\-::get\-Leaf\-Levels\-String} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_acba6350d62c4aa8c1d9de5589c039543}
\-Get a string of the leaf node levels.

\-Root is level 0, next level down is 1, etc. \-Example return string \char`\"{}3,3,2,1\char`\"{}

\begin{DoxyReturn}{\-Returns}
a comma separated string of leaf levels, left to right order 
\end{DoxyReturn}


\-Definition at line 579 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::get\-Leaf\-Node\-Levels\-String(), and root\-Vpaving.



\-Referenced by insert\-Data\-From\-Container().


\begin{DoxyCode}
{
    string retValue = "";
    if (NULL != rootVpaving)
        retValue = rootVpaving->getLeafNodeLevelsString();

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a8d94391339b619f6f3aefb89ca761e99}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Min\-Vol@{get\-Min\-Vol}}
\index{get\-Min\-Vol@{get\-Min\-Vol}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Min\-Vol}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf \-Adaptive\-Histogram\-Validation\-::get\-Min\-Vol} (
\begin{DoxyParamCaption}
\item[{double}]{min\-Vol\-B}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a8d94391339b619f6f3aefb89ca761e99}


get the value of the minimum volume for a splittable node. 

\-Minimum volume = min\-Vol\-B $\ast$ (log n) $^\wedge$2/n where n is points in histogram. \-Minimum volume is used in \-C\-O\-P\-E\-R\-R or \-A\-I\-C priority queue splitting to limit which nodes can be split. 
\begin{DoxyParams}{\-Parameters}
{\em min\-Vol\-B} & the multiplier applied to log n) $^\wedge$2/n to find the minimum allowed node volume at which a node can be split (children will half the volume of the parent node). \\
\hline
\end{DoxyParams}


\-Definition at line 560 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-P\-Snode\-::get\-Counter(), and root\-Vpaving.



\-Referenced by priority\-Split\-And\-Estimate(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{
    double retValue = 0.0;

    if (NULL != rootVpaving) {

        size_t counter = rootVpaving->getCounter();
        retValue =  minVolB * log(1.0*counter)*log(1.0*counter)/counter;
    }
    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_abba9be0456a1228037dd40e7353d2169}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Root\-Leaves@{get\-Root\-Leaves}}
\index{get\-Root\-Leaves@{get\-Root\-Leaves}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Root\-Leaves}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-Adaptive\-Histogram\-Validation\-::get\-Root\-Leaves} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_abba9be0456a1228037dd40e7353d2169}


\-Gets number of leaf nodes in the root paving. 



\-Definition at line 552 of file adaptivehistogramvalidation.\-cpp.



\-References root\-Vpaving, and subpavings\-::sp\-Leaves().



\-Referenced by priority\-Split\-And\-Estimate(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{ return spLeaves(rootVpaving); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a22ac33f1952cfb6b605193cddab42bae}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Root\-Sum\-Leaf\-Count\-Over\-Vol@{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol}}
\index{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol@{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Root\-Sum\-Leaf\-Count\-Over\-Vol}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-Validation\-::get\-Root\-Sum\-Leaf\-Count\-Over\-Vol} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a22ac33f1952cfb6b605193cddab42bae}


\-Gets the sum of leaf count over volume in root paving. 



\-Definition at line 556 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-P\-S\-Vnode\-::get\-Sum\-Leaf\-Count\-Over\-Vol(), and root\-Vpaving.


\begin{DoxyCode}
{ return rootVpaving->getSumLeafCountOverVol(); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a23a25c2169c94e019859f8efc2657c1b}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Root\-Vcounter@{get\-Root\-Vcounter}}
\index{get\-Root\-Vcounter@{get\-Root\-Vcounter}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Root\-Vcounter}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-Adaptive\-Histogram\-Validation\-::get\-Root\-Vcounter} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a23a25c2169c94e019859f8efc2657c1b}


\-Gets count in the rootpaving in the root paving. 



\-Definition at line 548 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-P\-S\-Vnode\-::get\-Vcounter(), and root\-Vpaving.



\-Referenced by main().


\begin{DoxyCode}
{ return rootVpaving->getVcounter(); }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a6449b127c16423141cbed8f193cfcf59}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Sub\-Paving@{get\-Sub\-Paving}}
\index{get\-Sub\-Paving@{get\-Sub\-Paving}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Sub\-Paving}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-S\-Vnode} $\ast$ {\bf \-Adaptive\-Histogram\-Validation\-::get\-Sub\-Paving} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a6449b127c16423141cbed8f193cfcf59}


\-Return a pointer to the \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} this manages. 



\-Definition at line 543 of file adaptivehistogramvalidation.\-cpp.



\-References root\-Vpaving.



\-Referenced by subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::\-Adaptive\-Histogram\-V\-Collator(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::add\-To\-Collation\-With\-Val(), get\-Fin\-Mix\-Interval\-I\-A\-E(), get\-Unif\-I\-A\-E(), main(), subpavings\-::\-Crit\-Leaves\-\_\-\-G\-T\-E\-V\-::operator()(), subpavings\-::\-Crit\-Leaves\-\_\-\-L\-T\-E\-V\-::operator()(), subpavings\-::\-Crit\-Smallest\-Count\-\_\-\-L\-T\-E\-V\-::operator()(), subpavings\-::\-Crit\-Largest\-Count\-\_\-\-L\-T\-E\-V\-::operator()(), subpavings\-::\-Crit\-Smallest\-Vol\-\_\-\-L\-T\-E\-V\-::operator()(), subpavings\-::\-Crit\-Largest\-Vol\-\_\-\-L\-T\-E\-V\-::operator()(), operator$<$$<$(), output\-Root\-To\-Txt(), output\-To\-Txt\-Tabs(), priority\-Split\-And\-Estimate(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{return rootVpaving;}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_aa54b166c50901dc9ec2976bb4a5df916}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!get\-Unif\-I\-A\-E@{get\-Unif\-I\-A\-E}}
\index{get\-Unif\-I\-A\-E@{get\-Unif\-I\-A\-E}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{get\-Unif\-I\-A\-E}]{\setlength{\rightskip}{0pt plus 5cm}real {\bf \-Adaptive\-Histogram\-Validation\-::get\-Unif\-I\-A\-E} (
\begin{DoxyParamCaption}
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{double}]{weight, }
\item[{vector$<$ int $>$}]{holes\-Loc, }
\item[{bool}]{full}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_aa54b166c50901dc9ec2976bb4a5df916}
\-Get the \-I\-A\-E for a uniform (mixture) distribution.

\-Get the \-I\-A\-E for the unform distribution 

\-Definition at line 3435 of file adaptivehistogramvalidation.\-cpp.



\-References dp\-I\-A\-E, subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaves(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Root\-Counter(), get\-Sub\-Paving(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Vcounter(), \-Intersection(), root\-Vpaving, and \-Volume().



\-Referenced by priority\-Split\-And\-Estimate(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{
   // get the true height, f of the corresponding box in myPart
  SPSnodePtrs trueLeaves;
  SPSnodePtrsItr trueIt;
  //AdaptiveHistogram * adhPtr;
  //adhPtr = &myPart;
  (myPart).getSubPaving()->getLeaves(trueLeaves);

  // setting up containers for the leaves
  SPSVnodePtrs leaves;
  SPSVnodePtrsItr it;
  getSubPaving()->getLeaves(leaves); // fill the container

  double trueF; //true density
  ivector temp;
  
  dotprecision dpIAE;    // use type dotprecision for summation  
  dpIAE=0.0;

  int n = getSubPaving()->getRootCounter();
  int allN = n + rootVpaving->getVcounter();
  //go through all the leaves in this
  for(it = leaves.begin(); it < leaves.end(); it++) {
    ivector thisBox = (*it)->getBox();
    //cout << "====checking " << (*it)->getBox() << endl;
      
    // get the height of this leaf
    double fhat;
    if ( full == 0 ) { 
      fhat = (*it)->getCounter()/(*it)->nodeVolume()/n;
      //cout << (*it)->getCounter() << "\t" << (*it)->nodeVolume() <<"\t" <<
       fhat << endl;
    }
    else {
      size_t totalCount = (*it)->getCounter() + (*it)->getVcounter();
      fhat = totalCount/(*it)->nodeVolume()/allN;
    }

    //cout << full << "\tfhat for box " << ":" << fhat << endl;

    size_t L = 0;
    for (trueIt = trueLeaves.begin(); trueIt < trueLeaves.end(); trueIt++) {
      //cout << "----True leaf: " << (*trueIt)->getBox() << "\t" << endl;
      ivector trueBox = (*trueIt)->getBox();

      if (  holesLoc[L] == 0 ) { trueF = 0; }
      else { trueF = weight/((*trueIt)->nodeVolume()); }
      //cout << "pdf: " << trueF  << endl;
      
      // if this is contained in trueBox
      if ( (*it)->getBox() <= (*trueIt)->getBox() || (*it)->getBox() == 
      (*trueIt)->getBox() ) {
        //use the volume of this
        real r = ((*it)->nodeVolume())*(fhat - trueF);
        //cout << "r: " << r << "\t" << abs(r) << endl;
        accumulate(dpIAE, abs(r), 1.0);
        //can move on to next leaf rather than iterating thru all trueBoxes
        //think about this later
      } //end of if this box is in trueBox
      
      // if this contains trueBox
      else if ((*trueIt)->getBox() <= (*it)->getBox()) {
        //use the volume of trueBox
        real r = ((*trueIt)->nodeVolume())*(fhat - trueF);
        //cout << "r: " << r << "\t" << abs(r) << endl;
        accumulate(dpIAE, abs(r), 1.0);
      } //end of if trueBox is in this box
      
      // if this is partially contained in trueBox 
      else if   (Intersection(temp, thisBox, trueBox)) {
        if (Inf(temp) != Sup(temp)){
          double volume = Volume(temp);
          real r = volume*(fhat - trueF);
          //cout << "r: " << r << "\t" << abs(r) << endl;
          accumulate(dpIAE, abs(r), 1.0);
        }
      }
      L++;
    } // end of going through trueBoxes
  } // end of going through thisBoxes
  
   //cast dotprecision to real
   real unifIAE = rnd(dpIAE);
   //cout << "IAE: " << unifIAE << endl;
  return unifIAE;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a7b6e78d7a069536dd096e81c6e3d8e1f}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!have\-Made\-Paving@{have\-Made\-Paving}}
\index{have\-Made\-Paving@{have\-Made\-Paving}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{have\-Made\-Paving}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::have\-Made\-Paving} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const size\-\_\-t}]{dim}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a7b6e78d7a069536dd096e81c6e3d8e1f}


\-Checks if we need to make root paving for the histogram object. 

\-Points root\-P\-Aving to a new \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} if root\-Paving is \-N\-U\-L\-L, with the box of the root node matching the dimensions of the data as given in function argument and tailored to fit the data in the\-Data.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data. \\
\hline
{\em dim} & the dimensions of the data. \\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{\-Postcondition}
if return value is true, root\-Paving points to a new \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} and a new ivector has been assigned to root\-Box, and the root\-Box ivector is the box of the root node of the \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} to which root\-Paving points. 
\end{DoxyPostcond}
\begin{DoxyReturn}{\-Returns}
true if function needed to make a new \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode}, false if root\-Paving already pointed to an \-S\-P\-S node. 
\end{DoxyReturn}


\-Definition at line 170 of file adaptivehistogramvalidation.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), hold\-All\-Stats, subpavings\-::is\-Empty(), make\-Box(), root\-Box, and root\-Vpaving.



\-Referenced by complete\-Data\-Insertion\-From\-Vec().


\begin{DoxyCode}
{

    bool retValue = false;

    try {

        // check if we need to make the paving on the basis of the data
        if (isEmpty(rootVpaving)) {

            rootBox = makeBox(theData, dim);

            // point rootVpaving to a new SPSVnode with box myBox
            // and also pass in the not value of holdAllStats which controls
            // whether all available statistics are maintained in the
            // rootVpaving (true) or just counts (false)
            rootVpaving = new SPSVnode(rootBox, !holdAllStats);
            creationString = rootVpaving->getNodeName();

            retValue = true;
        }
    }

    catch (bad_alloc& e)
    {
        const char* msg = e.what();
        std::cerr << msg << std::endl;
        std::cerr << "Error allocating memory in "
            << "AdaptiveHistogramValidation::haveMadePaving()"
            << std::endl;
        throw;
    }

    return retValue;
    // end of making the subpaving if there was not one
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ac57fa83d1ec2fc1e9cf1565c9cc07f91}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!insert\-Data\-From\-Container@{insert\-Data\-From\-Container}}
\index{insert\-Data\-From\-Container@{insert\-Data\-From\-Container}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{insert\-Data\-From\-Container}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t {\bf \-Adaptive\-Histogram\-Validation\-::insert\-Data\-From\-Container} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{hold\-Out\-Count, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{num\-Nodes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ac57fa83d1ec2fc1e9cf1565c9cc07f91}


\-Insert training and validation data from a container. 

\-Attempts to insert data from a container the\-Data into this \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram} object's data\-Collection and to associate the data with the leaves of the subpaving tree pointed to by this's root\-Paving. \-Data in the\-Data which falls outside the boundaries of the root\-Box will not be inserted and a message will be printed to standard output. \-A boolean is used to indicate if the data point should be in the training or validation set.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data. \\
\hline
{\em logging} & an enum controlling whether a log file is created for histogram creation process; set to \-T\-X\-T for logging to a txt file. \\
\hline
{\em bool\-Test} & is a reference to an object providing a function \\
\hline
{\em bool\-Val} & a boolean to indicate if the data point should be in the validation set (true) or not (false). operator determining whether to split a node when a data point arrives. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{\-Precondition}
\-A container the\-Data containing at least one rvector. 

this \hyperlink{classsubpavings_1_1AdaptiveHistogramValidation}{\-Adaptive\-Histogram\-Validation} object must have a root\-Paving pointing to an initialised \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode}; this \hyperlink{classsubpavings_1_1SPSnode}{\-S\-P\-Snode} may already have data associated with it. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
\-The data in the\-Data which is within the boundaries of the root\-Box has been put into the \hyperlink{classsubpavings_1_1AdaptiveHistogram}{\-Adaptive\-Histogram}'s data\-Collection and also associated with root\-Paving's leaves via iterators to data\-Collection. 
\end{DoxyPostcond}
\begin{DoxyReturn}{\-Returns}
number of datapoints for which insertion has been attempted. 
\end{DoxyReturn}


\-Definition at line 269 of file adaptivehistogramvalidation.\-cpp.



\-References creation\-String, data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), get\-Leaf\-Levels\-String(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-S\-P\-S\-Vnode\-::insert\-One\-Find(), subpavings\-::\-N\-O\-L\-O\-G, subpavings\-::\-O\-N\-\_\-\-P\-A\-R\-E\-N\-T, subpavings\-::output\-File(), root\-Vpaving, and subpavings\-::sp\-Total\-Nodes().



\-Referenced by complete\-Data\-Insertion\-From\-Vec().


\begin{DoxyCode}
{
    size_t counter = 0;    // to count the input
    bool boolVal; // to  indicate if this data is a training or validation
       point
    // for logging output to keep track of splits if necessary
    int i = 0;
    std::string baseFileName = "";
    std::string s = "";
    // if we are splitting as we go and logging, set up a log file
    if ((logging != NOLOG) && (boolTest() == true)) {
        baseFileName = "splitOutput";
        s = getUniqueFilename(baseFileName);
       // outputLogStart(s);
        // log the current state of the histogram
      //  outputLog(s, i);
        i++;
    }
   
   //int hist = 0;
   RVecDataCItr cit;
    // feed the data to myHist
    for(cit = theData.begin(); cit < theData.end(); cit++) {
        // put it into dataCollection
        BigDataItr it = dataCollection.end();
        it = dataCollection.insert(it, *cit);
        SPSVnode* insertedInto = NULL;
        if (counter < holdOutCount) {
          // try inserting 
          boolVal = true;
          insertedInto =
                rootVpaving->insertOneFind(it,ON_PARENT, boolTest, boolVal);
        }
        else {
         boolVal = false;
      // try inserting
         insertedInto =
                rootVpaving->insertOneFind(it,ON_PARENT, boolTest, boolVal);
           numNodes.push_back(spTotalNodes(rootVpaving));
           
           /* 
           string histFileName;
           std::ostringstream stm1;
           stm1 << hist;
           histFileName = "Hist";
           histFileName += stm1.str();
           histFileName += ".txt";
           cout << "get histogram:" << histFileName << endl;
           outputToTxtTabs(histFileName);     
           hist++;    
           */     
      }

        //insertOneFind returns either NULL if no insert possible
        // or a pointer to the node the data goes to before that node
        // is split (it could be split more than once)
        if (NULL == insertedInto) { // failed to insert
            std::cout << "Failed to insert point "
                << *cit << std::endl;
            std::cout << "Root node of subpaving has box "
                << rootVpaving << std::endl;
        }
        // successful insertion, and we are splitting as we go
        else if (boolTest() == true && boolVal == false ) {
            std::string newNames = insertedInto->getChildNodeNames();
     
            if(newNames.length() > 0) { // there are new nodes
                //add the new child names if any
                creationString += newNames;

                if (logging) { // log the current state of the histogram
//                    outputLog(s, i);
                    i++;
                }        
           
            }
       }
        counter++;
    }
    if (counter > 0) { // data inserted
         if ((logging != NOLOG) && (boolTest() == true))  {
            // add leaf node levels string to log
            outputFile(s, getLeafLevelsString());
        }
    }
    return counter;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ace1a6eca888d6251a7e3db5d1c59bf2b}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!insert\-From\-R\-S\-Sample\-For\-Hold\-Out@{insert\-From\-R\-S\-Sample\-For\-Hold\-Out}}
\index{insert\-From\-R\-S\-Sample\-For\-Hold\-Out@{insert\-From\-R\-S\-Sample\-For\-Hold\-Out}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{insert\-From\-R\-S\-Sample\-For\-Hold\-Out}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::insert\-From\-R\-S\-Sample\-For\-Hold\-Out} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-S\-Sample} \&}]{rss, }
\item[{int}]{label, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{int}]{hold\-Out\-Count, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ace1a6eca888d6251a7e3db5d1c59bf2b}
\-All \hyperlink{classRSSample}{\-R\-S\-Sample} are associated with the root paving for hold out estimation, no splitting. 

\-Definition at line 778 of file adaptivehistogramvalidation.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::get\-Rvectors\-From\-R\-S\-Sample(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

  //  bool boolVal=true;
    
    try {

        RVecData myDataRvectors; // container for the rvectors we take in

            // get data from the container and check how many data points found
            size_t numberFound = getRvectorsFromRSSample(myDataRvectors, rss, 
      label);


            if (numberFound > 0) {
                /*
                // confirm the amount of data taken from the container
                std::cout << "End of taking data from container of rvectors: "
                    << numberFound << " data points found" << std::endl;
                */
                // complete the data insertion

               // cout << "calling complateDataInsertion..." << endl;
          vector<size_t> temp;
                retValue = completeDataInsertionFromVec(myDataRvectors,
                                     boolTest, logging, holdOutCount, temp);
            }
      }
    
    catch (bad_alloc& ba) {
         string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
} // end of insertFromRSSampleForHoldOut
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_aa0d5d92e0474bfc0574340b34268dd39}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!insert\-From\-R\-Vec@{insert\-From\-R\-Vec}}
\index{insert\-From\-R\-Vec@{insert\-From\-R\-Vec}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{insert\-From\-R\-Vec}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::insert\-From\-R\-Vec} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_aa0d5d92e0474bfc0574340b34268dd39}
\-Adaptive splitting with each data point inserted. 

\-Definition at line 641 of file adaptivehistogramvalidation.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::get\-Rvectors\-From\-R\-Vec(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().



\-Referenced by main().


\begin{DoxyCode}
{
    bool retValue = false;

    try {

        RVecData myDataRvectors; // container for the rvectors we take in

        size_t numberFound = 0;

        if (rvec.empty()) { // no data points to get
            throw HistException("No data to insert");
        }

        else { // there is data to get

            // get data from the container and check how many data points found
            size_t numberFound = getRvectorsFromRVec(myDataRvectors, rvec);


            if (numberFound > 0) {
                /*
                // confirm the amount of data taken from the container
                std::cout << "End of taking data from container of rvectors: "
                    << numberFound << " data points found" << std::endl;
                */
                // complete the data insertion
           vector<size_t> temp;
                retValue = completeDataInsertionFromVec(myDataRvectors,
                                                        boolTest, logging, 0,
                                      temp);
            }
        }
    }
    catch (bad_alloc& ba) {
         string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a6817e38bd1c2749a711f702c70dd16b5}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!insert\-From\-R\-Vec\-For\-Hold\-Out@{insert\-From\-R\-Vec\-For\-Hold\-Out}}
\index{insert\-From\-R\-Vec\-For\-Hold\-Out@{insert\-From\-R\-Vec\-For\-Hold\-Out}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{insert\-From\-R\-Vec\-For\-Hold\-Out}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::insert\-From\-R\-Vec\-For\-Hold\-Out} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{rvec, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{int}]{hold\-Out\-Count, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a6817e38bd1c2749a711f702c70dd16b5}
\-All rvectors are associated with the root paving for hold out estimation, no splitting. 

\-Definition at line 709 of file adaptivehistogramvalidation.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::get\-Rvectors\-From\-R\-Vec(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().



\-Referenced by main().


\begin{DoxyCode}
{
    bool retValue = false;

  //  bool boolVal=true;
    
    try {

        RVecData myDataRvectors; // container for the rvectors we take in

//        size_t numberFound = 0;

        if (rvec.empty()) { // no data points to get
            throw HistException("No data to insert");
        }

        else { // there is data to get

            // get data from the container and check how many data points found
            size_t numberFound = getRvectorsFromRVec(myDataRvectors, rvec);


            if (numberFound > 0) {
                /*
                // confirm the amount of data taken from the container
                std::cout << "End of taking data from container of rvectors: "
                    << numberFound << " data points found" << std::endl;
                */
                // complete the data insertion

               // cout << "calling complateDataInsertion..." << endl;
          vector<size_t> temp;
                retValue = completeDataInsertionFromVec(myDataRvectors,
                                     boolTest, logging, holdOutCount, temp);
            }
        }
    }
    catch (bad_alloc& ba) {
         string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
} // end of insertRVecForHoldOut 
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a1c8f4b1ea86038de1e1d780f227f9b28}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}}
\index{insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{insert\-Rvectors\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::insert\-Rvectors\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{num\-Nodes, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a1c8f4b1ea86038de1e1d780f227f9b28}
\-All rvectors are associated with the root paving, no spliting. 

\-Definition at line 409 of file adaptivehistogramvalidation.\-hpp.



\-Referenced by main().


\begin{DoxyCode}
    {
        SplitNever sn; // a dummy split decision object
        return insertRvectorsFromTxt(s, numNodes, sn, headerlines, logging);
    }
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ad8df8dae6a879dc00975edfe4a0cc3b6}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}}
\index{insert\-Rvectors\-From\-Txt@{insert\-Rvectors\-From\-Txt}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{insert\-Rvectors\-From\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::insert\-Rvectors\-From\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{std\-::vector$<$ size\-\_\-t $>$ \&}]{num\-Nodes, }
\item[{const {\bf \-Split\-Decision\-Obj} \&}]{bool\-Test, }
\item[{const std\-::size\-\_\-t}]{headerlines = {\ttfamily 0}, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging = {\ttfamily {\bf \-N\-O\-L\-O\-G}}}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ad8df8dae6a879dc00975edfe4a0cc3b6}
\-Adaptive splitting with each data point inserted. 

\-Definition at line 589 of file adaptivehistogramvalidation.\-cpp.



\-References complete\-Data\-Insertion\-From\-Vec(), subpavings\-::read\-Rvectors\-From\-Txt(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool retValue = false;

    try {
        RVecData myDataRvectors; // container for the rvectors we take in

        // try to read in the file
        retValue = readRvectorsFromTxt(myDataRvectors, s, headerlines);

        if (retValue) {
            retValue = completeDataInsertionFromVec(myDataRvectors,
                                                    boolTest, logging, 0,
                                   numNodes);
        }
    }
    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory inserting data.  Orginal error: "
                                            + oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error inserting data.  Orginal error: "
                                    + oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException inserting data.  Orginal error: " + 
      oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error inserting data.  Orginal error: " + oldmsg;
        cout << msg << std::endl;
        throw HistException(msg);
    }

    return retValue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_abaa0f3ffd23bccd07a2c4a4b9a60e579}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!make\-Box@{make\-Box}}
\index{make\-Box@{make\-Box}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{make\-Box}]{\setlength{\rightskip}{0pt plus 5cm}ivector {\bf \-Adaptive\-Histogram\-Validation\-::make\-Box} (
\begin{DoxyParamCaption}
\item[{const {\bf \-R\-Vec\-Data} \&}]{the\-Data, }
\item[{const size\-\_\-t}]{dim}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_abaa0f3ffd23bccd07a2c4a4b9a60e579}


\-Make a box to contain all the data. 

\-Used if a box has not already been provided. \-Makes a box tailored to contain all of the data. \-So all the data has to be available for input.


\begin{DoxyParams}{\-Parameters}
{\em the\-Data} & a reference to a container of rvector data \\
\hline
{\em dim} & the dimensions of the data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{\-Returns}
an ivector same dimensions as the data and to fit all the data including an allowance for padding. 
\end{DoxyReturn}


\-Definition at line 209 of file adaptivehistogramvalidation.\-cpp.



\-References padding.



\-Referenced by have\-Made\-Paving().


\begin{DoxyCode}
{
    // set up a vector of maxes
    vector<real> maxs;

    // give maxs starting values from the first element in the rvectors
    rvector first = *theData.begin();

    for (size_t i = 1; i <=dim; i++) {
        maxs.push_back(first[i]);
    }

    // make mins the same as maxes to start with
    vector<real> mins = maxs;

    RVecDataCItr cit;

    // go over the rest of the container
    for(cit = theData.begin()+1; cit < theData.end(); cit++) {
        for (size_t i = 1; i <= dim; i++) {
            real r = (*cit)[i];
            // vectors indexed 0 - n-1, rvectors ndexed 1 - n
            if(r < mins[i-1]) {
                mins[i-1] = r;
            }
            if(r > maxs[i-1]) {
                maxs[i-1] = r;
            }
        } // end going through rvector elements
    } // end going through rvectors

    ivector retVal(dim);    // set up an ivector to become the return value

    // and make each interval the (min, max) of the corresponding elements
    // of the rvectors -/+ some padding

    std::cout << "A box is being made for the data.  "
        << "The box is " << std::endl;  // standard output message

    // make intervals and make them elements of the ivector
    for (size_t i = 1; i <=dim; i++) {
        interval myInterval(mins[i-1]-padding, maxs[i-1]+padding);
        std::cout << myInterval << "  ";    // output
        retVal[i]=myInterval;
    }
    std::cout << std::endl;

    return retVal;

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a30cd1199dfab7883a8191e501d372613}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!merge\-Up@{merge\-Up}}
\index{merge\-Up@{merge\-Up}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{merge\-Up}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::merge\-Up} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a30cd1199dfab7883a8191e501d372613}


\-Merge a multileaf histogram up to just root box. 

\-No prioritistion, just brute force \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ad3d12ca5330306b377001a4064599430}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!operator+@{operator+}}
\index{operator+@{operator+}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{operator+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation} subpavings\-::\-Adaptive\-Histogram\-Validation\-::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf \-Adaptive\-Histogram\-Validation} \&}]{rhs}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ad3d12ca5330306b377001a4064599430}


\-Overloaded addition operator. 

\-Makes a new histogram by adding this and rhs together. \-The subpaving will be the union of the subpavings of this and rhs. \-Data is reinserted into the new histogram so that the counts in each box of the subpaving are exactly right for that subpaving. \-This is in contrast to the way that the \-Adaptive\-Histogram\-Validation\-Collator works (divides a count evenly in two when apportioning it between bisected boxes). hold\-All\-Stats will be set to the logical and of the values for this and rhs. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_aba8d900d6f696824de3e6cb5bb99e794}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!operator=@{operator=}}
\index{operator=@{operator=}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{operator=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-Validation} \& \-Adaptive\-Histogram\-Validation\-::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf \-Adaptive\-Histogram\-Validation} \&}]{rhs}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_aba8d900d6f696824de3e6cb5bb99e794}


\-Copy assignment operator. 



\-Definition at line 495 of file adaptivehistogramvalidation.\-cpp.



\-References creation\-String, data\-Collection, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), hold\-All\-Stats, root\-Box, root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
{
    try {
        //cout << "copy assignment operator" << endl;
        // we have to make sure we delete the current paving
        if (NULL != rootVpaving) {
            delete rootVpaving;
            rootVpaving = NULL;
        }

        if (NULL != rhs.rootVpaving) {
            rootVpaving = new SPSVnode(*(rhs.rootVpaving));
            creationString = rootVpaving->getNodeName();
            creationString += rootVpaving->getChildNodeNames();

            //copy dataCollection from other to this
            dataCollection = rhs.dataCollection;
            holdAllStats = rhs.holdAllStats;
        }
        rootBox = rhs.rootBox;
        return *this;
    }
    catch (bad_alloc& ba) {
        std::cerr << "Error allocating memory in constructor" << std::endl;
        throw HistException("Error in constructor");
    }
    catch (SPnodeException& spe) {
        string msg(spe.what());
        std:: cerr << "SPnodeExcepton in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Error in constructor");
    }
    catch (exception& e) {
        string msg(e.what());
        std:: cerr << "Error in constructor: original error "
                                            << msg << std::endl;
        throw HistException("Error in constructor");
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a0286278b4e489ed8809dcb60d136dce7}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!output\-Graph\-Dot@{output\-Graph\-Dot}}
\index{output\-Graph\-Dot@{output\-Graph\-Dot}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{output\-Graph\-Dot}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::output\-Graph\-Dot} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a0286278b4e489ed8809dcb60d136dce7}


\-Make a .dot graph file from histogram structure. 

\-Makes a simple .dot graph from the histogram using node names and the .png image for this graph.

\begin{DoxyPrecond}{\-Precondition}
a constructed histogram 
\end{DoxyPrecond}
\begin{DoxyPostcond}{\-Postcondition}
a .dot file and a .png in the same directory as the program creating it was run in. 
\end{DoxyPostcond}


\-Definition at line 3349 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-Pnode\-::output\-Graph\-Dot(), and root\-Vpaving.


\begin{DoxyCode}
{
    bool success = false;

    if (NULL != rootVpaving) {
        success = rootVpaving->outputGraphDot();

    }
    else {
        std::cerr << "Sorry, you can't make a graph without a root paving"
                << std::endl;
    }
    return success;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a75453f853b530cd3e2a7afccf25e39d0}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!output\-Log@{output\-Log}}
\index{output\-Log@{output\-Log}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{output\-Log}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::output\-Log} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{const int}]{i}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a75453f853b530cd3e2a7afccf25e39d0}


\-Append current state of histogram to a txt log file. 

\-Format is a tab-\/delimited file of numeric data. \-Output includes node contributions to unscaled \-E\-M\-P under \-C\-O\-P\-E\-R\-R and \-A\-I\-C and the changes in \-E\-M\-P that would result from splitting the node.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em i} & the number of pass (ie, 0, 1, 2, 3 etc) in process \\
\hline
\end{DoxyParams}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a34f7487fd92886151634c00e8e75cca5}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!output\-Log\-Start@{output\-Log\-Start}}
\index{output\-Log\-Start@{output\-Log\-Start}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{output\-Log\-Start}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-Validation\-::output\-Log\-Start} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a34f7487fd92886151634c00e8e75cca5}


\-Opening line of a txt log file. 

\-Starts the log file with file name and date and time 
\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
\end{DoxyParams}


\-Definition at line 360 of file adaptivehistogramvalidation.\-cpp.



\-Referenced by priority\-Split\-And\-Estimate(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{
    // Make a string with filename and timestamp to start log file
    time_t rawtime;
    struct tm * timeinfo;
    time ( &rawtime );
    timeinfo = localtime ( &rawtime );
    ofstream os(s.c_str());         // replace data
    if (os.is_open()) {
        os << "File " << s << " created " <<  asctime (timeinfo) << std::endl;
        os.close();
    }
    else {
        std::cerr << "Error: could not open file named "
            << s << std::endl << std::endl;
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a78d5c3ad5e31fc438e0c4cac65e73313}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!output\-Root\-To\-Txt@{output\-Root\-To\-Txt}}
\index{output\-Root\-To\-Txt@{output\-Root\-To\-Txt}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{output\-Root\-To\-Txt}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-Validation\-::output\-Root\-To\-Txt} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{bool}]{confirm = {\ttfamily false}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a78d5c3ad5e31fc438e0c4cac65e73313}


\-Output details of full sample (from root) to txt tile. 

\-Format is a mixture of alpha and numeric data.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em confirm} & is a boolean controlling whether confirmation goes to console output (defaults to false). \\
\hline
\end{DoxyParams}


\-Definition at line 3391 of file adaptivehistogramvalidation.\-cpp.



\-References get\-Sub\-Paving(), subpavings\-::\-S\-P\-S\-Vnode\-::node\-Print(), and root\-Vpaving.


\begin{DoxyCode}
{
    if (NULL != rootVpaving) {

        // To generate a file output of root node of the
       AdaptiveHistogramValidation
        ofstream os(s.c_str());         // Filename, c-string version
        getSubPaving()->nodePrint(os); // the output
        if (confirm)
            std::cout << "Details of the root paving of the
       AdaptiveHistogramValidation "
                << "has been written to " << s << std::endl << std::endl;
    }

}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ac7ad1cd4a9403ae91083dc0ef2356a24}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!output\-To\-Txt\-Tabs@{output\-To\-Txt\-Tabs}}
\index{output\-To\-Txt\-Tabs@{output\-To\-Txt\-Tabs}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{output\-To\-Txt\-Tabs}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Adaptive\-Histogram\-Validation\-::output\-To\-Txt\-Tabs} (
\begin{DoxyParamCaption}
\item[{const std\-::string \&}]{s, }
\item[{bool}]{confirm = {\ttfamily false}}
\end{DoxyParamCaption}
) const}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ac7ad1cd4a9403ae91083dc0ef2356a24}


\-Output the subpaving managed by this to a txt file. 

\-Format is a tab-\/delimited file of numeric data starting with node\-Name, then the node box volume, then the node counter, then the description of the node box as a tab-\/delimited list of interval upper and lower bounds.


\begin{DoxyParams}{\-Parameters}
{\em s} & the name of the txt file to send output to. \\
\hline
{\em confirm} & is a boolean controlling whether confirmation goes to console output (defaults to false). \\
\hline
\end{DoxyParams}


\-Definition at line 3367 of file adaptivehistogramvalidation.\-cpp.



\-References get\-Sub\-Paving(), subpavings\-::\-S\-P\-S\-Vnode\-::leaves\-Output\-Tabs(), and root\-Vpaving.



\-Referenced by main().


\begin{DoxyCode}
{
    if (NULL != rootVpaving) {

        // To generate a file output of the AdaptiveHistogramValidation object
        ofstream os(s.c_str());         // Filename, c-string version
        if (os.is_open()) {

            getSubPaving()->leavesOutputTabs(os); // the output
            if (confirm)
                std::cout << "The output of the AdaptiveHistogramValidation "
                    << "has been written to " << s << std::endl << std::endl;
        }
        else {
            std::cerr << "Error: could not open file named "
                << s << std::endl << std::endl;
        }
    }
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a86feeca7ad74bc1c9ebc35f2ef0dd5e6}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-V\-Collator} {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{long double}]{tol, }
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a86feeca7ad74bc1c9ebc35f2ef0dd5e6}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a9a558b6a13ad7019acd893f0edbb107b}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split@{priority\-Split}}
\index{priority\-Split@{priority\-Split}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-V\-Collator} {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{long double}]{tol, }
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a9a558b6a13ad7019acd893f0edbb107b}
\-With random number generator. \-All other parameters supplied. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a261b3220218fe58d08713381aa7b0b44}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-V\-Collator} {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{int}]{distr, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a261b3220218fe58d08713381aa7b0b44}
2\-D shapes\-: min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Referenced by main(), and priority\-Split\-And\-Estimate().

\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ad076189eb2565d34b8f4998eb7330827}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-V\-Collator} {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{int}]{distr, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ad076189eb2565d34b8f4998eb7330827}
2\-D shapes\-: \-With random number generator. \-All other parameters supplied. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a63938649a46bb4a5ed5d432606b02427}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{double}]{weight, }
\item[{std\-::vector$<$ int $>$}]{holes\-Loc, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opt\-Hist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a63938649a46bb4a5ed5d432606b02427}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Definition at line 850 of file adaptivehistogramvalidation.\-cpp.



\-References priority\-Split\-And\-Estimate(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    gsl_rng * rgsl = NULL;
    bool cancontinue;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        // call the function with a random number generator
        cancontinue = prioritySplitAndEstimate(compTest, he, logging, 
      minChildPoints, 
                        minVolB, rgsl, stopCrit, myPart, weight, holesLoc,
                        method, hist,
                        maxLeafNodes, maxCheck, optHist);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority stage split.  Orginal
       error: "
                                     + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority stage split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
   
   return cancontinue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ae982e9b5ffc50d9893a557a09bfc89af}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{double}]{weight, }
\item[{std\-::vector$<$ int $>$}]{holes\-Loc, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opt\-Hist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ae982e9b5ffc50d9893a557a09bfc89af}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 922 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::add\-To\-Collation\-With\-Val(), check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand\-With\-Valid(), \-F(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaves(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Left\-Child(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Min\-Delta(), get\-Min\-Vol(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Number\-Collated(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Split\-Node\-Ptr(), get\-Sub\-Paving(), get\-Unif\-I\-A\-E(), get\-Unif\-True\-Delta(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Class\-All(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Delta(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, output\-Log\-Start(), root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
{
    //cout << "calling prioritySplitAndEstimate:" << endl;
   bool cancontinue = false;
   bool TooManyLeaves = false;
   
    //boolean for validation data
    bool boolVal = true;
    
    // for stopping criteria
    size_t flagStop = 0;
    int currentSmallest = 0;
    
    int n = getSubPaving()->getCounter();
    
    //set up collator to keep the histograms as splits happen
    AdaptiveHistogramVCollator coll;
    
   //=======initializing containers======================================
  //set up a list for the Yatracos set 
  list< set<CollatorSPVnode*, less<CollatorSPVnode*> > > listYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (row)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecRowYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (col)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecColYatSet;    
  //set up a vector for maximum Delta_theta vectors
  vector< vector<double> > vecMaxDeltaVec;
  //initializing the vector - to allow the delta vector to be in 
  // right order  since the first histogram does not have a 
  // Yatracos set
  //the first element in this vector will not be plotted since 
  // the first histogram is an empty set
  vector<double> theta0;
  theta0.push_back(-1*(numeric_limits<double>::infinity())); 
  //the supremum of an empty set is -Infimum 
  vecMaxDeltaVec.push_back(theta0);
  //set up a vector of the corresponding theta with the minimum 
  // distance estimates
  vector< vector<int> > vecMinDistTheta;
  // set up a vector for the infimum 
  vector<double> vecInfDelta;
  // set up a vector for the integrated absolute error for each histogram
   vector<real> vecIAE; 
   vector<real> vecIAEFull;
   real minIAE = 1000.00;
   
   vector<real> TrueDelta;
   TrueDelta.push_back(-1); 
   
   real trueDeltaCurrent = 0;
   
   // to keep the histograms
   vector<AdaptiveHistogramValidation> tempHist;
   //==============end of initializing
       containers=============================//   
   // check if the root box is empty
    if (NULL == rootVpaving) {
            throw HistException("No root paving for prioritySplit");
    }
    try {       
        // add the histogram before any split happens into the collator
        size_t agg = 0;
      coll.addToCollationWithVal(*this, 1, agg);
      tempHist.push_back(*this);
      // calculate the IAE 
      real IAE = getUnifIAE(myPart, weight, holesLoc, 0);
      // push back into vecIAE 
      vecIAE.push_back(IAE);
      minIAE = (IAE < minIAE) ? IAE : minIAE;
      
      //get the IAE for the full data set
      real IAEF = getUnifIAE(myPart, weight, holesLoc, 1);
      // push back into vecIAE 
      vecIAEFull.push_back(IAEF);

    //============checks  for splittable nodes=============================//
        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        //logging
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }
        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
            volChecking = true;
        }
      // a multiset for the queue (key values are not necessarily unique)
      multiset<SPSVnode*, MyCompare> pq((MyCompare(compTest)));
      int i=0;
      if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);    
            i++;
      }
      // put nodes into the starting set IF they meet minVol test AND IF either
      // there are enough points in the whole node
      // and minChildCountIfSplit is 0 (ie all points go to one child)
      // or the minChildCountIfSplit test passed
        if (rootVpaving->isLeaf()) {
            // check to insert a copy of the rootVpaving pointer into the set
           if (checkNodeCountForSplit(rootVpaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootVpaving);
            }
        }
        else { // root is not a leaf
            SPSVnodePtrs leaves;
            rootVpaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSVnodePtrsItr sit;            
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        bool bigEnough = cancontinue;
        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }        
        //==================end of
       checks=====================================//
  
      size_t ch = 0;
      
        //=========start priority queue====================================//
        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out   
      while (bigEnough && !he(this) && !TooManyLeaves) {          
            SPSVnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSVnode* chosenLargest;
            // find if there are any more equal to largest around
            multiset<SPSVnode*, MyCompare>::iterator mit;
            pair<multiset<SPSVnode*, MyCompare>::iterator,
                multiset<SPSVnode*, MyCompare>::iterator> equalLargest;
            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {
                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {
                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }
            else {
                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSVnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }
            // split the biggest one and divide up its training and validation 
            // data
            
            cout << "--------------Split " << coll.getNumberCollated() << endl;
            ExpandWithValid(chosenLargest, boolVal);
                          
            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

            // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed
            if (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new left child into the multiset
                pq.insert(chosenLargest->getLeftChild());
            }
            if (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new right child into the multiset
                pq.insert(chosenLargest->getRightChild());
            }
            if (logging != NOLOG) {
                // To add current state of histogram to log file               
          
                i++;
            }

          //==========get IAE for this histogram======================//
        //cout << "get IAE for histogram " << coll.getNumberCollated() << endl;
        real IAE = getUnifIAE(myPart, weight, holesLoc, 0);
        minIAE = (IAE < minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF =getUnifIAE(myPart, weight, holesLoc, 1);
        vecIAEFull.push_back(IAEF); 
        
        
        // keep this histogram in a container 
        tempHist.push_back(*this);
        
        /*
        string fileName = "QueueHist";
        ostringstream stm;
        stm << ch;
        fileName += stm.str();
        fileName += ".txt";
        outputToTxtTabs(fileName);
        
        ch++;
        */
        //cout << "add into collator" << endl;
        // add current histogram to collation
        size_t agg = 0;
        coll.addToCollationWithVal(*this, 1, agg);
          
        //cout << "get the split node" << endl;
        // first we need a pointer to the corresponding CollatorSPVnode 
        // of the SPSVnode* chosenLargest     
        CollatorSPVnode * splitCollNode;
        coll.getSplitNodePtr(splitCollNode, chosenLargest);
        //cout << chosenLargest->getNodeName() << "\t" <<
       splitCollNode->getNodeName() << endl;
        
        //cout << "get the yat class" << endl;
        // get the Yatracos class for this collation
        coll.getYatracosClassAll(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        //cout << "get delta theta" << endl;
        // get delta_theta for each theta
        coll.getYatracosDelta(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        // get the true delta
        real trueDelta = 0;
        vector< set<CollatorSPVnode*, less < CollatorSPVnode* > > >::iterator 
      listIt;   
        //cout << "Current Yatracos set has " << (*tempList).size() << "
       nodes." << endl;
        for (listIt = (vecRowYatSet).begin(); listIt < vecRowYatSet.end(); 
      listIt++) {
          if ( !(*listIt).empty() ) {
            real trueDeltaR = getUnifTrueDelta(myPart, weight, holesLoc, (*
      listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        for (listIt = (vecColYatSet).begin(); listIt < vecColYatSet.end(); 
      listIt++) {
          if ( !(*listIt).empty() ) {
            real trueDeltaR = getUnifTrueDelta(myPart, weight, holesLoc, (*
      listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        if ( vecRowYatSet.empty() && vecColYatSet.empty() ) { trueDelta = -1; 
      TrueDelta.push_back(trueDelta); } 

        //check theorem 10.1
        //cout << "check theorem: " << endl;
        //cout << IAE << "\t" << minIAE << "\t" << trueDelta << endl;
        //if (trueDelta >= 0) { assert(IAE <= (3*minIAE + 4*trueDelta)); }

        //stopping criteria
        if (stopCrit == true) {
          //cout << "checking stopping criteria: " << endl;
          bool toStop = coll.getMinDelta(maxCheck, vecMaxDeltaVec);
          if (toStop == true) {
            cout << "Stopping criteria met." << endl;
            break;
          } 
        }

        //==========checks to see if need to split again=========//
            //checking if there are any more 'largest' nodes in the priority
       queue
            bigEnough = (!pq.empty());
            if (!bigEnough){    
          std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
            }
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      } // end of while loop
      //cout << "===========End of splitting=============" << endl;
        
      //do the merging here based on vecMinDistTheta
         
      //================Outputs to .txt files=================== 
      ofstream os;         // ofstream object
      os << scientific;  // set formatting for input to oss
      os.precision(5);

       // get the minimum delta to get the MDE histogram
      vector< vector<double> >::iterator it1; 
      vector<double>::iterator it2;
      int Theta=0;
      //cout << "MaxDelta" << endl;
      size_t F = vecMaxDeltaVec.size(); 
      double minDelta = 1000;
      int minTheta = 0;
      for (size_t i = 0; i < F; i++){
        //cout << "Theta: " << Theta << "\t" << vecMaxDeltaVec[F-1][i] << endl;
        if ( vecMaxDeltaVec[F-1][i] < minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout << "MDE at " << minTheta << " with IAE " << vecIAE[minTheta] << endl
      ; 
         optHist = tempHist[minTheta];

      // output vecDeltaMaxVec into .txt 
      ostringstream stm1, stm2;
      stm1 << hist;
      stm2 << method;
      string fileNameDelta = "UnifMethod";
      fileNameDelta += stm2.str();
      fileNameDelta += "DeltaMax";
      fileNameDelta += stm1.str();
      fileNameDelta += ".txt";  
      os.open(fileNameDelta.c_str());
      for (it1 = vecMaxDeltaVec.begin(); it1 < vecMaxDeltaVec.end(); it1++){ 
        for (it2 = (*it1).begin(); it2 < (*it1).end(); it2++){
          os << (*it2) << "\t";
        }
        os << "\n";
      }          
      os << flush;
      os.close();
      std::cout << "DeltaMax for each theta output to " << fileNameDelta << "."
       << endl;
      //----------------end of output for vecDeltaMaxVec-------------
 
         //output vecIAE to .txt file
      string outputFileName;// for output file
      outputFileName = "UnifMethod";
      outputFileName += stm2.str();
      outputFileName += "IAEandTrueDelta";
      outputFileName += stm1.str();
      outputFileName += ".txt";
      os.open(outputFileName.c_str());
      for (size_t i = 0; i < vecIAE.size(); i++){
        os << vecIAE[i] << "\t" << vecIAEFull[i] << TrueDelta[i] << endl;
      }
      os << flush;
      os.close();
      std::cout << "IAE output to " << outputFileName << endl;
      //=================end of output for vecIAE---------------------------      
   } // end of try
    
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority stage split.  Orginal error: " + oldmsg
      ;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    
   return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a46ff8e128b5d734c3839871c465bcf46}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Fin\-Mix} \&}]{mixt, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{double}]{tol, }
\item[{int}]{deg, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opthist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a46ff8e128b5d734c3839871c465bcf46}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. 

\-Definition at line 2788 of file adaptivehistogramvalidation.\-cpp.



\-References priority\-Split\-And\-Estimate(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    gsl_rng * rgsl = NULL;
    bool cancontinue;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        // call the function with a random number generator
        cancontinue = prioritySplitAndEstimate(compTest, he, logging, 
      minChildPoints, 
                        minVolB, rgsl, stopCrit, mixt, method, hist,
                        maxLeafNodes, maxCheck, tol, deg, optHist);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority stage split.  Orginal
       error: "
                                     + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority stage split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
   
   return cancontinue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a990028dc08bc4780df6a04f78b4ec644}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Fin\-Mix} \&}]{mixt, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{double}]{tol, }
\item[{int}]{deg, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opthist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a990028dc08bc4780df6a04f78b4ec644}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 2858 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::add\-To\-Collation\-With\-Val(), check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand\-With\-Valid(), \-F(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Fin\-Mix\-Interval\-I\-A\-E(), get\-Fin\-Mix\-Interval\-True\-Delta(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaves(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Left\-Child(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Min\-Delta(), get\-Min\-Vol(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Number\-Collated(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Split\-Node\-Ptr(), get\-Sub\-Paving(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Class\-All(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Delta(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, output\-Log\-Start(), root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
{
    //cout << "calling prioritySplitAndEstimate:" << endl;
   bool cancontinue = false;
   bool TooManyLeaves = false;
   
    //boolean for validation data
    bool boolVal = true;
    
    // for stopping criteria
    size_t flagStop = 0;
    int currentSmallest = 0;
    
    int n = getSubPaving()->getCounter();
    
    //set up collator to keep the histograms as splits happen
    AdaptiveHistogramVCollator coll;
    
   //=======initializing containers======================================
  //set up a list for the Yatracos set 
  list< set<CollatorSPVnode*, less<CollatorSPVnode*> > > listYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (row)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecRowYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (col)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecColYatSet;    
  //set up a vector for maximum Delta_theta vectors
  vector< vector<double> > vecMaxDeltaVec;
  //initializing the vector - to allow the delta vector to be in 
  // right order  since the first histogram does not have a 
  // Yatracos set
  //the first element in this vector will not be plotted since 
  // the first histogram is an empty set
  vector<double> theta0;
  theta0.push_back(-1*(numeric_limits<double>::infinity())); 
  //the supremum of an empty set is -Infimum 
  vecMaxDeltaVec.push_back(theta0);
  //set up a vector of the corresponding theta with the minimum 
  // distance estimates
  vector< vector<int> > vecMinDistTheta;
  // set up a vector for the infimum 
  vector<double> vecInfDelta;
  // set up a vector for the integrated absolute error for each histogram
   vector<real> vecIAE; 
   vector<real> vecIAEFull;
   real minIAE = 1000.00;
   
   vector<real> TrueDelta;
   TrueDelta.push_back(-1); 
   
   real trueDeltaCurrent = 0;
   
   // to keep the histograms
   vector<AdaptiveHistogramValidation> tempHist;
   //==============end of initializing
       containers=============================//   
   // check if the root box is empty
    if (NULL == rootVpaving) {
            throw HistException("No root paving for prioritySplit");
    }
    try {       
        // add the histogram before any split happens into the collator
        size_t agg = 0;
      coll.addToCollationWithVal(*this, 1, agg);
      tempHist.push_back(*this);
      // calculate the IAE 
      real IAE = mid(getFinMixIntervalIAE(mixt, tol, deg, 0));
      // push back into vecIAE 
      vecIAE.push_back(IAE);
      minIAE = (IAE < minIAE) ? IAE : minIAE;
      
      //get the IAE for the full data set
      real IAEF = mid(getFinMixIntervalIAE(mixt, tol, deg, 1));
      // push back into vecIAE 
      vecIAEFull.push_back(IAEF);

    //============checks  for splittable nodes=============================//
        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        //logging
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }
        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
            volChecking = true;
        }
      // a multiset for the queue (key values are not necessarily unique)
      multiset<SPSVnode*, MyCompare> pq((MyCompare(compTest)));
      int i=0;
      if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);    
            i++;
      }
      // put nodes into the starting set IF they meet minVol test AND IF either
      // there are enough points in the whole node
      // and minChildCountIfSplit is 0 (ie all points go to one child)
      // or the minChildCountIfSplit test passed
        if (rootVpaving->isLeaf()) {
            // check to insert a copy of the rootVpaving pointer into the set
           if (checkNodeCountForSplit(rootVpaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootVpaving);
            }
        }
        else { // root is not a leaf
            SPSVnodePtrs leaves;
            rootVpaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSVnodePtrsItr sit;            
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        bool bigEnough = cancontinue;
        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }        
        //==================end of
       checks=====================================//
  
      size_t ch = 0;
      
        //=========start priority queue====================================//
        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out   
      while (bigEnough && !he(this) && !TooManyLeaves) {          
            SPSVnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSVnode* chosenLargest;
            // find if there are any more equal to largest around
            multiset<SPSVnode*, MyCompare>::iterator mit;
            pair<multiset<SPSVnode*, MyCompare>::iterator,
                multiset<SPSVnode*, MyCompare>::iterator> equalLargest;
            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {
                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {
                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }
            else {
                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSVnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }
            // split the biggest one and divide up its training and validation 
            // data
            
            cout << "--------------Split " << coll.getNumberCollated()-1 << 
      endl;
            ExpandWithValid(chosenLargest, boolVal);
                          
            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

            // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed
            if (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new left child into the multiset
                pq.insert(chosenLargest->getLeftChild());
            }
            if (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) {
                // insert the new right child into the multiset
                pq.insert(chosenLargest->getRightChild());
            }
            if (logging != NOLOG) {
                // To add current state of histogram to log file               
          
                i++;
            }

          //==========get IAE for this histogram======================//
        //cout << "get IAE for histogram " << coll.getNumberCollated() << endl;
        real IAE = mid(getFinMixIntervalIAE(mixt, tol, deg, 0));
        minIAE = (IAE < minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF = mid(getFinMixIntervalIAE(mixt, tol, deg, 1));
        vecIAEFull.push_back(IAEF); 
        
        
        // keep this histogram in a container 
        tempHist.push_back(*this);
        
        /*
        string fileName = "QueueHist";
        ostringstream stm;
        stm << ch;
        fileName += stm.str();
        fileName += ".txt";
        outputToTxtTabs(fileName);
        
        ch++;
        */
        //cout << "add into collator" << endl;
        // add current histogram to collation
        size_t agg = 0;
        coll.addToCollationWithVal(*this, 1, agg);
          
        //cout << "get the split node" << endl;
        // first we need a pointer to the corresponding CollatorSPVnode 
        // of the SPSVnode* chosenLargest     
        CollatorSPVnode * splitCollNode;
        coll.getSplitNodePtr(splitCollNode, chosenLargest);
        //cout << chosenLargest->getNodeName() << "\t" <<
       splitCollNode->getNodeName() << endl;
        
        //cout << "get the yat class" << endl;
        // get the Yatracos class for this collation
        coll.getYatracosClassAll(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        //cout << "get delta theta" << endl;
        // get delta_theta for each theta
        coll.getYatracosDelta(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        // get the true delta
        real trueDelta = 0.0;
        vector< set<CollatorSPVnode*, less < CollatorSPVnode* > > >::iterator 
      listIt;   
        //cout << "Current Yatracos set has " << (*tempList).size() << "
       nodes." << endl;
        for (listIt = (vecRowYatSet).begin(); listIt < vecRowYatSet.end(); 
      listIt++) {
          if ( !(*listIt).empty() ) {
              interval TrueDeltaI = getFinMixIntervalTrueDelta(mixt, tol, deg, 
      (*listIt));
              real trueDeltaR = mid(TrueDeltaI);
              trueDeltaR = abs(trueDeltaR);
              trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
              //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
              trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
              //cout << "delta after comparison: " << trueDelta << endl;
              trueDeltaCurrent = trueDelta;
              TrueDelta.push_back(trueDelta);
            }
          }

          for (listIt = (vecColYatSet).begin(); listIt < vecColYatSet.end(); 
      listIt++) {
            if ( !(*listIt).empty() ) {
              interval TrueDeltaI = getFinMixIntervalTrueDelta(mixt, tol, deg, 
      (*listIt));
              real trueDeltaR = mid(TrueDeltaI);
              trueDeltaR = abs(trueDeltaR);
              trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
              //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
              trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
              //cout << "delta after comparison: " << trueDelta << endl;
              trueDeltaCurrent = trueDelta;
              TrueDelta.push_back(trueDelta);
            }
          }

        if ( vecRowYatSet.empty() && vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
        //check theorem 10.1
        //cout << "check theorem: " << endl;
        //cout << IAE << "\t" << minIAE << "\t" << trueDelta << endl;
        if ( trueDelta >= 0) {  assert(IAE <= (3*minIAE + 4*trueDelta)); }

        //stopping criteria
        if (stopCrit == true) {
          //cout << "checking stopping criteria: " << endl;
          bool toStop = coll.getMinDelta(maxCheck, vecMaxDeltaVec);
          if (toStop == true) {
            cout << "Stopping criteria met." << endl;
            break;
          } 
        }
        //==========checks to see if need to split again=========//
            //checking if there are any more 'largest' nodes in the priority
       queue
            bigEnough = (!pq.empty());
            if (!bigEnough){    
          std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
            }
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      } // end of while loop
      //cout << "===========End of splitting=============" << endl;
        
      //do the merging here based on vecMinDistTheta
         
      //================Outputs to .txt files=================== 
      ofstream os;         // ofstream object
      os << scientific;  // set formatting for input to oss
      os.precision(5);

       // get the minimum delta to get the MDE histogram
      vector< vector<double> >::iterator it1; 
      vector<double>::iterator it2;
      int Theta=0;
      //cout << "MaxDelta" << endl;
      size_t F = vecMaxDeltaVec.size(); 
      double minDelta = 1000;
      int minTheta = 0;
      for (size_t i = 0; i < F; i++){
        //cout << "Theta: " << Theta << "\t" << vecMaxDeltaVec[F-1][i] << endl;
        if ( vecMaxDeltaVec[F-1][i] < minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout << "MDE at " << minTheta << " with IAE " << vecIAE[minTheta] << endl
      ; 
         optHist = tempHist[minTheta];

      // output vecDeltaMaxVec into .txt 
      ostringstream stm1, stm2;
      stm1 << hist;
      stm2 << method;
      string fileNameDelta = "FinMixMethod";
      fileNameDelta += stm2.str();
      fileNameDelta += "DeltaMax";
      fileNameDelta += stm1.str();
      fileNameDelta += ".txt";  
      os.open(fileNameDelta.c_str());
      for (it1 = vecMaxDeltaVec.begin(); it1 < vecMaxDeltaVec.end(); it1++){ 
        for (it2 = (*it1).begin(); it2 < (*it1).end(); it2++){
          os << (*it2) << "\t";
        }
        os << "\n";
      }          
      os << flush;
      os.close();
      std::cout << "DeltaMax for each theta output to " << fileNameDelta << "."
       << endl;
      //----------------end of output for vecDeltaMaxVec-------------
 
         //output vecIAE to .txt file
      string outputFileName;// for output file
      outputFileName = "FinMixMethod";
      outputFileName += stm2.str();
      outputFileName += "IAEandTrueDelta";
      outputFileName += stm1.str();
      outputFileName += ".txt";
      os.open(outputFileName.c_str());
      for (size_t i = 0; i < vecIAE.size(); i++){
        os << vecIAE[i] << "\t" << vecIAEFull[i] << TrueDelta[i] << endl;
      }
      os << flush;
      os.close();
      std::cout << "IAE output to " << outputFileName << endl;
      //=================end of output for vecIAE---------------------------      
   } // end of try
    
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority stage split.  Orginal error: " + oldmsg
      ;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    
   return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ae94f662a33afa791de400341ad98cff7}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Real\-Mapped\-S\-Pnode} \&}]{node\-Est, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opt\-Hist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ae94f662a33afa791de400341ad98cff7}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a831814eaa200ac0fb42b5b600ec785c3}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Real\-Mapped\-S\-Pnode} \&}]{node\-Est, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opt\-Hist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a831814eaa200ac0fb42b5b600ec785c3}
\-With random number generator. \-All other parameters supplied. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_aeb61aa929e6edebe98d6d4fbb10a6adb}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-V\-Collator} {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{{\bf \-Real\-Mapped\-S\-Pnode} \&}]{node\-Est}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_aeb61aa929e6edebe98d6d4fbb10a6adb}
min\-Vol\-B and min\-Child\-Points supplied but no random number generator. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ab38050780c66024e0c278789b37e25ed}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}}
\index{priority\-Split\-And\-Estimate@{priority\-Split\-And\-Estimate}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Adaptive\-Histogram\-V\-Collator} {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{{\bf \-Real\-Mapped\-S\-Pnode} \&}]{node\-Est}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ab38050780c66024e0c278789b37e25ed}
\-With random number generator. \-All other parameters supplied. \hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_aabc3d1996ec2e9e1e227f6012c0c8f06}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}}
\index{priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate\-With\-Switch}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate\-With\-Switch} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{double}]{weight, }
\item[{std\-::vector$<$ int $>$}]{holes\-Loc, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opthist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_aabc3d1996ec2e9e1e227f6012c0c8f06}


\-Definition at line 2244 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().



\-Referenced by main(), and priority\-Split\-And\-Estimate\-With\-Switch().


\begin{DoxyCode}
{
    gsl_rng * rgsl = NULL;
    bool cancontinue;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        // call the function with a random number generator
        cancontinue = prioritySplitAndEstimateWithSwitch(compTest, he, logging,
       minChildPoints, 
                        minVolB, rgsl, stopCrit, myPart, weight, holesLoc,
                        method, hist,
                        maxLeafNodes, maxCheck, optHist);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority stage split.  Orginal
       error: "
                                     + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority stage split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
   
   return cancontinue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ae2684877f0996eea6f6593f1be2ab38a}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}}
\index{priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate\-With\-Switch}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate\-With\-Switch} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Adaptive\-Histogram} \&}]{my\-Part, }
\item[{double}]{weight, }
\item[{std\-::vector$<$ int $>$}]{holes\-Loc, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opthist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ae2684877f0996eea6f6593f1be2ab38a}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 2316 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::add\-To\-Collation\-With\-Val(), check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand\-With\-Valid(), \-F(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaves(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Left\-Child(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Min\-Delta(), get\-Min\-Vol(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Number\-Collated(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Split\-Node\-Ptr(), get\-Sub\-Paving(), get\-Unif\-I\-A\-E(), get\-Unif\-True\-Delta(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Class\-All(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Delta(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, output\-Log\-Start(), root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
{
    //cout << "calling prioritySplitAndEstimate:" << endl;
   bool cancontinue = false;
   bool TooManyLeaves = false;
   
    //boolean for validation data
    bool boolVal = true;
    
    // for stopping criteria
    size_t flagStop = 0;
    int currentSmallest = 0;
    
    int n = getSubPaving()->getCounter();
    
    //set up collator to keep the histograms as splits happen
    AdaptiveHistogramVCollator coll;
    
   //=======initializing containers======================================
  //set up a list for the Yatracos set 
  list< set<CollatorSPVnode*, less<CollatorSPVnode*> > > listYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (row)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecRowYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (col)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecColYatSet;    
  //set up a vector for maximum Delta_theta vectors
  vector< vector<double> > vecMaxDeltaVec;
  //initializing the vector - to allow the delta vector to be in 
  // right order  since the first histogram does not have a 
  // Yatracos set
  //the first element in this vector will not be plotted since 
  // the first histogram is an empty set
  vector<double> theta0;
  theta0.push_back(-1*(numeric_limits<double>::infinity())); 
  //the supremum of an empty set is -Infimum 
  vecMaxDeltaVec.push_back(theta0);
  //set up a vector of the corresponding theta with the minimum 
  // distance estimates
  vector< vector<int> > vecMinDistTheta;
  // set up a vector for the infimum 
  vector<double> vecInfDelta;
  // set up a vector for the integrated absolute error for each histogram
   vector<real> vecIAE; 
   vector<real> vecIAEFull;
   real minIAE = 1000.00;
   
   vector<real> TrueDelta;
   TrueDelta.push_back(-1); 

  real trueDeltaCurrent = 0;
  
   // to keep the histograms
   vector<AdaptiveHistogramValidation> tempHist;
   //==============end of initializing
       containers=============================//   
   // check if the root box is empty
    if (NULL == rootVpaving) {
            throw HistException("No root paving for prioritySplit");
    }
    try {       
        // add the histogram before any split happens into the collator
        size_t agg = 0;
      coll.addToCollationWithVal(*this, 1, agg);
      tempHist.push_back(*this);
      // calculate the IAE 
      real IAE = getUnifIAE(myPart, weight, holesLoc, 0);
      // push back into vecIAE 
      vecIAE.push_back(IAE);
      minIAE = (IAE < minIAE) ? IAE : minIAE;
      
      //get the IAE for the full data set
      real IAEF = getUnifIAE(myPart, weight, holesLoc, 1);
      // push back into vecIAE 
      vecIAEFull.push_back(IAEF);

    //============checks  for splittable nodes=============================//
        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        //logging
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }
        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
            volChecking = true;
        }
      // a multiset for the queue (key values are not necessarily unique)
      multiset<SPSVnode*, MyCompare> pq((MyCompare(compTest)));
      int i=0;
      if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);    
            i++;
      }
      // put nodes into the starting set IF they meet minVol test AND IF either
      // there are enough points in the whole node
      // and minChildCountIfSplit is 0 (ie all points go to one child)
      // or the minChildCountIfSplit test passed
        if (rootVpaving->isLeaf()) {
            // check to insert a copy of the rootVpaving pointer into the set
           if (checkNodeCountForSplit(rootVpaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootVpaving);
            }
        }
        else { // root is not a leaf
            SPSVnodePtrs leaves;
            rootVpaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSVnodePtrsItr sit;            
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        bool bigEnough = cancontinue;
        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }        
        //==================end of
       checks=====================================//
  
        //=========start priority queue====================================//
        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out   
      while (bigEnough && !he(this) && !TooManyLeaves) {          
            SPSVnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSVnode* chosenLargest;
            // find if there are any more equal to largest around
            multiset<SPSVnode*, MyCompare>::iterator mit;
            pair<multiset<SPSVnode*, MyCompare>::iterator,
                multiset<SPSVnode*, MyCompare>::iterator> equalLargest;
            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {
                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {
                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }
            else {
                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSVnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }
            // split the biggest one and divide up its training and validation 
            // data
            ExpandWithValid(chosenLargest, boolVal);
           
            cout << "---------split " << coll.getNumberCollated()-1 << endl;
                           
            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

        // remove empty boxes AND
        // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed
            if ( ((chosenLargest->getLeftChild())->getCounter() > 0) 
            && (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new left child into the multiset
                //cout << (chosenLargest->getLeftChild())->getCounter()  <<
       endl;
                pq.insert(chosenLargest->getLeftChild());
            }

            if ( ((chosenLargest->getRightChild())->getCounter() > 0) 
            && (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new right child into the multiset
               //cout << (chosenLargest->getRightChild())->getCounter()  <<
       endl;
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file               
          
                i++;
            }

          //==========get IAE for this histogram======================//
         
        //cout << "get IAE for histogram " << coll.getNumberCollated() << endl;
        real IAE = getUnifIAE(myPart, weight, holesLoc, 0);
        minIAE = (IAE < minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF = getUnifIAE(myPart, weight, holesLoc, 1);
        vecIAEFull.push_back(IAEF); 

        // keep this histogram in a container 
        tempHist.push_back(*this);
        
        //cout << "add into collator" << endl;
        // add current histogram to collation
        size_t agg = 0;
        coll.addToCollationWithVal(*this, 1, agg);
          
        //cout << "get the split node" << endl;
        // first we need a pointer to the corresponding CollatorSPVnode 
        // of the SPSVnode* chosenLargest     
        CollatorSPVnode * splitCollNode;
        coll.getSplitNodePtr(splitCollNode, chosenLargest);
        //cout << chosenLargest->getNodeName() << "\t" <<
       splitCollNode->getNodeName() << endl;
        
        //cout << "get the yat class" << endl;
        // get the Yatracos class for this collation
        coll.getYatracosClassAll(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        //cout << "get delta theta" << endl;
        // get delta_theta for each theta
        coll.getYatracosDelta(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        // get the true delta
        real trueDelta = 0.0;
        vector< set<CollatorSPVnode*, less < CollatorSPVnode* > > >::iterator 
      listIt;   
        //cout << "Current Yatracos set has " << (*tempList).size() << "
       nodes." << endl;
        for (listIt = (vecRowYatSet).begin(); listIt < vecRowYatSet.end(); 
      listIt++) {
          if ( !(*listIt).empty() ) {
            real trueDeltaR = getUnifTrueDelta(myPart, weight, holesLoc, (*
      listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        for (listIt = (vecColYatSet).begin(); listIt < vecColYatSet.end(); 
      listIt++) {
          if ( !(*listIt).empty() ) {
            real trueDeltaR = getUnifTrueDelta(myPart, weight, holesLoc, (*
      listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        
        if ( vecRowYatSet.empty() && vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
        //check theorem 10.1
        //if ( trueDelta >= 0 ) { assert(IAE <= (3*minIAE + 4*trueDelta)); }

        //stopping criteria
        if (stopCrit == true) {
          //cout << "checking stopping criteria: " << endl;
          bool toStop = coll.getMinDelta(maxCheck, vecMaxDeltaVec);
          if (toStop == true) {
            cout << "Stopping criteria met." << endl;
            break;
          } 
        }
        


        //==========checks to see if need to split again=========//
            //checking if there are any more 'largest' nodes in the priority
       queue
            bigEnough = (!pq.empty());
            if (!bigEnough){    
          std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
            }
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      } // end of while loop
      //cout << "===========End of splitting=============" << endl;
        
      //do the merging here based on vecMinDistTheta
         
      //================Outputs to .txt files=================== 
      ofstream os;         // ofstream object
      os << scientific;  // set formatting for input to oss
      os.precision(5);

       // get the minimum delta to get the MDE histogram
      vector< vector<double> >::iterator it1; 
      vector<double>::iterator it2;
      int Theta=0;
      //cout << "MaxDelta" << endl;
      size_t F = vecMaxDeltaVec.size(); 
      double minDelta = 1000;
      int minTheta = 0;
      for (size_t i = 0; i < F; i++){
        //cout << "Theta: " << Theta << "\t" << vecMaxDeltaVec[F-1][i] << endl;
        if ( vecMaxDeltaVec[F-1][i] < minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout << "MDE at " << minTheta << " with IAE " << vecIAE[minTheta] << endl
      ; 
         optHist = tempHist[minTheta];

      // output vecDeltaMaxVec into .txt 
      ostringstream stm1, stm2;
      stm1 << hist;
      stm2 << method;
      string fileNameDelta = "UnifMethod";
      fileNameDelta += stm2.str();
      fileNameDelta += "DeltaMax";
      fileNameDelta += stm1.str();
      fileNameDelta += ".txt";  
      os.open(fileNameDelta.c_str());
      for (it1 = vecMaxDeltaVec.begin(); it1 < vecMaxDeltaVec.end(); it1++){ 
        for (it2 = (*it1).begin(); it2 < (*it1).end(); it2++){
          os << (*it2) << "\t";
        }
        os << "\n";
      }          
      os << flush;
      os.close();
      std::cout << "DeltaMax for each theta output to " << fileNameDelta << "."
       << endl;
      //----------------end of output for vecDeltaMaxVec-------------
 
         //output vecIAE to .txt file
      string outputFileName;// for output file
      outputFileName = "UnifMethod";
      outputFileName += stm2.str();
      outputFileName += "IAEandTrueDelta";
      outputFileName += stm1.str();
      outputFileName += ".txt";
      os.open(outputFileName.c_str());
      for (size_t i = 0; i < vecIAE.size(); i++){
        os << vecIAE[i] << "\t" << vecIAEFull[i] << "\t" << TrueDelta[i] << 
      endl;
      }
      os << flush;
      os.close();
      std::cout << "IAE output to " << outputFileName << endl;
      //=================end of output for vecIAE---------------------------      
   } // end of try
    
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority stage split.  Orginal error: " + oldmsg
      ;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    
   return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a8f39563ed08722fbe6be55474681abd5}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}}
\index{priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate\-With\-Switch}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate\-With\-Switch} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Fin\-Mix} \&}]{mixt, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{double}]{tol, }
\item[{int}]{deg, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opthist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a8f39563ed08722fbe6be55474681abd5}


\-Definition at line 1317 of file adaptivehistogramvalidation.\-cpp.



\-References priority\-Split\-And\-Estimate\-With\-Switch(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    gsl_rng * rgsl = NULL;
    bool cancontinue;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        // call the function with a random number generator
        cancontinue = prioritySplitAndEstimateWithSwitch(compTest, he, logging,
       minChildPoints, 
                        minVolB, rgsl, stopCrit, mixt, method, hist,
                        maxLeafNodes, maxCheck, tol, deg, optHist);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority stage split.  Orginal
       error: "
                                     + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority stage split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
   
   return cancontinue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a6bd25ba3a874dee64a2fd93984542f39}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}}
\index{priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate\-With\-Switch}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate\-With\-Switch} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Fin\-Mix} \&}]{mixt, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{double}]{tol, }
\item[{int}]{deg, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opthist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a6bd25ba3a874dee64a2fd93984542f39}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 1387 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::add\-To\-Collation\-With\-Val(), check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand\-With\-Valid(), \-F(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), get\-Fin\-Mix\-Interval\-I\-A\-E(), get\-Fin\-Mix\-Interval\-True\-Delta(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaves(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Left\-Child(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Min\-Delta(), get\-Min\-Vol(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Number\-Collated(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Split\-Node\-Ptr(), get\-Sub\-Paving(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Class\-All(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Delta(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, output\-Log\-Start(), root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
{
    //cout << "calling prioritySplitAndEstimate:" << endl;
   bool cancontinue = false;
   bool TooManyLeaves = false;
   
    //boolean for validation data
    bool boolVal = true;
    
    // for stopping criteria
    size_t flagStop = 0;
    int currentSmallest = 0;
    
    int n = getSubPaving()->getCounter();
    
    //set up collator to keep the histograms as splits happen
    AdaptiveHistogramVCollator coll;
    
   //=======initializing containers======================================
  //set up a list for the Yatracos set 
  list< set<CollatorSPVnode*, less<CollatorSPVnode*> > > listYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (row)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecRowYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (col)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecColYatSet;    
  //set up a vector for maximum Delta_theta vectors
  vector< vector<double> > vecMaxDeltaVec;
  //initializing the vector - to allow the delta vector to be in 
  // right order  since the first histogram does not have a 
  // Yatracos set
  //the first element in this vector will not be plotted since 
  // the first histogram is an empty set
  vector<double> theta0;
  theta0.push_back(-1*(numeric_limits<double>::infinity())); 
  //the supremum of an empty set is -Infimum 
  vecMaxDeltaVec.push_back(theta0);
  //set up a vector of the corresponding theta with the minimum 
  // distance estimates
  vector< vector<int> > vecMinDistTheta;
  // set up a vector for the infimum 
  vector<double> vecInfDelta;
  // set up a vector for the integrated absolute error for each histogram
   vector<real> vecIAE; 
   vector<real> vecIAEFull;
   real minIAE = 1000.00;
   
   vector<real> TrueDelta;
   TrueDelta.push_back(-1); 

  real trueDeltaCurrent = 0;
  
   // to keep the histograms
   vector<AdaptiveHistogramValidation> tempHist;
   //==============end of initializing
       containers=============================//   
   // check if the root box is empty
    if (NULL == rootVpaving) {
            throw HistException("No root paving for prioritySplit");
    }
    try {       
        // add the histogram before any split happens into the collator
        size_t agg = 0;
      coll.addToCollationWithVal(*this, 1, agg);
      tempHist.push_back(*this);
      // calculate the IAE 
      real IAE = mid(getFinMixIntervalIAE(mixt, tol, deg, 0));
      // push back into vecIAE 
      vecIAE.push_back(IAE);
      minIAE = (IAE < minIAE) ? IAE : minIAE;
      
      //get the IAE for the full data set
      real IAEF = mid(getFinMixIntervalIAE(mixt, tol, deg, 1));
      // push back into vecIAE 
      vecIAEFull.push_back(IAEF);

    //============checks  for splittable nodes=============================//
        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        //logging
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }
        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
            volChecking = true;
        }
      // a multiset for the queue (key values are not necessarily unique)
      multiset<SPSVnode*, MyCompare> pq((MyCompare(compTest)));
      int i=0;
      if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);    
            i++;
      }
      // put nodes into the starting set IF they meet minVol test AND IF either
      // there are enough points in the whole node
      // and minChildCountIfSplit is 0 (ie all points go to one child)
      // or the minChildCountIfSplit test passed
        if (rootVpaving->isLeaf()) {
            // check to insert a copy of the rootVpaving pointer into the set
           if (checkNodeCountForSplit(rootVpaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootVpaving);
            }
        }
        else { // root is not a leaf
            SPSVnodePtrs leaves;
            rootVpaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSVnodePtrsItr sit;            
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        bool bigEnough = cancontinue;
        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }        
        //==================end of
       checks=====================================//
  
        //=========start priority queue====================================//
        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out   
      while (bigEnough && !he(this) && !TooManyLeaves) {          
            SPSVnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSVnode* chosenLargest;
            // find if there are any more equal to largest around
            multiset<SPSVnode*, MyCompare>::iterator mit;
            pair<multiset<SPSVnode*, MyCompare>::iterator,
                multiset<SPSVnode*, MyCompare>::iterator> equalLargest;
            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {
                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {
                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }
            else {
                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSVnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }
            // split the biggest one and divide up its training and validation 
            // data
            ExpandWithValid(chosenLargest, boolVal);
           
            cout << "---------split " << coll.getNumberCollated()-1 << endl;
                           
            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

        // remove empty boxes AND
        // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed
            if ( ((chosenLargest->getLeftChild())->getCounter() > 0) 
            && (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new left child into the multiset
                //cout << (chosenLargest->getLeftChild())->getCounter()  <<
       endl;
                pq.insert(chosenLargest->getLeftChild());
            }

            if ( ((chosenLargest->getRightChild())->getCounter() > 0) 
            && (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new right child into the multiset
               //cout << (chosenLargest->getRightChild())->getCounter()  <<
       endl;
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file               
          
                i++;
            }

          //==========get IAE for this histogram======================//
         
        //cout << "get IAE for histogram " << coll.getNumberCollated() << endl;
        real IAE = mid(getFinMixIntervalIAE(mixt, tol, deg, 0));
        minIAE = (IAE < minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF = mid(getFinMixIntervalIAE(mixt, tol, deg, 1));
        vecIAEFull.push_back(IAEF); 

        // keep this histogram in a container 
        tempHist.push_back(*this);
        
        //cout << "add into collator" << endl;
        // add current histogram to collation
        size_t agg = 0;
        coll.addToCollationWithVal(*this, 1, agg);
          
        //cout << "get the split node" << endl;
        // first we need a pointer to the corresponding CollatorSPVnode 
        // of the SPSVnode* chosenLargest     
        CollatorSPVnode * splitCollNode;
        coll.getSplitNodePtr(splitCollNode, chosenLargest);
        //cout << chosenLargest->getNodeName() << "\t" <<
       splitCollNode->getNodeName() << endl;
        
        //cout << "get the yat class" << endl;
        // get the Yatracos class for this collation
        coll.getYatracosClassAll(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        //cout << "get delta theta" << endl;
        // get delta_theta for each theta
        coll.getYatracosDelta(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        // get the true delta
        real trueDelta = 0.0;
        vector< set<CollatorSPVnode*, less < CollatorSPVnode* > > >::iterator 
      listIt;   
        //cout << "Current Yatracos set has " << (*tempList).size() << "
       nodes." << endl;
        for (listIt = (vecRowYatSet).begin(); listIt < vecRowYatSet.end(); 
      listIt++) {
          if ( !((*listIt).empty()) ) {
            interval trueDeltaI = getFinMixIntervalTrueDelta(mixt, tol, deg, (*
      listIt));
            real trueDeltaR = mid(trueDeltaI);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        
        for (listIt = (vecColYatSet).begin(); listIt < vecColYatSet.end(); 
      listIt++) {
          if ( !((*listIt).empty()) ) {
            interval trueDeltaI = getFinMixIntervalTrueDelta(mixt, tol, deg, (*
      listIt));
            real trueDeltaR = mid(trueDeltaI);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        
        
        if ( vecRowYatSet.empty() && vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
      //check theorem 10.1
      if ( trueDelta >= 0) {  assert(IAE <= (3*minIAE + 4*trueDelta)); }

        //stopping criteria
        if (stopCrit == true) {
          //cout << "checking stopping criteria: " << endl;
          bool toStop = coll.getMinDelta(maxCheck, vecMaxDeltaVec);
          if (toStop == true) {
            cout << "Stopping criteria met." << endl;
            break;
          } 
        }

        //==========checks to see if need to split again=========//
            //checking if there are any more 'largest' nodes in the priority
       queue
            bigEnough = (!pq.empty());
            if (!bigEnough){    
          std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
            }
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      } // end of while loop
      //cout << "===========End of splitting=============" << endl;
        
      //do the merging here based on vecMinDistTheta
         
      //================Outputs to .txt files=================== 
      ofstream os;         // ofstream object
      os << scientific;  // set formatting for input to oss
      os.precision(5);

       // get the minimum delta to get the MDE histogram
      vector< vector<double> >::iterator it1; 
      vector<double>::iterator it2;
      int Theta=0;
      //cout << "MaxDelta" << endl;
      size_t F = vecMaxDeltaVec.size(); 
      double minDelta = 1000;
      int minTheta = 0;
      for (size_t i = 0; i < F; i++){
        //cout << "Theta: " << Theta << "\t" << vecMaxDeltaVec[F-1][i] << endl;
        if ( vecMaxDeltaVec[F-1][i] < minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout << "MDE at " << minTheta << " with IAE " << vecIAE[minTheta] << endl
      ; 
         optHist = tempHist[minTheta];

      // output vecDeltaMaxVec into .txt 
      ostringstream stm1, stm2;
      stm1 << hist;
      stm2 << method;
      string fileNameDelta = "FinMixMethod";
      fileNameDelta += stm2.str();
      fileNameDelta += "DeltaMax";
      fileNameDelta += stm1.str();
      fileNameDelta += ".txt";  
      os.open(fileNameDelta.c_str());
      for (it1 = vecMaxDeltaVec.begin(); it1 < vecMaxDeltaVec.end(); it1++){ 
        for (it2 = (*it1).begin(); it2 < (*it1).end(); it2++){
          os << (*it2) << "\t";
        }
        os << "\n";
      }          
      os << flush;
      os.close();
      std::cout << "DeltaMax for each theta output to " << fileNameDelta << "."
       << endl;
      //----------------end of output for vecDeltaMaxVec-------------
 
         //output vecIAE to .txt file
      string outputFileName;// for output file
      outputFileName = "FinMixMethod";
      outputFileName += stm2.str();
      outputFileName += "IAEandTrueDelta";
      outputFileName += stm1.str();
      outputFileName += ".txt";
      os.open(outputFileName.c_str());
      for (size_t i = 0; i < vecIAE.size(); i++){
        os << vecIAE[i] << "\t" << vecIAEFull[i] << "\t" << TrueDelta[i] << 
      endl;
      }
      os << flush;
      os.close();
      std::cout << "IAE output to " << outputFileName << endl;
      //=================end of output for vecIAE---------------------------      
   } // end of try
    
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority stage split.  Orginal error: " + oldmsg
      ;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    
   return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ae20e1507aad418b0d5aee31882b738ea}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}}
\index{priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate\-With\-Switch}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate\-With\-Switch} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Real\-Mapped\-S\-Pnode} \&}]{node\-Est, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opt\-Hist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ae20e1507aad418b0d5aee31882b738ea}


\-Definition at line 1777 of file adaptivehistogramvalidation.\-cpp.



\-References priority\-Split\-And\-Estimate\-With\-Switch(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    gsl_rng * rgsl = NULL;
    bool cancontinue;

    try {
        // set up a random number generator for uniform rvs
        const gsl_rng_type * tgsl;
        // set the library variables *gsl_rng_default and
        // gsl_rng_default_seed to default environmental vars
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; // make tgsl the default type
        rgsl = gsl_rng_alloc (tgsl); // set up with default seed

        // call the function with a random number generator
        cancontinue = prioritySplitAndEstimateWithSwitch(compTest, he, logging,
       minChildPoints, 
                        minVolB, rgsl, stopCrit, nodeEst, method, hist,
                        maxLeafNodes, maxCheck, optHist);
        gsl_rng_free (rgsl);
    }

    catch (bad_alloc& ba) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(ba.what());
        string msg = "Error allocating memory in priority stage split.  Orginal
       error: "
                                     + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "HistException error in priority stage split.  Orginal
       error: "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        if (NULL != rgsl) gsl_rng_free(rgsl); // free the random number
       generator
        string oldmsg(e.what());
        string msg = "Error in priority split.  Orginal error: " + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
   
   return cancontinue;
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_ad3f8cf7cf11ce1214abd2559bea54393}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}}
\index{priority\-Split\-And\-Estimate\-With\-Switch@{priority\-Split\-And\-Estimate\-With\-Switch}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{priority\-Split\-And\-Estimate\-With\-Switch}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::priority\-Split\-And\-Estimate\-With\-Switch} (
\begin{DoxyParamCaption}
\item[{const {\bf \-Node\-Comp\-Obj\-Val} \&}]{comp\-Test, }
\item[{const {\bf \-Hist\-Eval\-Obj\-Val} \&}]{he, }
\item[{{\bf \-L\-O\-G\-G\-I\-N\-G\-\_\-\-L\-E\-V\-E\-L}}]{logging, }
\item[{size\-\_\-t}]{min\-Child\-Points, }
\item[{double}]{min\-Vol\-B, }
\item[{gsl\-\_\-rng $\ast$}]{rgsl, }
\item[{bool}]{stop\-Crit, }
\item[{{\bf \-Real\-Mapped\-S\-Pnode} \&}]{node\-Est, }
\item[{int}]{method, }
\item[{size\-\_\-t}]{hist, }
\item[{size\-\_\-t}]{max\-Leaf\-Nodes, }
\item[{int}]{max\-Check, }
\item[{{\bf \-Adaptive\-Histogram\-Validation} \&}]{opt\-Hist}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_ad3f8cf7cf11ce1214abd2559bea54393}
\-With random number generator. \-All other parameters supplied. 

\-Definition at line 1847 of file adaptivehistogramvalidation.\-cpp.



\-References subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::add\-To\-Collation\-With\-Val(), check\-Node\-Count\-For\-Split(), creation\-String, subpavings\-::\-Expand\-With\-Valid(), \-F(), subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-P\-Snode\-::get\-Counter(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Leaves(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Left\-Child(), get\-Mapped\-Function\-True\-Delta(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Min\-Delta(), get\-Min\-Vol(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Number\-Collated(), subpavings\-::\-S\-P\-S\-Vnode\-::get\-Right\-Child(), get\-Root\-Leaves(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Split\-Node\-Ptr(), get\-Sub\-Paving(), subpavings\-::get\-Unique\-Filename(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Class\-All(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::get\-Yatracos\-Delta(), subpavings\-::\-S\-Pnode\-::is\-Leaf(), subpavings\-::\-N\-O\-L\-O\-G, output\-Log\-Start(), subpavings\-::\-Adaptive\-Histogram\-V\-Collator\-::output\-To\-Txt\-Tabs(), root\-Vpaving, and subpavings\-::\-S\-Pnode\-Exception\-::what().


\begin{DoxyCode}
{
    //cout << "calling prioritySplitAndEstimate:" << endl;
   bool cancontinue = false;
   bool TooManyLeaves = false;
   
    //boolean for validation data
    bool boolVal = true;
    
    // for stopping criteria
    size_t flagStop = 0;
    int currentSmallest = 0;
    
    int n = getSubPaving()->getCounter();
    
    //set up collator to keep the histograms as splits happen
    AdaptiveHistogramVCollator coll;
    
   //=======initializing containers======================================
  //set up a list for the Yatracos set 
  list< set<CollatorSPVnode*, less<CollatorSPVnode*> > > listYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (row)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecRowYatSet;
  //set up a vector for sets of pointers to CollatorSPVnode (col)
  vector< set<CollatorSPVnode*, less<CollatorSPVnode*> > > vecColYatSet;    
  //set up a vector for maximum Delta_theta vectors
  vector< vector<double> > vecMaxDeltaVec;
  //initializing the vector - to allow the delta vector to be in 
  // right order  since the first histogram does not have a 
  // Yatracos set
  //the first element in this vector will not be plotted since 
  // the first histogram is an empty set
  vector<double> theta0;
  theta0.push_back(-1*(numeric_limits<double>::infinity())); 
  //the supremum of an empty set is -Infimum 
  vecMaxDeltaVec.push_back(theta0);
  //set up a vector of the corresponding theta with the minimum 
  // distance estimates
  vector< vector<int> > vecMinDistTheta;
  // set up a vector for the infimum 
  vector<double> vecInfDelta;
  // set up a vector for the integrated absolute error for each histogram
   vector<real> vecIAE; 
   vector<real> vecIAEFull;
   real minIAE = 1000.00;
   
   vector<real> TrueDelta;
   TrueDelta.push_back(-1); 

  real trueDeltaCurrent = 0;
  
   // to keep the histograms
   vector<AdaptiveHistogramValidation> tempHist;
   //==============end of initializing
       containers=============================//   
   // check if the root box is empty
    if (NULL == rootVpaving) {
            throw HistException("No root paving for prioritySplit");
    }
    try {       
        // add the histogram before any split happens into the collator
        size_t agg = 0;
      coll.addToCollationWithVal(*this, 1, agg);
      tempHist.push_back(*this);
      // calculate the IAE 
      real IAE = 0.0;
      //real IAE = getMappedFunctionIAE(nodeEst, 0);
      // push back into vecIAE 
      vecIAE.push_back(IAE);
      minIAE = (IAE < minIAE) ? IAE : minIAE;
      
      //get the IAE for the full data set
      //real IAEF =getMappedFunctionIAE(nodeEst, 0);
      // push back into vecIAE 
      real IAEF = 0.0;
      vecIAEFull.push_back(IAEF);

    //============checks  for splittable nodes=============================//
        bool volChecking = false; // record if we need to check volume before
       split
        double minVol = -1.0; // minimum volume (used only if checking)
        //logging
        std::string baseFileName = "";
        std::string s = "";
        if (logging != NOLOG) {
            // pass to log output to keep track of splits
            baseFileName = "pqOutput";
            s = getUniqueFilename(baseFileName);
        }
        // make volChecking true if minVolB is > 0.0
        if (minVolB > 0.0) {
            // minimum volume of a splittable node is minVolB(log n)^2/n
            minVol = getMinVol(minVolB);
            volChecking = true;
        }
      // a multiset for the queue (key values are not necessarily unique)
      multiset<SPSVnode*, MyCompare> pq((MyCompare(compTest)));
      int i=0;
      if (logging != NOLOG) {
             // Start log file with filename and timestamp
            outputLogStart(s);    
            i++;
      }
      // put nodes into the starting set IF they meet minVol test AND IF either
      // there are enough points in the whole node
      // and minChildCountIfSplit is 0 (ie all points go to one child)
      // or the minChildCountIfSplit test passed
        if (rootVpaving->isLeaf()) {
            // check to insert a copy of the rootVpaving pointer into the set
           if (checkNodeCountForSplit(rootVpaving, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(rootVpaving);
            }
        }
        else { // root is not a leaf
            SPSVnodePtrs leaves;
            rootVpaving->getLeaves(leaves);
            // check to insert each of the leaves into the set
            SPSVnodePtrsItr sit;            
            for (sit = leaves.begin(); sit < leaves.end(); sit++) {
                if (checkNodeCountForSplit((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        bool bigEnough = cancontinue;
        if(!cancontinue) {
            std::cout << "No splittable leaves to split - aborting" << 
      std::endl;
        }        
        //==================end of
       checks=====================================//
  
        //=========start priority queue====================================//
        // split until the HistEvalObj he () operator returns true
        // we only put splittable nodes into the set, so we don't have to check
        // that they are splittable when we take them out   
      while (bigEnough && !he(this) && !TooManyLeaves) {          
            SPSVnode* largest = *(pq.rbegin ()); // the last largest in the set
            SPSVnode* chosenLargest;
            // find if there are any more equal to largest around
            multiset<SPSVnode*, MyCompare>::iterator mit;
            pair<multiset<SPSVnode*, MyCompare>::iterator,
                multiset<SPSVnode*, MyCompare>::iterator> equalLargest;
            equalLargest = pq.equal_range(largest); // everything that =
       largest
            size_t numberLargest = pq.count(largest); // number of =largest

            if (numberLargest > 1) {
                // draw a random number in [0,1)
                double rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                // random selection of the =largest node to chose
                for (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    if (rand < sum) {
                        break;
                    }
                }
                chosenLargest = *(mit); // the chosen largest in the set
                pq.erase(mit);// take the iterator to chosen largest out of the
       set
            }
            else {
                chosenLargest = *(pq.rbegin ()); // the only largest
                multiset<SPSVnode*, MyCompare>::iterator it = pq.end();
                it--;
                pq.erase(it);// take this largest out of the set
            }
            // split the biggest one and divide up its training and validation 
            // data
            ExpandWithValid(chosenLargest, boolVal);
           
            cout << "---------split " << coll.getNumberCollated()-1 << endl;
                           
            // add the new child names to the creation string
            creationString += chosenLargest->getChildNodeNames();

        // remove empty boxes AND
        // but only put the children into the container if they can be
            // split, which means IF the child meets the min vol test AND IF
            // either there are enough points in the whole child and
                // the child's minChildCountIfSplit is 0 (ie all points go to
                // one child of the child)
            // or the child's minChildCountIfSplit test is passed
            if ( ((chosenLargest->getLeftChild())->getCounter() > 0) 
            && (checkNodeCountForSplit(chosenLargest->getLeftChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new left child into the multiset
                //cout << (chosenLargest->getLeftChild())->getCounter()  <<
       endl;
                pq.insert(chosenLargest->getLeftChild());
            }

            if ( ((chosenLargest->getRightChild())->getCounter() > 0) 
            && (checkNodeCountForSplit(chosenLargest->getRightChild(),
                    volChecking, minVol, minChildPoints)) ) {
                // insert the new right child into the multiset
               //cout << (chosenLargest->getRightChild())->getCounter()  <<
       endl;
                pq.insert(chosenLargest->getRightChild());
            }

            if (logging != NOLOG) {
                // To add current state of histogram to log file               
          
                i++;
            }

          //==========get IAE for this histogram======================//
         
        //cout << "get IAE for histogram: \t";
        real IAE = 0.0;
        //real IAE = getMappedFunctionIAE(nodeEst, 0);
        minIAE = (IAE < minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        //cout << IAE << endl;
        
        real IAEF = 0.0;
        //real IAEF = getMappedFunctionIAE(nodeEst, 1);
        vecIAEFull.push_back(IAEF); 

        // keep this histogram in a container 
        tempHist.push_back(*this);
        
        //cout << "add into collator" << endl;
        // add current histogram to collation
        size_t agg = 0;
        coll.addToCollationWithVal(*this, 1, agg);
          
        //cout << "get the split node" << endl;
        // first we need a pointer to the corresponding CollatorSPVnode 
        // of the SPSVnode* chosenLargest     
        CollatorSPVnode * splitCollNode;
        coll.getSplitNodePtr(splitCollNode, chosenLargest);
        //cout << chosenLargest->getNodeName() << "\t" <<
       splitCollNode->getNodeName() << endl;
        
        //cout << "get the yat class" << endl;
        // get the Yatracos class for this collation
        coll.getYatracosClassAll(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        //cout << "get delta theta" << endl;
        // get delta_theta for each theta
        coll.getYatracosDelta(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        // get the true delta
        real trueDelta = 0.0;
        vector< set<CollatorSPVnode*, less < CollatorSPVnode* > > >::iterator 
      listIt;   
        //cout << "Current Yatracos set has " << (*tempList).size() << "
       nodes." << endl;
        for (listIt = (vecRowYatSet).begin(); listIt < vecRowYatSet.end(); 
      listIt++) {
          if ( !(*listIt).empty() ) {
            real trueDeltaR = getMappedFunctionTrueDelta(nodeEst, *listIt);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        for (listIt = (vecColYatSet).begin(); listIt < vecColYatSet.end(); 
      listIt++) {
          if ( !(*listIt).empty() ) {
            real trueDeltaR = getMappedFunctionTrueDelta(nodeEst, *listIt);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR > trueDelta) ? trueDeltaR : trueDelta;
            //cout << "previous: " << trueDeltaCurrent << "\t current: " <<
       trueDelta << endl;
            trueDelta = (trueDeltaCurrent > trueDelta) ? trueDeltaCurrent : 
      trueDelta;
            //cout << "delta after comparison: " << trueDelta << endl;
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        if ( vecRowYatSet.empty() && vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
        //check theorem 10.1
        //cout << "checking theorem 10.1" << endl;
        //cout << IAE << "\t" << minIAE << "\t" << trueDelta << endl;
        if ( trueDelta >= 0 ) { assert(IAE <= (3*minIAE + 4*trueDelta)); }

        //stopping criteria
        if (stopCrit == true) {
          //cout << "checking stopping criteria: " << endl;
          bool toStop = coll.getMinDelta(maxCheck, vecMaxDeltaVec);
          if (toStop == true) {
            cout << "Stopping criteria met." << endl;
            break;
          } 
        }

        //==========checks to see if need to split again=========//
            //checking if there are any more 'largest' nodes in the priority
       queue
            bigEnough = (!pq.empty());
            if (!bigEnough){    
          std::cout << "Terminated splitting: no splittable nodes left"
                    << std::endl;
            }
        // check if number of leaf nodes in subpaving > maxLeafNodes
        // maximum number of leaf nodes allowed
        //n^B, A+B > 1, 0  < A < 1, 0 < B < 1 - refer Prop. 1 in PQ paper
        TooManyLeaves = (getRootLeaves() > maxLeafNodes);
        if ( TooManyLeaves) {
          std::cout << "Terminated splitting: maximum number of leaf nodes = "<
      < maxLeafNodes << " reached"
                          << std::endl;
        }
      } // end of while loop
      //cout << "===========End of splitting=============" << endl;
        
      //do the merging here based on vecMinDistTheta
         
      //================Outputs to .txt files=================== 
      
      coll.outputToTxtTabs("CollFromMDEPQ.txt");
      
      ofstream os;         // ofstream object
      os << scientific;  // set formatting for input to oss
      os.precision(5);

       // get the minimum delta to get the MDE histogram
      vector< vector<double> >::iterator it1; 
      vector<double>::iterator it2;
      int Theta=0;
      //cout << "MaxDelta" << endl;
      size_t F = vecMaxDeltaVec.size(); 
      double minDelta = 1000;
      int minTheta = 0;
      for (size_t i = 0; i < F; i++){
        //cout << "Theta: " << Theta << "\t" << vecMaxDeltaVec[F-1][i] << endl;
        if ( vecMaxDeltaVec[F-1][i] < minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout << "MDE at " << minTheta << " with IAE " << vecIAE[minTheta] << endl
      ; 
         optHist = tempHist[minTheta];

      // output vecDeltaMaxVec into .txt 
      ostringstream stm1, stm2;
      stm1 << hist;
      stm2 << method;
      string fileNameDelta = "MappedFunctionMethod";
      fileNameDelta += stm2.str();
      fileNameDelta += "DeltaMax";
      fileNameDelta += stm1.str();
      fileNameDelta += ".txt";  
      os.open(fileNameDelta.c_str());
      for (it1 = vecMaxDeltaVec.begin(); it1 < vecMaxDeltaVec.end(); it1++){ 
        for (it2 = (*it1).begin(); it2 < (*it1).end(); it2++){
          os << (*it2) << "\t";
        }
        os << "\n";
      }          
      os << flush;
      os.close();
      std::cout << "DeltaMax for each theta output to " << fileNameDelta << "."
       << endl;
      //----------------end of output for vecDeltaMaxVec-------------
 
         //output vecIAE to .txt file
      string outputFileName;// for output file
      outputFileName = "MappedFunctionMethod";
      outputFileName += stm2.str();
      outputFileName += "IAEandTrueDelta";
      outputFileName += stm1.str();
      outputFileName += ".txt";
      os.open(outputFileName.c_str());
      for (size_t i = 0; i < vecIAE.size(); i++){
        os << vecIAE[i] << "\t" << vecIAEFull[i] << "\t" << TrueDelta[i] << 
      endl;
      }
      os << flush;
      os.close();
      std::cout << "IAE output to " << outputFileName << endl;
      //=================end of output for vecIAE---------------------------      
   } // end of try
    
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in priority stage split.  Orginal error: 
      "
                                    + oldmsg;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in priority stage split.  Orginal error: " + oldmsg
      ;
        std::cout << msg << std::endl;
        throw HistException(msg);
    }
    
   return (cancontinue);
}
\end{DoxyCode}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a7498bdc1663c857052e5bc147bf086f7}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!split\-To\-Shape@{split\-To\-Shape}}
\index{split\-To\-Shape@{split\-To\-Shape}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{split\-To\-Shape}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf \-Adaptive\-Histogram\-Validation\-::split\-To\-Shape} (
\begin{DoxyParamCaption}
\item[{std\-::string}]{instruction}
\end{DoxyParamCaption}
)}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a7498bdc1663c857052e5bc147bf086f7}


\-Split a histogram to a specified shape. 


\begin{DoxyParams}{\-Parameters}
{\em instruction} & specifies the required shape, eg \char`\"{}3, 3. 2, 1\char`\"{} \\
\hline
\end{DoxyParams}


\-Definition at line 3255 of file adaptivehistogramvalidation.\-cpp.



\-References creation\-String, subpavings\-::\-S\-Pnode\-::get\-Child\-Node\-Names(), subpavings\-::\-S\-Pnode\-::get\-Node\-Name(), root\-Vpaving, subpavings\-::\-S\-Pnode\-::split\-Root\-To\-Shape(), subpavings\-::\-S\-Pnode\-Exception\-::what(), and subpavings\-::\-Hist\-Exception\-::what().


\begin{DoxyCode}
{
    bool success = false;

    // checks:  is there a root paving, is the string properly formed?
    if (NULL == rootVpaving) {
        throw HistException("No root paving for splitToShape");
    }

    if (instruction.length() == 0) {
      throw HistException("No instruction");
    }

    std::string legal(", 0123456789");
    if (instruction.find_first_not_of(legal) != std::string::npos) {
        throw HistException("Illegal character in instruction");
    }

    try { // all seems to be okay, we can start spliting the root paving
        // specify what to look for as numbers or decimal point or + or -

       success = rootVpaving->splitRootToShape(instruction);

        if (success) {
            // update the creation string
            creationString = rootVpaving->getNodeName()
                + rootVpaving->getChildNodeNames();
        }
        else {
            std::cerr << std::endl;
            std::cerr << "Your instruction does not describe a proper tree.";
            std::cerr << "  Please check your instruction and try again."
            << std::endl;
       }
    }

    catch (bad_alloc& ba) {
        string oldmsg(ba.what());
        string msg = "Error allocating memory in splitToShape.  Orginal error: 
      "
                                            + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (HistException& e) {
        string oldmsg(e.what());
        string msg = "HistException error in splitToShape.  Orginal error: "
                                    + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (SPnodeException& spe) {
        string oldmsg(spe.what());
        string msg = "SPnodeException in splitToShape.  Orginal error: " + 
      oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }
    catch (exception& e) {
        string oldmsg(e.what());
        string msg = "Error in splitToShape.  Orginal error: " + oldmsg;
        std::cerr << msg << std::endl;
        throw HistException(msg);
    }

    return success;
}
\end{DoxyCode}


\subsubsection{\-Member \-Data \-Documentation}
\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a7d46cc6c04481f9579e9f5238ccea8b2}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!creation\-String@{creation\-String}}
\index{creation\-String@{creation\-String}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{creation\-String}]{\setlength{\rightskip}{0pt plus 5cm}std\-::string {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::creation\-String}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a7d46cc6c04481f9579e9f5238ccea8b2}


\-A string showing the order of creation of the root\-Paving. 



\-Definition at line 119 of file adaptivehistogramvalidation.\-hpp.



\-Referenced by \-Adaptive\-Histogram\-Validation(), have\-Made\-Paving(), insert\-Data\-From\-Container(), operator=(), priority\-Split\-And\-Estimate(), priority\-Split\-And\-Estimate\-With\-Switch(), and split\-To\-Shape().

\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_acae18e51a5026807492d2109702c3c93}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!data\-Collection@{data\-Collection}}
\index{data\-Collection@{data\-Collection}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{data\-Collection}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-Big\-Data\-Collection} {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::data\-Collection}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_acae18e51a5026807492d2109702c3c93}


\-A container for all sample data passed to this. 

\-The sample that has come in thus far. 

\-Definition at line 110 of file adaptivehistogramvalidation.\-hpp.



\-Referenced by \-Adaptive\-Histogram\-Validation(), insert\-Data\-From\-Container(), and operator=().

\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a4de24d08db784df2fdb619ba2c1f62fd}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!hold\-All\-Stats@{hold\-All\-Stats}}
\index{hold\-All\-Stats@{hold\-All\-Stats}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{hold\-All\-Stats}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::hold\-All\-Stats}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a4de24d08db784df2fdb619ba2c1f62fd}


\-Controls whether all available statistics are maintained in the root\-Paving. \-If set to false (default) only counts are maintained. 



\-Definition at line 115 of file adaptivehistogramvalidation.\-hpp.



\-Referenced by get\-Hold\-All\-Stats(), have\-Made\-Paving(), and operator=().

\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a0039bec0f033c35a5477375cb54eb8ea}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!padding@{padding}}
\index{padding@{padding}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{padding}]{\setlength{\rightskip}{0pt plus 5cm}const real {\bf \-Adaptive\-Histogram\-Validation\-::padding} = 0.\-000005\hspace{0.3cm}{\ttfamily  \mbox{[}static, private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a0039bec0f033c35a5477375cb54eb8ea}


a constant for padding a box if it is tailor-\/made for data. 

\-The padding if the size of the root box is obtained from the min and max of the data that is fully fed in. 

\-Definition at line 90 of file adaptivehistogramvalidation.\-hpp.



\-Referenced by make\-Box().

\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_aa8a961766f97013134d73f1735f3516c}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!root\-Box@{root\-Box}}
\index{root\-Box@{root\-Box}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{root\-Box}]{\setlength{\rightskip}{0pt plus 5cm}ivector {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::root\-Box}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_aa8a961766f97013134d73f1735f3516c}


\-The root box used to form the subpaving tree. 

\-We may not need this, at present it gets passed to the \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} constructor. 

\-Definition at line 104 of file adaptivehistogramvalidation.\-hpp.



\-Referenced by \-Adaptive\-Histogram\-Validation(), complete\-Data\-Insertion\-From\-Vec(), have\-Made\-Paving(), and operator=().

\hypertarget{classsubpavings_1_1AdaptiveHistogramValidation_a811e21423987027452237cabf38c008c}{\index{subpavings\-::\-Adaptive\-Histogram\-Validation@{subpavings\-::\-Adaptive\-Histogram\-Validation}!root\-Vpaving@{root\-Vpaving}}
\index{root\-Vpaving@{root\-Vpaving}!subpavings::AdaptiveHistogramValidation@{subpavings\-::\-Adaptive\-Histogram\-Validation}}
\paragraph[{root\-Vpaving}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-S\-P\-S\-Vnode}$\ast$ {\bf subpavings\-::\-Adaptive\-Histogram\-Validation\-::root\-Vpaving}\hspace{0.3cm}{\ttfamily  \mbox{[}private\mbox{]}}}}\label{classsubpavings_1_1AdaptiveHistogramValidation_a811e21423987027452237cabf38c008c}


\-Pointer to the root node of the subpaving tree. 

\-An \hyperlink{classsubpavings_1_1SPSVnode}{\-S\-P\-S\-Vnode} is a binary tree representation of a subpaving, designed for processing statistical data. 

\-Definition at line 97 of file adaptivehistogramvalidation.\-hpp.



\-Referenced by \-Adaptive\-Histogram\-Validation(), get2\-D\-I\-A\-E(), get\-Fin\-Mix\-I\-A\-E(), get\-Fin\-Mix\-Interval\-I\-A\-E(), get\-Leaf\-Counts(), get\-Leaf\-Levels(), get\-Leaf\-Levels\-String(), get\-Min\-Vol(), get\-Root\-Leaves(), get\-Root\-Sum\-Leaf\-Count\-Over\-Vol(), get\-Root\-Vcounter(), get\-Sub\-Paving(), get\-Unif\-I\-A\-E(), have\-Made\-Paving(), insert\-Data\-From\-Container(), operator=(), output\-Graph\-Dot(), output\-Root\-To\-Txt(), output\-To\-Txt\-Tabs(), priority\-Split\-And\-Estimate(), priority\-Split\-And\-Estimate\-With\-Switch(), split\-To\-Shape(), and $\sim$\-Adaptive\-Histogram\-Validation().



\-The documentation for this class was generated from the following files\-:\begin{DoxyCompactItemize}
\item 
\hyperlink{adaptivehistogramvalidation_8hpp}{adaptivehistogramvalidation.\-hpp}\item 
\hyperlink{adaptivehistogramvalidation_8cpp}{adaptivehistogramvalidation.\-cpp}\end{DoxyCompactItemize}
