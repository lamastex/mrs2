\hypertarget{AIAsubpaving_8cpp}{\subsection{\-A\-I\-Asubpaving.\-cpp \-File \-Reference}
\label{AIAsubpaving_8cpp}\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}}
}


\hyperlink{classAIASPnode}{\-A\-I\-A\-S\-Pnode} (\-A\-I\-S\-Sub\-Paving) definitions.  


{\ttfamily \#include \char`\"{}\-A\-I\-Asubpaving.\-hpp\char`\"{}}\*
\subsubsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
std\-::ostream \& \hyperlink{AIAsubpaving_8cpp_a545707f4bc32ad5dac67608be229b51d}{operator$<$$<$} (std\-::ostream \&os, \hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} a)
\item 
int \hyperlink{AIAsubpaving_8cpp_a6cc4fba2aef7df53e990c5348f84bd3b}{\-Nb\-Leaves} (\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} a)
\item 
double \hyperlink{AIAsubpaving_8cpp_a7f6354ab5e7b1310b03f0e190169eabe}{\-Volume} (\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} a)
\item 
\hyperlink{AIAsubpaving_8hpp_a04a5da87f7c1570d6ef4843fb476d1a6}{\-A\-I\-A\-\_\-\-B\-O\-O\-L\-\_\-\-I\-N\-T\-E\-R\-V\-A\-L} \hyperlink{AIAsubpaving_8cpp_a3dadc4f37899578c97e85ec6ea73b724}{operator$<$=} (const ivector \&z, \hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \-X)
\item 
void \hyperlink{AIAsubpaving_8cpp_aa3ceca06b6916b5ac1382a5aa8bf56aa}{\-Expand} (\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \-A, int comp)
\item 
\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \hyperlink{AIAsubpaving_8cpp_ad0b3998c79d0cbf91d21c550a6bb72e7}{\-Re\-Unite} (\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} l\-Child, \hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} r\-Child, ivector x)
\item 
\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \hyperlink{AIAsubpaving_8cpp_a9bc7ba1f54979fabaf0f0ffeab245234}{\-Sivia} (\hyperlink{AIAsubpaving_8hpp_ac3a2af016d66120f37b7e4b3da564876}{\-A\-I\-A\-\_\-\-P\-I\-B\-T} \-Bool\-Test, \hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \-A, double eps)
\item 
void \hyperlink{AIAsubpaving_8cpp_ab7921c5bd80f01985ee134c5d2ab595d}{\-Mince} (\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \-A, double eps)
\item 
void \hyperlink{AIAsubpaving_8cpp_ae77e1251191663a8f7eb8043cc1b3774}{\-Evaluate} (\hyperlink{AIAsubpaving_8hpp_aee443215927e43ef8f6880f25b053a2e}{\-A\-I\-A\-\_\-\-P\-I\-V\-F} \hyperlink{errorfunc_8hpp_aacb77b1211a6ca2e2beff1811cf9ecf4}{f}, \hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \-A, list$<$ ivector $>$ \&eval\-Images, ivector \&hull)
\item 
bool \hyperlink{AIAsubpaving_8cpp_a8713b30834070a586c0b99d9899f9b74}{vol\-Compare} (const ivector \&a, const ivector \&b)
\begin{DoxyCompactList}\small\item\em \-A function for comparing ivectors based on volume. \end{DoxyCompactList}\item 
\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \hyperlink{AIAsubpaving_8cpp_a1b1148d30745256482cbc7cca090253d}{\-Regularize} (ivector \&hull, list$<$ ivector $>$ \&ivector\-List, double eps)
\item 
\hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \hyperlink{AIAsubpaving_8cpp_a6df9f8ffe0d5fbd9ec10bd6954b3b800}{\-Image\-Sp} (\hyperlink{AIAsubpaving_8hpp_aee443215927e43ef8f6880f25b053a2e}{\-A\-I\-A\-\_\-\-P\-I\-V\-F} \hyperlink{errorfunc_8hpp_aacb77b1211a6ca2e2beff1811cf9ecf4}{f}, \hyperlink{AIAsubpaving_8hpp_ab6618d8727b32e897c1b7ab3415b93ff}{\-A\-I\-A\-Sub\-Paving} \-A, double eps)
\end{DoxyCompactItemize}


\subsubsection{\-Detailed \-Description}
\hyperlink{classAIASPnode}{\-A\-I\-A\-S\-Pnode} (\-A\-I\-S\-Sub\-Paving) definitions. 

\-Definition in file \hyperlink{AIAsubpaving_8cpp_source}{\-A\-I\-Asubpaving.\-cpp}.



\subsubsection{\-Function \-Documentation}
\hypertarget{AIAsubpaving_8cpp_ae77e1251191663a8f7eb8043cc1b3774}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Evaluate@{\-Evaluate}}
\index{\-Evaluate@{\-Evaluate}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Evaluate}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Evaluate} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-\_\-\-P\-I\-V\-F}}]{f, }
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{\-A, }
\item[{list$<$ ivector $>$ \&}]{eval\-Images, }
\item[{ivector \&}]{hull}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_ae77e1251191663a8f7eb8043cc1b3774}
\-Function to evaluate all the boxes in \-A\-I\-A\-Sub\-Paving. \-The images of all the boxes are formed and put into a list and the interval hull of the union of all the boxes is formed. \-Interval hull of a union is implemented under cxsc with $|$ operator. \-Boxes are expected to have been created by \hyperlink{AIAsubpaving_8cpp_ab7921c5bd80f01985ee134c5d2ab595d}{\-Mince()}. \-The argument f is a pointer to an interval vector function \-A\-I\-A\-\_\-\-P\-I\-V\-F (which returns an interval vector). \-A\-I\-A\-Sub\-Paving \-A is the \-A\-I\-A\-Sub\-Paving to be evaluated (should be const -\/ it is not changed in this function). eval\-Images is the current list of images to be added to in the function call, hull is an ivector hull of images currently in the list which may be altered in this call if an image is added to list 

\-Definition at line 365 of file \-A\-I\-Asubpaving.\-cpp.



\-References f(), \-A\-I\-A\-S\-Pnode\-::left\-Child, and \-A\-I\-A\-S\-Pnode\-::right\-Child.



\-Referenced by subpavings\-::\-Evaluate(), subpavings\-::\-Image\-Sp(), \-Image\-Sp(), and subpavings\-::\-Image\-Sp\-Non\-Minimal().


\begin{DoxyCode}
{
  if (A!=NULL && IsLeaf(A))
  {
    // make an ivector image using the AIA_PIVF function f on Box(A)
    ivector image = f(Box(A));

    // if no images in image set yet, make hull the image
    if (evalImages.size() == 0) hull = image;
    // if there are images in the image set, hull is the convex hull of
    else hull = (hull | image);
    // the current hull and the ivector image from f(Box(A))

    // add the image to the list of images
    evalImages.push_back(image);

  }                 // end of is a leaf

  // if not a leaf, recursively call Evaluate on children
  if (A!=NULL && !IsLeaf(A))
  {

    Evaluate(f, A->leftChild, evalImages, hull);
    Evaluate(f, A->rightChild, evalImages, hull);

  }                 // end of if is not a leaf

  // case where A == NULL does nothing, just returns
  return;
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_aa3ceca06b6916b5ac1382a5aa8bf56aa}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Expand@{\-Expand}}
\index{\-Expand@{\-Expand}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Expand}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Expand} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{\-A, }
\item[{int}]{comp}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_aa3ceca06b6916b5ac1382a5aa8bf56aa}

\begin{DoxyParams}{\-Parameters}
{\em \-A} & a pointer to the node to be expanded. \\
\hline
{\em comp} & is the dimension to split along. \\
\hline
\end{DoxyParams}


\-Definition at line 227 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-A\-I\-A\-S\-Pnode\-::left\-Child, \-Lower(), \-A\-I\-A\-S\-Pnode\-::right\-Child, and \-Upper().



\-Referenced by subpavings\-::\-Mince(), \-Mince(), subpavings\-::\-Sivia(), and \-Sivia().


\begin{DoxyCode}
{
  // comp argument is passed to Upper() and Lower()
  // these functions split the box normal to direction set by comp

  if (!IsLeaf(A)) return;
  ivector lC,rC;
  Lower(Box(A),lC,comp); Upper(Box(A), rC, comp);
  A->leftChild = new AIASPnode(lC);
  A->rightChild = new AIASPnode(rC);
  //A->leftChild = new AIASPnode(Lower(Box(A),comp));
  //A->rightChild = new AIASPnode(Upper(Box(A),comp));
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a6df9f8ffe0d5fbd9ec10bd6954b3b800}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Image\-Sp@{\-Image\-Sp}}
\index{\-Image\-Sp@{\-Image\-Sp}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Image\-Sp}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-A\-I\-A\-Sub\-Paving} {\bf \-Image\-Sp} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-\_\-\-P\-I\-V\-F}}]{f, }
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{\-A, }
\item[{double}]{eps}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_a6df9f8ffe0d5fbd9ec10bd6954b3b800}
\begin{DoxyReturn}{\-Returns}
a minimal regular subpaving coveringing the image of \-A under some function f 
\end{DoxyReturn}

\begin{DoxyParams}{\-Parameters}
{\em f} & a ($\ast$\-A\-I\-A\-\_\-\-P\-I\-V\-F) which specifies the inclusion function of f and returns the inclusion function image \mbox{[}f\mbox{]}\mbox{[}x\mbox{]} of an interval vector \mbox{[}x\mbox{]} \\
\hline
{\em \-A} & the subpaving for which we wish to find a subpaving covering the image under f \\
\hline
{\em eps} & the precision with which the returned subpaving should be formed \-Image\-Sp uses \hyperlink{AIAsubpaving_8cpp_ab7921c5bd80f01985ee134c5d2ab595d}{\-Mince()} to chop up \-A and then \hyperlink{AIAsubpaving_8cpp_ae77e1251191663a8f7eb8043cc1b3774}{\-Evaluate()} and \hyperlink{AIAsubpaving_8cpp_a1b1148d30745256482cbc7cca090253d}{\-Regularize()} to find a regular minimal subpaving covering the set of images of the boxes of the minced \-A. \\
\hline
\end{DoxyParams}


\-Definition at line 491 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-Evaluate(), \-Mince(), and \-Regularize().



\-Referenced by main().


\begin{DoxyCode}
{
  list<ivector> images;
  ivector hull;

  Mince(A, eps);

  //cout << "After mince " << endl;
  //cout << "A has volume  " << Volume (A) << " and number of leaves "
  //  << NbLeaves(A) << endl;

  Evaluate(f, A, images, hull);

  //cout << "After evaluate " << endl;
  //cout << "Size of image list is : " << images.size()
  //  << "  and hull has volume " << Volume(hull) << endl;

  /* the output of eval is not included in the AIA examples, but it makes
  an interesting comparison to the final subpaving */
  // Filename
  ofstream os2("eval.txt");
  list<ivector>::iterator it;
  for (it=images.begin(); it!=images.end(); it++)
  {
    ivector box = *it;
    os2 << "[ " << Inf(box[1]) << " , " << Sup(box[1]) << " ] , [ "
      << Inf(box[2]) << " , " << Sup(box[2]) << " ]" <<  endl;
  }
  // end of difference from AIA examples

  return (Regularize(hull, images, eps));

}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_ab7921c5bd80f01985ee134c5d2ab595d}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Mince@{\-Mince}}
\index{\-Mince@{\-Mince}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Mince}]{\setlength{\rightskip}{0pt plus 5cm}void {\bf \-Mince} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{\-A, }
\item[{double}]{eps}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_ab7921c5bd80f01985ee134c5d2ab595d}
\-Mince transforms a minimal \-A\-I\-A\-Sub\-Paving into a non-\/minimal \-A\-I\-A\-Sub\-Paving, ie may have sibling leaves. \-Any leaf \-A\-I\-A\-Sub\-Paving with a box with diameter greater than eps will be expanded. \-Mince will keep mincing until every leaf \-A\-I\-A\-Sub\-Paving has a box with diameter $<$ eps 

\-Definition at line 331 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-Expand(), \-A\-I\-A\-S\-Pnode\-::left\-Child, \-Max\-Diam(), and \-A\-I\-A\-S\-Pnode\-::right\-Child.



\-Referenced by subpavings\-::\-Image\-Sp(), \-Image\-Sp(), subpavings\-::\-Image\-Sp\-Non\-Minimal(), and subpavings\-::\-Mince().


\begin{DoxyCode}
{
  if (IsEmpty(A)) return;

  if (IsLeaf(A))
  {
    int comp;       // value is given by calling MaxDiam function below

    // if leaf and box smaller than eps then return
    if(MaxDiam(Box(A),comp)<eps) return;

    // if leaf and box not smaller than eps then expand
    Expand(A,comp);

  }                 // end if a leaf

  // not a leaf, recurse Mince() on left and right children
  Mince(A->rightChild,eps);
  Mince(A->leftChild,eps);

}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a6cc4fba2aef7df53e990c5348f84bd3b}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Nb\-Leaves@{\-Nb\-Leaves}}
\index{\-Nb\-Leaves@{\-Nb\-Leaves}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Nb\-Leaves}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf \-Nb\-Leaves} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{a}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_a6cc4fba2aef7df53e990c5348f84bd3b}


\-Definition at line 61 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-A\-I\-A\-S\-Pnode\-::left\-Child, and \-A\-I\-A\-S\-Pnode\-::right\-Child.



\-Referenced by main().


\begin{DoxyCode}
{
  int nbleaves=0;

  if (IsEmpty(a)) return 0;
  if (IsLeaf(a))  return 1;

  nbleaves += NbLeaves(a->leftChild);
  nbleaves += NbLeaves(a->rightChild);

  return (nbleaves);
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a545707f4bc32ad5dac67608be229b51d}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{operator$<$$<$}]{\setlength{\rightskip}{0pt plus 5cm}std\-::ostream\& operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\-::ostream \&}]{os, }
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{a}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_a545707f4bc32ad5dac67608be229b51d}
\-This output format is not the same as used in the example code provided for \mbox{[}\-A\-I\-A2001\mbox{]}, but is adapted for easy reading and rendering in \-Matlab. 

\-Definition at line 40 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-A\-I\-A\-S\-Pnode\-::left\-Child, \-A\-I\-A\-S\-Pnode\-::right\-Child, and \-A\-I\-A\-S\-Pnode\-::the\-Box.


\begin{DoxyCode}
{
  if (a==NULL) return os;

  //if (IsLeaf(a)) os << (*(a->theBox)) << std::endl;
  //output for Jenny's matlab format, dimension = 2 max
  if (IsLeaf(a))
  {
    ivector x = *(a->theBox);
    os << "[ " << Inf(x[1]) << " , " << Sup(x[1]) << " ] , "
      << "[ " << Inf(x[2]) << " , " << Sup(x[2]) << " ]"   << std::endl;
  }
  else
    { os << (a->leftChild); os << (a->rightChild); }

    return os;
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a3dadc4f37899578c97e85ec6ea73b724}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{operator$<$=}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-A\-I\-A\-\_\-\-B\-O\-O\-L\-\_\-\-I\-N\-T\-E\-R\-V\-A\-L} operator$<$= (
\begin{DoxyParamCaption}
\item[{const ivector \&}]{z, }
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{\-X}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_a3dadc4f37899578c97e85ec6ea73b724}


\-Definition at line 98 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-B\-I\-\_\-\-F\-A\-L\-S\-E, \-B\-I\-\_\-\-I\-N\-D\-E\-T, \-B\-I\-\_\-\-T\-R\-U\-E, \-Intersection(), \-A\-I\-A\-S\-Pnode\-::left\-Child, and \-A\-I\-A\-S\-Pnode\-::right\-Child.


\begin{DoxyCode}
{
  // z is assumed not to be empty
  // note that Intersection() gives an error if unequal index sets passed

  if (IsEmpty(X)) return BI_FALSE;

  ivector r;        // ivector to be passed to Intersection()
  // to contain the intersection

  // check if X is a leaf and if so
  if (IsLeaf(X))
  {
    // *************** old code
    //if (z<=Box(X)) return BI_TRUE;
    //if (!Intersection(r,z,Box(X))) return BI_FALSE;
    // what if Intersection() returns 1, ie there is an intersection
    // but z<=Box(X) is not true?
    // at present this goes down to the default (else) case below

    //**************** replacement code
    if (z<=Box(X))
                    // true if z is in the box
        return BI_TRUE;
    else if (!Intersection(r,z,Box(X)))
                    // false if there is no intersection between z and the box
        return BI_FALSE;
    else          // z is not contained in the box but there is an intersection
                  // so result is indeterminate
        return BI_INDET;
  }                 // end isLeaf()

  AIA_BOOL_INTERVAL Ltest=BI_TRUE,Rtest=BI_TRUE;

  ivector Lz,Rz;    // ivectors to be passed to Intersection()
  // will contain intersection after call to Intersection()

                    // both children exist
  if (!IsEmpty(X->leftChild)&&!IsEmpty(X->rightChild))
  {

                    // intersection with left child
    if (Intersection(Lz,z,Box(X->leftChild)))
      // Lz now contains this intersection
    {
                    // compare Lz and left child
      Ltest = (Lz<=(X->leftChild));

                    //check intersection with right child
      if (Intersection(Rz,z,Box(X->rightChild)))
      {
                    // compare Rz and right child
        Rtest = (Rz<=(X->rightChild));
                    // if left and right child tests same
        if (Ltest==Rtest)
                    // return this result from child tests
          return Ltest;
        else
                    // z overlaps the boundary of X
          return BI_INDET;
      }
      else
        return Ltest;
    }               // end if intersection with left child

                    // given no intersection with left child
    else if (Intersection(Rz,z,Box(X->rightChild)))
                    // check intersection with right child
                    // compare Rz and right child
      return (Rz<=(X->rightChild));

    else            // no intersection with either child
                    // used to be BI_TRUE here from the AIA website
        return BI_FALSE;
    // but this cannot possibly be correct!
  }                 // end if both children exist

                    // only left child exists
  else if (!IsEmpty(X->leftChild))
  {
                    // no intersection with left child
    if (!Intersection(Lz,z,Box(X->leftChild)))
      return BI_FALSE;
    // there is an intersection with the left child, this intersection now in
       Lz
                    // compare Lz and the left child
    Ltest = (Lz<=(X->leftChild));
    // Rtest will still be at default value of TRUE

                    // if left child intersection with z is not z
    if (!(Lz==z)) Rtest = BI_FALSE;
    else            // if left child intersection with z = z
      return Ltest; // ie is whole of z in left child
  }                 // end if  only left child exists

  else              // if is not a leaf, only right child exists
  // BUT if it is a leaf and there is an intersection but not full containment?
  // I have now replaced the code that gave rise to the latter case
  {
                    // no intersection with right child
    if (!Intersection(Rz,z,Box(X->rightChild)))
      return BI_FALSE;
    //there is an intersection with the right child, this intersection now in
       Rz
                    // compare Rz and right child
    Rtest = (Rz<=(X->rightChild));
    // Ltest will still be at default value of TRUE
                    // if right child intersection with z is not z
    if (!(Rz==z)) Ltest = BI_FALSE;
    else            // if right child intersection with z = z
      return Rtest; // ie is whole of z in right child
  }                 // end if only right child exists

  // only get here if only one child (left or right exists)
  // and the intersection of that child with z exists but is not z
  // in which case the other test will have been set to FALSE?
  // or if is a leaf and both Intersection() returns 1 but z<=Box(X) is not 1
  // in which case Ltest and Rtest will both be TRUE? - that code now replaced

  if (Ltest==Rtest)
    return Ltest;
  else
    // if only one child, and the whole of z is not in that child but
    // the intersection of z with that child is inside the child
    return BI_INDET;// z overlaps the boundary of X
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a1b1148d30745256482cbc7cca090253d}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Regularize@{\-Regularize}}
\index{\-Regularize@{\-Regularize}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Regularize}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-A\-I\-A\-Sub\-Paving} {\bf \-Regularize} (
\begin{DoxyParamCaption}
\item[{ivector \&}]{hull, }
\item[{list$<$ ivector $>$ \&}]{ivector\-List, }
\item[{double}]{eps}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_a1b1148d30745256482cbc7cca090253d}
\-Regularize creates an \-A\-I\-A\-Sub\-Paving from all the ivectors in the ivector\-List. \-The root of the \-A\-I\-A\-Sub\-Paving will have \-Box = hull where hull has already been formed from the union of all the ivectors in the ivector\-List. \-Regularize is applied recursively on bisected half of hull and new lists until either there are no images in the list or the diameter of the hull is below eps. 

\-Definition at line 427 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-Intersection(), \-Lower(), \-Max\-Diam(), \-Re\-Unite(), \-Upper(), and \-A\-I\-A\-S\-Pnode\-::vol\-Compare().



\-Referenced by \-Image\-Sp().


\begin{DoxyCode}
{
                    // return NULL if the list is empty
  if (ivectorList.size()==0) return NULL;

  // sort the list
  // Jaulin et al do not have this step because they have their own IMAGELIST
  // class which acts like a set and keeps the contents in order.  But we are
  // using the stl std::list and so it is unsorted when it is passed to
  // Regularize.  It is more effient to sort it once per call to Regularise
  // than to keep it sorted as it is being built because the sorted order is
  // only needed when the entire list has been built

  // sort using the volCompare function
  ivectorList.sort(volCompare);
  // this sorts smallest to largest (the opposite to Jaulin et al)

  // if the hull is equal to the last (largest) box in the list,
  // this becomes the AIASubPaving
  if (hull==(*ivectorList.rbegin())) return new AIASPnode(hull);

  // un-valued int to take value for larged dimension calculated from MaxDiam
  int maxdiamcomp;

  //if the current maximum diameter is < eps return a new AIASubPaving from
       hull
  if (MaxDiam(hull,maxdiamcomp)<eps) return new AIASPnode(hull);

  // new ivectors from splitting hull in its biggest dimension
  ivector lefthull = Lower(hull,maxdiamcomp);
  ivector righthull = Upper(hull,maxdiamcomp);

  // create two empty lists
  list<ivector> leftlist,rightlist;

  // iterator to for the list
  list<ivector>::iterator it;

  // iterate through the current list and put the intersection of any element
  // with the lefthull into the new left list, and the intersection of any
  // element with new right hull into the new rightlist.
  for (it=ivectorList.begin(); it!=ivectorList.end(); it++)
  {
    // temporary variables to take the results of call in Intersect
    ivector interLeft, interRight;

    if (Intersection(interLeft, *it, lefthull))
    {
      leftlist.push_back(interLeft);
    }

    if (Intersection(interRight, *it, righthull))
    {
      rightlist.push_back(interRight);
    }

  }  // end of iteration through list elements

  // recursively call Regularize with lefthull, leftlist, righthull, rightlist
  // reunite the results using hull as the box for the parent node
  // Regularize creates a minimal AIASubPaving (no sibling child nodes)
  return ReUnite(Regularize(lefthull,leftlist,eps),
    Regularize(righthull,rightlist,eps),hull);
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_ad0b3998c79d0cbf91d21c550a6bb72e7}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Re\-Unite@{\-Re\-Unite}}
\index{\-Re\-Unite@{\-Re\-Unite}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Re\-Unite}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-A\-I\-A\-Sub\-Paving} {\bf \-Re\-Unite} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{l\-Child, }
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{r\-Child, }
\item[{ivector}]{x}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_ad0b3998c79d0cbf91d21c550a6bb72e7}
\-If two potential children are provided and they are both leaves, then \-Reunite combines the two leaf siblings into this. \-If the potential children are not leaves or if only one potential child is provided, grafts the potential child/children onto this as its child/children.

\begin{DoxyReturn}{\-Returns}
a minimal subpaving from two sibling subpavings 
\end{DoxyReturn}

\begin{DoxyParams}{\-Parameters}
{\em l\-Child} & a pointer to the left\-Child node to be reunited \\
\hline
{\em r\-Child} & a pointer to the right\-Child node to be reunited \\
\hline
{\em x} & is the box of the new subpaving to be returned \\
\hline
\end{DoxyParams}


\-Definition at line 247 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-A\-I\-A\-S\-Pnode\-::left\-Child, and \-A\-I\-A\-S\-Pnode\-::right\-Child.



\-Referenced by \-Regularize(), and \-Sivia().


\begin{DoxyCode}
{
  if(IsEmpty(lChild)&&IsEmpty(rChild)) return NULL;
  AIASubPaving result = new AIASPnode(x);
  // both AIASubPavings are leaves so discard them: new AIASubPaving is a leaf
  if( IsLeaf(lChild)
    &&IsLeaf(rChild)
    &&(  x == ( Box(lChild) | Box(rChild) )  )
    )
    { delete lChild; delete rChild; return result; }

    // if there are not two non-null potential children
    // (so presumably just one child), just graft it on
    // similarly if at least one child is not a leaf, just graft the potential
    // children on
    result->leftChild = lChild; result->rightChild = rChild;

  return result;
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a9bc7ba1f54979fabaf0f0ffeab245234}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Sivia@{\-Sivia}}
\index{\-Sivia@{\-Sivia}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Sivia}]{\setlength{\rightskip}{0pt plus 5cm}{\bf \-A\-I\-A\-Sub\-Paving} {\bf \-Sivia} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-\_\-\-P\-I\-B\-T}}]{\-Bool\-Test, }
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{\-A, }
\item[{double}]{eps}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_a9bc7ba1f54979fabaf0f0ffeab245234}
\-Set \-Inversion \-Via \-Interval \-Analysis method taken from \-A\-I\-A2001. \-Sivia gives an \-A\-I\-A\-Sub\-Paving which is based on the reciprocal image \-X of some function. \-Note that in this implementation, we get the outer \-A\-I\-A\-Sub\-Paving of a two, (lower\-X and \-Upper\-X) such that lower\-X is in \-X is in upper\-X \-The \-A\-I\-A\-\_\-\-P\-I\-B\-T points to a function wich specifies the function for which we want the reciprocal image and the \-A\-I\-A\-Sub\-Paving \-Y which should contain the reciprocal image. \-The \-A\-I\-A\-\_\-\-P\-I\-B\-T function evaluates whether the image of some box (ivector) is in \-Y. \-The \-A\-I\-A\-\_\-\-P\-I\-B\-T can return \-B\-I\-\_\-\-T\-R\-U\-E, \-B\-I\-\_\-\-F\-A\-L\-S\-E, or \-B\-I\-\_\-\-I\-N\-D\-E\-T (box partly in \-Y but not totally). \-If the \-A\-I\-A\-Sub\-Paving box tests \-B\-I\-\_\-\-I\-N\-D\-E\-T and the box diameter is sufficiently small then it is given the benefit of the doubt and included in upper\-X. \-Otherwise if the \-A\-I\-A\-\_\-\-P\-I\-B\-T function returns \-B\-I\-\_\-\-I\-N\-D\-E\-T then the \-A\-I\-A\-Sub\-Paving is expanded, ie two \-A\-I\-A\-Sub\-Paving children created, and these \-A\-I\-A\-Sub\-Paving children are then tested. \-The argument \-A is an \-A\-I\-A\-Sub\-Paving. \-On the first pass through \-S\-I\-V\-I\-A, \-A should have a box which is guaranteed to contain upper\-X; this \-A\-I\-A\-Sub\-Paving is progressively refined. \-The argument eps specifies the 'sufficiently small' width for a box to be included in upper\-X... 

\-Definition at line 288 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-B\-I\-\_\-\-F\-A\-L\-S\-E, \-B\-I\-\_\-\-T\-R\-U\-E, \-Expand(), \-A\-I\-A\-S\-Pnode\-::left\-Child, \-Max\-Diam(), \-Re\-Unite(), \-A\-I\-A\-S\-Pnode\-::right\-Child, and subpavings\-::\-S\-Pnode\-::\-Sivia().



\-Referenced by main(), and subpavings\-::\-Sivia().


\begin{DoxyCode}
{
  if (A==NULL) return NULL;

                    // test the box of the given AIASubPaving
  AIA_BOOL_INTERVAL test = BoolTest(Box(A));
  // Test function (may be passed as parameter to Sivia)

  // maxdiamcomp will be given a value by call to MaxDiam() below
  int maxdiamcomp;

  // the box fails the test
  if ( test==BI_FALSE ) return NULL;

  // if the box passes or the result is BI_INDET but the maximum diameter of
  // the box is small enough, then return a new AIASubPaving which is a copy of
  // the current one, ie include this AIASubPaving in outerX, our approximation
  // of X the reciprocal image
  if (test==BI_TRUE || MaxDiam(Box(A),maxdiamcomp)<eps)
    return new AIASPnode(*A);

  // SIVIA will only reach this point if the result of the test was BI_INDET
  // and the maximum diameter of the box is not small enough for the box to be
  // in outerX -- in this case we expand the AIASubPaving by giving it child
  // nodes and test them
  if (IsLeaf(A)) Expand(A,maxdiamcomp);

  // ReUnite is used to get a minimal AIASubPaving from merging two
  // AIASubPavings.  So will ensure that the AIASubPaving we return from Sivia
  // is minimal, ie will not have sibling leaves
  return ReUnite( Sivia(BoolTest,A->leftChild,eps),
    Sivia(BoolTest,A->rightChild,eps),
    Box(A));

}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a8713b30834070a586c0b99d9899f9b74}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!vol\-Compare@{vol\-Compare}}
\index{vol\-Compare@{vol\-Compare}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{vol\-Compare}]{\setlength{\rightskip}{0pt plus 5cm}bool {\bf vol\-Compare} (
\begin{DoxyParamCaption}
\item[{const ivector \&}]{a, }
\item[{const ivector \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}related\mbox{]}}}}\label{AIAsubpaving_8cpp_a8713b30834070a586c0b99d9899f9b74}


\-A function for comparing ivectors based on volume. 

\-Used in sorting a list of ivectors ordered by volume.

\-Uses \hyperlink{AIAsubpaving_8cpp_a7f6354ab5e7b1310b03f0e190169eabe}{\-Volume()} as defined in toolz. \begin{DoxyReturn}{\-Returns}
\-T\-R\-U\-E if the \-Volume of a is strictly less than \-Volume of b. 
\end{DoxyReturn}


\-Definition at line 397 of file \-A\-I\-Asubpaving.\-cpp.



\-References taylor\-::\-Lb(), taylor\-::\-Ub(), and \-Volume().



\-Referenced by subpavings\-::\-S\-Pnode\-::make\-Tree\-From\-Leaves(), subpavings\-::\-S\-Pnode\-::make\-Tree\-From\-Voxels(), subpavings\-::\-Regularize(), and subpavings\-::\-Regularize\-Non\-Minimal().


\begin{DoxyCode}
{
  bool returnValue = 0;

  // Make sure the vectors have the same number of elements and at
  // least one element each
  if( (Ub(a) - Lb(a)) == (Ub(b) - Lb(b)) && (Ub(a) - Lb(a))>=1 )
  {

                    // compare the two volumes
    returnValue = ((Volume(a)<Volume(b)));

  }
  else
  {
    std::cout
      << "Error in volCompare : comparing ivectors of different dimensions"
      << std::endl;
  }

  return returnValue;
}
\end{DoxyCode}
\hypertarget{AIAsubpaving_8cpp_a7f6354ab5e7b1310b03f0e190169eabe}{\index{\-A\-I\-Asubpaving.\-cpp@{\-A\-I\-Asubpaving.\-cpp}!\-Volume@{\-Volume}}
\index{\-Volume@{\-Volume}!AIAsubpaving.cpp@{\-A\-I\-Asubpaving.\-cpp}}
\paragraph[{\-Volume}]{\setlength{\rightskip}{0pt plus 5cm}double {\bf \-Volume} (
\begin{DoxyParamCaption}
\item[{{\bf \-A\-I\-A\-Sub\-Paving}}]{a}
\end{DoxyParamCaption}
)}}\label{AIAsubpaving_8cpp_a7f6354ab5e7b1310b03f0e190169eabe}
\-Sums the volumes of the leaves of the \-A\-I\-A\-Sub\-Paving. 

\-Definition at line 77 of file \-A\-I\-Asubpaving.\-cpp.



\-References \-A\-I\-A\-S\-Pnode\-::left\-Child, and \-A\-I\-A\-S\-Pnode\-::right\-Child.



\-Referenced by subpavings\-::\-Collator\-S\-Pnode\-::\-\_\-marginalise(), get\-Reg\-Hist\-Unif\-I\-A\-E(), subpavings\-::\-Adaptive\-Histogram\-Collator\-::get\-Unif\-I\-A\-E(), subpavings\-::\-Adaptive\-Histogram\-Validation\-::get\-Unif\-I\-A\-E(), subpavings\-::\-Adaptive\-Histogram\-::get\-Unif\-I\-A\-E(), get\-Unif\-True\-Delta(), main(), subpavings\-::\-S\-Pnode\-::make\-Tree\-From\-Leaves(), subpavings\-::\-S\-Pnode\-::make\-Tree\-From\-Voxels(), \-M\-R\-Sampler\-::\-M\-R\-Soutput(), subpavings\-::\-S\-Pnode\-::node\-Volume(), subpavings\-::vol\-Compare(), vol\-Compare(), subpavings\-::\-S\-Pnode\-::vol\-Difference(), subpavings\-::\-S\-Pnode\-::vol\-Intersection(), subpavings\-::\-S\-Pnode\-::vol\-Outer\-Jacket(), and subpavings\-::\-S\-Pnode\-::vtk\-Paving().


\begin{DoxyCode}
{

  if (IsEmpty(a)) return 0.0;
  if (IsLeaf(a))
  {

                    // using Volume taking ivector argument
    return Volume(Box(a));
  }
  double vol=0.0;

  vol += Volume(a->leftChild);
  vol += Volume(a->rightChild);

  return (vol);
}
\end{DoxyCode}
