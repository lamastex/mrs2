<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: toolz.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('toolz_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">toolz.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Definition of various tools; functions and structs, for MRS.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;sstream&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &quot;<a class="el" href="toolz_8hpp_source.shtml">toolz.hpp</a>&quot;</code><br/>
<code>#include &lt;stdexcept&gt;</code><br/>
</div>
<p><a href="toolz_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a24b3d8486c8dca4d0f62658bb4da8528">mean</a> (const size_t ssize, const double *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sample mean of a double array using a recurrence.  <a href="#a24b3d8486c8dca4d0f62658bb4da8528"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a03a292f5dfc6f19a070570e44eeb8552">var</a> (const size_t ssize, double *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Variance.  <a href="#a03a292f5dfc6f19a070570e44eeb8552"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a9efdc4ede6e6e3539c2ddca8b71e79a8">mean_var</a> (const vector&lt; real &gt; &amp;x, real &amp;<a class="el" href="toolz_8hpp.shtml#a24b3d8486c8dca4d0f62658bb4da8528">mean</a>, real &amp;<a class="el" href="toolz_8hpp.shtml#a03a292f5dfc6f19a070570e44eeb8552">var</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#afbd188266fc6cb199c4d23bd27d2a8c3">MSE</a> (double exact, int ssize, double *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute MSE using gsl_stats_variance_with_fixed_mean.  <a href="#afbd188266fc6cb199c4d23bd27d2a8c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#aed5587466d9191177de49b5f1e0301ad">Min</a> (real x, real y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Minimum of two real types.  <a href="#aed5587466d9191177de49b5f1e0301ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a4fb345087779da0877e22420a2ff922d">DrawUnifInterval</a> (gsl_rng *rgsl, const interval &amp;X)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a real uniformly at random from the interval X in R.  <a href="#a4fb345087779da0877e22420a2ff922d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a7f15a72d3cac8f3a6b8b333864b2c79e">DrawUnifUnitBox</a> (gsl_rng *rgsl, const int n_dimensions)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a vector uniformly at pseudo-random from unit box [0,1)^n_dimensions.  <a href="#a7f15a72d3cac8f3a6b8b333864b2c79e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#abc84f170f624cc9d449c0cfcaac0f157">DrawUnifBox</a> (gsl_rng *rgsl, const ivector &amp;X)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a vector uniformly at pseudo-random from a Box.  <a href="#abc84f170f624cc9d449c0cfcaac0f157"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#adfd4a448ba53eebbc7284fc6414798c6">DrawQZUnifBox</a> (gsl_qrng *qrgsl, const ivector &amp;X)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a vector uniformly at quasi-random from a Box.  <a href="#adfd4a448ba53eebbc7284fc6414798c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a6aa3917d7eb0f56bea69ce1924ad4445">DrawQZUnifBoxV</a> (double *v, const ivector &amp;X)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a vector uniformly at quasi-random from a Box: trans-dimensional case.  <a href="#a6aa3917d7eb0f56bea69ce1924ad4445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#af7098b26cfe9466d751176b29c67342c">MaxDiamComp</a> (ivector &amp;iv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first dimension with maximal diameter.  <a href="#af7098b26cfe9466d751176b29c67342c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a418bc35de36effbb3522fc58fa035b60">BlowUpFromZero</a> (ivector iv, real FromZero, real eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Blow up a box by eps pivoted at FromZero and return it.  <a href="#a418bc35de36effbb3522fc58fa035b60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667">MaxDiam</a> (ivector x, int &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximal diameter of box x.  <a href="#ac7e3723f9b82103197575fd3be3db667"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533">Intersection</a> (interval &amp;r, const interval &amp;a, const interval &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection interval r of interval a and interval b.  <a href="#a4b95fc9f126441c04e5b773e5fe56533"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a0c91bae4b16d5270e24a7ba9dc3b5dfa">Intersection</a> (ivector &amp;r, const ivector &amp;a, const ivector &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection box r of box a and box b.  <a href="#a0c91bae4b16d5270e24a7ba9dc3b5dfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f">Lower</a> (const ivector &amp;x, int split)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisect box x normal to direction "split" and return the lower half.  <a href="#ae667f0f5dcaff56bf979f20da13e9c9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3">Upper</a> (const ivector &amp;x, int split)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisect box x normal to direction "split" and return the upper half.  <a href="#acb5cc90c84a0b29fbbf2bed1f4ece8d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a849f3db59fb73147d7b220db2456e088">Lower</a> (const ivector &amp;x, ivector &amp;y, int split)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisect box x normal to direction "split" and set box y to the lower half.  <a href="#a849f3db59fb73147d7b220db2456e088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a941924d49b132adc638d12d7eb7cda92">Upper</a> (const ivector &amp;x, ivector &amp;y, int split)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bisect box x normal to direction "split" and set box y to the upper half.  <a href="#a941924d49b132adc638d12d7eb7cda92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#ae06411dd54912b039475819875c13ecb">Volume</a> (const ivector &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the volume of box x.  <a href="#ae06411dd54912b039475819875c13ecb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#acdd3d20a2f2c8114e1195f5e6baa078f">realVolume</a> (const ivector &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the volume of box x as a real.  <a href="#acdd3d20a2f2c8114e1195f5e6baa078f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a1dc9bf6a99daaa6cf7349f16c1e558f5">lCk</a> (const int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return log of Catalan number of k.  <a href="#a1dc9bf6a99daaa6cf7349f16c1e558f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a7f3b31a0850236fe59b892825f09fd2d">toString</a> (const cxsc::rvector &amp;rv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of rvector, formatted with brackets etc.  <a href="#a7f3b31a0850236fe59b892825f09fd2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a9e40bf6c2156aaa804a8bb8939b86742">toString</a> (const cxsc::ivector &amp;iv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of ivector, formatted with brackets etc.  <a href="#a9e40bf6c2156aaa804a8bb8939b86742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a9d4d9a3d991d98a1b2d72aaed3c33704">toString</a> (const cxsc::interval &amp;ival)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of interval, formatted with brackets etc.  <a href="#a9d4d9a3d991d98a1b2d72aaed3c33704"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#aa58a6fd70016ae5a2ca4a4424c1dc8a6">prettyPrint</a> (std::ostream &amp;out, const cxsc::rvector &amp;rv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output formatted with brackets etc, suitable for human reading of rvectors.  <a href="#aa58a6fd70016ae5a2ca4a4424c1dc8a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#aea221cbc39241cd4d2a09bf9a93dd62c">prettyPrint</a> (std::ostream &amp;out, const cxsc::ivector &amp;iv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output formatted with brackets etc, suitable for human reading of ivectors.  <a href="#aea221cbc39241cd4d2a09bf9a93dd62c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#a456949a2a9837eb7179b90899cbfa51c">prettyPrint</a> (std::ostream &amp;out, const cxsc::interval &amp;ival)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output formatted with brackets etc, suitable for human reading of intervals.  <a href="#a456949a2a9837eb7179b90899cbfa51c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="toolz_8cpp.shtml#aa9b4054253be604eff5693db56eef957">plainPrint</a> (std::ostream &amp;out, const cxsc::rvector &amp;rv)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Definition of various tools; functions and structs, for MRS. </p>

<p>Definition in file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a418bc35de36effbb3522fc58fa035b60"></a><!-- doxytag: member="toolz.cpp::BlowUpFromZero" ref="a418bc35de36effbb3522fc58fa035b60" args="(ivector iv, real FromZero, real eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="toolz_8hpp.shtml#a418bc35de36effbb3522fc58fa035b60">BlowUpFromZero</a> </td>
          <td>(</td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>FromZero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blow up a box by eps pivoted at FromZero and return it. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00175">175</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, a = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> (iv), z = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a> (iv);
  interval x;
  interval EPS = _interval (-eps, eps);
  ivector ov (a, z);
  <span class="keywordflow">for</span> (i = a; i &lt;= z; i++)
  {
    x = iv[i] + EPS;
    ov[i] =
      _interval (pred (max (FromZero, Inf (x))),
      succ (max (FromZero, Sup (x))));
  }
  <span class="keywordflow">return</span> ov;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adfd4a448ba53eebbc7284fc6414798c6"></a><!-- doxytag: member="toolz.cpp::DrawQZUnifBox" ref="adfd4a448ba53eebbc7284fc6414798c6" args="(gsl_qrng *qrgsl, const ivector &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="toolz_8hpp.shtml#adfd4a448ba53eebbc7284fc6414798c6">DrawQZUnifBox</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_qrng *&#160;</td>
          <td class="paramname"><em>qrgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a vector uniformly at quasi-random from a Box. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00128">128</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, a = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> (X), z = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a> (X);
  vector&lt;double&gt; v(z - a + 1);

  gsl_qrng_get (qrgsl, (&amp;v[0]));
  rvector UX (a, z);
  <span class="keywordflow">for</span> (i = a; i &lt;= z; i++)
  {
    UX[i] = Inf (X[i]) + (diam (X[i]) * v[i - a]);
  }
  <span class="keywordflow">return</span> UX;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6aa3917d7eb0f56bea69ce1924ad4445"></a><!-- doxytag: member="toolz.cpp::DrawQZUnifBoxV" ref="a6aa3917d7eb0f56bea69ce1924ad4445" args="(double *v, const ivector &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="toolz_8hpp.shtml#a6aa3917d7eb0f56bea69ce1924ad4445">DrawQZUnifBoxV</a> </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a vector uniformly at quasi-random from a Box: trans-dimensional case. </p>
<p>Draw a real uniformly at quasi-random from the box X in R^n given a quasi-random vector in hypercube; the quasi-random vector v may have dimensionality greater than that of X, in which case the extra elements at the end of v are not used. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00147">147</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="MRSampler_8cpp_source.shtml#l00423">MRSampler::ImportanceSampleMany()</a>, and <a class="el" href="MRSampler_8cpp_source.shtml#l00537">MRSampler::ImportanceSampleManyQuasi()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, a = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> (X), z = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a> (X);
  rvector UX (a, z);
  <span class="keywordflow">for</span> (i = a; i &lt;= z; i++)
  {
    UX[i] = Inf (X[i]) + (diam (X[i]) * v[i - a]);
  }
  <span class="keywordflow">return</span> UX;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abc84f170f624cc9d449c0cfcaac0f157"></a><!-- doxytag: member="toolz.cpp::DrawUnifBox" ref="abc84f170f624cc9d449c0cfcaac0f157" args="(gsl_rng *rgsl, const ivector &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="toolz_8hpp.shtml#abc84f170f624cc9d449c0cfcaac0f157">DrawUnifBox</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a vector uniformly at pseudo-random from a Box. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00116">116</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00096">DrawUnifInterval()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="MappedSPSamplingGaussian_8cpp_source.shtml#l00213">doMCMCGRAuto()</a>, <a class="el" href="MRSampler_8cpp_source.shtml#l00423">MRSampler::ImportanceSampleMany()</a>, <a class="el" href="MRSampler_8cpp_source.shtml#l00537">MRSampler::ImportanceSampleManyQuasi()</a>, <a class="el" href="GeneralScheffe_8cpp_source.shtml#l00042">main()</a>, and <a class="el" href="MRSampler_8cpp_source.shtml#l00279">MRSampler::RejectionSampleOnce()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, a = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> (X), z = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a> (X);
  rvector UX (a, z);
  <span class="keywordflow">for</span> (i = a; i &lt;= z; i++)
  {
    UX[i] = <a class="code" href="toolz_8cpp.shtml#a4fb345087779da0877e22420a2ff922d" title="Draw a real uniformly at random from the interval X in R.">DrawUnifInterval</a> (rgsl, X[i]);
  }
  <span class="keywordflow">return</span> UX;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4fb345087779da0877e22420a2ff922d"></a><!-- doxytag: member="toolz.cpp::DrawUnifInterval" ref="a4fb345087779da0877e22420a2ff922d" args="(gsl_rng *rgsl, const interval &amp;X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="toolz_8hpp.shtml#a4fb345087779da0877e22420a2ff922d">DrawUnifInterval</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const interval &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a real uniformly at random from the interval X in R. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00096">96</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="toolz_8cpp_source.shtml#l00116">DrawUnifBox()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">double</span> r = gsl_rng_uniform (rgsl);
  <span class="keywordflow">return</span> (Inf (X) + (r * diam (X)));
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7f15a72d3cac8f3a6b8b333864b2c79e"></a><!-- doxytag: member="toolz.cpp::DrawUnifUnitBox" ref="a7f15a72d3cac8f3a6b8b333864b2c79e" args="(gsl_rng *rgsl, const int n_dimensions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="toolz_8hpp.shtml#a7f15a72d3cac8f3a6b8b333864b2c79e">DrawUnifUnitBox</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_dimensions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draw a vector uniformly at pseudo-random from unit box [0,1)^n_dimensions. </p>
<p>return rvector representing point drawn uniformly pseudo-randomly from unit box with n_dimensions dimensions. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00105">105</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="MRSampler_8cpp_source.shtml#l00423">MRSampler::ImportanceSampleMany()</a>, and <a class="el" href="MRSampler_8cpp_source.shtml#l00354">MRSampler::RejectionSampleMany()</a>.</p>
<div class="fragment"><pre class="fragment">{
  rvector rand_vector(1, n_dimensions);
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i&lt;=n_dimensions; i++)
  {
    rand_vector[i] = gsl_rng_uniform(rgsl);
  }
  <span class="keywordflow">return</span> rand_vector;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4b95fc9f126441c04e5b773e5fe56533"></a><!-- doxytag: member="toolz.cpp::Intersection" ref="a4b95fc9f126441c04e5b773e5fe56533" args="(interval &amp;r, const interval &amp;a, const interval &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="toolz_8hpp.shtml#a0c91bae4b16d5270e24a7ba9dc3b5dfa">Intersection</a> </td>
          <td>(</td>
          <td class="paramtype">interval &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const interval &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const interval &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersection interval r of interval a and interval b. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the intersection is empty, else return 1. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00203">203</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01286">getRegHistUnifIAE()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l01271">subpavings::AdaptiveHistogramCollator::getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">subpavings::AdaptiveHistogramValidation::getUnifIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03774">subpavings::AdaptiveHistogram::getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04264">getUnifTrueDelta()</a>, <a class="el" href="Exm__3__4_8cpp_source.shtml#l00037">IBT_ex3_4()</a>, <a class="el" href="Exm__3__3_8cpp_source.shtml#l00036">IBTAnnular()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">subpavings::SPnode::makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">subpavings::SPnode::makeTreeFromVoxels()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00098">operator&lt;=()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00184">subpavings::Regularize()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">Regularize()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00309">subpavings::RegularizeNonMinimal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">subpavings::SPnode::spContains()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02613">subpavings::SPSnode::spsContains()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// disjoint?</span>
  <span class="keywordflow">if</span>( (Inf(a) &gt; Sup(b)) || (Inf(b) &gt; Sup(a)) )
    <span class="keywordflow">return</span> 0;
  <span class="keywordflow">else</span> {r = a &amp; b; <span class="keywordflow">return</span> 1;}
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c91bae4b16d5270e24a7ba9dc3b5dfa"></a><!-- doxytag: member="toolz.cpp::Intersection" ref="a0c91bae4b16d5270e24a7ba9dc3b5dfa" args="(ivector &amp;r, const ivector &amp;a, const ivector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="toolz_8hpp.shtml#a0c91bae4b16d5270e24a7ba9dc3b5dfa">Intersection</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intersection box r of box a and box b. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if the intersection is empty, else return dimension of r. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00213">213</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, il = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(a), iu = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(a);
  <span class="keywordtype">int</span> intersect = iu-il+2;
  <span class="keywordflow">if</span>( (iu != <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(b)) || (il != <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(b)) )
  {
    cerr &lt;&lt; <span class="stringliteral">&quot;\n unequal index sets in Intersection\n&quot;</span>;
    exit(0);
  }
  Resize(r, il, iu);
  <span class="keywordflow">for</span> (i = il; i &lt;= iu; i++)
  {
    <span class="comment">// disjoint?</span>
    <span class="keywordflow">if</span>( (Inf(a[i]) &gt; Sup(b[i])) || (Inf(b[i]) &gt; Sup(a[i])) )
      <span class="keywordflow">return</span> 0;
    <span class="keywordflow">else</span> {r[i] = a[i] &amp; b[i]; intersect--;}
  }
  <span class="keywordflow">return</span> intersect;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1dc9bf6a99daaa6cf7349f16c1e558f5"></a><!-- doxytag: member="toolz.cpp::lCk" ref="a1dc9bf6a99daaa6cf7349f16c1e558f5" args="(const int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="toolz_8hpp.shtml#a1dc9bf6a99daaa6cf7349f16c1e558f5">lCk</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to return log of Catalan number of k. </p>
<p>In a histogram, k is the number of leaves-1, ie the number of splits. Catalan(k) = 1/(k+1)Binomial(2k choose k) = (2k)!/((k+1)!k!) ln(Catalan(k)) is 0 for k-0, k=1, sum(from i=1 to i=k-2) of (ln(2k-i) - ln(k-i)) for integer k &gt; 1.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>the integer to calculate the Catalan number for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the natural log of the Catalan number for k. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00310">310</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="histmcmcobjs_8hpp_source.shtml#l00080">subpavings::LogCatalanPrior::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00106">subpavings::PenAIC1::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00146">subpavings::PenAIC2::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00185">subpavings::PenAIC3::operator()()</a>, and <a class="el" href="histpenalty_8hpp_source.shtml#l00222">subpavings::PenAIC4::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">double</span> retValue = 0.0;
    <span class="keywordflow">if</span> (k &gt; 1) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k-1; i++) {
            retValue += (log(2*k-i) - log(k-i));
        }
    }
    <span class="keywordflow">return</span> retValue; <span class="comment">// return 0 for k=0, k=1</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae667f0f5dcaff56bf979f20da13e9c9f"></a><!-- doxytag: member="toolz.cpp::Lower" ref="ae667f0f5dcaff56bf979f20da13e9c9f" args="(const ivector &amp;x, int split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="toolz_8hpp.shtml#a849f3db59fb73147d7b220db2456e088">Lower</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bisect box x normal to direction "split" and return the lower half. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00234">234</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00986">subpavings::SPSVnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01238">subpavings::SPSnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">subpavings::SPnode::makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">subpavings::SPnode::makeTreeFromVoxels()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">subpavings::SPnode::nodeExpand()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00170">subpavings::SPSVnode::nodeExpansionOnly()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00171">subpavings::SPSnode::nodeExpansionOnly()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00184">subpavings::Regularize()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">Regularize()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00309">subpavings::RegularizeNonMinimal()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01782">subpavings::SPnode::vecBoxNodeDifference()</a>.</p>
<div class="fragment"><pre class="fragment">{
  ivector t = x;
  SetSup( t[split], mid(x[split]) );
  <span class="keywordflow">return</span> t;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a849f3db59fb73147d7b220db2456e088"></a><!-- doxytag: member="toolz.cpp::Lower" ref="a849f3db59fb73147d7b220db2456e088" args="(const ivector &amp;x, ivector &amp;y, int split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="toolz_8hpp.shtml#a849f3db59fb73147d7b220db2456e088">Lower</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bisect box x normal to direction "split" and set box y to the lower half. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00250">250</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  Resize(y, <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(x), <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(x));
  y = x;
  SetSup( y[split], mid(x[split]) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac7e3723f9b82103197575fd3be3db667"></a><!-- doxytag: member="toolz.cpp::MaxDiam" ref="ac7e3723f9b82103197575fd3be3db667" args="(ivector x, int &amp;c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="toolz_8hpp.shtml#ac7e3723f9b82103197575fd3be3db667">MaxDiam</a> </td>
          <td>(</td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the maximal diameter of box x. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00192">192</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l00986">subpavings::SPSVnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01238">subpavings::SPSnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00932">subpavings::SPSVnode::getRightCountIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">subpavings::SPnode::makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">subpavings::SPnode::makeTreeFromVoxels()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">subpavings::Mince()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00384">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00753">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00798">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00489">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01344">subpavings::SPnode::nodeExpand()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01873">subpavings::SPSVnode::nodeExpand()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02853">subpavings::SPSnode::nodeExpand()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00217">subpavings::CompHellingerDist1DMassDiamVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00256">subpavings::CompHellingerDistMassDiamVal::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00385">subpavings::CompHellingerDist1DMassDiam::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00428">subpavings::CompHellingerDistMassDiam::operator()()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00184">subpavings::Regularize()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">Regularize()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00309">subpavings::RegularizeNonMinimal()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">subpavings::Sivia()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">Sivia()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i, a=<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(x), z=<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(x);
  real Diam = diam(x[a]); c = a;
  <span class="keywordflow">for</span> (i=a+1;i&lt;=z;i++)
    <span class="keywordflow">if</span> (diam(x[i])&gt;Diam) { Diam = diam(x[i]); c = i; }
    <span class="keywordflow">return</span> _double(Diam);
}
</pre></div>
</div>
</div>
<a class="anchor" id="af7098b26cfe9466d751176b29c67342c"></a><!-- doxytag: member="toolz.cpp::MaxDiamComp" ref="af7098b26cfe9466d751176b29c67342c" args="(ivector &amp;iv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="toolz_8hpp.shtml#af7098b26cfe9466d751176b29c67342c">MaxDiamComp</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>iv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the first dimension with maximal diameter. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00159">159</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="MRSampler_8cpp_source.shtml#l00848">MRSampler::Bisect()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01238">subpavings::SPSnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01170">subpavings::SPSnode::getLeftCountIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00372">subpavings::SPnode::isSplittableNode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01122">subpavings::SPSnode::isSplittableNode()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01782">subpavings::SPnode::vecBoxNodeDifference()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> mc, k;
  rvector d (<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> (iv), <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a> (iv));

  d = diam (iv);
  mc = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> (iv);
  <span class="keywordflow">for</span> (k = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> (iv) + 1; k &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a> (iv); k++)
  {
    <span class="keywordflow">if</span> (d[k] &gt; d[mc])
      mc = k;
  }
  <span class="keywordflow">return</span> mc;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a24b3d8486c8dca4d0f62658bb4da8528"></a><!-- doxytag: member="toolz.cpp::mean" ref="a24b3d8486c8dca4d0f62658bb4da8528" args="(const size_t ssize, const double *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="toolz_8hpp.shtml#a24b3d8486c8dca4d0f62658bb4da8528">mean</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the sample mean of a double array using a recurrence. </p>
<p>Compute the arithmetic mean of a double array using the recurrence relation mean_(n) = mean(n-1) + (x[n] - mean(n-1))/(n+1). </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00039">39</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="CesaroBellNo_8cpp_source.shtml#l00063">main()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00066">mean_var()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> gsl_stats_mean (x, 1, ssize);
 <span class="comment">/* long double mean = 0;</span>
<span class="comment">  size_t i;</span>
<span class="comment"></span>
<span class="comment">  for (i = 0; i &lt; ssize; i++)</span>
<span class="comment">  {</span>
<span class="comment">    mean += (x[i] - mean) / (i + 1);</span>
<span class="comment">  }</span>
<span class="comment"></span>
<span class="comment">  return mean;*/</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9efdc4ede6e6e3539c2ddca8b71e79a8"></a><!-- doxytag: member="toolz.cpp::mean_var" ref="a9efdc4ede6e6e3539c2ddca8b71e79a8" args="(const vector&lt; real &gt; &amp;x, real &amp;mean, real &amp;var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="toolz_8hpp.shtml#a9efdc4ede6e6e3539c2ddca8b71e79a8">mean_var</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the arithmetic mean of a double array -- curruntly ugly/unstable</p>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000015">Todo:</a></b></dt><dd>using the recurrence relation in <a class="el" href="structkahan__sum.shtml" title="Stable Summation Routine of Kahan&#39;s.">kahan_sum</a> and the sample variance using a similar recurrence OR cxsc DotPrecision Accumulators. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00066">66</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00039">mean()</a>.</p>
<div class="fragment"><pre class="fragment">{
  vector &lt; real &gt;::const_iterator it = x.begin ();
  real sum (0.0), sumsq (0.0);
  <span class="keywordtype">long</span> count (0);
  <span class="keywordflow">for</span> (; it != x.end (); it++)
  {
    sum += *it;
    sumsq += *it * *it;
    count++;
  }
  <a class="code" href="toolz_8cpp.shtml#a24b3d8486c8dca4d0f62658bb4da8528" title="Compute the sample mean of a double array using a recurrence.">mean</a> = sum / count;
  <a class="code" href="toolz_8cpp.shtml#a03a292f5dfc6f19a070570e44eeb8552" title="Compute the Variance.">var</a> = sumsq / count - <a class="code" href="toolz_8cpp.shtml#a24b3d8486c8dca4d0f62658bb4da8528" title="Compute the sample mean of a double array using a recurrence.">mean</a> * <a class="code" href="toolz_8cpp.shtml#a24b3d8486c8dca4d0f62658bb4da8528" title="Compute the sample mean of a double array using a recurrence.">mean</a>;
  <span class="keywordflow">return</span> count;
  <span class="comment">//sum = std::accumulate(x.begin(),x.end(),0.,kahan_sum&lt;real&gt;());</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aed5587466d9191177de49b5f1e0301ad"></a><!-- doxytag: member="toolz.cpp::Min" ref="aed5587466d9191177de49b5f1e0301ad" args="(real x, real y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="toolz_8hpp.shtml#aed5587466d9191177de49b5f1e0301ad">Min</a> </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find Minimum of two real types. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00090">90</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (x &lt; y) ? x : y;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afbd188266fc6cb199c4d23bd27d2a8c3"></a><!-- doxytag: member="toolz.cpp::MSE" ref="afbd188266fc6cb199c4d23bd27d2a8c3" args="(double exact, int ssize, double *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="toolz_8hpp.shtml#afbd188266fc6cb199c4d23bd27d2a8c3">MSE</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute MSE using gsl_stats_variance_with_fixed_mean. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00084">84</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="CesaroBellNo_8cpp_source.shtml#l00063">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> gsl_stats_variance_with_fixed_mean (x, 1, ssize, exact);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa9b4054253be604eff5693db56eef957"></a><!-- doxytag: member="toolz.cpp::plainPrint" ref="aa9b4054253be604eff5693db56eef957" args="(std::ostream &amp;out, const cxsc::rvector &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="toolz_8cpp.shtml#aa9b4054253be604eff5693db56eef957">plainPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::rvector &amp;&#160;</td>
          <td class="paramname"><em>rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00380">380</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> i = 0;
  <span class="keywordflow">for</span>(i=<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(rv); i&lt;<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(rv); ++i)
  {
    out &lt;&lt; rv[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
  }
  out &lt;&lt; rv[i];  <span class="comment">// final one with no tab at the end </span>

  <span class="keywordflow">return</span> out;
}<span class="comment">//--src_trunk_0701</span>
</pre></div>
</div>
</div>
<a class="anchor" id="aa58a6fd70016ae5a2ca4a4424c1dc8a6"></a><!-- doxytag: member="toolz.cpp::prettyPrint" ref="aa58a6fd70016ae5a2ca4a4424c1dc8a6" args="(std::ostream &amp;out, const cxsc::rvector &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="toolz_8hpp.shtml#a456949a2a9837eb7179b90899cbfa51c">prettyPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::rvector &amp;&#160;</td>
          <td class="paramname"><em>rv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output formatted with brackets etc, suitable for human reading of rvectors. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to send the output to. </td></tr>
    <tr><td class="paramname">rv</td><td>the rvector to describe in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the stream with the new output. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00346">346</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="toolz_8cpp_source.shtml#l00359">prettyPrint()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00322">toString()</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(rv); i&lt;=<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(rv); ++i)
  {
  out &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rv[i];
  }
  out &lt;&lt; <span class="stringliteral">&quot; )&quot;</span>; 

  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aea221cbc39241cd4d2a09bf9a93dd62c"></a><!-- doxytag: member="toolz.cpp::prettyPrint" ref="aea221cbc39241cd4d2a09bf9a93dd62c" args="(std::ostream &amp;out, const cxsc::ivector &amp;iv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="toolz_8hpp.shtml#a456949a2a9837eb7179b90899cbfa51c">prettyPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::ivector &amp;&#160;</td>
          <td class="paramname"><em>iv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output formatted with brackets etc, suitable for human reading of ivectors. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to send the output to. </td></tr>
    <tr><td class="paramname">iv</td><td>the ivector to describe in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the stream with the new output. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00359">359</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00346">prettyPrint()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(iv); i&lt;=<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(iv); ++i)
  {
  out &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
  <a class="code" href="toolz_8cpp.shtml#aa58a6fd70016ae5a2ca4a4424c1dc8a6" title="Output formatted with brackets etc, suitable for human reading of rvectors.">prettyPrint</a>(out, iv[i]);
  }


  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a456949a2a9837eb7179b90899cbfa51c"></a><!-- doxytag: member="toolz.cpp::prettyPrint" ref="a456949a2a9837eb7179b90899cbfa51c" args="(std::ostream &amp;out, const cxsc::interval &amp;ival)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="toolz_8hpp.shtml#a456949a2a9837eb7179b90899cbfa51c">prettyPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::interval &amp;&#160;</td>
          <td class="paramname"><em>ival</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output formatted with brackets etc, suitable for human reading of intervals. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to send the output to. </td></tr>
    <tr><td class="paramname">ival</td><td>the interval to describe in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the stream with the new output. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00372">372</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  out &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(ival) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; Sup(ival) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span>;

  <span class="keywordflow">return</span> out;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acdd3d20a2f2c8114e1195f5e6baa078f"></a><!-- doxytag: member="toolz.cpp::realVolume" ref="acdd3d20a2f2c8114e1195f5e6baa078f" args="(const ivector &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="toolz_8hpp.shtml#acdd3d20a2f2c8114e1195f5e6baa078f">realVolume</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the volume of box x as a real. </p>
<p>unclear what behaviour of vol() is if the interval vector x is uninitialised. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00285">285</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00372">subpavings::SPnode::isSplittableNode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00465">subpavings::SPnode::nodeRealVolume()</a>, and <a class="el" href="UniformFobj_8cpp_source.shtml#l00037">subpavings::UniformFobj::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> low_index = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(x);
  <span class="keywordtype">int</span> upp_index = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(x);
  
  <span class="keywordflow">if</span> (upp_index &lt; low_index) <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;Ub &lt; Lb&quot;</span>);

  real accVol = 1.0;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= low_index; i&lt;=upp_index; ++i)
  {

    accVol *= diam(x[i]);

  }                 <span class="comment">//</span>

  <span class="keywordflow">return</span> accVol;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7f3b31a0850236fe59b892825f09fd2d"></a><!-- doxytag: member="toolz.cpp::toString" ref="a7f3b31a0850236fe59b892825f09fd2d" args="(const cxsc::rvector &amp;rv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="toolz_8hpp.shtml#a9d4d9a3d991d98a1b2d72aaed3c33704">toString</a> </td>
          <td>(</td>
          <td class="paramtype">const cxsc::rvector &amp;&#160;</td>
          <td class="paramname"><em>rv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>String representation of rvector, formatted with brackets etc. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rv</td><td>the rvector to describe in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>string representation of <em>rv</em>. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00322">322</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00346">prettyPrint()</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::ostringstream oss;
  <a class="code" href="toolz_8cpp.shtml#aa58a6fd70016ae5a2ca4a4424c1dc8a6" title="Output formatted with brackets etc, suitable for human reading of rvectors.">prettyPrint</a>(oss, rv);
  <span class="keywordflow">return</span> oss.str();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e40bf6c2156aaa804a8bb8939b86742"></a><!-- doxytag: member="toolz.cpp::toString" ref="a9e40bf6c2156aaa804a8bb8939b86742" args="(const cxsc::ivector &amp;iv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="toolz_8hpp.shtml#a9d4d9a3d991d98a1b2d72aaed3c33704">toString</a> </td>
          <td>(</td>
          <td class="paramtype">const cxsc::ivector &amp;&#160;</td>
          <td class="paramname"><em>iv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>String representation of ivector, formatted with brackets etc. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iv</td><td>the ivector to describe in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>string representation of <em>iv</em>. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00329">329</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00346">prettyPrint()</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::ostringstream oss;
  <a class="code" href="toolz_8cpp.shtml#aa58a6fd70016ae5a2ca4a4424c1dc8a6" title="Output formatted with brackets etc, suitable for human reading of rvectors.">prettyPrint</a>(oss, iv);
  <span class="keywordflow">return</span> oss.str();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9d4d9a3d991d98a1b2d72aaed3c33704"></a><!-- doxytag: member="toolz.cpp::toString" ref="a9d4d9a3d991d98a1b2d72aaed3c33704" args="(const cxsc::interval &amp;ival)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="toolz_8hpp.shtml#a9d4d9a3d991d98a1b2d72aaed3c33704">toString</a> </td>
          <td>(</td>
          <td class="paramtype">const cxsc::interval &amp;&#160;</td>
          <td class="paramname"><em>ival</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>String representation of interval, formatted with brackets etc. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ival</td><td>the interval to describe in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>string representation of <em>ival</em>. </dd></dl>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00336">336</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00346">prettyPrint()</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::ostringstream oss;
  <a class="code" href="toolz_8cpp.shtml#aa58a6fd70016ae5a2ca4a4424c1dc8a6" title="Output formatted with brackets etc, suitable for human reading of rvectors.">prettyPrint</a>(oss, ival);
  <span class="keywordflow">return</span> oss.str();
}
</pre></div>
</div>
</div>
<a class="anchor" id="acb5cc90c84a0b29fbbf2bed1f4ece8d3"></a><!-- doxytag: member="toolz.cpp::Upper" ref="acb5cc90c84a0b29fbbf2bed1f4ece8d3" args="(const ivector &amp;x, int split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="toolz_8hpp.shtml#a941924d49b132adc638d12d7eb7cda92">Upper</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bisect box x normal to direction "split" and return the upper half. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00242">242</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00986">subpavings::SPSVnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01238">subpavings::SPSnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00932">subpavings::SPSVnode::getRightCountIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">subpavings::SPnode::makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">subpavings::SPnode::makeTreeFromVoxels()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">subpavings::SPnode::nodeExpand()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00170">subpavings::SPSVnode::nodeExpansionOnly()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00171">subpavings::SPSnode::nodeExpansionOnly()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00184">subpavings::Regularize()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">Regularize()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00309">subpavings::RegularizeNonMinimal()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01782">subpavings::SPnode::vecBoxNodeDifference()</a>.</p>
<div class="fragment"><pre class="fragment">{
  ivector t = x;
  SetInf( t[split], mid(x[split]) );
  <span class="keywordflow">return</span> t;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a941924d49b132adc638d12d7eb7cda92"></a><!-- doxytag: member="toolz.cpp::Upper" ref="a941924d49b132adc638d12d7eb7cda92" args="(const ivector &amp;x, ivector &amp;y, int split)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="toolz_8hpp.shtml#a941924d49b132adc638d12d7eb7cda92">Upper</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bisect box x normal to direction "split" and set box y to the upper half. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00258">258</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  Resize(y, <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(x), <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(x));
  y = x;
  SetInf( y[split], mid(x[split]) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a03a292f5dfc6f19a070570e44eeb8552"></a><!-- doxytag: member="toolz.cpp::var" ref="a03a292f5dfc6f19a070570e44eeb8552" args="(const size_t ssize, double *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="toolz_8hpp.shtml#a03a292f5dfc6f19a070570e44eeb8552">var</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the Variance. </p>
<p>the non-parametric plug-in estimate of variance (1/N) sum (x_i - mean)^2 </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00055">55</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>Referenced by <a class="el" href="CesaroBellNo_8cpp_source.shtml#l00063">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> gsl_stats_variance (x, 1, ssize)*((double) (ssize-1) / (double) ssize);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae06411dd54912b039475819875c13ecb"></a><!-- doxytag: member="toolz.cpp::Volume" ref="ae06411dd54912b039475819875c13ecb" args="(const ivector &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="toolz_8hpp.shtml#ae06411dd54912b039475819875c13ecb">Volume</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the volume of box x. </p>
<p>unclear what behaviour of vol() is if the interval vector x is uninitialised. </p>

<p>Definition at line <a class="el" href="toolz_8cpp_source.shtml#l00266">266</a> of file <a class="el" href="toolz_8cpp_source.shtml">toolz.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> low_index = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(x);
  <span class="keywordtype">int</span> upp_index = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(x);

  real accVol = 1.0;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= low_index; i&lt;=upp_index; i++)
  {

    accVol *= diam(x[i]);

  }                 <span class="comment">//</span>

  <span class="keywordflow">return</span> _double(accVol);
}
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="toolz_8cpp.shtml">toolz.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:23 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
