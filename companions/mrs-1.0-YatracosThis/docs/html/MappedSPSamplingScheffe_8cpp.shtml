<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: MappedSPSamplingScheffe.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('MappedSPSamplingScheffe_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MappedSPSamplingScheffe.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="IAECalculations_2FinMixFobj_8hpp_source.shtml">FinMixFobj.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="GaussianFobj1D_8hpp_source.shtml">GaussianFobj1D.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="GaussianFobj2D_8hpp_source.shtml">GaussianFobj2D.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="GaussianFobj10D_8hpp_source.shtml">GaussianFobj10D.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="GaussianFobj100D_8hpp_source.shtml">GaussianFobj100D.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mappedspnodevisitor__expand_8hpp_source.shtml">mappedspnodevisitor_expand.hpp</a>&quot;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;gsl/gsl_randist.h&gt;</code><br/>
<code>#include &lt;valarray&gt;</code><br/>
<code>#include &quot;<a class="el" href="toolz_8hpp_source.shtml">toolz.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="histall_8hpp_source.shtml">histall.hpp</a>&quot;</code><br/>
<code>#include &lt;gsl/gsl_qrng.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="Fobj_8hpp_source.shtml">Fobj.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="FRosenbrock_8hpp_source.shtml">FRosenbrock.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="MRSampler_8hpp_source.shtml">MRSampler.hpp</a>&quot;</code><br/>
</div>
<p><a href="MappedSPSamplingScheffe_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLexicoSorting.shtml">LexicoSorting&lt; T &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MappedSPSamplingScheffe_8cpp.shtml#a91337b8216794ab4371528e4d8f07aa2">output</a> (string &amp;filename, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MappedSPSamplingScheffe_8cpp.shtml#a2ebd3788007a04909c0805d18f7cc302">getAllWeights</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *thisNodePtr, vector&lt; double &gt; &amp;WeightsVector, vector&lt; interval &gt; &amp;WeightsInt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MappedSPSamplingScheffe_8cpp.shtml#a071c6769f9c807ff0719ce7470b94a86">getHeightAndBox</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *thisNodePtr, vector&lt; ivector &gt; &amp;BoxVector, vector&lt; real &gt; &amp;HeightsVector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MappedSPSamplingScheffe_8cpp.shtml#aaccdd027128215abfb51d30ca3bfc190">normHeights</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *thisNodePtr, double totalArea, vector&lt; <a class="el" href="classsubpavings_1_1RangeCollectionClass.shtml">RangeCollectionClass</a>&lt; real &gt; &gt; &amp;heightNorm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MappedSPSamplingScheffe_8cpp.shtml#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2ebd3788007a04909c0805d18f7cc302"></a><!-- doxytag: member="MappedSPSamplingScheffe.cpp::getAllWeights" ref="a2ebd3788007a04909c0805d18f7cc302" args="(RealMappedSPnode *thisNodePtr, vector&lt; double &gt; &amp;WeightsVector, vector&lt; interval &gt; &amp;WeightsInt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="MappedSPSamplingTest_8cpp.shtml#a2ebd3788007a04909c0805d18f7cc302">getAllWeights</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *&#160;</td>
          <td class="paramname"><em>thisNodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>WeightsVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; interval &gt; &amp;&#160;</td>
          <td class="paramname"><em>WeightsInt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml#l00099">99</a> of file <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml">MappedSPSamplingScheffe.cpp</a>.</p>

<p>References <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">subpavings::RealMappedSPnode::getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">subpavings::RealMappedSPnode::getRightChild()</a>, <a class="el" href="rangecollection_8hpp_source.shtml#l00339">subpavings::RangeCollectionClass&lt; T &gt;::getWeights()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
     <span class="comment">//get the weights</span>
     <a class="code" href="classsubpavings_1_1RangeCollectionClass.shtml" title="A class for range collection objects.">RangeCollectionClass&lt;real&gt;</a> myContainer;
     myContainer = thisNodePtr-&gt;getRangeCollection();
     myContainer.<a class="code" href="classsubpavings_1_1RangeCollectionClass.shtml#a6173b655063220537c3630f1347cfdd5">getWeights</a>(WeightsVector, WeightsInt, thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>());
  }

  <span class="comment">//recurse on the children</span>
  <span class="keywordflow">if</span> (thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#ad413fb4b470884bbd346547f10dd5b67">getAllWeights</a>(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>(), WeightsVector, WeightsInt);
  }
   <span class="keywordflow">if</span> (thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#ad413fb4b470884bbd346547f10dd5b67">getAllWeights</a>(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>(), WeightsVector, WeightsInt);
   }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a071c6769f9c807ff0719ce7470b94a86"></a><!-- doxytag: member="MappedSPSamplingScheffe.cpp::getHeightAndBox" ref="a071c6769f9c807ff0719ce7470b94a86" args="(RealMappedSPnode *thisNodePtr, vector&lt; ivector &gt; &amp;BoxVector, vector&lt; real &gt; &amp;HeightsVector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="MappedSPSamplingTest_8cpp.shtml#a071c6769f9c807ff0719ce7470b94a86">getHeightAndBox</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *&#160;</td>
          <td class="paramname"><em>thisNodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; ivector &gt; &amp;&#160;</td>
          <td class="paramname"><em>BoxVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>HeightsVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml#l00119">119</a> of file <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml">MappedSPSamplingScheffe.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="rangecollection_8hpp_source.shtml#l00366">subpavings::RangeCollectionClass&lt; T &gt;::getHeight()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">subpavings::RealMappedSPnode::getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">subpavings::RealMappedSPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
     <span class="comment">//push back this box into the BoxVector</span>
     BoxVector.push_back(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>());
     
     <span class="comment">//get the heights</span>
     <a class="code" href="classsubpavings_1_1RangeCollectionClass.shtml" title="A class for range collection objects.">RangeCollectionClass&lt;real&gt;</a> myContainer;
     myContainer = thisNodePtr-&gt;getRangeCollection();
     myContainer.<a class="code" href="classsubpavings_1_1RangeCollectionClass.shtml#a14b0dd04add88d021dc3a67a3a1c8656">getHeight</a>(HeightsVector);
  }
  <span class="comment">//recurse on the children</span>
  <span class="keywordflow">if</span> (thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#a071c6769f9c807ff0719ce7470b94a86">getHeightAndBox</a>(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>(), BoxVector, HeightsVector);
  }
   <span class="keywordflow">if</span> (thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#a071c6769f9c807ff0719ce7470b94a86">getHeightAndBox</a>(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>(), BoxVector, HeightsVector);
   }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="MappedSPSamplingScheffe.cpp::main" ref="a0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ImageSetDiff_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml#l00162">162</a> of file <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml">MappedSPSamplingScheffe.cpp</a>.</p>

<p>References <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">subpavings::MappedSPnode&lt; T &gt;::allocateRanges()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00116">DrawUnifBox()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00238">RSSample::EnvelopeIntegral</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00018">Height</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00245">RSSample::IntegralEstimate()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00260">RSSample::Mean()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00118">normHeights()</a>, <a class="el" href="Ex1D_8cpp_source.shtml#l00021">output()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, <a class="el" href="MRSampler_8cpp_source.shtml#l00354">MRSampler::RejectionSampleMany()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00241">RSSample::Samples</a>, and <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00017">Tinverse</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//===========user-defined parameters==============================//</span>
  <span class="keywordflow">if</span> ( argc != 7 ) {
    cerr &lt;&lt; <span class="stringliteral">&quot;Syntax: MappedFunctions n dataSeed dims lb ub critLeaves maxCheck approxLeaves&quot;</span> &lt;&lt; endl;
    exit(0);
  }

  <span class="comment">//user inputs</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = atoi(argv[1]); <span class="comment">//number of points</span>
  <span class="keywordtype">long</span> <span class="keywordtype">int</span> dataSeed = atoi(argv[2]); <span class="comment">//seed for generating data</span>
  <span class="keywordtype">int</span> simNum = dataSeed;
  <span class="keywordtype">int</span> dims = atoi(argv[3]); <span class="comment">//which data set </span>

 
  <span class="keywordtype">size_t</span> critLeaves = atoi(argv[4]);

  <span class="keywordtype">int</span> maxCheck = atoi(argv[5]);
  
  <span class="keywordtype">int</span> approxLeaves = atoi(argv[6]);

  <span class="comment">//string formatting</span>
  ofstream oss;         <span class="comment">// ofstream object</span>
  oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
  oss.precision(10);

  <span class="comment">//=========================end of setting up parameter===================//</span>

<span class="comment">//=========set up to estimate the function==============================// </span>
  <span class="comment">// Function object</span>
  <a class="code" href="classGaussianFobj1D.shtml">GaussianFobj1D</a> realF;
<span class="comment">//   GaussianFobj2D realF;</span>
<span class="comment">//   GaussianFobj10D realF;</span>
  <span class="comment">//RosenFobj2D realF;  </span>
  <span class="comment">//RosenFobj10D realF;</span>

  <span class="comment">//make a root box</span>
  ivector pavingBox(dims);
  interval pavingInterval(-5,5);
  <span class="comment">//interval pavingInterval(-2,3);</span>
  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=1; k &lt;= dims; k++) pavingBox[k] = pavingInterval;

   <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> nodeEst(pavingBox); <span class="comment">// make a MappedSPnode object</span>
    <span class="comment">// estimate the function</span>
   <a class="code" href="classsubpavings_1_1MappedSPnodeVisitorExpand.shtml">MappedSPnodeVisitorExpand</a> expander(realF, 0);
   vector&lt;real&gt; eps;
   nodeEst.priorityAccept(expander, approxLeaves, eps);
   cout &lt;&lt; <span class="stringliteral">&quot;Estimate function has &quot;</span> &lt;&lt; nodeEst.getNumLeaves() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
   
   <span class="comment">//output to .txt  </span>
   <span class="keywordtype">string</span> thefilename = <span class="stringliteral">&quot;EstFunction.txt&quot;</span>;
   <a class="code" href="Ex1D_8cpp.shtml#a91337b8216794ab4371528e4d8f07aa2">output</a>(thefilename, nodeEst);
  <span class="comment">//=======================================================================//</span>
  
  <span class="comment">//==================Get the weights of the boxes=========================//</span>
   cout &lt;&lt; <span class="stringliteral">&quot;Getting boxes and weights:&quot;</span> &lt;&lt; endl;
    vector&lt;ivector&gt; BoxVector;
   vector&lt;real&gt; HeightsVector;
   <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* nodePtr;
   nodePtr = &amp;nodeEst;
   vector&lt;double&gt;* WeightsVectorPtr;
   WeightsVectorPtr = <span class="keyword">new</span> vector&lt;double&gt;;
   vector&lt;interval&gt;* WeightsIntPtr;
   WeightsIntPtr = <span class="keyword">new</span> vector&lt;interval&gt;;
   
   <span class="comment">// iterate through the leaf nodes to get boxes and heights and weights</span>
   <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#a071c6769f9c807ff0719ce7470b94a86">getHeightAndBox</a>(nodePtr, BoxVector, HeightsVector);
   <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#ad413fb4b470884bbd346547f10dd5b67">getAllWeights</a>(nodePtr, *WeightsVectorPtr, *WeightsIntPtr);
   
   <span class="comment">//now put elements of WeightsVector into an array of doubles</span>
   <span class="keywordtype">size_t</span> sizeWeight =(*WeightsVectorPtr).size();
   <span class="comment">//check that number of boxes &lt; 10^6</span>
   <span class="keywordflow">if</span> (sizeWeight &gt; <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(10,7)) { 
      cerr &lt;&lt; <span class="stringliteral">&quot;Too many boxes (&quot;</span> &lt;&lt; sizeWeight &lt;&lt; <span class="stringliteral">&quot;).&quot;</span> &lt;&lt; endl;
      exit(1);
   }

  <span class="comment">// normalize using heights</span>
  interval areaInt = interval(0);
   <span class="comment">//normalize the heights so that the function integrates to 1</span>
   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; sizeWeight; i++) {
    areaInt = areaInt + (*WeightsIntPtr)[i];
    
    <span class="comment">//cout &lt;&lt; (*WeightsVectorPtr)[i] &lt;&lt; &quot;\t&quot; &lt;&lt; (*WeightsIntPtr)[i] &lt;&lt; endl;</span>
   }
  cout &lt;&lt; <span class="stringliteral">&quot;Total area: &quot;</span> &lt;&lt; mid(areaInt) &lt;&lt; endl; 
   
   <span class="keywordtype">double</span> totalArea = _double(mid(areaInt));
   
   <span class="comment">// very important - normalize the heights in nodeEst</span>
   vector&lt; RangeCollectionClass&lt;real&gt; &gt;* heightNorm = <span class="keyword">new</span> vector&lt; RangeCollectionClass&lt;real&gt; &gt;;
   <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#aaccdd027128215abfb51d30ca3bfc190">normHeights</a>(nodePtr, totalArea, *heightNorm);
   nodeEst.allocateRanges(*heightNorm, 0);
   <span class="keywordtype">string</span> filename = <span class="stringliteral">&quot;EstFunctionAfterNormalized.txt&quot;</span>;
   <a class="code" href="Ex1D_8cpp.shtml#a91337b8216794ab4371528e4d8f07aa2">output</a>(filename, nodeEst);
   
   <span class="comment">//need to check that the weights equal to 1</span>
   <span class="keywordtype">double</span> densityCheck = 0.0;
    <span class="comment">//convert vector to array</span>
   <span class="keywordtype">double</span> WeightsArray[sizeWeight];
   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; sizeWeight; i++) {
      WeightsArray[i] = (*WeightsVectorPtr)[i];
      densityCheck += (*WeightsVectorPtr)[i]/totalArea;
   }
   
  cout &lt;&lt; <span class="stringliteral">&quot;Total area after normalizing: &quot;</span> &lt;&lt; densityCheck &lt;&lt; endl;
  <span class="comment">/*</span>
<span class="comment">  if ( (densityCheck != 1.0) ) {</span>
<span class="comment">    cout &lt;&lt; densityCheck &lt;&lt; endl; </span>
<span class="comment">    cerr &lt;&lt; &quot;Function does not integrate to 1. Need to normalize.&quot; &lt;&lt; endl; </span>
<span class="comment">    exit(0); </span>
<span class="comment">  }</span>
<span class="comment">  */</span>
  
   <span class="comment">//return to the system the memory that was pointed to by WeightsVectorPtr</span>
   <span class="comment">// and heightNorm</span>
   <span class="keyword">delete</span> WeightsVectorPtr;
   <span class="keyword">delete</span> heightNorm;
   
    <span class="comment">//now get the lookup table returned from gsl_ran_discrete_preproc</span>
   <span class="comment">//i.e. the box indices with their weights</span>
   gsl_ran_discrete_t* gslpdfstruct;
   gslpdfstruct = gsl_ran_discrete_preproc(sizeWeight, WeightsArray);

   <span class="comment">//===================end of getting box weights=======================//</span>

  <span class="comment">//===================generate data===================================</span>
  <span class="comment">// set up a random number generator to draw from weighted boxes</span>
  <span class="keyword">const</span> gsl_rng_type * T;
  gsl_rng * r;

  <span class="comment">//create a generator chosen by the environment variable GSL_RNG_TYPE</span>
  gsl_rng_env_setup();
  T = gsl_rng_default;
  r = gsl_rng_alloc (T);
  <span class="comment">// set a seed for the data</span>
  gsl_rng_set(r, dataSeed);

  <span class="comment">//now sample n data points from boxes given by the proposed indices</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Sample data points using weighted boxes:&quot;</span> &lt;&lt; endl;
  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> theData;   <span class="comment">// a container for all the points generated</span>
   <span class="comment">// make a simulated data set</span>
  <span class="comment">// data sampled as weighted-uniform-mixtures</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {
    rvector thisrv(dims);
    <span class="keywordtype">size_t</span> proposedIndex = gsl_ran_discrete(r, gslpdfstruct);
    <span class="comment">//int proposed_index = static_cast&lt;int&gt;(gsl_ran_discrete(r, gslpdfstruct));</span>
    thisrv = <a class="code" href="toolz_8cpp.shtml#abc84f170f624cc9d449c0cfcaac0f157" title="Draw a vector uniformly at pseudo-random from a Box.">DrawUnifBox</a>(r, BoxVector[proposedIndex]);
    <span class="comment">// put points generated into container</span>
    theData.push_back(thisrv);
  }  <span class="comment">// data  should be in theData</span>

    <span class="comment">// /* optional output for data</span>
    <span class="comment">//string dataFileName = &quot;FinMix&quot;;</span>
    <span class="comment">//dataFileName += mix.str();</span>
    <span class="keywordtype">string</span> dataFileName = <span class="stringliteral">&quot;MappedData&quot;</span>; 
    <span class="comment">//dataFileName += simNum.str();</span>
    dataFileName += <span class="stringliteral">&quot;.txt&quot;</span>; 
    oss.open(dataFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; i++) { 
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt;= dims; j++) {
            <span class="comment">//cout &lt;&lt; (*theData)[i][j] &lt;&lt; endl;</span>
          oss &lt;&lt; (theData)[i][j] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
        }
        oss &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      }
      oss &lt;&lt; flush;
      oss.close();
    <span class="comment">// */</span>

  <span class="comment">//================Setting up parameters for the Rosenbrock density========//</span>
   <span class="comment">//Parameters specific to the Rosenbrock target</span>
   <span class="comment">// set default values</span>
   <span class="keywordtype">int</span> n_dimensions = 2;
   <span class="keywordtype">int</span> n_boxes = 1000000;
   <span class="keywordtype">double</span> Alb = 1.0;<span class="comment">// partition until lower bound on Acceptance Prob. is &gt; Alb</span>
   <span class="comment">//Parameters specific to the Rosenbrock target</span>
   real <a class="code" href="RosenFobj2D_8cpp.shtml#aec5c4d9798cfa73539577e4a2206ab1a">Tinverse</a> = 1.0;
   real <a class="code" href="RosenFobj2D_8cpp.shtml#ab0eb64c1a8d085bcf238d947f3fa839f">Height</a> = 100.0;
   
   real RosenDomainLimit = 3.0;
   
  <span class="keywordtype">unsigned</span> theSeed =  1; 

<span class="comment">/*</span>
<span class="comment">   if (argc &gt;= 2) {</span>
<span class="comment">         sscanf (argv[1], &quot;%i&quot;, &amp;n_dimensions);</span>
<span class="comment">         if (argc &gt;= 3) {</span>
<span class="comment">            sscanf (argv[2], &quot;%i&quot;, &amp;n_boxes);</span>
<span class="comment">            if (argc &gt;= 4) sscanf (argv[3], &quot;%i&quot;, &amp;n_samples);</span>
<span class="comment">            if (argc &gt;= 5) sscanf (argv[4], &quot;%ui&quot;, &amp;theSeed);</span>
<span class="comment">            if (argc &gt;= 6)</span>
<span class="comment">            cout &lt;&lt; &quot;# Usage: MRS &lt;n_dimensions&gt; &lt;n_boxes&gt; &lt;n_samples&gt; &lt;seed&gt;; &quot;</span>
<span class="comment">             &lt;&lt; &quot;extra arguments ignored.\n&quot;;</span>
<span class="comment">         }</span>
<span class="comment">         else </span>
<span class="comment">         cout &lt;&lt; &quot;# Usage: MRS &lt;n_dimensions&gt; &lt;n_boxes&gt; &lt;n_samples&gt; &lt;seed&gt;; &quot;</span>
<span class="comment">                 &lt;&lt; &quot;extra arguments ignored.\n&quot;;</span>
<span class="comment">      }*/</span>
      
     cout &lt;&lt; <span class="stringliteral">&quot;# n_dimensions: &quot;</span> &lt;&lt; n_dimensions &lt;&lt; <span class="stringliteral">&quot;  n_boxes: &quot;</span> &lt;&lt; n_boxes
        &lt;&lt; <span class="stringliteral">&quot;  n: &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;  rng_seed = &quot;</span> &lt;&lt; theSeed
        &lt;&lt; endl; <span class="comment">//getchar();</span>
      <span class="keywordtype">bool</span> UseLogPi = <span class="keyword">false</span>; <span class="comment">// log scale won&#39;t work naively</span>
      <span class="keywordtype">bool</span> use_f_scale = <span class="keyword">false</span>;
      <span class="comment">// make the function object</span>
      <a class="code" href="classFRosenbrock.shtml" title="n-dimensional Rosenbrock density as a function object class">FRosenbrock</a> FRosen (n_dimensions, Tinverse, Height, RosenDomainLimit, UseLogPi);
      <span class="comment">// produce the samples</span>
      <a class="code" href="classMRSampler.shtml" title="The Moore rejection sampler class for trans-dimensional targets over labeled metric spaces...">MRSampler</a> theSampler (FRosen, n_boxes, Alb, theSeed, (use_f_scale == 1));
    <a class="code" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> rs_sample;
    cout &lt;&lt; <span class="stringliteral">&quot;before Rej..SampleMany \n&quot;</span>;
    cout &lt;&lt; <span class="stringliteral">&quot;n_samples: &quot;</span> &lt;&lt; n &lt;&lt; endl;
    theSampler.RejectionSampleMany (n, rs_sample);
    cout &lt;&lt; <span class="stringliteral">&quot;after Rej..SampleMany \n&quot;</span>;
    <span class="keywordtype">double</span> IntegralEstimate = _double (rs_sample.<a class="code" href="classRSSample.shtml#a9537562ed9b4bc945e4c92b2237732a8" title="A real estimate of the integral of the function over the domain.">IntegralEstimate</a> ());
    cout &lt;&lt; <span class="stringliteral">&quot;rs_sample IU, N, Nrs: &quot;</span> &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#aa3f52ce941256fc7d6cf71347fdfa67c" title="The envelope integral as a cxsc::real.">EnvelopeIntegral</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
        &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.size() &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;RSSampleMany, integral est: &quot;</span> &lt;&lt; IntegralEstimate &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;RSSampleMany mean: \n&quot;</span>; rs_sample.<a class="code" href="classRSSample.shtml#a6e553a95e36dbecd6f0491bf71c6a761" title="Arithmetic mean of the sampled labeled points in a label-specific way.">Mean</a> ();

    vector&lt;LabPnt&gt;::iterator LabPntIt; <span class="comment">//to iterate over labData.Samples</span>
    dataFileName = <span class="stringliteral">&quot;Data.txt&quot;</span>;
    oss.open(dataFileName.c_str());
    <span class="keywordflow">for</span> (LabPntIt = rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.begin(); LabPntIt &lt; rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.end();
          LabPntIt++) {
        (*LabPntIt).Print(oss);
    }
    oss &lt;&lt; flush;
    oss.close();
    
  <span class="comment">//==================Hold-out MDE===========================================</span>
  
  <span class="comment">/*</span>
<span class="comment">  cout &lt;&lt; &quot;========================================================&quot; &lt;&lt; endl;</span>
<span class="comment">  cout &lt;&lt; &quot;Run hold out estimation...&quot; &lt;&lt; endl;</span>
<span class="comment"></span>
<span class="comment">  //=========insert data into an AdaptiveHistogramValidation object=========//</span>
<span class="comment">  //containers for output needed</span>
<span class="comment">  vector&lt;real&gt; IAEV;</span>
<span class="comment">  vector&lt;int&gt; NumLeafNodesV;</span>
<span class="comment">  vector&lt;double&gt; timings;</span>
<span class="comment">  double timing = 0;</span>
<span class="comment">  </span>
<span class="comment">  </span>
<span class="comment">  // stopping criteria </span>
<span class="comment">  bool stopCrit = true; // to remove this?</span>
<span class="comment"></span>
<span class="comment">  //maximum number of leaf nodes allowed</span>
<span class="comment">  int holdOutCount = int(n/3);</span>
<span class="comment">  int trainCount = n-holdOutCount; </span>
<span class="comment">  cout &lt;&lt; n-holdOutCount &lt;&lt; &quot; training data and &quot; </span>
<span class="comment">      &lt;&lt; holdOutCount &lt;&lt; &quot; validation data inserted.&quot; &lt;&lt; endl; </span>
<span class="comment">  size_t maxLeafNodes = 1500;</span>
<span class="comment">//  size_t maxLeafNodes = int(trainCount/log(trainCount*(2*dims+1))); // temporarily</span>
<span class="comment">  //size_t maxLeafNodes = 50;</span>
<span class="comment">  //cout &lt;&lt; &quot;max leaf nodes: &quot; &lt;&lt; maxLeafNodes &lt;&lt; endl;</span>
<span class="comment"></span>
<span class="comment">  // indicators</span>
<span class="comment">   bool successfulInsertion1 = false;</span>
<span class="comment">   bool successfulInsertion2 = false;</span>
<span class="comment">   bool successfulInsertion3 = false;</span>
<span class="comment">   bool successfulInsertion4 = false;</span>
<span class="comment">   bool successfulInsertion5 = false;</span>
<span class="comment">   bool successfulInsertion6 = false;</span>
<span class="comment">   bool successfulInsertion7 = false;</span>
<span class="comment">   bool successfulInsertion8 = false;</span>
<span class="comment">   </span>
<span class="comment">   </span>
<span class="comment">   bool successfulPQSplit1 = false;</span>
<span class="comment">   bool successfulPQSplit2 = false;</span>
<span class="comment">   bool successfulPQSplit3 = false;</span>
<span class="comment">   bool successfulPQSplit4 = false;</span>
<span class="comment">   bool successfulPQSplit5 = false;</span>
<span class="comment">   bool successfulPQSplit6 = false;</span>
<span class="comment">   bool successfulPQSplit7 = false;</span>
<span class="comment">   bool successfulPQSplit8 = false;</span>
<span class="comment">   </span>
<span class="comment">   </span>
<span class="comment">   // comparison objects</span>
<span class="comment">   CompCountVal compCount;</span>
<span class="comment">   CompVolVal compVol;</span>
<span class="comment">   CompAreaVal compArea;</span>
<span class="comment">   CompMeanMassVal compMeanMass;</span>
<span class="comment">   CompCovarVal compCovarMass;</span>
<span class="comment">   CompHellingerDistMassVal compH;</span>
<span class="comment">   CompHellingerDistMassDiamVal compHD;</span>
<span class="comment">   SplitNever sn;   </span>
<span class="comment">  bool holdAllStats = true;</span>
<span class="comment">  </span>
<span class="comment">  int finalK = 1;</span>
<span class="comment">  //CritLargestCount_LTEV critCount(finalK);</span>
<span class="comment">  size_t minChildPoints = 0;</span>
<span class="comment">  CritLeaves_GTEV critCount(critLeaves);</span>
<span class="comment"></span>
<span class="comment">  //container for scheffe tournament candidates</span>
<span class="comment">  vector&lt;AdaptiveHistogramValidation&gt; optHist;</span>
<span class="comment"></span>
<span class="comment">  cout &lt;&lt; &quot;PQ1&quot; &lt;&lt; endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal1(pavingBox);</span>
<span class="comment">  AdaptiveHistogramValidation optHist1(pavingBox);</span>
<span class="comment">  int m = 1;</span>
<span class="comment">  successfulInsertion1 = myHistVal1.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment">  if (successfulInsertion1) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    successfulPQSplit1 = myHistVal1.prioritySplitAndEstimate(compCount, </span>
<span class="comment">                        critCount, NOLOG, minChildPoints, </span>
<span class="comment">                         0.0, stopCrit, nodeEst, m, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck, optHist1);</span>
<span class="comment">    end = clock();</span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit1) { </span>
<span class="comment">      optHist1.outputToTxtTabs(&quot;HistPQ1.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist1); timings.push_back(timing);}</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;\nPQ2 &quot; &lt;&lt; endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal2(pavingBox);</span>
<span class="comment">  AdaptiveHistogramValidation optHist2(pavingBox);   </span>
<span class="comment">  m=2;</span>
<span class="comment">  successfulInsertion2 = myHistVal2.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment">  if (successfulInsertion2) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    successfulPQSplit2 = myHistVal2.prioritySplitAndEstimate(compVol, </span>
<span class="comment">                        critCount, NOLOG, </span>
<span class="comment">                         0, 0.0, stopCrit, nodeEst, m, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck, optHist2);</span>
<span class="comment">    end = clock();  </span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit2) { </span>
<span class="comment">      optHist2.outputToTxtTabs(&quot;HistPQ2.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist2); timings.push_back(timing); }</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;\nPQ3&quot; &lt;&lt; endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal3(pavingBox);   </span>
<span class="comment">  AdaptiveHistogramValidation optHist3(pavingBox);</span>
<span class="comment">  successfulInsertion3 = myHistVal3.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment">  if (successfulInsertion3) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    successfulPQSplit3 = myHistVal3.prioritySplitAndEstimateWithSwitch(compVol, </span>
<span class="comment">                        critCount, NOLOG, </span>
<span class="comment">                         0, 0.0, stopCrit, nodeEst, 3, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck, optHist3);</span>
<span class="comment">    end = clock();  </span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit3) { </span>
<span class="comment">      optHist3.outputToTxtTabs(&quot;HistPQ3.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist3); timings.push_back(timing);}</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;\nPQ4&quot; &lt;&lt; endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal4(pavingBox);</span>
<span class="comment">  AdaptiveHistogramValidation optHist4(pavingBox);</span>
<span class="comment">  successfulInsertion4 = myHistVal4.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment"></span>
<span class="comment">  if (successfulInsertion4) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    successfulPQSplit4 = myHistVal4.prioritySplitAndEstimateWithSwitch(compArea, </span>
<span class="comment">                        critCount, NOLOG, </span>
<span class="comment">                         0, 0.0, stopCrit, nodeEst, 4, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck,  optHist4);</span>
<span class="comment">    end = clock();  </span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit4) { </span>
<span class="comment">      optHist4.outputToTxtTabs(&quot;HistPQ4.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist4); timings.push_back(timing);}</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;\nPQ5&quot; &lt;&lt;  endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal5(pavingBox, holdAllStats);   </span>
<span class="comment">  AdaptiveHistogramValidation optHist5(pavingBox, holdAllStats);</span>
<span class="comment">  successfulInsertion5 = myHistVal5.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment">  //cout &lt;&lt; myHistVal5.getHoldAllStats() &lt;&lt; endl;</span>
<span class="comment">  //cout &lt;&lt; myHistVal5.getSubPaving() &lt;&lt; endl;</span>
<span class="comment">  if (successfulInsertion5) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    int m = 5;</span>
<span class="comment">    successfulPQSplit5 = myHistVal5.prioritySplitAndEstimateWithSwitch(compMeanMass, </span>
<span class="comment">                        critCount, NOLOG, </span>
<span class="comment">                         minChildPoints, 0.0, stopCrit, nodeEst, m, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck, optHist5);</span>
<span class="comment"> </span>
<span class="comment">    end = clock();  </span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit5) { </span>
<span class="comment">      optHist5.outputToTxtTabs(&quot;HistPQ5.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist5); timings.push_back(timing);</span>
<span class="comment">    }</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;\nPQ6&quot; &lt;&lt; endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal6(pavingBox, holdAllStats); </span>
<span class="comment">  AdaptiveHistogramValidation  optHist6(pavingBox, holdAllStats);</span>
<span class="comment">  successfulInsertion6 = myHistVal6.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment">  if (successfulInsertion6) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    successfulPQSplit6 = myHistVal6.prioritySplitAndEstimateWithSwitch(compCovarMass, </span>
<span class="comment">                        critCount, NOLOG, </span>
<span class="comment">                         0, 0.0, stopCrit, nodeEst, 6, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck, optHist6);</span>
<span class="comment">    end = clock();  </span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit6) { </span>
<span class="comment">      optHist6.outputToTxtTabs(&quot;HistPQ6.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist6); timings.push_back(timing); }</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;\nPQ7&quot; &lt;&lt; endl &lt;&lt; endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal7(pavingBox, holdAllStats); </span>
<span class="comment">  AdaptiveHistogramValidation optHist7(pavingBox, holdAllStats);</span>
<span class="comment">  </span>
<span class="comment">  successfulInsertion7 = myHistVal7.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment">  if (successfulInsertion7) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    successfulPQSplit7 = myHistVal7.prioritySplitAndEstimateWithSwitch(compH, </span>
<span class="comment">                        critCount, NOLOG, </span>
<span class="comment">                         0, 0.0, stopCrit, nodeEst, 7, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck, optHist7);</span>
<span class="comment">    end = clock();  </span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit7) { </span>
<span class="comment">      optHist7.outputToTxtTabs(&quot;HistPQ7.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist7); timings.push_back(timing);}</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;\nPQ8&quot; &lt;&lt; endl;</span>
<span class="comment">  // Put the data from the container into the histogram  </span>
<span class="comment">  AdaptiveHistogramValidation myHistVal8(pavingBox, holdAllStats);</span>
<span class="comment">  AdaptiveHistogramValidation optHist8(pavingBox, holdAllStats);</span>
<span class="comment">  successfulInsertion8 = myHistVal8.insertFromRVecForHoldOut(theData, sn, holdOutCount, NOLOG);</span>
<span class="comment">  if (successfulInsertion8) {</span>
<span class="comment">    clock_t start, end;</span>
<span class="comment">    start = clock();</span>
<span class="comment">    successfulPQSplit8 = myHistVal8.prioritySplitAndEstimateWithSwitch(compHD, </span>
<span class="comment">                        critCount, NOLOG, </span>
<span class="comment">                         0, 0.0, stopCrit, nodeEst, 8, simNum, </span>
<span class="comment">                         maxLeafNodes, maxCheck, optHist8);</span>
<span class="comment">    end = clock();  </span>
<span class="comment">    timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">    cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">    if (successfulPQSplit8) { </span>
<span class="comment">      optHist8.outputToTxtTabs(&quot;HistPQ8.txt&quot;);</span>
<span class="comment">      optHist.push_back(optHist8); timings.push_back(timing);}</span>
<span class="comment">  }</span>
<span class="comment">  </span>
<span class="comment">//================start the Scheffe tournament======================//</span>
<span class="comment">//  if (successfulPQSplit1 &amp;&amp; successfulPQSplit2 &amp;&amp; successfulPQSplit3 &amp;&amp;</span>
<span class="comment">//    successfulPQSplit4 &amp;&amp; successfulPQSplit5 &amp;&amp; successfulPQSplit6 &amp;&amp;</span>
<span class="comment">//    successfulPQSplit7 &amp;&amp; successfulPQSplit8) {</span>
<span class="comment"></span>
<span class="comment">  ofstream os;         // ofstream object</span>
<span class="comment">  os &lt;&lt; scientific;  // set formatting for input to oss</span>
<span class="comment">  os.precision(5);</span>
<span class="comment"></span>
<span class="comment">  vector&lt;real&gt; TrueDelta;</span>
<span class="comment">  AdaptiveHistogramVCollator coll;</span>
<span class="comment">  size_t agg = 0;</span>
<span class="comment">  vector&lt;real&gt; IAEMDE;</span>
<span class="comment">  vector&lt;real&gt; IAEMDEFull;</span>
<span class="comment"></span>
<span class="comment">  for (size_t i = 0; i &lt; optHist.size(); i++) {</span>
<span class="comment">    IAEMDE.push_back(optHist[i].getMappedFunctionIAE(nodeEst, 0));</span>
<span class="comment">    IAEMDEFull.push_back(optHist[i].getMappedFunctionIAE(nodeEst, 1));</span>
<span class="comment">    coll.addToCollationWithVal(optHist[i], 1, agg);</span>
<span class="comment">  }</span>
<span class="comment"></span>
<span class="comment">  cout &lt;&lt; &quot;Get the Yatracos set for theorem checks: &quot; &lt;&lt; endl;</span>
<span class="comment">  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecYatSet;</span>
<span class="comment"></span>
<span class="comment">  vector&lt;double&gt; maxDelta;</span>
<span class="comment">  vector&lt;double&gt;::iterator it;</span>
<span class="comment">  clock_t start, end;</span>
<span class="comment">  start = clock();</span>
<span class="comment">  coll.getMinDistEst(maxDelta, vecYatSet);</span>
<span class="comment">  end = clock();  </span>
<span class="comment">  timing = ((static_cast&lt;double&gt;(end - start)) / CLOCKS_PER_SEC);</span>
<span class="comment">  cout &lt;&lt; &quot;Computing time : &quot; &lt;&lt; timing &lt;&lt; &quot; s.&quot;&lt;&lt; endl;</span>
<span class="comment">  timings.push_back(timing);  </span>
<span class="comment">  </span>
<span class="comment">  double minMaxDelta = 100;</span>
<span class="comment">  real minMinIAE = 100;</span>
<span class="comment">  int minPosIAE; </span>
<span class="comment">  int minPosDelta;</span>
<span class="comment">  </span>
<span class="comment">  for (size_t i = 0; i &lt; coll.getNumberCollated(); i++) {</span>
<span class="comment">    cout &lt;&lt; maxDelta[i] &lt;&lt; &quot;\t&quot; &lt;&lt; IAEMDE[i] &lt;&lt; endl;</span>
<span class="comment">    if (maxDelta[i] &lt; minMaxDelta) { minPosDelta = i+1; minMaxDelta = maxDelta[i]; }</span>
<span class="comment">    if (IAEMDE[i] &lt; minMinIAE) { minPosIAE = i+1; minMinIAE = IAEMDE[i]; }</span>
<span class="comment">  }</span>
<span class="comment"></span>
<span class="comment">  cout &lt;&lt; &quot;Min IAE at candidate &quot; &lt;&lt; minPosIAE &lt;&lt; endl;</span>
<span class="comment">  cout &lt;&lt; &quot;Min delta max at candidate &quot; &lt;&lt; minPosDelta &lt;&lt; endl;</span>
<span class="comment"></span>
<span class="comment">  //get the true Delta</span>
<span class="comment">  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt;::iterator vecYatSetIt;</span>
<span class="comment">  real trueDelta = 0.0;</span>
<span class="comment">  if (!vecYatSet.empty()) {</span>
<span class="comment">    for (vecYatSetIt = vecYatSet.begin(); vecYatSetIt &lt; vecYatSet.end(); vecYatSetIt++) {</span>
<span class="comment">      real trueDeltaR = getMappedFunctionTrueDelta(nodeEst, *vecYatSetIt);</span>
<span class="comment">      trueDeltaR = abs(trueDeltaR);</span>
<span class="comment">      //cout &lt;&lt; trueDeltaR &lt;&lt; &quot;\t&quot;;</span>
<span class="comment">      trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;</span>
<span class="comment">      //cout &lt;&lt; trueDelta &lt;&lt; endl; </span>
<span class="comment">    }</span>
<span class="comment">    cout &lt;&lt; &quot;Delta over the Yatracos set: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
<span class="comment">  }</span>
<span class="comment">  else { trueDelta = -1; }</span>
<span class="comment">  </span>
<span class="comment">  ostringstream stm;</span>
<span class="comment">  stm &lt;&lt; simNum;</span>
<span class="comment">  string deltaFile;</span>
<span class="comment">  deltaFile = &quot;TrueDeltaAll&quot;;</span>
<span class="comment">  deltaFile += stm.str();</span>
<span class="comment">  deltaFile += &quot;.txt&quot;;</span>
<span class="comment">  os.open(deltaFile.c_str());</span>
<span class="comment">  os &lt;&lt; trueDelta &lt;&lt; endl;</span>
<span class="comment">  os &lt;&lt; flush;</span>
<span class="comment">  os.close();</span>
<span class="comment"></span>
<span class="comment"></span>
<span class="comment">  string IAEMDEFile = &quot;IAEMDEandDeltaMax&quot;;</span>
<span class="comment">  IAEMDEFile += stm.str();</span>
<span class="comment">  IAEMDEFile += &quot;.txt&quot;;</span>
<span class="comment">  os.open(IAEMDEFile.c_str());</span>
<span class="comment">  for (size_t i = 0; i &lt; IAEMDE.size(); i++) {</span>
<span class="comment">    os &lt;&lt; IAEMDE[i] &lt;&lt; &quot;\t&quot; &lt;&lt; IAEMDEFull[i] &lt;&lt; &quot;\t&quot; &lt;&lt; maxDelta[i] &lt;&lt; endl;</span>
<span class="comment">  }</span>
<span class="comment">  os &lt;&lt; flush;</span>
<span class="comment">  os.close();</span>
<span class="comment"></span>
<span class="comment">  string TimeFile = &quot;Times&quot;;</span>
<span class="comment">  TimeFile += stm.str();</span>
<span class="comment">  TimeFile += &quot;.txt&quot;;</span>
<span class="comment">  os.open(TimeFile.c_str());</span>
<span class="comment">  for (size_t i = 0; i &lt; timings.size(); i++) {</span>
<span class="comment">    os &lt;&lt; timings[i] &lt;&lt; endl;</span>
<span class="comment">  }</span>
<span class="comment">  os &lt;&lt; flush;</span>
<span class="comment">  os.close();</span>
<span class="comment">*/</span>
  <span class="comment">// free the random number generator</span>
  gsl_rng_free (r);  
  gsl_ran_discrete_free (gslpdfstruct);

  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaccdd027128215abfb51d30ca3bfc190"></a><!-- doxytag: member="MappedSPSamplingScheffe.cpp::normHeights" ref="aaccdd027128215abfb51d30ca3bfc190" args="(RealMappedSPnode *thisNodePtr, double totalArea, vector&lt; RangeCollectionClass&lt; real &gt; &gt; &amp;heightNorm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="MappedSPSamplingTest_8cpp.shtml#aaccdd027128215abfb51d30ca3bfc190">normHeights</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *&#160;</td>
          <td class="paramname"><em>thisNodePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>totalArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classsubpavings_1_1RangeCollectionClass.shtml">RangeCollectionClass</a>&lt; real &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>heightNorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml#l00141">141</a> of file <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml">MappedSPSamplingScheffe.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">subpavings::RealMappedSPnode::getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">subpavings::RealMappedSPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00118">normHeights()</a>, and <a class="el" href="rangecollection_8hpp_source.shtml#l00426">subpavings::RangeCollectionClass&lt; T &gt;::normNodeHeight()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) ) { <span class="comment">// this is non-empty</span>
     <a class="code" href="classsubpavings_1_1RangeCollectionClass.shtml" title="A class for range collection objects.">RangeCollectionClass&lt;real&gt;</a> myContainer;
     myContainer = thisNodePtr-&gt;getRangeCollection();
     real newHeight = myContainer.<a class="code" href="classsubpavings_1_1RangeCollectionClass.shtml#a4a8632e2e2f9f9743256c7dbaa7a7529">normNodeHeight</a>(totalArea);
     
     <a class="code" href="classsubpavings_1_1RangeCollectionClass.shtml" title="A class for range collection objects.">RangeCollectionClass&lt;real&gt;</a> height(newHeight);
    heightNorm.push_back(height);
  }
  <span class="comment">//recurse on the children</span>
  <span class="keywordflow">if</span> (thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#aaccdd027128215abfb51d30ca3bfc190">normHeights</a>(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>(), totalArea, heightNorm);
  }
   <span class="keywordflow">if</span> (thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="MappedFiniteMixtureLeafCounts_8cpp.shtml#aaccdd027128215abfb51d30ca3bfc190">normHeights</a>(thisNodePtr-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>(), totalArea, heightNorm);
   }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a91337b8216794ab4371528e4d8f07aa2"></a><!-- doxytag: member="MappedSPSamplingScheffe.cpp::output" ref="a91337b8216794ab4371528e4d8f07aa2" args="(string &amp;filename, const SPnode &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="MappedSPSamplingTest_8cpp.shtml#a91337b8216794ab4371528e4d8f07aa2">output</a> </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml#l00082">82</a> of file <a class="el" href="MappedSPSamplingScheffe_8cpp_source.shtml">MappedSPSamplingScheffe.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00923">subpavings::SPnode::leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="comment">// To generate a file output</span>
   ofstream os(filename.c_str());         <span class="comment">// Filename, c-string version</span>
   <span class="keywordflow">if</span> (os.is_open()) {
      node.<a class="code" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">leavesOutputTabs</a>(os); <span class="comment">// the output</span>
      std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the estimated function&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot; has been written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;
         os.close();
      }
   <span class="keywordflow">else</span> {
      std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
         &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;
   }
}
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="MappedSPSamplingScheffe_8cpp.shtml">MappedSPSamplingScheffe.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:21 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
