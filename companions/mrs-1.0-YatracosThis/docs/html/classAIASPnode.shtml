<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: AIASPnode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classAIASPnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">AIASPnode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="AIASPnode" -->
<p>AIASubPaving node class.  
 <a href="classAIASPnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for AIASPnode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classAIASPnode__coll__graph.png" border="0" usemap="#AIASPnode_coll__map" alt="Collaboration graph"/></div>
<map name="AIASPnode_coll__map" id="AIASPnode_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classAIASPnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194">AIASPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a69e70b41f415cb17b09690315320b194"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a71f172fa0bf3aba39084ea502f79f523">AIASPnode</a> (ivector &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized constructor.  <a href="#a71f172fa0bf3aba39084ea502f79f523"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a95c45cd98b8ffad6b1bec8bdbdf36c3a">AIASPnode</a> (const <a class="el" href="classAIASPnode.shtml">AIASPnode</a> &amp;n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a95c45cd98b8ffad6b1bec8bdbdf36c3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a57d10c2f272f0e78f1a72e4f5f548e77">~AIASPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a57d10c2f272f0e78f1a72e4f5f548e77"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143">theBox</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The interval vector the node represents.  <a href="#ab904c07918618a89d5511fbaf87f5143"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85">leftChild</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The node's left child.  <a href="#a64dc679fe03b03b7beb6ddb04b2a0f85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1">rightChild</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The node's right child.  <a href="#adbaa03014929ff2ab653d6d916ca2fc1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Friend functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>We have followed the implementation in [AIA2001, p. 336-348], which uses friend functions in order to give non-member functions access to the private data members of the class. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3">Box</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of theBox of an AIASubPaving. */.  <a href="#ae78ba41711edb725cf1ef43c27144be3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4">IsEmpty</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the AIASubPaving is empty.  <a href="#a1d5eb42dff486e08cf1cb54fa2a719a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807">IsLeaf</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the AIASubPaving is a leaf.  <a href="#a8528a3302f3cce257686222b065bb807"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume of an AIASubPaving.  <a href="#a7f6354ab5e7b1310b03f0e190169eabe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of leaves of an AIASubPaving.  <a href="#a6cc4fba2aef7df53e990c5348f84bd3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6">AIA_BOOL_INTERVAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a0869804e6aaefcc26aebe081061df6ad">operator&lt;=</a> (const ivector &amp;, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for containment of interval vector or box in the AIASubPaving.  <a href="#a0869804e6aaefcc26aebe081061df6ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#abf9101628f2ef58fbd1132a1c7086d06">operator&lt;&lt;</a> (std::ostream &amp;, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the contents of an AIASubPaving.  <a href="#abf9101628f2ef58fbd1132a1c7086d06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a7ca818aa239136500bfc1020684160de">Sivia</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ac3a2af016d66120f37b7e4b3da564876">AIA_PIBT</a> BoolTest, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Inversion Via Interval Analysis method taken from AIA2001.  <a href="#a7ca818aa239136500bfc1020684160de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to have two child nodes.  <a href="#aa3ceca06b6916b5ac1382a5aa8bf56aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7">ReUnite</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> lChild, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> rChild, ivector x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a minimal subpaving from two sibling subpavings.  <a href="#ad0b3998c79d0cbf91d21c550a6bb72e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mince up a subpaving.  <a href="#ab7921c5bd80f01985ee134c5d2ab595d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a1032a6cd48f87337e0980fe290c140b8">Evaluate</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a>, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, list&lt; ivector &gt; &amp;evalImages, ivector &amp;hull)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the image.  <a href="#a1032a6cd48f87337e0980fe290c140b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d">Regularize</a> (ivector &amp;hull, list&lt; ivector &gt; &amp;ivectorList, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a minimal image subpaving from a list of interval vector images.  <a href="#a1b1148d30745256482cbc7cca090253d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#aa860838286031ef8164937725092a2c2">ImageSp</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a>, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of an image subpaving (ImageSp) with Interval Analysis from AIA2001.  <a href="#aa860838286031ef8164937725092a2c2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74">volCompare</a> (const ivector &amp;a, const ivector &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare volumes of two boxes.  <a href="#a8713b30834070a586c0b99d9899f9b74"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>AIASubPaving node class. </p>
<p>A class based on the Sub-paving node class from [AIA2001, p. 336-348] implemented over C-XSC. <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> is a node in the tree representation of a regular subpaving. A node represents a box (interval vector). SPnodes are linked to children to form a binary tree. A subpaving of [<b>x</b>] (union of non-overlapping subboxes of [<b>x</b>]) is represented by the leaves (degenerate/ child-less) nodes in the tree. This class replicates the set computation functionality of the subpaving nodes developed in AIA2001. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00082">82</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a69e70b41f415cb17b09690315320b194"></a><!-- doxytag: member="AIASPnode::AIASPnode" ref="a69e70b41f415cb17b09690315320b194" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194">AIASPnode::AIASPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00094">94</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">leftChild</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">rightChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00086">theBox</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00029">AIASPnode()</a>.</p>
<div class="fragment"><pre class="fragment">      {<a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>=NULL; <a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>=NULL; <a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>=NULL;}
</pre></div>
</div>
</div>
<a class="anchor" id="a71f172fa0bf3aba39084ea502f79f523"></a><!-- doxytag: member="AIASPnode::AIASPnode" ref="a71f172fa0bf3aba39084ea502f79f523" args="(ivector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194">AIASPnode::AIASPnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialized constructor. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00098">98</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">leftChild</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">rightChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00086">theBox</a>.</p>
<div class="fragment"><pre class="fragment">      {<a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(v); <a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>=NULL; <a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>=NULL;}
</pre></div>
</div>
</div>
<a class="anchor" id="a95c45cd98b8ffad6b1bec8bdbdf36c3a"></a><!-- doxytag: member="AIASPnode::AIASPnode" ref="a95c45cd98b8ffad6b1bec8bdbdf36c3a" args="(const AIASPnode &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194">AIASPnode::AIASPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAIASPnode.shtml">AIASPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00029">29</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00094">AIASPnode()</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">leftChild</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">rightChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00086">theBox</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(*n.<a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>);
  <span class="comment">//recursion on the children</span>
  <span class="keywordflow">if</span> (n.<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>) <a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>=<span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(*n.<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>);
  <span class="keywordflow">else</span> <a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>=NULL;
  <span class="keywordflow">if</span> (n.<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>) <a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>=<span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(*n.<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>);
  <span class="keywordflow">else</span> <a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>=NULL;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a57d10c2f272f0e78f1a72e4f5f548e77"></a><!-- doxytag: member="AIASPnode::~AIASPnode" ref="a57d10c2f272f0e78f1a72e4f5f548e77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAIASPnode.shtml#a57d10c2f272f0e78f1a72e4f5f548e77">AIASPnode::~AIASPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00105">105</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">leftChild</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">rightChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00086">theBox</a>.</p>
<div class="fragment"><pre class="fragment">      {<span class="keyword">delete</span> <a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>; <span class="keyword">delete</span> <a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>; <span class="keyword">delete</span> <a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>;}
</pre></div>
</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ae78ba41711edb725cf1ef43c27144be3"></a><!-- doxytag: member="AIASPnode::Box" ref="ae78ba41711edb725cf1ef43c27144be3" args="(AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3">Box</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of theBox of an AIASubPaving. */. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00114">114</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>
<div class="fragment"><pre class="fragment">      { <span class="keywordflow">return</span> (*a-&gt;<a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>); }
</pre></div>
</div>
</div>
<a class="anchor" id="a1032a6cd48f87337e0980fe290c140b8"></a><!-- doxytag: member="AIASPnode::Evaluate" ref="a1032a6cd48f87337e0980fe290c140b8" args="(AIA_PIVF, AIASubPaving A, list&lt; ivector &gt; &amp;evalImages, ivector &amp;hull)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAIASPnode.shtml#a1032a6cd48f87337e0980fe290c140b8">Evaluate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; ivector &gt; &amp;&#160;</td>
          <td class="paramname"><em>evalImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate the image. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a pointer to an interval vector function which returns the image box under f of some interval vector </td></tr>
    <tr><td class="paramname">A</td><td>the node of the subpaving to be evaluated </td></tr>
    <tr><td class="paramname">evalImages</td><td>a container of image interval vectors </td></tr>
    <tr><td class="paramname">hull</td><td>the interval hull of the image interval vectors Fills in the list of images using f of the subpaving boxes and update the hull of all the images.</td></tr>
  </table>
  </dd>
</dl>
<p>Function to evaluate all the boxes in AIASubPaving. The images of all the boxes are formed and put into a list and the interval hull of the union of all the boxes is formed. Interval hull of a union is implemented under cxsc with | operator. Boxes are expected to have been created by <a class="el" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d" title="Mince up a subpaving.">Mince()</a>. The argument f is a pointer to an interval vector function AIA_PIVF (which returns an interval vector). AIASubPaving A is the AIASubPaving to be evaluated (should be const - it is not changed in this function). evalImages is the current list of images to be added to in the function call, hull is an ivector hull of images currently in the list which may be altered in this call if an image is added to list </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">365</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (A!=NULL &amp;&amp; <a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(A))
  {
    <span class="comment">// make an ivector image using the AIA_PIVF function f on Box(A)</span>
    ivector image = <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>(<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(A));

    <span class="comment">// if no images in image set yet, make hull the image</span>
    <span class="keywordflow">if</span> (evalImages.size() == 0) hull = image;
    <span class="comment">// if there are images in the image set, hull is the convex hull of</span>
    <span class="keywordflow">else</span> hull = (hull | image);
    <span class="comment">// the current hull and the ivector image from f(Box(A))</span>

    <span class="comment">// add the image to the list of images</span>
    evalImages.push_back(image);

  }                 <span class="comment">// end of is a leaf</span>

  <span class="comment">// if not a leaf, recursively call Evaluate on children</span>
  <span class="keywordflow">if</span> (A!=NULL &amp;&amp; !<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(A))
  {

    <a class="code" href="classAIASPnode.shtml#a1032a6cd48f87337e0980fe290c140b8" title="Evaluate the image.">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>, evalImages, hull);
    <a class="code" href="classAIASPnode.shtml#a1032a6cd48f87337e0980fe290c140b8" title="Evaluate the image.">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>, evalImages, hull);

  }                 <span class="comment">// end of if is not a leaf</span>

  <span class="comment">// case where A == NULL does nothing, just returns</span>
  <span class="keywordflow">return</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa3ceca06b6916b5ac1382a5aa8bf56aa"></a><!-- doxytag: member="AIASPnode::Expand" ref="aa3ceca06b6916b5ac1382a5aa8bf56aa" args="(AIASubPaving A, int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAIASPnode.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to have two child nodes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a pointer to the node to be expanded. </td></tr>
    <tr><td class="paramname">comp</td><td>is the dimension to split along. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">227</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// comp argument is passed to Upper() and Lower()</span>
  <span class="comment">// these functions split the box normal to direction set by comp</span>

  <span class="keywordflow">if</span> (!<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(A)) <span class="keywordflow">return</span>;
  ivector lC,rC;
  <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(A),lC,comp); <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(A), rC, comp);
  A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a> = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(lC);
  A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a> = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(rC);
  <span class="comment">//A-&gt;leftChild = new AIASPnode(Lower(Box(A),comp));</span>
  <span class="comment">//A-&gt;rightChild = new AIASPnode(Upper(Box(A),comp));</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa860838286031ef8164937725092a2c2"></a><!-- doxytag: member="AIASPnode::ImageSp" ref="aa860838286031ef8164937725092a2c2" args="(AIA_PIVF, AIASubPaving A, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classAIASPnode.shtml#aa860838286031ef8164937725092a2c2">ImageSp</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creation of an image subpaving (ImageSp) with Interval Analysis from AIA2001. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal regular subpaving coveringing the image of A under some function f </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a (*AIA_PIVF) which specifies the inclusion function of f and returns the inclusion function image [f][x] of an interval vector [x] </td></tr>
    <tr><td class="paramname">A</td><td>the subpaving for which we wish to find a subpaving covering the image under f </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed ImageSp uses <a class="el" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d" title="Mince up a subpaving.">Mince()</a> to chop up A and then <a class="el" href="classAIASPnode.shtml#a1032a6cd48f87337e0980fe290c140b8" title="Evaluate the image.">Evaluate()</a> and <a class="el" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d" title="Forms a minimal image subpaving from a list of interval vector images.">Regularize()</a> to find a regular minimal subpaving covering the set of images of the boxes of the minced A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00491">491</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  list&lt;ivector&gt; images;
  ivector hull;

  <a class="code" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d" title="Mince up a subpaving.">Mince</a>(A, eps);

  <span class="comment">//cout &lt;&lt; &quot;After mince &quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;A has volume  &quot; &lt;&lt; Volume (A) &lt;&lt; &quot; and number of leaves &quot;</span>
  <span class="comment">//  &lt;&lt; NbLeaves(A) &lt;&lt; endl;</span>

  <a class="code" href="classAIASPnode.shtml#a1032a6cd48f87337e0980fe290c140b8" title="Evaluate the image.">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, A, images, hull);

  <span class="comment">//cout &lt;&lt; &quot;After evaluate &quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;Size of image list is : &quot; &lt;&lt; images.size()</span>
  <span class="comment">//  &lt;&lt; &quot;  and hull has volume &quot; &lt;&lt; Volume(hull) &lt;&lt; endl;</span>

  <span class="comment">/* the output of eval is not included in the AIA examples, but it makes</span>
<span class="comment">  an interesting comparison to the final subpaving */</span>
  <span class="comment">// Filename</span>
  ofstream os2(<span class="stringliteral">&quot;eval.txt&quot;</span>);
  list&lt;ivector&gt;::iterator it;
  <span class="keywordflow">for</span> (it=images.begin(); it!=images.end(); it++)
  {
    ivector box = *it;
    os2 &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(box[1]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(box[1]) &lt;&lt; <span class="stringliteral">&quot; ] , [ &quot;</span>
      &lt;&lt; Inf(box[2]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(box[2]) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span> &lt;&lt;  endl;
  }
  <span class="comment">// end of difference from AIA examples</span>

  <span class="keywordflow">return</span> (<a class="code" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d" title="Forms a minimal image subpaving from a list of interval vector images.">Regularize</a>(hull, images, eps));

}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d5eb42dff486e08cf1cb54fa2a719a4"></a><!-- doxytag: member="AIASPnode::IsEmpty" ref="a1d5eb42dff486e08cf1cb54fa2a719a4" args="(AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4">IsEmpty</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the AIASubPaving is empty. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00118">118</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>
<div class="fragment"><pre class="fragment">      {<span class="keywordflow">return</span> ( (a==NULL) || (a-&gt;<a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>==NULL) ); }
</pre></div>
</div>
</div>
<a class="anchor" id="a8528a3302f3cce257686222b065bb807"></a><!-- doxytag: member="AIASPnode::IsLeaf" ref="a8528a3302f3cce257686222b065bb807" args="(AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807">IsLeaf</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the AIASubPaving is a leaf. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00122">122</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
      <span class="keywordflow">return</span> ( !<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(a) &amp;&amp; <a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>)
        &amp;&amp; <a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>) );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab7921c5bd80f01985ee134c5d2ab595d"></a><!-- doxytag: member="AIASPnode::Mince" ref="ab7921c5bd80f01985ee134c5d2ab595d" args="(AIASubPaving A, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mince up a subpaving. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a pointer to the node whose box is to be minced </td></tr>
    <tr><td class="paramname">eps</td><td>the maximum diameter any box in the subpaving should be Mince minces recursively until each leaf has maximum diameter smaller than eps.</td></tr>
  </table>
  </dd>
</dl>
<p>Mince transforms a minimal AIASubPaving into a non-minimal AIASubPaving, ie may have sibling leaves. Any leaf AIASubPaving with a box with diameter greater than eps will be expanded. Mince will keep mincing until every leaf AIASubPaving has a box with diameter &lt; eps </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">331</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(A)) <span class="keywordflow">return</span>;

  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(A))
  {
    <span class="keywordtype">int</span> comp;       <span class="comment">// value is given by calling MaxDiam function below</span>

    <span class="comment">// if leaf and box smaller than eps then return</span>
    <span class="keywordflow">if</span>(<a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(A),comp)&lt;eps) <span class="keywordflow">return</span>;

    <span class="comment">// if leaf and box not smaller than eps then expand</span>
    <a class="code" href="classAIASPnode.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa" title="Expand a leaf node to have two child nodes.">Expand</a>(A,comp);

  }                 <span class="comment">// end if a leaf</span>

  <span class="comment">// not a leaf, recurse Mince() on left and right children</span>
  <a class="code" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d" title="Mince up a subpaving.">Mince</a>(A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>,eps);
  <a class="code" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d" title="Mince up a subpaving.">Mince</a>(A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>,eps);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a6cc4fba2aef7df53e990c5348f84bd3b"></a><!-- doxytag: member="AIASPnode::NbLeaves" ref="a6cc4fba2aef7df53e990c5348f84bd3b" args="(AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classAIASPnode.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of leaves of an AIASubPaving. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00061">61</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> nbleaves=0;

  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(a)) <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(a))  <span class="keywordflow">return</span> 1;

  nbleaves += <a class="code" href="classAIASPnode.shtml#a6cc4fba2aef7df53e990c5348f84bd3b" title="Number of leaves of an AIASubPaving.">NbLeaves</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>);
  nbleaves += <a class="code" href="classAIASPnode.shtml#a6cc4fba2aef7df53e990c5348f84bd3b" title="Number of leaves of an AIASubPaving.">NbLeaves</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>);

  <span class="keywordflow">return</span> (nbleaves);
}
</pre></div>
</div>
</div>
<a class="anchor" id="abf9101628f2ef58fbd1132a1c7086d06"></a><!-- doxytag: member="AIASPnode::operator&lt;&lt;" ref="abf9101628f2ef58fbd1132a1c7086d06" args="(std::ostream &amp;, AIASubPaving)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the contents of an AIASubPaving. </p>
<p>This output format is not the same as used in the example code provided for [AIA2001], but is adapted for easy reading and rendering in Matlab. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00040">40</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (a==NULL) <span class="keywordflow">return</span> os;

  <span class="comment">//if (IsLeaf(a)) os &lt;&lt; (*(a-&gt;theBox)) &lt;&lt; std::endl;</span>
  <span class="comment">//output for Jenny&#39;s matlab format, dimension = 2 max</span>
  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(a))
  {
    ivector x = *(a-&gt;<a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>);
    os &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(x[1]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(x[1]) &lt;&lt; <span class="stringliteral">&quot; ] , &quot;</span>
      &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(x[2]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(x[2]) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span>   &lt;&lt; std::endl;
  }
  <span class="keywordflow">else</span>
    { os &lt;&lt; (a-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>); os &lt;&lt; (a-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>); }

    <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0869804e6aaefcc26aebe081061df6ad"></a><!-- doxytag: member="AIASPnode::operator&lt;=" ref="a0869804e6aaefcc26aebe081061df6ad" args="(const ivector &amp;, AIASubPaving)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6">AIA_BOOL_INTERVAL</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for containment of interval vector or box in the AIASubPaving. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00098">98</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// z is assumed not to be empty</span>
  <span class="comment">// note that Intersection() gives an error if unequal index sets passed</span>

  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(X)) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;

  ivector r;        <span class="comment">// ivector to be passed to Intersection()</span>
  <span class="comment">// to contain the intersection</span>

  <span class="comment">// check if X is a leaf and if so</span>
  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(X))
  {
    <span class="comment">// *************** old code</span>
    <span class="comment">//if (z&lt;=Box(X)) return BI_TRUE;</span>
    <span class="comment">//if (!Intersection(r,z,Box(X))) return BI_FALSE;</span>
    <span class="comment">// what if Intersection() returns 1, ie there is an intersection</span>
    <span class="comment">// but z&lt;=Box(X) is not true?</span>
    <span class="comment">// at present this goes down to the default (else) case below</span>

    <span class="comment">//**************** replacement code</span>
    <span class="keywordflow">if</span> (z&lt;=<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(X))
                    <span class="comment">// true if z is in the box</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(r,z,<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(X)))
                    <span class="comment">// false if there is no intersection between z and the box</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="keywordflow">else</span>          <span class="comment">// z is not contained in the box but there is an intersection</span>
                  <span class="comment">// so result is indeterminate</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;
  }                 <span class="comment">// end isLeaf()</span>

  <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> Ltest=<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>,Rtest=<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>;

  ivector Lz,Rz;    <span class="comment">// ivectors to be passed to Intersection()</span>
  <span class="comment">// will contain intersection after call to Intersection()</span>

                    <span class="comment">// both children exist</span>
  <span class="keywordflow">if</span> (!<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>)&amp;&amp;!<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>))
  {

                    <span class="comment">// intersection with left child</span>
    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Lz,z,<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>)))
      <span class="comment">// Lz now contains this intersection</span>
    {
                    <span class="comment">// compare Lz and left child</span>
      Ltest = (Lz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>));

                    <span class="comment">//check intersection with right child</span>
      <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz,z,<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>)))
      {
                    <span class="comment">// compare Rz and right child</span>
        Rtest = (Rz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>));
                    <span class="comment">// if left and right child tests same</span>
        <span class="keywordflow">if</span> (Ltest==Rtest)
                    <span class="comment">// return this result from child tests</span>
          <span class="keywordflow">return</span> Ltest;
        <span class="keywordflow">else</span>
                    <span class="comment">// z overlaps the boundary of X</span>
          <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;
      }
      <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> Ltest;
    }               <span class="comment">// end if intersection with left child</span>

                    <span class="comment">// given no intersection with left child</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz,z,<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>)))
                    <span class="comment">// check intersection with right child</span>
                    <span class="comment">// compare Rz and right child</span>
      <span class="keywordflow">return</span> (Rz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>));

    <span class="keywordflow">else</span>            <span class="comment">// no intersection with either child</span>
                    <span class="comment">// used to be BI_TRUE here from the AIA website</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="comment">// but this cannot possibly be correct!</span>
  }                 <span class="comment">// end if both children exist</span>

                    <span class="comment">// only left child exists</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>))
  {
                    <span class="comment">// no intersection with left child</span>
    <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Lz,z,<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>)))
      <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="comment">// there is an intersection with the left child, this intersection now in Lz</span>
                    <span class="comment">// compare Lz and the left child</span>
    Ltest = (Lz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>));
    <span class="comment">// Rtest will still be at default value of TRUE</span>

                    <span class="comment">// if left child intersection with z is not z</span>
    <span class="keywordflow">if</span> (!(Lz==z)) Rtest = <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="keywordflow">else</span>            <span class="comment">// if left child intersection with z = z</span>
      <span class="keywordflow">return</span> Ltest; <span class="comment">// ie is whole of z in left child</span>
  }                 <span class="comment">// end if  only left child exists</span>

  <span class="keywordflow">else</span>              <span class="comment">// if is not a leaf, only right child exists</span>
  <span class="comment">// BUT if it is a leaf and there is an intersection but not full containment?</span>
  <span class="comment">// I have now replaced the code that gave rise to the latter case</span>
  {
                    <span class="comment">// no intersection with right child</span>
    <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz,z,<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>)))
      <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="comment">//there is an intersection with the right child, this intersection now in Rz</span>
                    <span class="comment">// compare Rz and right child</span>
    Rtest = (Rz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>));
    <span class="comment">// Ltest will still be at default value of TRUE</span>
                    <span class="comment">// if right child intersection with z is not z</span>
    <span class="keywordflow">if</span> (!(Rz==z)) Ltest = <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="keywordflow">else</span>            <span class="comment">// if right child intersection with z = z</span>
      <span class="keywordflow">return</span> Rtest; <span class="comment">// ie is whole of z in right child</span>
  }                 <span class="comment">// end if only right child exists</span>

  <span class="comment">// only get here if only one child (left or right exists)</span>
  <span class="comment">// and the intersection of that child with z exists but is not z</span>
  <span class="comment">// in which case the other test will have been set to FALSE?</span>
  <span class="comment">// or if is a leaf and both Intersection() returns 1 but z&lt;=Box(X) is not 1</span>
  <span class="comment">// in which case Ltest and Rtest will both be TRUE? - that code now replaced</span>

  <span class="keywordflow">if</span> (Ltest==Rtest)
    <span class="keywordflow">return</span> Ltest;
  <span class="keywordflow">else</span>
    <span class="comment">// if only one child, and the whole of z is not in that child but</span>
    <span class="comment">// the intersection of z with that child is inside the child</span>
    <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;<span class="comment">// z overlaps the boundary of X</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1b1148d30745256482cbc7cca090253d"></a><!-- doxytag: member="AIASPnode::Regularize" ref="a1b1148d30745256482cbc7cca090253d" args="(ivector &amp;hull, list&lt; ivector &gt; &amp;ivectorList, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d">Regularize</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; ivector &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivectorList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forms a minimal image subpaving from a list of interval vector images. </p>
<p>Uses <a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec" title="Tries to reunite two nodes into to form a single leaf.">Reunite()</a> and recursive calls to <a class="el" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d" title="Forms a minimal image subpaving from a list of interval vector images.">Regularize()</a> to work up from leaf nodes to form a minimal subpaving </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a regular mimimal subpaving with root box hull </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hull</td><td>the interval hull of all the interval vectors in the image list </td></tr>
    <tr><td class="paramname">ivectorList</td><td>a collection of possibly overlapping interval vectors to be made into a regular subpaving </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed There are some minor changes in this function compared to the implementation in AIA2001, p. 346. We use the std::list to store the interval vector images instead of a [constantly sorted] set. We sort the list, using <a class="el" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74" title="Compare volumes of two boxes.">volCompare()</a>, only when we need to. We sort smallest to largest (the natural std::list sort order) (the Jaulin et al images are sorted largest to smallest) and hence we find the largest image box at the end of the the list rather than at the start.</td></tr>
  </table>
  </dd>
</dl>
<p>Regularize creates an AIASubPaving from all the ivectors in the ivectorList. The root of the AIASubPaving will have Box = hull where hull has already been formed from the union of all the ivectors in the ivectorList. Regularize is applied recursively on bisected half of hull and new lists until either there are no images in the list or the diameter of the hull is below eps. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">427</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
                    <span class="comment">// return NULL if the list is empty</span>
  <span class="keywordflow">if</span> (ivectorList.size()==0) <span class="keywordflow">return</span> NULL;

  <span class="comment">// sort the list</span>
  <span class="comment">// Jaulin et al do not have this step because they have their own IMAGELIST</span>
  <span class="comment">// class which acts like a set and keeps the contents in order.  But we are</span>
  <span class="comment">// using the stl std::list and so it is unsorted when it is passed to</span>
  <span class="comment">// Regularize.  It is more effient to sort it once per call to Regularise</span>
  <span class="comment">// than to keep it sorted as it is being built because the sorted order is</span>
  <span class="comment">// only needed when the entire list has been built</span>

  <span class="comment">// sort using the volCompare function</span>
  ivectorList.sort(<a class="code" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74" title="Compare volumes of two boxes.">volCompare</a>);
  <span class="comment">// this sorts smallest to largest (the opposite to Jaulin et al)</span>

  <span class="comment">// if the hull is equal to the last (largest) box in the list,</span>
  <span class="comment">// this becomes the AIASubPaving</span>
  <span class="keywordflow">if</span> (hull==(*ivectorList.rbegin())) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(hull);

  <span class="comment">// un-valued int to take value for larged dimension calculated from MaxDiam</span>
  <span class="keywordtype">int</span> maxdiamcomp;

  <span class="comment">//if the current maximum diameter is &lt; eps return a new AIASubPaving from hull</span>
  <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(hull,maxdiamcomp)&lt;eps) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(hull);

  <span class="comment">// new ivectors from splitting hull in its biggest dimension</span>
  ivector lefthull = <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(hull,maxdiamcomp);
  ivector righthull = <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(hull,maxdiamcomp);

  <span class="comment">// create two empty lists</span>
  list&lt;ivector&gt; leftlist,rightlist;

  <span class="comment">// iterator to for the list</span>
  list&lt;ivector&gt;::iterator it;

  <span class="comment">// iterate through the current list and put the intersection of any element</span>
  <span class="comment">// with the lefthull into the new left list, and the intersection of any</span>
  <span class="comment">// element with new right hull into the new rightlist.</span>
  <span class="keywordflow">for</span> (it=ivectorList.begin(); it!=ivectorList.end(); it++)
  {
    <span class="comment">// temporary variables to take the results of call in Intersect</span>
    ivector interLeft, interRight;

    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interLeft, *it, lefthull))
    {
      leftlist.push_back(interLeft);
    }

    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interRight, *it, righthull))
    {
      rightlist.push_back(interRight);
    }

  }  <span class="comment">// end of iteration through list elements</span>

  <span class="comment">// recursively call Regularize with lefthull, leftlist, righthull, rightlist</span>
  <span class="comment">// reunite the results using hull as the box for the parent node</span>
  <span class="comment">// Regularize creates a minimal AIASubPaving (no sibling child nodes)</span>
  <span class="keywordflow">return</span> <a class="code" href="classAIASPnode.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7" title="Return a minimal subpaving from two sibling subpavings.">ReUnite</a>(<a class="code" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d" title="Forms a minimal image subpaving from a list of interval vector images.">Regularize</a>(lefthull,leftlist,eps),
    <a class="code" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d" title="Forms a minimal image subpaving from a list of interval vector images.">Regularize</a>(righthull,rightlist,eps),hull);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad0b3998c79d0cbf91d21c550a6bb72e7"></a><!-- doxytag: member="AIASPnode::ReUnite" ref="ad0b3998c79d0cbf91d21c550a6bb72e7" args="(AIASubPaving lChild, AIASubPaving rChild, ivector x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classAIASPnode.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7">ReUnite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>rChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a minimal subpaving from two sibling subpavings. </p>
<p>If two potential children are provided and they are both leaves, then Reunite combines the two leaf siblings into this. If the potential children are not leaves or if only one potential child is provided, grafts the potential child/children onto this as its child/children.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal subpaving from two sibling subpavings </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lChild</td><td>a pointer to the leftChild node to be reunited </td></tr>
    <tr><td class="paramname">rChild</td><td>a pointer to the rightChild node to be reunited </td></tr>
    <tr><td class="paramname">x</td><td>is the box of the new subpaving to be returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00247">247</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span>(<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(lChild)&amp;&amp;<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(rChild)) <span class="keywordflow">return</span> NULL;
  <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> result = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(x);
  <span class="comment">// both AIASubPavings are leaves so discard them: new AIASubPaving is a leaf</span>
  <span class="keywordflow">if</span>( <a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(lChild)
    &amp;&amp;<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(rChild)
    &amp;&amp;(  x == ( <a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(lChild) | <a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(rChild) )  )
    )
    { <span class="keyword">delete</span> lChild; <span class="keyword">delete</span> rChild; <span class="keywordflow">return</span> result; }

    <span class="comment">// if there are not two non-null potential children</span>
    <span class="comment">// (so presumably just one child), just graft it on</span>
    <span class="comment">// similarly if at least one child is not a leaf, just graft the potential</span>
    <span class="comment">// children on</span>
    result-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a> = lChild; result-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a> = rChild;

  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7ca818aa239136500bfc1020684160de"></a><!-- doxytag: member="AIASPnode::Sivia" ref="a7ca818aa239136500bfc1020684160de" args="(AIA_PIBT BoolTest, AIASubPaving A, double)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classAIASPnode.shtml#a7ca818aa239136500bfc1020684160de">Sivia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ac3a2af016d66120f37b7e4b3da564876">AIA_PIBT</a>&#160;</td>
          <td class="paramname"><em>BoolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Inversion Via Interval Analysis method taken from AIA2001. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal regular subpaving covering the reciprocal image of a subpaving under some function f </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">BoolTest</td><td>a (*AIA_PIBT)() which specifies the inclusion function of f and tests the inclusion function image [f][x] of an interval vector [x] for containment in an SPnode. In this implementation, the body of BoolTest specifies both the subpaving we want the image of and the function f forming the image </td></tr>
    <tr><td class="paramname">A</td><td>a subpaving whose box forms the interval vector passed to BoolTest </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed SIVIA progressively subdivides the boxes of the initial search subpaving and calls itself recursively to select or reject or retest the resulting subpavings until the desired level of precision, specified by eps, in forming the subpaving to be returned has been achieved.</td></tr>
  </table>
  </dd>
</dl>
<p>Set Inversion Via Interval Analysis method taken from AIA2001. Sivia gives an AIASubPaving which is based on the reciprocal image X of some function. Note that in this implementation, we get the outer AIASubPaving of a two, (lowerX and UpperX) such that lowerX is in X is in upperX The AIA_PIBT points to a function wich specifies the function for which we want the reciprocal image and the AIASubPaving Y which should contain the reciprocal image. The AIA_PIBT function evaluates whether the image of some box (ivector) is in Y. The AIA_PIBT can return BI_TRUE, BI_FALSE, or BI_INDET (box partly in Y but not totally). If the AIASubPaving box tests BI_INDET and the box diameter is sufficiently small then it is given the benefit of the doubt and included in upperX. Otherwise if the AIA_PIBT function returns BI_INDET then the AIASubPaving is expanded, ie two AIASubPaving children created, and these AIASubPaving children are then tested. The argument A is an AIASubPaving. On the first pass through SIVIA, A should have a box which is guaranteed to contain upperX; this AIASubPaving is progressively refined. The argument eps specifies the 'sufficiently small' width for a box to be included in upperX... </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">288</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (A==NULL) <span class="keywordflow">return</span> NULL;

                    <span class="comment">// test the box of the given AIASubPaving</span>
  <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> test = BoolTest(<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(A));
  <span class="comment">// Test function (may be passed as parameter to Sivia)</span>

  <span class="comment">// maxdiamcomp will be given a value by call to MaxDiam() below</span>
  <span class="keywordtype">int</span> maxdiamcomp;

  <span class="comment">// the box fails the test</span>
  <span class="keywordflow">if</span> ( test==<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a> ) <span class="keywordflow">return</span> NULL;

  <span class="comment">// if the box passes or the result is BI_INDET but the maximum diameter of</span>
  <span class="comment">// the box is small enough, then return a new AIASubPaving which is a copy of</span>
  <span class="comment">// the current one, ie include this AIASubPaving in outerX, our approximation</span>
  <span class="comment">// of X the reciprocal image</span>
  <span class="keywordflow">if</span> (test==<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a> || <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(A),maxdiamcomp)&lt;eps)
    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml#a69e70b41f415cb17b09690315320b194" title="Default constructor.">AIASPnode</a>(*A);

  <span class="comment">// SIVIA will only reach this point if the result of the test was BI_INDET</span>
  <span class="comment">// and the maximum diameter of the box is not small enough for the box to be</span>
  <span class="comment">// in outerX -- in this case we expand the AIASubPaving by giving it child</span>
  <span class="comment">// nodes and test them</span>
  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(A)) <a class="code" href="classAIASPnode.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa" title="Expand a leaf node to have two child nodes.">Expand</a>(A,maxdiamcomp);

  <span class="comment">// ReUnite is used to get a minimal AIASubPaving from merging two</span>
  <span class="comment">// AIASubPavings.  So will ensure that the AIASubPaving we return from Sivia</span>
  <span class="comment">// is minimal, ie will not have sibling leaves</span>
  <span class="keywordflow">return</span> <a class="code" href="classAIASPnode.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7" title="Return a minimal subpaving from two sibling subpavings.">ReUnite</a>( <a class="code" href="classAIASPnode.shtml#a7ca818aa239136500bfc1020684160de" title="Set Inversion Via Interval Analysis method taken from AIA2001.">Sivia</a>(BoolTest,A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>,eps),
    <a class="code" href="classAIASPnode.shtml#a7ca818aa239136500bfc1020684160de" title="Set Inversion Via Interval Analysis method taken from AIA2001.">Sivia</a>(BoolTest,A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>,eps),
    <a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(A));

}
</pre></div>
</div>
</div>
<a class="anchor" id="a8713b30834070a586c0b99d9899f9b74"></a><!-- doxytag: member="AIASPnode::volCompare" ref="a8713b30834070a586c0b99d9899f9b74" args="(const ivector &amp;a, const ivector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74">volCompare</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare volumes of two boxes. </p>
<p>A function for comparing ivectors based on volume. Used in sorting a list of ivectors ordered by volume. Will abort if the index sets of the two ivectors are different sizes. Uses <a class="el" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe" title="Volume of an AIASubPaving.">Volume()</a> as defined in <a class="el" href="toolz_8hpp.shtml" title="Declaration of various tools; functions and structs, for MRS.">toolz.hpp</a> </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the Volume of a is strictly less than Volume of b </dd></dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00397">397</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">Regularize()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> returnValue = 0;

  <span class="comment">// Make sure the vectors have the same number of elements and at</span>
  <span class="comment">// least one element each</span>
  <span class="keywordflow">if</span>( (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(a) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(a)) == (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(b) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(b)) &amp;&amp; (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(a) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(a))&gt;=1 )
  {

                    <span class="comment">// compare the two volumes</span>
    returnValue = ((<a class="code" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe" title="Volume of an AIASubPaving.">Volume</a>(a)&lt;<a class="code" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe" title="Volume of an AIASubPaving.">Volume</a>(b)));

  }
  <span class="keywordflow">else</span>
  {
    std::cout
      &lt;&lt; <span class="stringliteral">&quot;Error in volCompare : comparing ivectors of different dimensions&quot;</span>
      &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> returnValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7f6354ab5e7b1310b03f0e190169eabe"></a><!-- doxytag: member="AIASPnode::Volume" ref="a7f6354ab5e7b1310b03f0e190169eabe" args="(AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Volume of an AIASubPaving. </p>
<p>Sums the volumes of the leaves of the AIASubPaving. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">77</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a1d5eb42dff486e08cf1cb54fa2a719a4" title="Check if the AIASubPaving is empty.">IsEmpty</a>(a)) <span class="keywordflow">return</span> 0.0;
  <span class="keywordflow">if</span> (<a class="code" href="classAIASPnode.shtml#a8528a3302f3cce257686222b065bb807" title="Check if the AIASubPaving is a leaf.">IsLeaf</a>(a))
  {

                    <span class="comment">// using Volume taking ivector argument</span>
    <span class="keywordflow">return</span> <a class="code" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe" title="Volume of an AIASubPaving.">Volume</a>(<a class="code" href="classAIASPnode.shtml#ae78ba41711edb725cf1ef43c27144be3" title="Returns a copy of theBox of an AIASubPaving. */.">Box</a>(a));
  }
  <span class="keywordtype">double</span> vol=0.0;

  vol += <a class="code" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe" title="Volume of an AIASubPaving.">Volume</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>);
  vol += <a class="code" href="classAIASPnode.shtml#a7f6354ab5e7b1310b03f0e190169eabe" title="Volume of an AIASubPaving.">Volume</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>);

  <span class="keywordflow">return</span> (vol);
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a64dc679fe03b03b7beb6ddb04b2a0f85"></a><!-- doxytag: member="AIASPnode::leftChild" ref="a64dc679fe03b03b7beb6ddb04b2a0f85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85">AIASPnode::leftChild</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The node's left child. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">88</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00029">AIASPnode()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">Evaluate()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00061">NbLeaves()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00040">operator&lt;&lt;()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00098">operator&lt;=()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00247">ReUnite()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">Sivia()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00105">~AIASPnode()</a>.</p>

</div>
</div>
<a class="anchor" id="adbaa03014929ff2ab653d6d916ca2fc1"></a><!-- doxytag: member="AIASPnode::rightChild" ref="adbaa03014929ff2ab653d6d916ca2fc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1">AIASPnode::rightChild</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The node's right child. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">90</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00029">AIASPnode()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">Evaluate()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00061">NbLeaves()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00040">operator&lt;&lt;()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00098">operator&lt;=()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00247">ReUnite()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">Sivia()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00105">~AIASPnode()</a>.</p>

</div>
</div>
<a class="anchor" id="ab904c07918618a89d5511fbaf87f5143"></a><!-- doxytag: member="AIASPnode::theBox" ref="ab904c07918618a89d5511fbaf87f5143" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector* <a class="el" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143">AIASPnode::theBox</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The interval vector the node represents. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00086">86</a> of file <a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00029">AIASPnode()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00040">operator&lt;&lt;()</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00105">~AIASPnode()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a></li>
<li><a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classAIASPnode.shtml">AIASPnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:24 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
