<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::SPSVnode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1SPSVnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::SPSVnode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::SPSVnode" --><!-- doxytag: inherits="subpavings::SPSnode" -->
<p>A derived class based on <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> for processing sample data split to training and validation sets.  
 <a href="classsubpavings_1_1SPSVnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for subpavings::SPSVnode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1SPSVnode__inherit__graph.png" border="0" usemap="#subpavings_1_1SPSVnode_inherit__map" alt="Inheritance graph"/></div>
<map name="subpavings_1_1SPSVnode_inherit__map" id="subpavings_1_1SPSVnode_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::SPSVnode:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1SPSVnode__coll__graph.png" border="0" usemap="#subpavings_1_1SPSVnode_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1SPSVnode_coll__map" id="subpavings_1_1SPSVnode_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1SPSVnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">SPSVnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a1fac8007420cae9fb27af8e7c81eaa52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a29413a70c5c7f01002665a8319971984">SPSVnode</a> (ivector &amp;v, bool cntOnly, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a29413a70c5c7f01002665a8319971984"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a4d33a48a0510f2988d17ae9c1f56eb1a">SPSVnode</a> (ivector &amp;v, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a4d33a48a0510f2988d17ae9c1f56eb1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#aa91b89ffdb65468e88ab8cecf290a75d">SPSVnode</a> (ivector &amp;v, size_t max, bool cntOnly, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#aa91b89ffdb65468e88ab8cecf290a75d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a62e88e96ee22be76109b387277ef6955">SPSVnode</a> (ivector &amp;v, size_t max, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a62e88e96ee22be76109b387277ef6955"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a22251951e28c6876d4159e82bf2f36e1">SPSVnode</a> (<a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb, bool cntOnly=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a22251951e28c6876d4159e82bf2f36e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0652f353916bda77708ed26053a21789">SPSVnode</a> (<a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb, size_t max, bool cntOnly=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a0652f353916bda77708ed26053a21789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ac34ad69da8e0f3894b74f4027de2614b">SPSVnode</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ac34ad69da8e0f3894b74f4027de2614b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad4e310986c60dcebb3fd3c54dab19c33">operator=</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ad4e310986c60dcebb3fd3c54dab19c33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a7d7f4ecaaf020bcb614557eba4743f6a">getVcounter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the node's validation data counter.  <a href="#a7d7f4ecaaf020bcb614557eba4743f6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a899334f4e1760a380a776bc38d664710">getJustSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the node's justSplit boolean flag.  <a href="#a899334f4e1760a380a776bc38d664710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a05d47c013af462f857c6f54b20cb3404">getVdata</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the node's validation data collection.  <a href="#a05d47c013af462f857c6f54b20cb3404"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#af7739cf5333fccbe27610cbbd1138719">clearData</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the node's data collection for both training and validation set.  <a href="#af7739cf5333fccbe27610cbbd1138719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a9a51fbde60e061846a93981688cc67af">getRightCountIfSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The count the right child would have if this node was split.  <a href="#a9a51fbde60e061846a93981688cc67af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a64b5d63790c02a454aa0e86222b1a3d3">getLeftCountIfSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The count the left child would have if this node was split.  <a href="#a64b5d63790c02a454aa0e86222b1a3d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a43024ae81075f8a822ccccad013b3ef7">getMinChildCountIfSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest number of points in either child if this was split.  <a href="#a43024ae81075f8a822ccccad013b3ef7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad1e930cb7befb42cd1985e91f3ddd9b6">getChildrensLeftAndRightCountsIfSplit</a> (<a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;grandchildCounts) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return a container of counts for prospective grandchildren.  <a href="#ad1e930cb7befb42cd1985e91f3ddd9b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0d6df4752e05170510e43b67d8eb3110">getLeafNodeCounts</a> (<a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;counts) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508">getLeaves</a> (<a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;leaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to all descendent leaf nodes.  <a href="#a6f3850e716947e051a9e9af16c2b4508"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#aa5408d2d74de8b95325c5973cf43f7fb">getSubLeaves</a> (<a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;subleaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to all sub-leaf descendent nodes.  <a href="#aa5408d2d74de8b95325c5973cf43f7fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ac637655f207bc9bc049145a2bd904fdf">getAllNodes</a> (<a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;allNodes) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to all nodes.  <a href="#ac637655f207bc9bc049145a2bd904fdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a346a5ff0d8177212b23342cada4b5c18">getRootCounter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The count in the node's ultimate ancestor root.  <a href="#a346a5ff0d8177212b23342cada4b5c18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#acb4a623e5679b79f05244e79a078e6c1">getRootVcounter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The count in the node's ultimate ancestor root.  <a href="#acb4a623e5679b79f05244e79a078e6c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2d2b97cb6916b19ad2affc4907265b6f">getMean</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample mean.  <a href="#a2d2b97cb6916b19ad2affc4907265b6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae2cfb09a96d3c6b0d716236cbfccebd3">getUniformMean</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the uniform mean vector where each element is the midpoint of the coordinate.  <a href="#ae2cfb09a96d3c6b0d716236cbfccebd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a24fc7b09a8293edce2e3b602763a45e3">getChebDistMean</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Chebyshev distance for the mean.  <a href="#a24fc7b09a8293edce2e3b602763a45e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#afb9e32e6d78db527309d95ccc8c0049f">getEmpMass</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the empirical mass of the node  <a href="#afb9e32e6d78db527309d95ccc8c0049f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a63ea0f67b354888a8a12c0ffc81b0e5e">getChebDistCovar</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Chebyshev distance for the var-covar.  <a href="#a63ea0f67b354888a8a12c0ffc81b0e5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2e0a1a393daed9e3f5887162b68b0e6e">getHellingerDist</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Bhattarchaya coefficient.  <a href="#a2e0a1a393daed9e3f5887162b68b0e6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3b56f3b8a024ab6929087e803e7af765">getHellingerDist1D</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">getUniformVarCovar</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ab1f050670fdcdc6f68e009a0cba0ed35">getUniformVarCovar</a> (<a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;varCovar) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ac741a9772d992ba74911cf692e1ed772">getSumLeafCountOverVol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sum of the count over volume in the leaf nodes.  <a href="#ac741a9772d992ba74911cf692e1ed772"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d355f8da3eb609f5c81ce63b437fcf9">getSmallestLeafCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of the leaf with the smallest count.  <a href="#a5d355f8da3eb609f5c81ce63b437fcf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#adfb30c9946f868e143c81e6bf35a7a6f">getLargestLeafCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count in the leaf with the smallest count.  <a href="#adfb30c9946f868e143c81e6bf35a7a6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a51715ef7b6e370006e914fee15061cfc">nodePrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output details of a specific node.  <a href="#a51715ef7b6e370006e914fee15061cfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a01b35db8ce4b99460ff352f6d25a529c">leafOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a01b35db8ce4b99460ff352f6d25a529c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#abcac815b9e5e60a3d18fa3534a12c518">leavesOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#abcac815b9e5e60a3d18fa3534a12c518"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#adc55cda7856cfdd854051b891263d3bf">leavesOutputTabsWithHistHeight</a> (std::ostream &amp;os, const int prec) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#adc55cda7856cfdd854051b891263d3bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a8419f16a2f0667bc190a4a9ed41121c1">leavesOutputTabsWithHistHeight</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a8419f16a2f0667bc190a4a9ed41121c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">nodeExpand</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#a94c33927011a8d2613d40ccf6ccfafc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#acbad110f9ed41364774c9e2fea658594">nodeExpand</a> (const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#acbad110f9ed41364774c9e2fea658594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0eb85efd74fa770f3259d6ba948b65b8">nodeExpand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#a0eb85efd74fa770f3259d6ba948b65b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ada1ce5002ee4985a22d35d8cb651d191">nodeExpand</a> (const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, bool boolVal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#ada1ce5002ee4985a22d35d8cb651d191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a4846c8d9c7d29d0f0850a7a9c30eec2b">nodeExpand</a> (bool boolVal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to make two leaves as children.  <a href="#a4846c8d9c7d29d0f0850a7a9c30eec2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#aed19a06dc479c2edc865243d2c131c30">nodeReabsorbChildren</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reabsorbs both children of the node.  <a href="#aed19a06dc479c2edc865243d2c131c30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5abf598ead77d94aa130a8a7bf78f1f7">nodeReunite</a> (<a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *lChild, <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reunite nodes to form one leaf.  <a href="#a5abf598ead77d94aa130a8a7bf78f1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a928db3d7b687a9fb5d50fa135f51b040">nodeAdoptLeft</a> (<a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *lChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#a928db3d7b687a9fb5d50fa135f51b040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a33d64bef2bd9dd7f430b732719eab71d">nodeAdoptRight</a> (<a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#a33d64bef2bd9dd7f430b732719eab71d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135">insertOneFind</a> (<a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">BigDataItr</a> newItr, <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a> childInd, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, bool boolVal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data into this node.  <a href="#a58deac20a0a5b69bb06cdc04fc059135"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a803d11f31d86f0565dbe682a33099698">nodeContains</a> (const rvector &amp;p, <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a> childInd) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the box a node represents contains a datapoint p.  <a href="#a803d11f31d86f0565dbe682a33099698"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors for links between the nodes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These accessor methods shadow equivalent methods in the base class. Thus the method used is determined at compile time, not run time as would be the case if virtual methods were used. Because the pointers to parents and children are part of the base class definition, the methods have to cast the base class form to the derived class form in order for the pointer returned to be able to be used with derived class members.</p>
<p>Note that pointers for parent, leftChild, and rightChild are not reference counted so there could potentially be problems with the use of returned pointers (for instance, being used to delete nodes). These pointers might be better implemented with boost::shared_ptr . </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the parent of a node.  <a href="#ae42cbf85bd00caf12e6acac68ae1fcd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2">getLeftChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the left child of a node.  <a href="#a3ef0b662df21eb88689644cb5d1279d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42">getRightChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the right child of a node.  <a href="#af681e178575b285f123c1c01bac9ac42"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get the sample variance-covariance matrix.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This calculates the sample variance-covariance matrix from the accumulators for the sumproducts and sums of data point elements.</p>
<p>cov(i,j) = [sumproduct(i,j)-sum(i)xsum(j)/counter]/(counter-1)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a RealVec or reference to a RealVec representing the sample variance-covariance matrix in row-major order. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">getVarCovar</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a61adf71c4652c4ec29a9dc323174d1a3">getVarCovar</a> (<a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;varCovar) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">strippedConstructor</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad61518c409809cca73c262dbd17d320f">unionTreeStructure</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const rhs)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef">spaceIndication</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An indication of the maximum number of data points a node needs to carry.  <a href="#a98a73d1c8dafe1d9248aeec76c8f74ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951">justSplit</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A boolean flag to know if this node was being split or node.  <a href="#a288af7a8149effcb2d19e163e217e951"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">mutable data members.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These data members are mutable to allow them to be modified by const functions as data passed to or through the node.</p>
<p>Only leaf nodes have data associated with them but the recursively computable statistics, such as counter and sum, are maintained for all nodes. Thus when a data point is sent to the root node and progresses down the tree to find which leaf node it should be associated with, the counter is incremented and the data sum increased for each non-leaf node it passes through (ie, where it is contained in the box of that node but that node is not a leaf node so the box has been sub- divided and the datapoint continues on to one of the children). </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12">Vcounter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter for how many data points from the validation set that are covered by theBox.  <a href="#a5d0154d5c5d30fa214b8a2d9deedee12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a60f29b9bd7f1a448515c5465e5f7f1ba">dpVSums</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container representing the sum of the data points covered by theBox.  <a href="#a60f29b9bd7f1a448515c5465e5f7f1ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#af35e25f257c98de51097428419d0cf81">dpVSumProducts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container representing the sumproduct matrix of the data points covered by theBox.  <a href="#af35e25f257c98de51097428419d0cf81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647">VdataItrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for the association of validation data with a node.  <a href="#a0e6c6ea9c454b9ce280915b59c7f3647"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c">defaultMaxPts</a> =  1000
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To define the default maximum number of datapoints the node is expected to have associated with it.  <a href="classsubpavings_1_1SPSVnode.shtml#ae284ba2007e19bf4e2d546d6d844346a">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#af37c85866ee5bdb968faf84856b51291">recalculateStats</a> (rvector &amp;newdata, bool boolVal) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate summary statistics associated with node.  <a href="#af37c85866ee5bdb968faf84856b51291"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a7590c8e3a8502b3b8a15bc2c4c494904">recalculateSums</a> (rvector &amp;newdata) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate summary statistics associated with node.  <a href="#a7590c8e3a8502b3b8a15bc2c4c494904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3df955b69f0e3d73efd0ccc3026fe0e7">recalculateSumProducts</a> (rvector &amp;newdata) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate summary statistics associated with node.  <a href="#a3df955b69f0e3d73efd0ccc3026fe0e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a747a3c135503cbf1f1b349a5898cebc4">nodeExpansionOnly</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the node with no reallocation of data.  <a href="#a747a3c135503cbf1f1b349a5898cebc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a82423d1ad9f1589dbeef2018705591ad">splitData</a> (const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, bool boolVal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data associated with this down to children.  <a href="#a82423d1ad9f1589dbeef2018705591ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5868a7661363e2f3bd7d2e267c22ceb1">nodeDataPrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the data in a specified format.  <a href="#a5868a7661363e2f3bd7d2e267c22ceb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a768f9507517be618970d19874b1ff992">nodeMeanPrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the mean in a specified format.  <a href="#a768f9507517be618970d19874b1ff992"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a096bff1081ceb308590aac8f2f3ee660">nodeVarCovarPrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the variance-covariance in a specified format.  <a href="#a096bff1081ceb308590aac8f2f3ee660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2ab7acc0aff92694976546f1555f67ed">leafOutputTabsWithEMPs</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a2ab7acc0aff92694976546f1555f67ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6eff83d7095798158c0bc17ee70e54c0">leafOutputTabsWithHistHeight</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a6eff83d7095798158c0bc17ee70e54c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a4ed4d26826f77814558a0ad3770582f4">leafOutputTabsWithHistHeightAndEMPs</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a4ed4d26826f77814558a0ad3770582f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d6459ebf84a81b4759a3dd6524df4cf">setSplits</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the splitDimension and SplitValue when children grafted.  <a href="#a5d6459ebf84a81b4759a3dd6524df4cf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1">gatherData</a> (<a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp;container, <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the node data.  <a href="#ad9b78707e372d9b66876e6afa0cb8eb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#ab79e2b1aa783e2df56abf8279c5dc564">unionNoData</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const rhs)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A derived class based on <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> for processing sample data split to training and validation sets. </p>
<p>The <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> class is used to form a regular subpaving representing containers of sample data using data-splitting methods. Here we implement the minimum distance estimator based on Devroye and Lugosi (200.)..clearer citation here.</p>
<p>Leaves of the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> class have data associated with them in the form of pointers to some big collection of sample data for both the training and validation sets. If an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> is bisected the data associated with it descends to its children, so that only leaf SPSVnodes have data associated with them. However, for the training set, "recursively-computable statistical summaries", such as, count, sum, etc, of the data which would be contained in the box an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> represents are kept for all SPSVnodes and continue to be updated when the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> has children and data reaching the node is passed on to be finally associated with a leaf. For the validation set, only the count is maintained.</p>
<p>By default, all recursively computable statistics provided except counts are not maintained in each <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>, since this uses memory and is always needed in the data splitting method implemented here.</p>
<p>Each node also has a boolean flag to indicate if this node has been split or not. </p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00071">71</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ae284ba2007e19bf4e2d546d6d844346a"></a><!-- doxytag: member="subpavings::SPSVnode::@1" ref="ae284ba2007e19bf4e2d546d6d844346a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To define the default maximum number of datapoints the node is expected to have associated with it. </p>
<p>This is used for efficiency only to reserve vector space and a node can have more than this default maximum number of data points associated with it. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c"></a><!-- doxytag: member="defaultMaxPts" ref="ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c" args="" -->defaultMaxPts</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00084">84</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c">defaultMaxPts</a> = 1000};
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1fac8007420cae9fb27af8e7c81eaa52"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="a1fac8007420cae9fb27af8e7c81eaa52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00572">572</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00084">defaultMaxPts</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l00791">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">SPSVnode()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00859">strippedConstructor()</a>.</p>
<div class="fragment"><pre class="fragment">                       :  <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(0), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(<span class="keyword">false</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class default constructor</span>
            <span class="comment">// then does additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">// reserve space</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c">defaultMaxPts</a>);
            <span class="comment">// not sure whether to do this or not - leave for the moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a29413a70c5c7f01002665a8319971984"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="a29413a70c5c7f01002665a8319971984" args="(ivector &amp;v, bool cntOnly, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents and a value for countsOnly which controls whether all available stats are maintained (false) or just counts (true), and optionally initialised with a label which defaults to 0 if not provided. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00623">623</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8hpp_source.shtml#l00084">defaultMaxPts</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">                                                        : 
                                                <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(v, cntOnly, lab),
                                <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(0), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(<span class="keyword">false</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with ivector, cntOnly &amp; label</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c">defaultMaxPts</a>);
            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4d33a48a0510f2988d17ae9c1f56eb1a"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="a4d33a48a0510f2988d17ae9c1f56eb1a" args="(ivector &amp;v, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents and optionally initialised with a label which defaults to 0 if not provided. The value for countsOnly will default to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00598">598</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00084">defaultMaxPts</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>.</p>
<div class="fragment"><pre class="fragment">                                          : <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(v, lab),
                               <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(0), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(<span class="keyword">false</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with ivector &amp; label</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c">defaultMaxPts</a>);
            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa91b89ffdb65468e88ab8cecf290a75d"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="aa91b89ffdb65468e88ab8cecf290a75d" args="(ivector &amp;v, size_t max, bool cntOnly, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents, a space indication, and a value for countsOnly which controls wether all available stats are maintained (false) or just counts (true), and optionally initialised with a label for the model which defaults to 0 if not provided. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00675">675</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                                                                    :
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(v, max, cntOnly, lab), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(0), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(<span class="keyword">false</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with ivector, max, cntOnly and    </span>
            <span class="comment">//label</span>
            <span class="comment">//and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">//reserve space - not sure if important - leave for moment</span>
          <span class="comment">//  VdataItrs.reserve(spaceIndication+1); // this will somehow affect the constructor </span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in SPSVnode constructor&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a62e88e96ee22be76109b387277ef6955"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="a62e88e96ee22be76109b387277ef6955" args="(ivector &amp;v, size_t max, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents, a space indication, and optionally initialised with a label for the model which defaults to 0 if not provided. The value for countsOnly will default to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00650">650</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">                                                      :
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(v, max, lab), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(0), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(<span class="keyword">false</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with ivector, max and label</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>+1);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a22251951e28c6876d4159e82bf2f36e1"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="a22251951e28c6876d4159e82bf2f36e1" args="(LabBox &amp;lb, bool cntOnly=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> for the labeled box it represents. Also optionally initialised with a value for countsOnly, defaults to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00724">724</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8hpp_source.shtml#l00084">defaultMaxPts</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">                                               : <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(lb, cntOnly), 
                                  <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(0), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(<span class="keyword">false</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with LabBox and cntOnly </span>
            <span class="comment">//argument</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae284ba2007e19bf4e2d546d6d844346aa0a41030519d8a235798dcc07a0c2948c">defaultMaxPts</a>);
            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0652f353916bda77708ed26053a21789"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="a0652f353916bda77708ed26053a21789" args="(LabBox &amp;lb, size_t max, bool cntOnly=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> for the labeled box it represents, and a space indication. Also optionally initialised with a value for countsOnly, defaults to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00700">700</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">                                                           : 
      <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(lb, max, cntOnly), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(0), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(<span class="keyword">false</span>)
    {
        <span class="keywordflow">try</span> {

            <span class="comment">//invokes the base class constructor with LabBox, max and cntOnly</span>
            <span class="comment">//and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>+1);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac34ad69da8e0f3894b74f4027de2614b"></a><!-- doxytag: member="subpavings::SPSVnode::SPSVnode" ref="ac34ad69da8e0f3894b74f4027de2614b" args="(const SPSVnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52">subpavings::SPSVnode::SPSVnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00749">749</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">subpavings::SPSnode::countsOnly</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00381">subpavings::SPSnode::dpSumProducts</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00344">subpavings::SPSnode::dpSums</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">subpavings::SPSnode::splitDim</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00408">subpavings::SPSnode::splitValue</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00572">SPSVnode()</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">                                            : <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(*(other.theBox),
        other.label), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>(other.Vcounter), <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>(other.justSplit)
    {
        <span class="keywordflow">try</span> {
        <span class="comment">// cout &lt;&lt; &quot;copy constructor for &quot; &lt;&lt; nodeName &lt;&lt; &quot; called:&quot; &lt;&lt; endl;</span>
            <span class="comment">//reserve space</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve((other.dataItrs).size());
         <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.reserve((other.VdataItrs).size());

        <span class="comment">//dataItrs = other.dataItrs;</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> = other.counter;
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = other.spaceIndication;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a> = other.dpSums;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a> = other.dpSumProducts; 
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = other.splitDim;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = other.splitValue;
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> = other.countsOnly;
        
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a> = other.VdataItrs;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.nodeName;;

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (other.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(*(other.getLeftChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (other.rightChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(*(other.getRightChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af7739cf5333fccbe27610cbbd1138719"></a><!-- doxytag: member="subpavings::SPSVnode::clearData" ref="af7739cf5333fccbe27610cbbd1138719" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#af7739cf5333fccbe27610cbbd1138719">subpavings::SPSVnode::clearData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the node's data collection for both training and validation set. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa4b207c66d28113dc641d7cddf691547">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00907">907</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">    { 
    <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.clear(); 
      <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.clear();   
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad9b78707e372d9b66876e6afa0cb8eb1"></a><!-- doxytag: member="subpavings::SPSVnode::gatherData" ref="ad9b78707e372d9b66876e6afa0cb8eb1" args="(NodeData &amp;container, SPSVnode *spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1">subpavings::SPSVnode::gatherData</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the node data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of data associated with the node <b> and its descendents </b>. </dd></dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00433">433</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02036">nodeAdoptLeft()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02085">nodeAdoptRight()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">nodeReabsorbChildren()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01960">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!spn-&gt;isLeaf()) {
            <span class="keywordflow">if</span> (spn-&gt;hasLCwithBox()) {
                container =
                    <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(container,
                            spn-&gt;getLeftChild());
            }
            <span class="keywordflow">if</span> (spn-&gt;hasRCwithBox()) {
                container =
                    <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(container,
                            spn-&gt;getRightChild());
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// is a leaf</span>
            <span class="comment">// copy data from spn&#39;s dataItrs into temp container</span>
            container.insert(container.end(),
                            (spn-&gt;dataItrs).begin(),
                            (spn-&gt;dataItrs).end());
        }
        <span class="keywordflow">return</span> container;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac637655f207bc9bc049145a2bd904fdf"></a><!-- doxytag: member="subpavings::SPSVnode::getAllNodes" ref="ac637655f207bc9bc049145a2bd904fdf" args="(SPSVnodePtrs &amp;allNodes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ac637655f207bc9bc049145a2bd904fdf">subpavings::SPSVnode::getAllNodes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>allNodes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to all nodes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of node pointers. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a8683fb9b17016cbe615408b51e791b9c">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01123">1123</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l01123">getAllNodes()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01123">getAllNodes()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) { <span class="comment">// this is not empty</span>
      <span class="comment">//if (!hasLCwithBox() &amp;&amp; !hasRCwithBox()) { // this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
        <span class="comment">//cout &lt;&lt; nodeName &lt;&lt; endl;</span>
            allNodes.push_back(const_cast&lt;SPSVnode*&gt;(<span class="keyword">this</span>));
        }
      
      <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ac637655f207bc9bc049145a2bd904fdf" title="Return a reference to all nodes.">getAllNodes</a>(allNodes);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ac637655f207bc9bc049145a2bd904fdf" title="Return a reference to all nodes.">getAllNodes</a>(allNodes);
        }       
        <span class="keywordflow">return</span> allNodes;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a63ea0f67b354888a8a12c0ffc81b0e5e"></a><!-- doxytag: member="subpavings::SPSVnode::getChebDistCovar" ref="a63ea0f67b354888a8a12c0ffc81b0e5e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a63ea0f67b354888a8a12c0ffc81b0e5e">subpavings::SPSVnode::getChebDistCovar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Chebyshev distance for the var-covar. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7713822499beb30a3d30f43b79c608b8">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01389">1389</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01730">getUniformVarCovar()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01347">getVarCovar()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobjval_8hpp_source.shtml#l00160">subpavings::CompCovarVal::operator()()</a>, and <a class="el" href="nodecompobjval_8hpp_source.shtml#l00175">subpavings::CompCovarMassVal::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> Covar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">getVarCovar</a>();
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> unifCovar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">getUniformVarCovar</a>();

    real ChebDist = 0;
    <span class="comment">//loop through the real vector and get the Chebyshev distances</span>
    
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        real temp = abs(Covar[i] - unifCovar[i]);
        <span class="comment">//std::cout &lt;&lt; temp &lt;&lt; &quot;\t&quot; &lt;&lt; ChebDist &lt;&lt; std::endl;</span>
        ChebDist  = ( temp &gt; ChebDist) ? temp : ChebDist;
      }
      
      <span class="comment">//cout &lt;&lt; &quot;getChebDist: &quot; &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> ChebDist;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a24fc7b09a8293edce2e3b602763a45e3"></a><!-- doxytag: member="subpavings::SPSVnode::getChebDistMean" ref="a24fc7b09a8293edce2e3b602763a45e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a24fc7b09a8293edce2e3b602763a45e3">subpavings::SPSVnode::getChebDistMean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Chebyshev distance for the mean. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa3a4a9df979f04453e82d76866b52850">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01370">1370</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01267">getMean()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01356">getUniformMean()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobjval_8hpp_source.shtml#l00130">subpavings::CompMeanVal::operator()()</a>, and <a class="el" href="nodecompobjval_8hpp_source.shtml#l00145">subpavings::CompMeanMassVal::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    rvector Mean = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a2d2b97cb6916b19ad2affc4907265b6f" title="Get the sample mean.">getMean</a>();
    rvector MeanUnif = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae2cfb09a96d3c6b0d716236cbfccebd3" title="Get the uniform mean vector where each element is the midpoint of the coordinate.">getUniformMean</a>();
    real ChebDist = 0;
    <span class="comment">//loop through the means and get the Chebyshev distances</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        real temp = abs(Mean[i] - MeanUnif[i]);
        <span class="comment">//std::cout &lt;&lt; temp &lt;&lt; &quot;\t&quot; &lt;&lt; ChebDist &lt;&lt; std::endl;</span>
        ChebDist  = ( temp &gt; ChebDist) ? temp : ChebDist;
      }
      
      <span class="comment">//cout &lt;&lt; &quot;getChebDist: &quot; &lt;&lt; endl;</span>
      <span class="comment">//std::cout &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; getMean() &lt;&lt; &quot;\t&quot; &lt;&lt; getUniformMean() &lt;&lt; std::endl;</span>
    <span class="keywordflow">return</span> ChebDist;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ad1e930cb7befb42cd1985e91f3ddd9b6"></a><!-- doxytag: member="subpavings::SPSVnode::getChildrensLeftAndRightCountsIfSplit" ref="ad1e930cb7befb42cd1985e91f3ddd9b6" args="(Size_tVec &amp;grandchildCounts) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad1e930cb7befb42cd1985e91f3ddd9b6">subpavings::SPSVnode::getChildrensLeftAndRightCountsIfSplit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td>
          <td class="paramname"><em>grandchildCounts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return a container of counts for prospective grandchildren. </p>
<p>Should be called only on leaf nodes.</p>
<p>returns an indexable container of the number of points the prospective children of each prospective child (ie all four prospective grandchildren) would be associated with, indexed like this [0] = left child's left child count, [1] = left child's rght child count, [2] = rght child's left child count, [3] = rght child's rght child count, </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">grandchildCounts</td><td>a reference to a container to be filled with the prospective grandchild counts </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>grandchildCounts filled with the prospective grandchild counts. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#acbe47754c218f0c895a900330491cbb3">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00986">986</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// first find what the right hand child&#39;s box would be if that child</span>
        <span class="comment">// were to be created</span>
            <span class="keywordtype">int</span> maxdiamcomp1; <span class="comment">// variable to hold first longest dimension</span>
            <span class="keywordtype">double</span> temp1 = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp1);

            <span class="comment">// ivectors to be new boxes for new children</span>
            ivector rCBox;
            ivector lCBox;
            <span class="comment">// Call Upper() to get what would be the right hand child box</span>
            <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rCBox, maxdiamcomp1);
            <span class="comment">// Call Lower() to get what would be the left hand child box</span>
            <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lCBox, maxdiamcomp1);

            <span class="keywordtype">int</span> maxdiamcomp2; <span class="comment">// variable to hold first longest dimension</span>
            <span class="keywordtype">double</span> temp2 = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(rCBox, maxdiamcomp2);

            <span class="comment">// ivectors to be new boxes for new children</span>
            ivector rCrCBox;
            ivector rClCBox;

            <span class="comment">// Call Upper() to get what would be the right hand child box</span>
            <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rCrCBox, maxdiamcomp2);

            <span class="comment">// Call Lower() to get what would be the left hand child box</span>
            <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rClCBox, maxdiamcomp2);

            <span class="keywordtype">int</span> maxdiamcomp3; <span class="comment">// variable to hold first longest dimension</span>
            <span class="keywordtype">double</span> temp3 = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(lCBox, maxdiamcomp3);

            <span class="comment">// ivectors to be new boxes for new children</span>
            ivector lCrCBox;
            ivector lClCBox;

            <span class="comment">// Call Upper() to get what would be the right hand child box</span>
            <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lCrCBox, maxdiamcomp3);

            <span class="comment">// Call Lower() to get what would be the left hand child box</span>
            <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lClCBox, maxdiamcomp3);


        <span class="comment">// now find how many of this node&#39;s data points would go right</span>
        <span class="comment">// and left children of left and right children</span>
        <span class="keywordtype">size_t</span> rightRightCount = 0;
        <span class="keywordtype">size_t</span> rightLeftCount = 0;
        <span class="keywordtype">size_t</span> leftRightCount = 0;
        <span class="keywordtype">size_t</span> leftLeftCount = 0;
        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

        <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin(); it &lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); it++) {
            <span class="comment">// DataItrs is a container of iterators to a BigDataCollection</span>
            ivector pvec = _ivector((*(*it)));
            <span class="comment">// increment rightCount if the point is in rC</span>
            <span class="keywordflow">if</span> (pvec &lt;= rCBox) {
                <span class="keywordflow">if</span> (pvec &lt;= rCrCBox) rightRightCount++;
                <span class="keywordflow">else</span> leftRightCount++;
            }
            <span class="keywordflow">else</span> {
                <span class="keywordflow">if</span> (pvec &lt;= lCrCBox) rightLeftCount++;
                <span class="keywordflow">else</span> leftLeftCount++;
            }
        }

        grandchildCounts.push_back(leftLeftCount);
        grandchildCounts.push_back(rightLeftCount);
        grandchildCounts.push_back(leftRightCount);
        grandchildCounts.push_back(rightRightCount);

        <span class="keywordflow">return</span> grandchildCounts;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="afb9e32e6d78db527309d95ccc8c0049f"></a><!-- doxytag: member="subpavings::SPSVnode::getEmpMass" ref="afb9e32e6d78db527309d95ccc8c0049f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPSVnode.shtml#afb9e32e6d78db527309d95ccc8c0049f">subpavings::SPSVnode::getEmpMass</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the empirical mass of the node </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a31ee93bb53be29fd0e50ff7fcd189c98">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01409">1409</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01238">getRootCounter()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobjval_8hpp_source.shtml#l00145">subpavings::CompMeanMassVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00175">subpavings::CompCovarMassVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00203">subpavings::CompHellingerDist1DMassVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00217">subpavings::CompHellingerDist1DMassDiamVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00242">subpavings::CompHellingerDistMassVal::operator()()</a>, and <a class="el" href="nodecompobjval_8hpp_source.shtml#l00256">subpavings::CompHellingerDistMassDiamVal::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a346a5ff0d8177212b23342cada4b5c18" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
    <span class="keywordtype">double</span> empMass = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>()*1.0/(n*1.0);
    <span class="comment">//cout &lt;&lt; nodeName &lt;&lt; &quot;\t&quot; &lt;&lt; empMass &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> empMass;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a2e0a1a393daed9e3f5887162b68b0e6e"></a><!-- doxytag: member="subpavings::SPSVnode::getHellingerDist" ref="a2e0a1a393daed9e3f5887162b68b0e6e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2e0a1a393daed9e3f5887162b68b0e6e">subpavings::SPSVnode::getHellingerDist</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Bhattarchaya coefficient. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa0ea6455e40f7f2bdb1e972ab080f5a5">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01419">1419</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01267">getMean()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01238">getRootCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01356">getUniformMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01730">getUniformVarCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01347">getVarCovar()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobjval_8hpp_source.shtml#l00242">subpavings::CompHellingerDistMassVal::operator()()</a>, and <a class="el" href="nodecompobjval_8hpp_source.shtml#l00256">subpavings::CompHellingerDistMassDiamVal::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> Covar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">getVarCovar</a>(); <span class="comment">//get the covariance matrix/</span>
    real HD = 0.0; <span class="comment">//initialize hellinger distance to 0.</span>

    <span class="comment">// if there are no points, cov should be undefined. But since we want to push</span>
    <span class="comment">// this node to the bottom of the queue, hence let HD = 0.</span>
    <span class="comment">// if there is one point, the variance is 0. At the moment, we do not </span>
    <span class="comment">// want to split boxes with only one point and so also let HD = 0.</span>
    <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() == 0 || <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() == 1 ) { <span class="keywordflow">return</span> HD = 0.0; } 

    <span class="keywordflow">else</span> {
      <span class="comment">//cout &lt;&lt; &quot;===========================&quot; &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; getCounter() &lt;&lt; endl;</span>
      <span class="comment">//get the differences of the mean vectors</span>
      rvector diffMean = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a2d2b97cb6916b19ad2affc4907265b6f" title="Get the sample mean.">getMean</a>() - <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae2cfb09a96d3c6b0d716236cbfccebd3" title="Get the uniform mean vector where each element is the midpoint of the coordinate.">getUniformMean</a>();
      <span class="comment">//cout &lt;&lt; &quot;mean differences: &quot; &lt;&lt; diffMean &lt;&lt; endl;</span>

      <span class="comment">//make a gsl matrix for the mean difference</span>
      gsl_matrix * diffMeanMat = gsl_matrix_alloc(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>, 1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 1; j++) {
          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));
        }
      }

      <span class="comment">// get the variances</span>
      <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> unifCovar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">getUniformVarCovar</a>();

      <span class="comment">// initialize matrix objects</span>
      gsl_matrix * CovarMat = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * CovarMatMult = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * UnifCovarMat = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * PMat = gsl_matrix_alloc(dimension, dimension); <span class="comment">//make this same as</span>
                                              <span class="comment">//CovarMat first</span>
      <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a346a5ff0d8177212b23342cada4b5c18" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
    
      <span class="comment">// problem with stably inverting the covariance matrix - if determinant is wrong, will get -DB</span>
      <span class="comment">// fill up the matrics for the var-covar</span>
      <span class="keywordtype">int</span> k = 0; <span class="comment">//counter for RealVec</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {

          <span class="keywordflow">if</span> ( i == j ) {
            gsl_matrix_set(CovarMat, i, j, _double(Covar[k]) + 0.00000001); <span class="comment">//cast to double</span>
            gsl_matrix_set(CovarMatMult, i, j, 100*(_double(Covar[k]))+0.00000001);
          }
          <span class="keywordflow">else</span> {
            gsl_matrix_set(CovarMat, i, j, _double(Covar[k])); <span class="comment">//cast to double</span>
            gsl_matrix_set(CovarMatMult, i, j, 100*(_double(Covar[k])));
          }
          
          gsl_matrix_set(PMat, i, j, _double(Covar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(UnifCovarMat, i, j, _double(unifCovar[k])); <span class="comment">//cast to double</span>
          k++;
        }
      }

      <span class="comment">// if variance is -ve, atomic data points? treat as only one point (not</span>
      <span class="comment">// a very good assumption at the moment) and let HD = 0. </span>
      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
          <span class="keywordflow">if</span> ( (i == j) &amp;&amp; (gsl_matrix_get(CovarMat, i, j) &lt; 0) ) {
            cerr &lt;&lt; <span class="stringliteral">&quot;Negative variance!&quot;</span> &lt;&lt; endl;
            cout.precision(20);
            cout &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &lt;&lt; endl;
            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr;
            cout &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; endl;
            cout.precision(20);
            cout &lt;&lt; <span class="stringliteral">&quot;Data is&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin();
              dataItr!= <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); dataItr++) {
              <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *dataItr;
              rvector theData = *bigIt;
              cout &lt;&lt; theData &lt;&lt; endl; 
            } <span class="comment">// end loop through data container</span>
        
            cerr &lt;&lt; <span class="stringliteral">&quot;Variance cannot be negative.&quot;</span> &lt;&lt; endl; 
            exit(1); 
            
            <span class="comment">/*</span>
<span class="comment">            gsl_matrix_free(CovarMat);</span>
<span class="comment">            gsl_matrix_free(UnifCovarMat);</span>
<span class="comment">            gsl_matrix_free(PMat);</span>
<span class="comment">            return HD = 0.0;</span>
<span class="comment">            */</span> 
          }
        }
      }
  
      <span class="comment">//else {</span>
        <span class="comment">/*cout &lt;&lt; &quot;CovarMat: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(CovarMat, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }</span>
<span class="comment">        cout &lt;&lt; &quot;CovarMatMult: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(CovarMatMult, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }</span>
<span class="comment">        cout &lt;&lt; &quot;UnifCovarMat: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(UnifCovarMat, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }*/</span>

        <span class="comment">//add the two matrices</span>
        gsl_matrix_add(PMat, UnifCovarMat);
        gsl_matrix_scale(PMat, 0.5);
        
        gsl_matrix * PMatForInv = gsl_matrix_alloc(dimension, dimension);
        PMatForInv = PMat; 
        <span class="comment">/*cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(PMat, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }*/</span>

        <span class="comment">// get the determinants of CovarMat, UnifCovarMat, PMat</span>
        <span class="keywordtype">int</span> s;
        gsl_permutation * p = gsl_permutation_alloc(dimension);
        gsl_linalg_LU_decomp(CovarMatMult, p, &amp;s);
        <span class="comment">//cout &lt;&lt; &quot;CovarMat LU decomp: &quot; &lt;&lt; endl;</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
            <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(CovarMat, i, j) &lt;&lt; endl; </span>
          }
        }
        <span class="keywordtype">double</span> detCovarMat = gsl_linalg_LU_det(CovarMatMult, s)/(<a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(100,dimension));
        <span class="comment">//cout &lt;&lt; &quot;det covar mat: &quot; &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; endl;</span>
        gsl_permutation_free(p);
        <span class="comment">// it is possible to get negative determinants, and negative DB, temporarily sweeping this under the rug </span>
        <span class="keywordflow">if</span> (detCovarMat &lt; 0) { cout &lt;&lt; <span class="stringliteral">&quot;Negative determinant.&quot;</span> &lt;&lt; endl; exit(1); }<span class="comment">//return HD = 0.0; }</span>
        <span class="keywordflow">else</span> {
          
          <span class="keywordtype">int</span> s1;
          gsl_permutation * p1 = gsl_permutation_alloc(dimension);
          gsl_linalg_LU_decomp(UnifCovarMat, p1, &amp;s1);
          <span class="comment">//cout &lt;&lt; &quot;UnifCovarMat decomp: &quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(UnifCovarMat, i, j) &lt;&lt; endl; </span>
            }
          }
          <span class="keywordtype">double</span> detUnifCovarMat = gsl_linalg_LU_det(UnifCovarMat, s1);
          <span class="comment">//cout &lt;&lt; &quot;det unif covar mat: &quot; &lt;&lt; detUnifCovarMat &lt;&lt; endl;</span>
          gsl_permutation_free(p1);

          <span class="keywordtype">int</span> s2;
          gsl_permutation * p2 = gsl_permutation_alloc(dimension);
          gsl_linalg_LU_decomp(PMat, p2, &amp;s2);
          <span class="keywordtype">double</span> detPMat = gsl_linalg_LU_det(PMat, s2);
          <span class="comment">//cout &lt;&lt; &quot;det p mat: &quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
  
          <span class="comment">//now get the inverse of P</span>
          gsl_matrix * Pinverse = gsl_matrix_alloc(dimension, dimension); 
          gsl_linalg_LU_invert(PMat, p2, Pinverse);
          gsl_permutation_free(p2);
          <span class="comment">//cout &lt;&lt; &quot;p inverse &quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
            }
          }
      
          <span class="comment">//now get the Bhattacharya coefficient</span>
          <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
          gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, dimension);
          gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);
        
          <span class="comment">// now convert all to rmatrix for easier computations</span>
          rmatrix diffMeanR(0, dimension-1, 0, 0);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 1; j++) {
              diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); 
            }
          }
        
          rmatrix diffMeanTransR(0, 0, 0, dimension-1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); 
            }
          }
        
          rmatrix PinvR(0, dimension-1, 0, dimension-1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); 
            }
          }
        
          <span class="comment">//free the gsl_matrices</span>
          gsl_matrix_free(CovarMat);
          gsl_matrix_free(UnifCovarMat);
          gsl_matrix_free(PMat);
        
          <span class="comment">//cout &lt;&lt; diffMeanR &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; diffMeanTransR &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; PinvR &lt;&lt; endl;</span>
        
          <span class="comment">//now get the Bhattacharya coefficient</span>
          <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
          <span class="comment">//cout &lt;&lt; (diffMeanTransR*PinvR)*diffMeanR &lt;&lt; endl;</span>
          rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;
          <span class="comment">//cout &lt;&lt; MatOp &lt;&lt; &quot;\t&quot; &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
          assert(MatOp &gt;= 0);
          real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(detCovarMat*detUnifCovarMat));
          <span class="comment">//cout &lt;&lt; &quot;DB: &quot; &lt;&lt; DB &lt;&lt; endl;</span>
          <span class="keywordflow">if</span> ( DB &lt;  0 ) { <span class="keywordflow">return</span> HD = 0.0; }
          <span class="keywordflow">else</span> {
          
            real BC = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-DB);
            assert(BC &gt;= 0);
          <span class="comment">//cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
            real HD = <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1-BC);
          <span class="comment">//cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HD &lt;&lt; endl;</span>
            assert(HD &gt;=0);
            <span class="keywordflow">return</span> HD;
          }
        } <span class="comment">// end of determinant is not zero</span>
      }
  }   
</pre></div>
</div>
</div>
<a class="anchor" id="a3b56f3b8a024ab6929087e803e7af765"></a><!-- doxytag: member="subpavings::SPSVnode::getHellingerDist1D" ref="a3b56f3b8a024ab6929087e803e7af765" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3b56f3b8a024ab6929087e803e7af765">subpavings::SPSVnode::getHellingerDist1D</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#afe386393d18f1e251972e959e79c3847">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01651">1651</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01267">getMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01356">getUniformMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01730">getUniformVarCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01347">getVarCovar()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobjval_8hpp_source.shtml#l00189">subpavings::CompHellingerDist1DVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00203">subpavings::CompHellingerDist1DMassVal::operator()()</a>, and <a class="el" href="nodecompobjval_8hpp_source.shtml#l00217">subpavings::CompHellingerDist1DMassDiamVal::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">   {
    real HD = 0.0; 
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> Covar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">getVarCovar</a>();

    <span class="comment">// if the variance is negative - need to investiage this more</span>
    <span class="comment">/*</span>
<span class="comment">    if (Covar[0] &lt; 0) {</span>
<span class="comment">      cout &lt;&lt; getCounter() &lt;&lt; endl;</span>
<span class="comment">      cout &lt;&lt; Covar[0] &lt;&lt; endl;</span>
<span class="comment">      NodeDataItr dataItr;</span>
<span class="comment">      cout &lt;&lt; getNodeName() &lt;&lt; endl;</span>
<span class="comment">      cout &lt;&lt; &quot;Data is&quot; &lt;&lt; std::endl;</span>
<span class="comment">          for (dataItr = dataItrs.begin();</span>
<span class="comment">                dataItr!= dataItrs.end(); dataItr++) {</span>
<span class="comment"></span>
<span class="comment">                BigDataItr bigIt = *dataItr;</span>
<span class="comment">                rvector theData = *bigIt;</span>
<span class="comment"></span>
<span class="comment">                cout &lt;&lt; theData &lt;&lt; endl; </span>
<span class="comment">      } // end loop through data container</span>
<span class="comment">      </span>
<span class="comment">      cerr &lt;&lt; &quot;Variance cannot be negative.&quot; &lt;&lt; endl; </span>
<span class="comment">      exit(1); </span>
<span class="comment">    }</span>
<span class="comment">  */</span>
  
    <span class="comment">// can continue if variance is not negative</span>

      <span class="comment">// if there are no points, should be undefined. But since we want to push</span>
      <span class="comment">// this node to the bottom of the queue, hence let HD = 0.</span>
      <span class="comment">// if there is one point, the variance is 0. At the moment, we do not </span>
      <span class="comment">//want to split boxes with only one point and so also let HD = 0.</span>
      <span class="comment">// if variance is -ve, atomic data points? treat as only one point (not</span>
      <span class="comment">// a very good assumption at the moment) and let HD = 0. </span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() == 0  || Covar[0] &lt;= 0 ) { <span class="keywordflow">return</span> HD = 0.0; } 
      <span class="comment">/*else if ( Covar[0] == 0 ) { </span>
<span class="comment">        cout &lt;&lt; getCounter() &lt;&lt; endl;</span>
<span class="comment">        cout &lt;&lt; getEmpMass() &lt;&lt; endl;</span>
<span class="comment">        cout &lt;&lt; nodeVolume() &lt;&lt; endl;</span>
<span class="comment">        cout &lt;&lt; getMean() &lt;&lt; endl;</span>
<span class="comment">        cerr &lt;&lt; &quot;no variance. check!&quot; &lt;&lt; endl;</span>
<span class="comment">        exit(1);</span>
<span class="comment">      }*/</span>

      <span class="keywordflow">else</span> {
        <span class="comment">//get the differences of the mean vectors</span>
        rvector diffMean = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a2d2b97cb6916b19ad2affc4907265b6f" title="Get the sample mean.">getMean</a>() - <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae2cfb09a96d3c6b0d716236cbfccebd3" title="Get the uniform mean vector where each element is the midpoint of the coordinate.">getUniformMean</a>();
        <span class="comment">//cout &lt;&lt; &quot;mean differences: &quot; &lt;&lt; diffMean[1] &lt;&lt; endl;</span>
        
        <span class="comment">// get the variances</span>
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> unifCovar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">getUniformVarCovar</a>();
        <span class="comment">//cout &lt;&lt; &quot;Covar: &quot; &lt;&lt; Covar[0] &lt;&lt;  endl;</span>
        <span class="comment">//cout &lt;&lt; &quot;unifCovar: &quot; &lt;&lt; unifCovar[0] &lt;&lt; endl;</span>
        <span class="comment">//if all the elements for CovarMat are all zero, we do not have any points in </span>
        <span class="comment">//this leaf node - so return hellinger distance as 0</span>
  
        <span class="comment">// use the sqrt of the squared hellinger distance for two normal distributions</span>
        <span class="comment">// 1 - sqrt(2*sigma1*sigma2/(sigma1^2 + sigma2^2))*exp(-0.25*(mu1-mu2)^2/(sigma1^2+sigma2^2))</span>
        <span class="comment">//cout &lt;&lt; diffMean &lt;&lt; &quot;\t&quot;;</span>
        interval covarI = interval(Covar[0]);
        interval unifCovarI = interval(unifCovar[0]);
        interval sumVar = covarI + unifCovarI;
        <span class="comment">//cout &lt;&lt; sumVar &lt;&lt; &quot;\t&quot;;</span>
        interval insqrt = 2*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(covarI)*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(unifCovarI)/sumVar;
        <span class="comment">//cout &lt;&lt; insqrt &lt;&lt; &quot;\t&quot;;</span>
        interval H2 = interval(1,1) - <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(insqrt) *<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>((-0.25*diffMean[1]*diffMean[1])/sumVar);
        <span class="comment">//cout &lt;&lt; &quot;H2: &quot; &lt;&lt; H2 &lt;&lt; endl;</span>
        HD = mid(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(H2));
        <span class="comment">//cout &lt;&lt; HD &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( HD &gt; 1 || HD &lt; 0) { 
          cerr &lt;&lt; <span class="stringliteral">&quot;HD should be between 0 and 1.&quot;</span> &lt;&lt; endl;
          exit(0);
        }
        <span class="keywordflow">return</span> HD;
      }

  }
</pre></div>
</div>
</div>
<a class="anchor" id="a899334f4e1760a380a776bc38d664710"></a><!-- doxytag: member="subpavings::SPSVnode::getJustSplit" ref="a899334f4e1760a380a776bc38d664710" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a899334f4e1760a380a776bc38d664710">subpavings::SPSVnode::getJustSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the node's justSplit boolean flag. </p>
<p>Returns justSplit. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00898">898</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8hpp_source.shtml#l00266">justSplit</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="adfb30c9946f868e143c81e6bf35a7a6f"></a><!-- doxytag: member="subpavings::SPSVnode::getLargestLeafCount" ref="adfb30c9946f868e143c81e6bf35a7a6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#adfb30c9946f868e143c81e6bf35a7a6f">subpavings::SPSVnode::getLargestLeafCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the count in the leaf with the smallest count. </p>
<p>Returns the count of the largest (by count) leaf node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#ae094573d2988d458e00a549039a6ad56">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01207">1207</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">getLeaves()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> largestCount = 0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            largestCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>

            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <span class="comment">// could be just this if no children</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <span class="comment">// find the largest child by volume</span>
            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> it;
            largestCount = (*(leaves.begin()))-&gt;counter;

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;counter &gt; largestCount) {
                    largestCount = (*it)-&gt;counter;
                }
            }
        } <span class="comment">// end else not a leaf</span>

        <span class="keywordflow">return</span> largestCount;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0d6df4752e05170510e43b67d8eb3110"></a><!-- doxytag: member="subpavings::SPSVnode::getLeafNodeCounts" ref="a0d6df4752e05170510e43b67d8eb3110" args="(Size_tVec &amp;counts) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0d6df4752e05170510e43b67d8eb3110">subpavings::SPSVnode::getLeafNodeCounts</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td>
          <td class="paramname"><em>counts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills in container of leaf counts, left to right.</p>
<p>Traverses the leaves left to right, puts the leaf counts into container.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">counts</td><td>is reference to the container to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the container filled in with leaf counts. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a2f8ce829fd9ba3ef3838d640ae201e9e">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01060">1060</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01060">getLeafNodeCounts()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03337">subpavings::AdaptiveHistogramValidation::getLeafCounts()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01060">getLeafNodeCounts()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0d6df4752e05170510e43b67d8eb3110">getLeafNodeCounts</a>(counts);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0d6df4752e05170510e43b67d8eb3110">getLeafNodeCounts</a>(counts);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

            counts.push_back(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>);
        }
        <span class="keywordflow">return</span> counts;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6f3850e716947e051a9e9af16c2b4508"></a><!-- doxytag: member="subpavings::SPSVnode::getLeaves" ref="a6f3850e716947e051a9e9af16c2b4508" args="(SPSVnodePtrs &amp;leaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508">subpavings::SPSVnode::getLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to all descendent leaf nodes. </p>
<p>Will be just this if this is a leaf.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of node pointers. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01080">1080</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l01080">getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">subpavings::AdaptiveHistogramValidation::getFinMixIntervalIAE()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01207">getLargestLeafCount()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01175">getSmallestLeafCount()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01147">getSumLeafCountOverVol()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">subpavings::AdaptiveHistogramValidation::getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
            leaves.push_back(const_cast&lt;SPSVnode*&gt;(<span class="keyword">this</span>));
        }
        <span class="keywordflow">return</span> leaves;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3ef0b662df21eb88689644cb5d1279d2"></a><!-- doxytag: member="subpavings::SPSVnode::getLeftChild" ref="a3ef0b662df21eb88689644cb5d1279d2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2">subpavings::SPSVnode::getLeftChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the left child of a node. </p>
<p>Hides the base class version of this method.</p>
<p>Returns a copy of the pointer to leftChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00920">920</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">gatherData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01123">getAllNodes()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01060">getLeafNodeCounts()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01103">getSubLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01795">leavesOutputTabs()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01828">leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">nodeReabsorbChildren()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">operator=()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">strippedConstructor()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00503">unionNoData()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a64b5d63790c02a454aa0e86222b1a3d3"></a><!-- doxytag: member="subpavings::SPSVnode::getLeftCountIfSplit" ref="a64b5d63790c02a454aa0e86222b1a3d3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a64b5d63790c02a454aa0e86222b1a3d3">subpavings::SPSVnode::getLeftCountIfSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The count the left child would have if this node was split. </p>
<p>Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the left child if the node were to be split. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad077233e00a7093d66e35cca6fc6db6b">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00964">964</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00932">getRightCountIfSplit()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a9a51fbde60e061846a93981688cc67af" title="The count the right child would have if this node was split.">getRightCountIfSplit</a>();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2d2b97cb6916b19ad2affc4907265b6f"></a><!-- doxytag: member="subpavings::SPSVnode::getMean" ref="a2d2b97cb6916b19ad2affc4907265b6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2d2b97cb6916b19ad2affc4907265b6f">subpavings::SPSVnode::getMean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sample mean. </p>
<p>This calculates the sample mean from the accumulators for the sums of data point elements. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa5ae31017fb2fdee8b9168009d8d08a6">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01267">1267</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">subpavings::SPSnode::countsOnly</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00344">subpavings::SPSnode::dpSums</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01370">getChebDistMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">getHellingerDist()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01651">getHellingerDist1D()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// set up an rvector retMean of the correct dimensions</span>
        rvector retMean(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);
        <span class="comment">// loop through the elements in the dpSums vector</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {

            <span class="comment">// if no data elements each element or if only counts are held,</span>
            <span class="comment">// that element of the mean is 0.0</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> || (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> == 0)) {
                <span class="comment">// cxsc::rvector is indexed 1 to n</span>
                retMean[i+1] = 0.0;
            }
            <span class="comment">// if data elements, find the element-by-element mean</span>
            <span class="keywordflow">else</span> {
                <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
                retMean[i+1] = rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i])/(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>);

            }
        }<span class="comment">// end loop through the elements in dpSums</span>

        <span class="keywordflow">return</span> retMean;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a43024ae81075f8a822ccccad013b3ef7"></a><!-- doxytag: member="subpavings::SPSVnode::getMinChildCountIfSplit" ref="a43024ae81075f8a822ccccad013b3ef7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a43024ae81075f8a822ccccad013b3ef7">subpavings::SPSVnode::getMinChildCountIfSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Smallest number of points in either child if this was split. </p>
<p>Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the left and right child if the node were to be split. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00970">970</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00932">getRightCountIfSplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">subpavings::AdaptiveHistogramValidation::checkNodeCountForSplit()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> min = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a9a51fbde60e061846a93981688cc67af" title="The count the right child would have if this node was split.">getRightCountIfSplit</a>();
        <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - min) &lt; min) min = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - min;
        <span class="keywordflow">return</span> min;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ae42cbf85bd00caf12e6acac68ae1fcd3"></a><!-- doxytag: member="subpavings::SPSVnode::getParent" ref="ae42cbf85bd00caf12e6acac68ae1fcd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3">subpavings::SPSVnode::getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the parent of a node. </p>
<p>Hides the base class version of this method.</p>
<p>Returns a copy of the pointer to parent node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00915">915</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01238">getRootCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01252">getRootVcounter()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l02184">nodeContains()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="af681e178575b285f123c1c01bac9ac42"></a><!-- doxytag: member="subpavings::SPSVnode::getRightChild" ref="af681e178575b285f123c1c01bac9ac42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42">subpavings::SPSVnode::getRightChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the right child of a node. </p>
<p>Hides the base class version of this method.</p>
<p>Returns a copy of the pointer to rightChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00925">925</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">gatherData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01123">getAllNodes()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01060">getLeafNodeCounts()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01103">getSubLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01795">leavesOutputTabs()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01828">leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">nodeReabsorbChildren()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">operator=()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">strippedConstructor()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00503">unionNoData()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a9a51fbde60e061846a93981688cc67af"></a><!-- doxytag: member="subpavings::SPSVnode::getRightCountIfSplit" ref="a9a51fbde60e061846a93981688cc67af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a9a51fbde60e061846a93981688cc67af">subpavings::SPSVnode::getRightCountIfSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The count the right child would have if this node was split. </p>
<p>Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the right child if the node were to be split. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa10917d57d9a50cb2d393a422188a51f">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00932">932</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l00964">getLeftCountIfSplit()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00970">getMinChildCountIfSplit()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// first find what the right hand child&#39;s box would be if that child</span>
        <span class="comment">// were to be created</span>
            <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
            <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);

            <span class="comment">// ivectors to be new boxes for new children</span>
            ivector rCBox;

            <span class="comment">// Call Upper() to get what would be the right hand child box</span>
            <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rCBox, maxdiamcomp);

        <span class="comment">// now find how many of this node&#39;s data points would go right</span>
        <span class="comment">// all the rest of them would go left</span>
        <span class="keywordtype">size_t</span> rightCount = 0;
        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

        <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin(); it &lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); it++) {
            <span class="comment">// DataItrs is a container of iterators to a BigDataCollection</span>
            ivector pvec = _ivector((*(*it)));
            <span class="comment">// increment rightCount if the point is in rC</span>
            <span class="keywordflow">if</span> (pvec &lt;= rCBox) rightCount++;
        }

        <span class="keywordflow">return</span> rightCount;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a346a5ff0d8177212b23342cada4b5c18"></a><!-- doxytag: member="subpavings::SPSVnode::getRootCounter" ref="a346a5ff0d8177212b23342cada4b5c18" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a346a5ff0d8177212b23342cada4b5c18">subpavings::SPSVnode::getRootCounter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The count in the node's ultimate ancestor root. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aeac2247b4626b1adfa609d3ff109ceb2">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01238">1238</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00915">getParent()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01238">getRootCounter()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00263">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01409">getEmpMass()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">getHellingerDist()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01238">getRootCounter()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">subpavings::AdaptiveHistogramValidation::getUnifIAE()</a>, and <a class="el" href="nodecompobjval_8hpp_source.shtml#l00103">subpavings::CompAreaVal::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> retValue = 0;
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) { <span class="comment">// this is root</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
        }
        <span class="keywordflow">else</span> {
            <span class="comment">// recurse upwards</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a346a5ff0d8177212b23342cada4b5c18" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
        }
        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="acb4a623e5679b79f05244e79a078e6c1"></a><!-- doxytag: member="subpavings::SPSVnode::getRootVcounter" ref="acb4a623e5679b79f05244e79a078e6c1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#acb4a623e5679b79f05244e79a078e6c1">subpavings::SPSVnode::getRootVcounter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The count in the node's ultimate ancestor root. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01252">1252</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l00915">getParent()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01252">getRootVcounter()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00285">Vcounter</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00263">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01252">getRootVcounter()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> retValue = 0;
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) { <span class="comment">// this is root</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>;
        }
        <span class="keywordflow">else</span> {
            <span class="comment">// recurse upwards</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#acb4a623e5679b79f05244e79a078e6c1" title="The count in the node&#39;s ultimate ancestor root.">getRootVcounter</a>();
        }
        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5d355f8da3eb609f5c81ce63b437fcf9"></a><!-- doxytag: member="subpavings::SPSVnode::getSmallestLeafCount" ref="a5d355f8da3eb609f5c81ce63b437fcf9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d355f8da3eb609f5c81ce63b437fcf9">subpavings::SPSVnode::getSmallestLeafCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the count of the leaf with the smallest count. </p>
<p>Returns the count in the smallest (by count) leaf node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a6a75d9675312fb76aaf98bbeb084f9d6">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01175">1175</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">getLeaves()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> smallestCount = 0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            smallestCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>
            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <span class="comment">// find the smallest child by count</span>
            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> it;
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* smallest = *(leaves.begin());

            smallestCount = smallest-&gt;counter;

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;counter &lt; smallestCount) {

                    smallestCount = (*it)-&gt;counter;
                }
            }
        } <span class="comment">// end else not a leaf</span>

        <span class="keywordflow">return</span> smallestCount;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa5408d2d74de8b95325c5973cf43f7fb"></a><!-- doxytag: member="subpavings::SPSVnode::getSubLeaves" ref="aa5408d2d74de8b95325c5973cf43f7fb" args="(SPSVnodePtrs &amp;subleaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#aa5408d2d74de8b95325c5973cf43f7fb">subpavings::SPSVnode::getSubLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>subleaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to all sub-leaf descendent nodes. </p>
<p>Sub-leaf nodes have at least one child but any child must be a leaf, ie sub-leaves are the parents of leaf nodes.</p>
<p>Will be just this if this is a subleaf.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of node pointers. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01103">1103</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01103">getSubLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00443">subpavings::SPnode::isSubLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01103">getSubLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#aa5408d2d74de8b95325c5973cf43f7fb" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#aa5408d2d74de8b95325c5973cf43f7fb" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc" title="find if this node is a subleaf node.">isSubLeaf</a>()) { <span class="comment">// this is a subleaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a subleaf</span>
            subleaves.push_back(const_cast&lt;SPSVnode*&gt;(<span class="keyword">this</span>));
        }
        <span class="keywordflow">return</span> subleaves;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac741a9772d992ba74911cf692e1ed772"></a><!-- doxytag: member="subpavings::SPSVnode::getSumLeafCountOverVol" ref="ac741a9772d992ba74911cf692e1ed772" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ac741a9772d992ba74911cf692e1ed772">subpavings::SPSVnode::getSumLeafCountOverVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sum of the count over volume in the leaf nodes. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf589d16a3e20b4285f428c8dc42d75d">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01147">1147</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">getLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00556">subpavings::AdaptiveHistogramValidation::getRootSumLeafCountOverVol()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision sum(0.0);

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            accumulate(sum, 1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, (1.0/<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>

            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> it;

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                accumulate(sum, 1.0*((*it)-&gt;getCounter()),
                            (1.0/(*it)-&gt;nodeVolume()));
            }
        }
        <span class="keywordflow">return</span> rnd(sum);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ae2cfb09a96d3c6b0d716236cbfccebd3"></a><!-- doxytag: member="subpavings::SPSVnode::getUniformMean" ref="ae2cfb09a96d3c6b0d716236cbfccebd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae2cfb09a96d3c6b0d716236cbfccebd3">subpavings::SPSVnode::getUniformMean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the uniform mean vector where each element is the midpoint of the coordinate. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a4369d3887385551e053d3873b600f8a1">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01356">1356</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01370">getChebDistMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">getHellingerDist()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01651">getHellingerDist1D()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    rvector unifMean(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);
    
    <span class="comment">// loop through the coordinates of this box to get the midpoint at each</span>
    <span class="comment">// coordinate</span>
    ivector thisBox = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
      unifMean[i] = mid(thisBox[i]);
    }
    <span class="keywordflow">return</span> unifMean;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a0a9c9ba4802d37fdb0ee1fff25908fbb"></a><!-- doxytag: member="subpavings::SPSVnode::getUniformVarCovar" ref="a0a9c9ba4802d37fdb0ee1fff25908fbb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">subpavings::SPSVnode::getUniformVarCovar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01730">1730</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01389">getChebDistCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">getHellingerDist()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01651">getHellingerDist1D()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> retVarCovar;
        retVarCovar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">getUniformVarCovar</a>(retVarCovar);
        <span class="keywordflow">return</span> retVarCovar;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab1f050670fdcdc6f68e009a0cba0ed35"></a><!-- doxytag: member="subpavings::SPSVnode::getUniformVarCovar" ref="ab1f050670fdcdc6f68e009a0cba0ed35" args="(RealVec &amp;varCovar) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">subpavings::SPSVnode::getUniformVarCovar</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td>
          <td class="paramname"><em>varCovar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a8ca1683e838159d5a33048344bec9b49">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01739">1739</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>.</p>
<div class="fragment"><pre class="fragment">    {
      unifVarCovar.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);
      ivector thisBox = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
      
      <span class="comment">// fill in the matrix where the diag are (1/12)*(b-a)^2 and off-diag </span>
      <span class="comment">// are 0.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; dimension*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
          unifVarCovar.push_back(0.0); <span class="comment">//first fill up the container with 0</span>
      }
      <span class="comment">// then fill up the diags</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordtype">int</span> pos = i*dimension + i;
        unifVarCovar[pos] = 1.0/12.0 * (Sup(thisBox[i+1]) - Inf(thisBox[i+1])) 
                      * (Sup(thisBox[i+1]) - Inf(thisBox[i+1]));
      }
      
      <span class="comment">//for (size_t i = 0; i &lt; dimension*dimension; i++) {cout &lt;&lt; unifVarCovar[i] &lt;&lt; endl;}</span>

        <span class="keywordflow">return</span> unifVarCovar;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="abdef36aad99bfe53f78d4e8304ac59d6"></a><!-- doxytag: member="subpavings::SPSVnode::getVarCovar" ref="abdef36aad99bfe53f78d4e8304ac59d6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> <a class="el" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">subpavings::SPSVnode::getVarCovar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01347">1347</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01389">getChebDistCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">getHellingerDist()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01651">getHellingerDist1D()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> retVarCovar;
        retVarCovar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">getVarCovar</a>(retVarCovar);
        <span class="keywordflow">return</span> retVarCovar;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a61adf71c4652c4ec29a9dc323174d1a3"></a><!-- doxytag: member="subpavings::SPSVnode::getVarCovar" ref="a61adf71c4652c4ec29a9dc323174d1a3" args="(RealVec &amp;varCovar) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">subpavings::SPSVnode::getVarCovar</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td>
          <td class="paramname"><em>varCovar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a1bc0843e834ae4d09db3bc148b64761b">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01294">1294</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">subpavings::SPSnode::countsOnly</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00381">subpavings::SPSnode::dpSumProducts</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00344">subpavings::SPSnode::dpSums</a>.</p>
<div class="fragment"><pre class="fragment">    {
        varCovar.clear();
        varCovar.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);

        <span class="comment">// loop through the elements in the dpSumProducts vector</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; dimension*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; k++) {

            <span class="comment">// counts only held or if 0 or 1 data points</span>
            <span class="comment">// each element of the var-covar is 0.0</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> || (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &lt;= 1)) {
                varCovar.push_back(0.0);
            }
            <span class="comment">// if &gt;1 data points find element-by-element var-covar</span>

            <span class="comment">/*the var-covar is the sample var-covar</span>
<span class="comment">            which is</span>
<span class="comment">            [sumproduct(i,j)-sum(i)sum(j)/counter]/(counter-1)</span>
<span class="comment"></span>
<span class="comment">            element k in the vector of dotprecison sumproducts</span>
<span class="comment">            corresponds to row k/n, (row 0 to n-1)</span>
<span class="comment">            and column k-row*n (col 0 to n-1)</span>
<span class="comment">            in a matrix view of the sumproducts */</span>

            <span class="keywordflow">else</span> {
                <span class="keywordtype">size_t</span> i = k/<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; <span class="comment">// row  (int/int = int)</span>
                <span class="keywordtype">size_t</span> j = k - i*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; <span class="comment">// column</span>

                <span class="comment">// make another dotprecision variable</span>
                dotprecision temp1 = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[k];

                dotprecision temp2(0.0);
                <span class="comment">// sum(i) x sum(j)</span>
                <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
                accumulate(temp2,  rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i]),
                        rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[j]));

                real div = -1.0/<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;

                <span class="comment">// sumproduct(i,j) - sum(i)(sum(j)/counter</span>
                <span class="comment">// default cxsc rounding</span>
                accumulate(temp1, rnd(temp2), div);
                <span class="comment">// calculate the variance covariance element</span>
                varCovar.push_back(rnd(temp1)/(1.0*(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>-1)));

            }
        }<span class="comment">// end loop through the elements in dpSumProducts</span>

        <span class="keywordflow">return</span> varCovar;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7d7f4ecaaf020bcb614557eba4743f6a"></a><!-- doxytag: member="subpavings::SPSVnode::getVcounter" ref="a7d7f4ecaaf020bcb614557eba4743f6a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a7d7f4ecaaf020bcb614557eba4743f6a">subpavings::SPSVnode::getVcounter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the node's validation data counter. </p>
<p>Returns Vcounter. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00894">894</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8hpp_source.shtml#l00285">Vcounter</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">subpavings::AdaptiveHistogramValidation::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00548">subpavings::AdaptiveHistogramValidation::getRootVcounter()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">subpavings::AdaptiveHistogramValidation::getUnifIAE()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a05d47c013af462f857c6f54b20cb3404"></a><!-- doxytag: member="subpavings::SPSVnode::getVdata" ref="a05d47c013af462f857c6f54b20cb3404" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a05d47c013af462f857c6f54b20cb3404">subpavings::SPSVnode::getVdata</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the node's validation data collection. </p>
<p>Returns a copy of the node's collection of iterators to the big data set. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00903">903</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a58deac20a0a5b69bb06cdc04fc059135"></a><!-- doxytag: member="subpavings::SPSVnode::insertOneFind" ref="a58deac20a0a5b69bb06cdc04fc059135" args="(BigDataItr newItr, OPERATIONS_ON childInd, const SplitDecisionObj &amp;boolTest, bool boolVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135">subpavings::SPSVnode::insertOneFind</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">BigDataItr</a>&#160;</td>
          <td class="paramname"><em>newItr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a>&#160;</td>
          <td class="paramname"><em>childInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boolVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts data into this node. </p>
<p>Called recursively from the root and through the tree, seeking leaf node whose box contains the data point. If data is inserted, this method also tests whether the node should be expanded following the addition of the data. Following an expansion, insertOneFind is used again to pass the the node's data down to its new children.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newItr</td><td>an iterator to the data in big data collection. </td></tr>
    <tr><td class="paramname">childInd</td><td>an indicator for whether the current node is a treated as a left or right child or a root. This is passed to <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a803d11f31d86f0565dbe682a33099698" title="Check if the box a node represents contains a datapoint p.">nodeContains()</a> when testing whether the node contains the data. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. This object can a dummy which never splits the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the node the data is 'inserted' into, before it is split, or NULL if no insert. </dd></dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l02132">2132</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02184">nodeContains()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01873">nodeExpand()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_RIGHT</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00073">recalculateStats()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">subpavings::AdaptiveHistogramValidation::insertDataFromContainer()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02036">nodeAdoptLeft()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02085">nodeAdoptRight()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01960">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">   {
      rvector newData = *newItr;
      <span class="comment">// start at the top</span>
      <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* retObj = NULL;
      <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a803d11f31d86f0565dbe682a33099698" title="Check if the box a node represents contains a datapoint p.">nodeContains</a>(newData, childInd)) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af37c85866ee5bdb968faf84856b51291" title="Recalculate summary statistics associated with node.">recalculateStats</a>(newData, boolVal);
            <span class="keywordtype">bool</span> wasLeaf = (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>());
            <span class="comment">// if it is a leaf, add the data and return this object</span>
            <span class="keywordflow">if</span>(wasLeaf) { 
                <span class="keywordflow">if</span> (boolVal==<span class="keyword">true</span>) {
                   <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.push_back(newItr);
                }
                <span class="keywordflow">else</span> {
                     <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.push_back(newItr);
                }            
                <span class="comment">// give this node as return value</span>
                retObj = <span class="keyword">this</span>;
                <span class="comment">// split if we need to</span>
                <span class="keywordflow">if</span> (boolTest(<span class="keyword">this</span>)) {
                    <span class="comment">// expand and split data to children</span>
                    <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0eb85efd74fa770f3259d6ba948b65b8" title="Expand a leaf node.">nodeExpand</a>(boolTest, boolVal);
                } <span class="comment">// end if we need to split</span>
            } <span class="comment">// end of isLeaf</span>
            <span class="comment">// if not a leaf before we had split, and contains data</span>
            <span class="comment">// recurse on the children if any</span>
            <span class="keywordflow">if</span> (!wasLeaf) {
               <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>!=NULL &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()){
                    retObj =
                    (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(
                        newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>, boolTest, boolVal);
               }
               <span class="comment">// only try left if we did not find on the right</span>
               <span class="keywordflow">if</span>(retObj == NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>!=NULL &amp;&amp;
                                    !<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
                    retObj =
                    (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(newItr,
                    <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>, boolTest, boolVal);
               }
            }
         } <span class="comment">// end if node contains</span>
        <span class="comment">// will return null if does not contain the data</span>
        <span class="keywordflow">return</span> retObj;
      }
</pre></div>
</div>
</div>
<a class="anchor" id="a01b35db8ce4b99460ff352f6d25a529c"></a><!-- doxytag: member="subpavings::SPSVnode::leafOutputTabs" ref="a01b35db8ce4b99460ff352f6d25a529c" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a01b35db8ce4b99460ff352f6d25a529c">subpavings::SPSVnode::leafOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector is:</p>
<p>label [tab] counter [tab] Vcounter [tab] volume [tabl] Inf(ivector[1]) [tab] Sup(ivector[1]) [tab] ... [tab] Inf(ivector[n]) [tab] Sup(ivector[n]) </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a3cc0c8bb64c854ef16ba03891f5945d6">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00373">373</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01795">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> prec = 5; <span class="comment">// precision for output</span>

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy of theBox</span>

            <span class="comment">// output the node name, nodeVolume, counter</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>;
            <span class="comment">// followed by the intervals of box using Inf and Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>

            streamsize oldPrec = os.precision();
            os &lt;&lt; setprecision(prec);

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
            os &lt;&lt; setprecision(oldPrec);

        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2ab7acc0aff92694976546f1555f67ed"></a><!-- doxytag: member="subpavings::SPSVnode::leafOutputTabsWithEMPs" ref="a2ab7acc0aff92694976546f1555f67ed" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2ab7acc0aff92694976546f1555f67ed">subpavings::SPSVnode::leafOutputTabsWithEMPs</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data.</p>
<p>The format for a d-dimensional interval vector is</p>
<p>nodeName [tab] counter [tab] volume [tab] scaled EMP contribution COPERR [tab] change in scaled EMP contribution COPERR if split [tab] scaled EMP contribution AIC [tab] change in scaled EMP contribution AIC if split [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[d]) [tab] Sup(ivector[d] </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total datapoints, used by the emps calculation </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#ac273545c33e3abb0114811e7a1b06f98">subpavings::SPSnode</a>.</p>

</div>
</div>
<a class="anchor" id="a6eff83d7095798158c0bc17ee70e54c0"></a><!-- doxytag: member="subpavings::SPSVnode::leafOutputTabsWithHistHeight" ref="a6eff83d7095798158c0bc17ee70e54c0" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6eff83d7095798158c0bc17ee70e54c0">subpavings::SPSVnode::leafOutputTabsWithHistHeight</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Includes the height of a bin represented by this leaf node for a normalised histogram, ie counter/(node volume * total count in tree)</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for a d-dimensional interval vector is:</p>
<p>nodeName [tab] counter [tab] volume [tabl] counter/(volume*total count) [tab] Inf(ivector[1]) [tab] Sup(ivector[1]) [tab] ... [tab] Inf(ivector[d]) [tab] Sup(ivector[d]) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by the height calculation </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aaf9ac8d98bda6e99c74b946d85c6bc61">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00405">405</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01828">leavesOutputTabsWithHistHeight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy of theBox</span>
            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();

            <span class="comment">// output the node name, nodeVolume, counter, counter/(bigN * vol)</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; counter/(vol * bigN);
            <span class="comment">// followed by the intervals of box using Inf and Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            streamsize oldPrec = os.precision();
            os &lt;&lt; setprecision(prec);

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
            os &lt;&lt; setprecision(oldPrec);
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4ed4d26826f77814558a0ad3770582f4"></a><!-- doxytag: member="subpavings::SPSVnode::leafOutputTabsWithHistHeightAndEMPs" ref="a4ed4d26826f77814558a0ad3770582f4" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a4ed4d26826f77814558a0ad3770582f4">subpavings::SPSVnode::leafOutputTabsWithHistHeightAndEMPs</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data.</p>
<p>Includes the height of a bin represented by this leaf node for a normalised histogram, ie counter/(node volume * total count in tree)</p>
<p>The format for a d-dimensional interval vector is</p>
<p>nodeName [tab] counter [tab] volume [tabl] counter/(volume*total count) scaled EMP contribution COPERR [tab] change in scaled EMP contribution COPERR if split [tab] scaled EMP contribution AIC [tab] change in scaled EMP contribution AIC if split [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[d]) [tab] Sup(ivector[d] </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by emps and height calculations </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad64bd4af47589b21d9c8dde5135c3d0a">subpavings::SPSnode</a>.</p>

</div>
</div>
<a class="anchor" id="abcac815b9e5e60a3d18fa3534a12c518"></a><!-- doxytag: member="subpavings::SPSVnode::leavesOutputTabs" ref="abcac815b9e5e60a3d18fa3534a12c518" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#abcac815b9e5e60a3d18fa3534a12c518">subpavings::SPSVnode::leavesOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a01b35db8ce4b99460ff352f6d25a529c" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs()</a> to output information for each leaf node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01795">1795</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00373">leafOutputTabs()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01795">leavesOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01795">leavesOutputTabs()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03367">subpavings::AdaptiveHistogramValidation::outputToTxtTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// uses  member function leafOutputTabs to generate node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a01b35db8ce4b99460ff352f6d25a529c" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs</a>(os);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#abcac815b9e5e60a3d18fa3534a12c518" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#abcac815b9e5e60a3d18fa3534a12c518" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="adc55cda7856cfdd854051b891263d3bf"></a><!-- doxytag: member="subpavings::SPSVnode::leavesOutputTabsWithHistHeight" ref="adc55cda7856cfdd854051b891263d3bf" args="(std::ostream &amp;os, const int prec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#adc55cda7856cfdd854051b891263d3bf">subpavings::SPSVnode::leavesOutputTabsWithHistHeight</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6eff83d7095798158c0bc17ee70e54c0" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeight()</a> to output information for each leaf node. Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points of this root. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a11c1e7c0e652b891c08dfefebd285904">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01818">1818</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01828">leavesOutputTabsWithHistHeight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#adc55cda7856cfdd854051b891263d3bf" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeight</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, os, prec);
        <span class="keywordflow">return</span> (os);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8419f16a2f0667bc190a4a9ed41121c1"></a><!-- doxytag: member="subpavings::SPSVnode::leavesOutputTabsWithHistHeight" ref="a8419f16a2f0667bc190a4a9ed41121c1" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#adc55cda7856cfdd854051b891263d3bf">subpavings::SPSVnode::leavesOutputTabsWithHistHeight</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6eff83d7095798158c0bc17ee70e54c0" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeight()</a> to output information for each leaf node. Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points of this root. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by emps and height calculations </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7f8027e04d883efdf7b627208775b989">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01828">1828</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00405">leafOutputTabsWithHistHeight()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01818">leavesOutputTabsWithHistHeight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// uses  member function leafOutputTabs to generate node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6eff83d7095798158c0bc17ee70e54c0" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeight</a>(bigN, os, prec);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#adc55cda7856cfdd854051b891263d3bf" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeight</a>(bigN, os, prec);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#adc55cda7856cfdd854051b891263d3bf" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeight</a>(bigN, os, prec);
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a928db3d7b687a9fb5d50fa135f51b040"></a><!-- doxytag: member="subpavings::SPSVnode::nodeAdoptLeft" ref="a928db3d7b687a9fb5d50fa135f51b040" args="(SPSVnode *lChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a928db3d7b687a9fb5d50fa135f51b040">subpavings::SPSVnode::nodeAdoptLeft</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a left child rather than attempting to reunite two children into this. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>not thoroughly tested </dd></dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l02036">2036</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">gatherData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00457">setSplits()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01960">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// we have to collect all the data from the child,</span>
        <span class="comment">// and fire it into this to make sure that the stats</span>
        <span class="comment">// for this (this node) are correct</span>

        <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> tempContainer;
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(tempContainer, lChild);

        <span class="comment">// reserve capacity in this</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(tempContainer.size());

        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* insertedInto = NULL;

        <span class="keywordflow">for</span> (it = tempContainer.begin();
            it &lt; tempContainer.end(); it++) {

            SplitNever sn; <span class="comment">// dummy split decision maker</span>
            <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>;
            insertedInto = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(*it, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, sn, boolVal);
            <span class="comment">// insert with no splitting</span>
            <span class="keywordflow">if</span> (insertedInto == NULL) {
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Check SPSVnode::nodeAdoptLeft: &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;data &quot;</span> &lt;&lt; **it &lt;&lt; <span class="stringliteral">&quot; from node &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;to be adopted rejected by new &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;parent&quot;</span> &lt;&lt; std::endl;
            }
        }

        <span class="comment">// the stats for this should now be right</span>
        <span class="comment">// but the data is associated with its descendent nodes</span>
        <span class="comment">// so we need to clear the actual data</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.clear();

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddLeft() checks labels, hull size , present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(lChild);
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d6459ebf84a81b4759a3dd6524df4cf" title="Set the splitDimension and SplitValue when children grafted.">setSplits</a>(); <span class="comment">// set the split dimension and split value</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a33d64bef2bd9dd7f430b732719eab71d"></a><!-- doxytag: member="subpavings::SPSVnode::nodeAdoptRight" ref="a33d64bef2bd9dd7f430b732719eab71d" args="(SPSVnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a33d64bef2bd9dd7f430b732719eab71d">subpavings::SPSVnode::nodeAdoptRight</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a right child rather than attempting to reunite two children into this. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Not thoroughly tested </dd></dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l02085">2085</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">gatherData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00457">setSplits()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01960">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//* this is the node which will become the parent</span>

        <span class="comment">// we have to collect all the data from the child,</span>
        <span class="comment">// and fire it into this to make sure that the stats</span>
        <span class="comment">// for this (this node) are correct</span>
        <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> tempContainer;
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(tempContainer, rChild);

        <span class="comment">// reserve capacity in this</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(tempContainer.size());

        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* insertedInto = NULL;

        <span class="keywordflow">for</span> (it = tempContainer.begin();
            it &lt; tempContainer.end(); it++) {

            SplitNever sn; <span class="comment">// dummy split decision maker</span>
            <span class="keywordtype">bool</span> boolVal = <span class="keyword">false</span>;
            insertedInto = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(*it, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, sn, boolVal);
            <span class="comment">// insert with no splitting</span>
            <span class="keywordflow">if</span> (insertedInto == NULL) {
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Check SPSVnode::nodeAdoptRight: &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;data &quot;</span> &lt;&lt; **it &lt;&lt; <span class="stringliteral">&quot; from node to &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;be adopted rejected by new parent&quot;</span>
                    &lt;&lt; std::endl;
            }
        }

        <span class="comment">// the stats for this should now be right</span>
        <span class="comment">// but the data is associated with its descendent nodes</span>
        <span class="comment">// so we need to clear the actual data</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.clear();

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddRight() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(rChild);
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d6459ebf84a81b4759a3dd6524df4cf" title="Set the splitDimension and SplitValue when children grafted.">setSplits</a>(); <span class="comment">// set the split dimension and split value</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a803d11f31d86f0565dbe682a33099698"></a><!-- doxytag: member="subpavings::SPSVnode::nodeContains" ref="a803d11f31d86f0565dbe682a33099698" args="(const rvector &amp;p, OPERATIONS_ON childInd) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a803d11f31d86f0565dbe682a33099698">subpavings::SPSVnode::nodeContains</a> </td>
          <td>(</td>
          <td class="paramtype">const rvector &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a>&#160;</td>
          <td class="paramname"><em>childInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the box a node represents contains a datapoint p. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the value of the data point being tested for containment in the box represented by this node. </td></tr>
    <tr><td class="paramname">childInd</td><td>indicates whether this should be considered to be a left child or a right child (ie where we need to take splitting dimension and value into account) or as a parent node.</td></tr>
  </table>
  </dd>
</dl>
<p>childInd, together with the splitValue and splitDimension of the parent, is used to to make sure that the containment assessment takes notice of the open and closed intervals at the split value on the split dimension that result from splitting a box. The interval in the split dimension of the right child's box is closed at the split value and the interval of the left child's box is open. A datapoint whose element in the split dimension is exactly the split value should be assessed to be in the right child's box but not the left child's box. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a918067afb150c053f7450fd18c6ecd22">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l02184">2184</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00915">getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01001">subpavings::SPSnode::getSplitDim()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01005">subpavings::SPSnode::getSplitValue()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>; <span class="comment">// for the return value</span>

        <span class="comment">// cast p to an ivector</span>
        ivector pvec = _ivector(p);

        <span class="comment">//find if p is in the box</span>
        <span class="keywordflow">if</span> (pvec &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) {
            retValue = <span class="keyword">true</span>;
        }

        <span class="comment">// if true and there is a parent and this is a left child,</span>
        <span class="comment">// we need to check the split</span>
        <span class="comment">// find what dimension the parent was split on and what</span>
        <span class="comment">// the split value was</span>
        <span class="comment">// pvector must be strictly less than parentSplitValue</span>
        <span class="comment">// on the split dimension</span>
        <span class="keywordflow">if</span> (retValue &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>!=NULL &amp;&amp; childInd == <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>) {

            <span class="keywordtype">int</span> parentSplitDim = (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3" title="Accessor for the parent of a node.">getParent</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#afe262ee997e6ac57a15193a7d585f0ac" title="Accessor for the split dimension.">getSplitDim</a>();
            real parentSplitValue = (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3" title="Accessor for the parent of a node.">getParent</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#aeaa3e348d84106def631d3cd742a1420" title="Accessor for the split value.">getSplitValue</a>();

            <span class="keywordflow">if</span> (!(p[parentSplitDim] &lt; parentSplitValue)) {
            retValue = <span class="keyword">false</span>;
            }
        }

        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5868a7661363e2f3bd7d2e267c22ceb1"></a><!-- doxytag: member="subpavings::SPSVnode::nodeDataPrint" ref="a5868a7661363e2f3bd7d2e267c22ceb1" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5868a7661363e2f3bd7d2e267c22ceb1">subpavings::SPSVnode::nodeDataPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the data in a specified format. </p>
<p>Replaces the format that the cxsc::&lt;&lt; operator produces for vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional real vector data point is:</p>
<p>label [tab] rvector[1] [tab] . . . [tab] rvector[n] </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a799dd8e194518c3dd525ecba26072585">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00292">292</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01765">nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.empty()) {

            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr;

            os &lt;&lt; <span class="stringliteral">&quot;Data is&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin();
                dataItr!= <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); dataItr++) {

                <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *dataItr;
                rvector theData = *bigIt;

                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> + 1; i++) {
                    os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>; <span class="comment">// print the label</span>
                    os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; theData[i]; <span class="comment">// print data</span>
                }   <span class="comment">// end loop through data elements</span>

                os &lt;&lt; std::endl;

            } <span class="comment">// end loop through data container</span>
        } <span class="comment">// end if counter &gt; 0</span>
        <span class="comment">// if no data, ie counter = 0, then just return os unaltered</span>

        <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a94c33927011a8d2613d40ccf6ccfafc1"></a><!-- doxytag: member="subpavings::SPSVnode::nodeExpand" ref="a94c33927011a8d2613d40ccf6ccfafc1" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">subpavings::SPSVnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand a leaf node to have two children and pass data down to the children with no further splitting.</p>
<p>Uses nodeExpansion() and <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a82423d1ad9f1589dbeef2018705591ad" title="Send the data associated with this down to children.">splitData()</a>.</p>
<p>Equivalent to bisecting a box in a regular subpaving. Makes two new sibling child nodes of this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>is the dimension on which to to bisect theBox. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf0575b58b84a0910a8d5b67b6ec0f48">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01850">1850</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l00170">nodeExpansionOnly()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00223">splitData()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a747a3c135503cbf1f1b349a5898cebc4" title="Expand the node with no reallocation of data.">nodeExpansionOnly</a>(comp);    <span class="comment">// expand the node</span>
        SplitNever sn;      
        <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>;        <span class="comment">// dummy split decision maker</span>
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a82423d1ad9f1589dbeef2018705591ad" title="Send the data associated with this down to children.">splitData</a>(sn, boolVal);            <span class="comment">// split the data with no further splitting</span>


    }
</pre></div>
</div>
</div>
<a class="anchor" id="acbad110f9ed41364774c9e2fea658594"></a><!-- doxytag: member="subpavings::SPSVnode::nodeExpand" ref="acbad110f9ed41364774c9e2fea658594" args="(const SplitDecisionObj &amp;boolTest, int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">subpavings::SPSVnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand a leaf node to have two children and pass data down to the children, allowing for further splitting.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">comp</td><td>is the dimension on which to to bisect theBox. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a0728b0ec4deee17f6a729a97c8b5a560">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01862">1862</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l00170">nodeExpansionOnly()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00223">splitData()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a747a3c135503cbf1f1b349a5898cebc4" title="Expand the node with no reallocation of data.">nodeExpansionOnly</a>(comp);    <span class="comment">// expand the node</span>
        <span class="comment">// split the data, allowing for further splitting</span>
        <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>; 
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a82423d1ad9f1589dbeef2018705591ad" title="Send the data associated with this down to children.">splitData</a>(boolTest, boolVal);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0eb85efd74fa770f3259d6ba948b65b8"></a><!-- doxytag: member="subpavings::SPSVnode::nodeExpand" ref="a0eb85efd74fa770f3259d6ba948b65b8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">subpavings::SPSVnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand a leaf node to have two children and pass data down to the children with no further splitting.</p>
<p>Finds the splitting dimension. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#ae432186483a5ec950dab0eb00b08a9bc">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01873">1873</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0eb85efd74fa770f3259d6ba948b65b8" title="Expand a leaf node.">nodeExpand</a>(maxdiamcomp); <span class="comment">// complete nodeExpand</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ada1ce5002ee4985a22d35d8cb651d191"></a><!-- doxytag: member="subpavings::SPSVnode::nodeExpand" ref="ada1ce5002ee4985a22d35d8cb651d191" args="(const SplitDecisionObj &amp;boolTest, bool boolVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">subpavings::SPSVnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boolVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand the leaf node to have two children and pass data down to the children, allowing for further splitting.</p>
<p>Finds the dimension to split on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01882">1882</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00266">justSplit</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00170">nodeExpansionOnly()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00223">splitData()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
      
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a747a3c135503cbf1f1b349a5898cebc4" title="Expand the node with no reallocation of data.">nodeExpansionOnly</a>(maxdiamcomp);
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a> = <span class="keyword">true</span>;
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a82423d1ad9f1589dbeef2018705591ad" title="Send the data associated with this down to children.">splitData</a>(boolTest, boolVal);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4846c8d9c7d29d0f0850a7a9c30eec2b"></a><!-- doxytag: member="subpavings::SPSVnode::nodeExpand" ref="a4846c8d9c7d29d0f0850a7a9c30eec2b" args="(bool boolVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">subpavings::SPSVnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boolVal</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to make two leaves as children. </p>
<p>Has parameter boolVal for validation data (ingeritance polymorphism) </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a3b16d632897f3a4fb11f36db1e9004bf">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01893">1893</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00266">justSplit</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00170">nodeExpansionOnly()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00223">splitData()</a>.</p>
<div class="fragment"><pre class="fragment">    {
              
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension      </span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);        
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a747a3c135503cbf1f1b349a5898cebc4" title="Expand the node with no reallocation of data.">nodeExpansionOnly</a>(maxdiamcomp);        
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951" title="A boolean flag to know if this node was being split or node.">justSplit</a> = <span class="keyword">true</span>;                
        SplitNever sn;
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a82423d1ad9f1589dbeef2018705591ad" title="Send the data associated with this down to children.">splitData</a>(sn, boolVal);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a747a3c135503cbf1f1b349a5898cebc4"></a><!-- doxytag: member="subpavings::SPSVnode::nodeExpansionOnly" ref="a747a3c135503cbf1f1b349a5898cebc4" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a747a3c135503cbf1f1b349a5898cebc4">subpavings::SPSVnode::nodeExpansionOnly</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand the node with no reallocation of data. </p>
<p>Bisect box, make two new nodes (one for each half box) and graft onto this node provided that this node is a leaf. Equivalent to bisecting a box in a regular subpaving. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#ac549870ef3b7994d9e87b952a012a7e9">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00170">170</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02192">subpavings::isLeaf()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01850">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        
        <span class="keywordflow">try</span>
        {
            <span class="comment">// only do something if this SPSVnode is a leaf</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                <span class="comment">// ivectors to become boxes for new children</span>
                ivector lC, rC;

                <span class="comment">// Call Lower() and Upper() to put the split</span>
                <span class="comment">// boxes into lC and rC respectively</span>
                
                   
                <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lC, comp);
                <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rC, comp);

                <span class="comment">// when making new children, use constructor</span>
                <span class="comment">// that will give space indication (for data)</span>
                <span class="comment">// of the size of this node&#39;s dataItrs</span>
                <span class="keywordtype">size_t</span> space = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.size();
                
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(lC, space, <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>));
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(rC,space, <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>));


                <span class="comment">//name the new children</span>
                <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
                <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);

                <span class="comment">// store the split dimension in this</span>
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = comp;

                <span class="comment">// store the split value in this</span>
                <span class="comment">// the split value is the infinum of interval</span>
                <span class="comment">// of right child box for dimension split on</span>
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = _double(Inf(
                    ((<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())[comp]));
            }
        }

        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;SPSVnode::nodeExpansionOnly()&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a768f9507517be618970d19874b1ff992"></a><!-- doxytag: member="subpavings::SPSVnode::nodeMeanPrint" ref="a768f9507517be618970d19874b1ff992" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a768f9507517be618970d19874b1ff992">subpavings::SPSVnode::nodeMeanPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the mean in a specified format. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a5f5cc02f707a2b98f7a93543c71298b2">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00320">320</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01765">nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0) &amp;&amp; !<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>) {

            os &lt;&lt; <span class="stringliteral">&quot;Mean is &quot;</span>;

            <span class="comment">// loop through the elements in the dpSums vector</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
                <span class="comment">// default cxsc rounding of dotprecision</span>
                <span class="comment">// to rnd_next</span>
                os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; (rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i])/(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>));

            }<span class="comment">// end loop through the elements in dpSums</span>

            os &lt;&lt; std::endl;

        } <span class="comment">// end if</span>
        <span class="comment">// if no data, ie counter = 0, or if we are only keeping counts</span>
        <span class="comment">// then just return os unaltered</span>

        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a51715ef7b6e370006e914fee15061cfc"></a><!-- doxytag: member="subpavings::SPSVnode::nodePrint" ref="a51715ef7b6e370006e914fee15061cfc" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a51715ef7b6e370006e914fee15061cfc">subpavings::SPSVnode::nodePrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output details of a specific node. </p>
<p>This is intended for console output or output to a mixed alpha and numeric file. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aba02715cb75f803df7c3ffd1eaf027e8">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01765">1765</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00292">nodeDataPrint()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00320">nodeMeanPrint()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00346">nodeVarCovarPrint()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00285">Vcounter</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03391">subpavings::AdaptiveHistogramValidation::outputRootToTxt()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// output for box in form:</span>
        <span class="comment">// box, volume, counter, mean, variance covariance, and data</span>

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            os &lt;&lt; <span class="stringliteral">&quot;Box is :&quot;</span>;

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
                <span class="comment">// c-xsc default output for intervals</span>
                os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; thisBox[i];
            }

            os &lt;&lt; std::endl;
            os &lt;&lt; <span class="stringliteral">&quot;Box volume is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>() &lt;&lt; std::endl;
            os &lt;&lt; <span class="stringliteral">&quot;Counter = &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &lt;&lt; std::endl;
        os &lt;&lt; <span class="stringliteral">&quot;VCounter = &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a> &lt;&lt; std::endl;
        
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a768f9507517be618970d19874b1ff992" title="Print the mean in a specified format.">nodeMeanPrint</a>(os);
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a096bff1081ceb308590aac8f2f3ee660" title="Print the variance-covariance in a specified format.">nodeVarCovarPrint</a>(os);
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5868a7661363e2f3bd7d2e267c22ceb1" title="Print the data in a specified format.">nodeDataPrint</a>(os);
            os &lt;&lt; std::endl;
        }
        <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aed19a06dc479c2edc865243d2c131c30"></a><!-- doxytag: member="subpavings::SPSVnode::nodeReabsorbChildren" ref="aed19a06dc479c2edc865243d2c131c30" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#aed19a06dc479c2edc865243d2c131c30">subpavings::SPSVnode::nodeReabsorbChildren</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reabsorbs both children of the node. </p>
<p>Effectively reverses any split of the node.</p>
<p>Data associated with the children is pushed back up to this and the splitDim and splitValue reset to leaf defaults.</p>
<p>Works even if the children are not leaves. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01909">1909</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">gatherData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">nodeReabsorbChildren()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">subpavings::SPSnode::splitDim</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00408">subpavings::SPSnode::splitValue</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01909">nodeReabsorbChildren()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// first recursively deal with the children of the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>())
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#aed19a06dc479c2edc865243d2c131c30" title="Reabsorbs both children of the node.">nodeReabsorbChildren</a>();
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>())
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#aed19a06dc479c2edc865243d2c131c30" title="Reabsorbs both children of the node.">nodeReabsorbChildren</a>();

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>, <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>());
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>, <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>());
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
        }

        <span class="comment">// reset splitDim and splitValue to their defaults</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = -1;
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = 0.0;

        <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5abf598ead77d94aa130a8a7bf78f1f7"></a><!-- doxytag: member="subpavings::SPSVnode::nodeReunite" ref="a5abf598ead77d94aa130a8a7bf78f1f7" args="(SPSVnode *lChild, SPSVnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5abf598ead77d94aa130a8a7bf78f1f7">subpavings::SPSVnode::nodeReunite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to reunite nodes to form one leaf. </p>
<p>Note that the nodes provided, lChild and rChild, are not the actual children of this, they are potential children which we are trying to either totally bring into this (if there are two of them) or to graft onto this if there is only one of them. This is typically a new, part-formed node whose formation can be completed by reuniting already two already-formed nodes into it or by adding on one child if only one is available. nodeReunite is used in building a tree upwards (rather than in pruning leaves of formed tree from the bottom up).</p>
<p>If two potential children are provided and they are both leaves, it combines the two leaf siblings into this. If the potential children are not leaves or if only one potential child is provided, it grafts the potential child/children onto this as its child/children.</p>
<p>Data associated with the children is moved to the new parent and statistics recalculated.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>nodeReunite would not normally be used with SPSVnodes but is in the base class and is reimplemented to try do it appropriately for this derived class should it be needed. This function is untested. </dd></dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l01960">1960</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">gatherData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02036">nodeAdoptLeft()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02085">nodeAdoptRight()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">subpavings::SPnode::recursiveRename()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// redo the box, move the data up,</span>

        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// check that the labels match and exit if not</span>
        <span class="keywordflow">if</span> ((lChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> ) || (rChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>)) {
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Labels do not match&quot;</span>);
        }

        <span class="comment">// if both subpavings are leaves and hull of boxes is x,</span>
        <span class="comment">// discard them: *this is a leaf</span>
        <span class="keywordflow">if</span> (lChild-&gt;isLeaf() &amp;&amp; rChild-&gt;isLeaf()) {
            <span class="keywordflow">if</span> (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> !=
                (*(lChild-&gt;theBox) | *(rChild-&gt;theBox))) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes to be reunited do not fit&quot;</span>);
            }

            <span class="comment">// we have to collect all the data from the children,</span>
            <span class="comment">// and fire it into this to make sure that the</span>
            <span class="comment">// stats for this (this node) are correct</span>
            <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> tempContainer;
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(tempContainer, lChild);
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ad9b78707e372d9b66876e6afa0cb8eb1" title="Return a reference to the node data.">gatherData</a>(tempContainer, rChild);

            <span class="comment">// reserve capacity in this</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(tempContainer.size());

            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* insertedInto = NULL;

            <span class="keywordflow">for</span> (it = tempContainer.begin();
                it &lt; tempContainer.end(); it++) {
                <span class="comment">// insert with no splitting</span>
                SplitNever sn;
                <span class="keywordtype">bool</span> boolVal = <span class="keyword">false</span>;
                insertedInto = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(*it, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, sn, boolVal);
                <span class="keywordflow">if</span> (insertedInto == NULL) {
                    std::cerr &lt;&lt; <span class="stringliteral">&quot;Check &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot;SPSVnode::nodeReunite: &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot; data &quot;</span> &lt;&lt; **it
                        &lt;&lt; <span class="stringliteral">&quot; from nodes to be adopted &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot;rejected by new parent&quot;</span>
                        &lt;&lt; std::endl;
                }
            }

            <span class="comment">// the stats for this should now be right</span>
            <span class="comment">// and this will be a leaf so the data</span>
            <span class="comment">// should stay associated with it</span>

            <span class="comment">//discard the two subpavings given</span>
            <span class="keyword">delete</span> lChild;
            <span class="keyword">delete</span> rChild;

        }

        <span class="keywordflow">else</span> {  <span class="comment">// at least one of the children is not a leaf</span>
            <span class="comment">// this has to adopt them rather than reuniting them</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a33d64bef2bd9dd7f430b732719eab71d" title="Builds a higher level of a tree from existing nodes.">nodeAdoptRight</a>(rChild);
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a928db3d7b687a9fb5d50fa135f51b040" title="Builds a higher level of a tree from existing nodes.">nodeAdoptLeft</a>(lChild);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>(); <span class="comment">// recursively rename child branches</span>
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a096bff1081ceb308590aac8f2f3ee660"></a><!-- doxytag: member="subpavings::SPSVnode::nodeVarCovarPrint" ref="a096bff1081ceb308590aac8f2f3ee660" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a096bff1081ceb308590aac8f2f3ee660">subpavings::SPSVnode::nodeVarCovarPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the variance-covariance in a specified format. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a03042a5084349960b1fd35396dc509a5">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00346">346</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01765">nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0) &amp;&amp; !<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>) {

            <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> varCovar;
            varCovar = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">getVarCovar</a>(varCovar);

            <span class="comment">/* element k in the vector representing the</span>
<span class="comment">            variance-covariance matrix corresponds to</span>
<span class="comment">            row k/n, (row 0 to n-1) and column k-row*n (col 0 to n-1)</span>
<span class="comment">            in a matrix view variance-covariance */</span>

            os &lt;&lt; <span class="stringliteral">&quot;Variance Covariance is &quot;</span> &lt;&lt; std::endl;

            <span class="comment">// loop through the elements and print as matrix</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
                    os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; varCovar[(i*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>)+j];
                }
                os &lt;&lt; std::endl;
            }
        }
        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad4e310986c60dcebb3fd3c54dab19c33"></a><!-- doxytag: member="subpavings::SPSVnode::operator=" ref="ad4e310986c60dcebb3fd3c54dab19c33" args="(const SPSVnode &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> &amp; subpavings::SPSVnode::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00791">791</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">subpavings::SPSnode::counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">subpavings::SPSnode::countsOnly</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00393">subpavings::SPSnode::dataItrs</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00381">subpavings::SPSnode::dpSumProducts</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00344">subpavings::SPSnode::dpSums</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00260">spaceIndication</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">subpavings::SPSnode::splitDim</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00408">subpavings::SPSnode::splitValue</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00572">SPSVnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, <a class="el" href="spsvnode_8hpp_source.shtml#l00285">Vcounter</a>, and <a class="el" href="spsvnode_8hpp_source.shtml#l00363">VdataItrs</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {

          <span class="comment">//  cout &lt;&lt; &quot;copy assignment operator for node &quot; &lt;&lt; nodeName &lt;&lt; &quot; called:&quot; &lt;&lt; endl;</span>
     
            <span class="comment">// delete the current children (deletes their children as well)</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>();
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
            }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>();
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
            }
            <span class="comment">// and delete the current box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = NULL;
            }

            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>=NULL;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(*rhs.theBox);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = rhs.dimension;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = rhs.label;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = rhs.nodeName;

            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = rhs.spaceIndication;

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> = rhs.counter;
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a> = rhs.Vcounter;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a> = rhs.dpSums;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a> = rhs.dpSumProducts;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = rhs.splitDim;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = rhs.splitValue;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> = rhs.countsOnly;

            <span class="comment">//reserve space</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve((rhs.dataItrs).size());
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.reserve((rhs.VdataItrs).size());
            <span class="comment">//copy dataItrs from other to this</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a> = rhs.dataItrs;
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a> = rhs.VdataItrs;
        
            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (rhs.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(*(rhs.getLeftChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (rhs.rightChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(*(rhs.getRightChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af37c85866ee5bdb968faf84856b51291"></a><!-- doxytag: member="subpavings::SPSVnode::recalculateStats" ref="af37c85866ee5bdb968faf84856b51291" args="(rvector &amp;newdata, bool boolVal) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#af37c85866ee5bdb968faf84856b51291">subpavings::SPSVnode::recalculateStats</a> </td>
          <td>(</td>
          <td class="paramtype">rvector &amp;&#160;</td>
          <td class="paramname"><em>newdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boolVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate summary statistics associated with node. </p>
<p>Recalculates counter and sums (used for mean) and sumproducts (used for variance-covariance). </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00073">73</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (boolVal==<span class="keyword">false</span>) { <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>++; } <span class="comment">// update the counter  </span>
      
      <span class="keywordflow">else</span> { <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12" title="A counter for how many data points from the validation set that are covered by theBox.">Vcounter</a>++; } <span class="comment">// update  the Vcounter</span>
      
      <span class="comment">//cout &lt;&lt; &quot;incrementing counters for node &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
    
      <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>) {
            <span class="comment">//cout &lt;&lt; &quot;mean/var calc is on&quot; &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> (boolVal == <span class="keyword">false</span>) {
          <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a7590c8e3a8502b3b8a15bc2c4c494904" title="Recalculate summary statistics associated with node.">recalculateSums</a>(newdata); <span class="comment">// update the sums</span>
          <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3df955b69f0e3d73efd0ccc3026fe0e7" title="Recalculate summary statistics associated with node.">recalculateSumProducts</a>(newdata); <span class="comment">// update the sumproducts</span>
      }
    }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3df955b69f0e3d73efd0ccc3026fe0e7"></a><!-- doxytag: member="subpavings::SPSVnode::recalculateSumProducts" ref="a3df955b69f0e3d73efd0ccc3026fe0e7" args="(rvector &amp;newdata) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3df955b69f0e3d73efd0ccc3026fe0e7">subpavings::SPSVnode::recalculateSumProducts</a> </td>
          <td>(</td>
          <td class="paramtype">rvector &amp;&#160;</td>
          <td class="paramname"><em>newdata</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate summary statistics associated with node. </p>
<p>Recalculates sumproducts (used for variance-covariance). </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#ab49e57afe0939b41930e0cbb22c9ba8a">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00114">114</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">/* the sumproducts can be thought of as an nxn matrix,</span>
<span class="comment">        which is implemented here as a nxn element vector of</span>
<span class="comment">        dotprecision variables, using row-major order.</span>
<span class="comment">        Ie the m-th element (m = 0, . . . nxn-1) is in row floor(m/n)</span>
<span class="comment">        and column m-rowxn in the matrix configuration.</span>
<span class="comment">        Or, the sumproduct of elements i and j in an rvector,</span>
<span class="comment">        i,j = 0,...,n-1, is element m=(ixn+j) of the sumproducts</span>
<span class="comment">        vector. */</span>

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>.empty()) {    <span class="comment">//nothing there yet</span>
            <span class="comment">// reserve space for all elements</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);

            <span class="comment">// for each dimnsn^2 of data, initialise element</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; (dimension*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>); i++) {
                dotprecision dp;
                dp = 0.0;
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>.push_back(dp);
            }
        }

        <span class="comment">// make a dot precision variable out of the ith element</span>
        <span class="comment">// and jth element of the of the rvector of new data and</span>
        <span class="comment">// store in dpSumProducts.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; dimension + 1; i++) {
            <span class="comment">// only need to do columns 1 to i because of symmetry</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j&lt; i + 1; j++) {

                <span class="keywordtype">size_t</span> index = (i-1)*dimension + (j-1);
                <span class="comment">// rvectors indexed 1 to n</span>
                accumulate(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[index],
                        newdata[i], newdata[j]);

                <span class="comment">//if not on the diagonal of the matrix,</span>
                <span class="comment">// we can also fill in the symmetric element</span>
                <span class="keywordflow">if</span> (i!=j) {
                    <span class="keywordtype">size_t</span> sym_index = (j-1)*dimension
                        + (i-1);
                    <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[sym_index] =
                        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[index];
                } <span class="comment">// end if</span>
            }<span class="comment">// end j-loop</span>
        }<span class="comment">// end i-loop</span>

        <span class="comment">// sumproducts has been updated for new datapoint</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7590c8e3a8502b3b8a15bc2c4c494904"></a><!-- doxytag: member="subpavings::SPSVnode::recalculateSums" ref="a7590c8e3a8502b3b8a15bc2c4c494904" args="(rvector &amp;newdata) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a7590c8e3a8502b3b8a15bc2c4c494904">subpavings::SPSVnode::recalculateSums</a> </td>
          <td>(</td>
          <td class="paramtype">rvector &amp;&#160;</td>
          <td class="paramname"><em>newdata</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate summary statistics associated with node. </p>
<p>Recalculates sums (used for mean). </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa70c978a273b7266c75e7d617ae4d100">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00091">91</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.empty()) {   <span class="comment">//nothing in the sums yet</span>
            <span class="comment">// reserve space in dpSums for all elements of the mean</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);

            <span class="comment">// for each dimnsn of data, initialise element</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
                dotprecision dp;
                dp = 0.0;
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.push_back(dp);
            }
        }

        <span class="comment">// make a dot precision variable out of the ith element</span>
        <span class="comment">// of the rvector of new data and store in dpSums</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i&lt; dimension + 1; i++) {
            <span class="comment">// rvectors indexed 1 to n, vectors indexed 0 to n-1</span>
            accumulate(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i-1], newdata[i], 1.0);
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5d6459ebf84a81b4759a3dd6524df4cf"></a><!-- doxytag: member="subpavings::SPSVnode::setSplits" ref="a5d6459ebf84a81b4759a3dd6524df4cf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d6459ebf84a81b4759a3dd6524df4cf">subpavings::SPSVnode::setSplits</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the splitDimension and SplitValue when children grafted. </p>
<p>Sets the splitDimension and SplitValue for this node when children are grafted on. Called by nodeAdoptLeft or nodeAdoptRight.</p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this has splitDimension and SplitValue corresponding to children. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a785e03fc466a6a1ea851f08338f8103d">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00457">457</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02036">nodeAdoptLeft()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l02085">nodeAdoptRight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// set the split dimension and split value for this box</span>
        <span class="comment">// based on the children which have been added</span>
        ivector childBox;
        <span class="keywordtype">bool</span> alreadyDone = <span class="keyword">false</span>;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            childBox = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            childBox = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
        }
        <span class="keywordtype">int</span> pLb = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>); <span class="comment">// parent box lower bound</span>
        <span class="keywordtype">int</span> dim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>) + 1;
        <span class="keywordtype">int</span> cLb = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(childBox); <span class="comment">// child box lower bound (should be = pLb)</span>

        <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> != -1 &amp;&amp;
            (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> == Inf(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb])
            || <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> == Sup(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb])))
                alreadyDone = <span class="keyword">true</span>;

        <span class="keywordflow">if</span> (!alreadyDone) {
            <span class="keywordtype">int</span> d = 1;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = -1;
            <span class="keywordflow">while</span> ((d &lt;= dim) &amp;&amp; (<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> == -1)) {
                <span class="keywordflow">if</span> (diam(childBox[d + cLb - 1]) &lt; diam((*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>)[d])) {
                    <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = d + pLb - 1; <span class="comment">// the split dimension</span>
                }
                d++;
            }
            <span class="comment">// split value is bottom of right child box on dth dim</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = Inf(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb]);
            }
            <span class="comment">// else split value is top of left child box on dth dim</span>
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = Sup(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb]);
            }
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a82423d1ad9f1589dbeef2018705591ad"></a><!-- doxytag: member="subpavings::SPSVnode::splitData" ref="a82423d1ad9f1589dbeef2018705591ad" args="(const SplitDecisionObj &amp;boolTest, bool boolVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a82423d1ad9f1589dbeef2018705591ad">subpavings::SPSVnode::splitData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boolVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send the data associated with this down to children. </p>
<p>Children may then be resplit using boolTest. </p>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00223">223</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_RIGHT</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01850">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">   {
        <span class="comment">// check that both children exist</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() || !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Cannot split data when there are not two &quot;</span>;
            msg += <span class="stringliteral">&quot; children&quot;</span>;
            <span class="keywordflow">throw</span> SPnodeException(msg);
        }

        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr; <span class="comment">// iterator</span>
     
        boolVal = <span class="keyword">false</span>;
        <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin();
            dataItr!= <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); dataItr++) {
            <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> newItr = *dataItr;

            <span class="comment">//calls insertOneFind on the children of this node</span>
            <span class="comment">// so stats are not recalculated for this node itself</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* reinsertedInto = NULL;

            <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>!=NULL &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {

                reinsertedInto =
                    (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(
                    newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>, boolTest, boolVal);
            }

            <span class="comment">// only try the left if it&#39;s not on the right</span>
            <span class="keywordflow">if</span>(reinsertedInto==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>!=NULL
            &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {

                reinsertedInto =
                    (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(
                    newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>, boolTest, boolVal);
            }
        }

        <span class="comment">//divide the data up amongst the children</span>
         boolVal = <span class="keyword">true</span>;
         <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.begin();
            dataItr!= <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647" title="A container for the association of validation data with a node.">VdataItrs</a>.end(); dataItr++) {
            <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> newItr = *dataItr;

            <span class="comment">//calls insertOneFind on the children of this node</span>
            <span class="comment">// so stats are not recalculated for this node itself</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* reinsertedInto = NULL;

            <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>!=NULL &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {

                reinsertedInto =
                    (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(
                    newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>, boolTest, boolVal);
            }

            <span class="comment">// only try the left if it&#39;s not on the right</span>
            <span class="keywordflow">if</span>(reinsertedInto==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>!=NULL
            &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {

                reinsertedInto =
                    (<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(
                    newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>, boolTest, boolVal);
            }
        }
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#af7739cf5333fccbe27610cbbd1138719" title="Clears the node&#39;s data collection for both training and validation set.">clearData</a>();         <span class="comment">//clear the data in this node</span>
        
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0e051b28a89645eb09e8bbccc7b13780"></a><!-- doxytag: member="subpavings::SPSVnode::strippedConstructor" ref="a0e051b28a89645eb09e8bbccc7b13780" args="(const SPSVnode *const other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">subpavings::SPSVnode::strippedConstructor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00859">859</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00418">subpavings::SPSnode::countsOnly</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">subpavings::SPSnode::splitDim</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00408">subpavings::SPSnode::splitValue</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00572">SPSVnode()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* newNode = NULL;
        <span class="keywordflow">try</span> {
            <span class="keywordflow">if</span> (other != NULL) {
                <span class="keywordflow">if</span> (other-&gt;isEmpty())
                    newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>;
                <span class="keywordflow">else</span> {
                    ivector* newBox = <span class="keyword">new</span> ivector(other-&gt;getBox());
                    newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(*newBox);
                    newNode-&gt;splitDim = other-&gt;splitDim;
                    newNode-&gt;splitValue = other-&gt;splitValue;
                }

                newNode-&gt;nodeName = other-&gt;nodeName;
                newNode-&gt;label = 0;
                newNode-&gt;countsOnly = <span class="keyword">false</span>;

                <span class="keywordflow">if</span> (other-&gt;getLeftChild() != NULL)
                    newNode-&gt;nodeAddLeft(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">strippedConstructor</a>(other-&gt;getLeftChild()));
                <span class="keywordflow">if</span> (other-&gt;getRightChild() != NULL)
                    newNode-&gt;nodeAddRight(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">strippedConstructor</a>(other-&gt;getRightChild()));
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newNode;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab79e2b1aa783e2df56abf8279c5dc564"></a><!-- doxytag: member="subpavings::SPSVnode::unionNoData" ref="ab79e2b1aa783e2df56abf8279c5dc564" args="(const SPSVnode *const lhs, const SPSVnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ab79e2b1aa783e2df56abf8279c5dc564">subpavings::SPSVnode::unionNoData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the non-minimal union of nodes with no data.</p>
<p>Calls itself recursively to adds two pavings together as the union of the two but discards the actual data.</p>
<p>Does not rename the nodes from root downwards.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to root of first <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>pointer to root of second <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to root of a new <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree whose leaves are the union of the leaves of lhs, rhs and which has no data. </dd></dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l00503">503</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02220">unionTreeStructure()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* newNode = NULL;

        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;  <span class="comment">// indicator for done adding</span>

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (lhs == NULL &amp;&amp; rhs == NULL) done = <span class="keyword">true</span>; <span class="comment">// we will return NULL</span>

            <span class="comment">// if the lhs is null or has no box, return a tree or node based on rhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (lhs==NULL || ((lhs != NULL) &amp;&amp; (lhs-&gt;isEmpty())))) {

                newNode = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">SPSVnode::strippedConstructor</a>(rhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// if the rhs is null or has no box, return a tree or node based on lhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (rhs==NULL || ((rhs != NULL) &amp;&amp; (rhs-&gt;isEmpty())))) {

                newNode = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">SPSVnode::strippedConstructor</a>(lhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// by now, if we are not done, both pavings are not null and both have boxes</span>
            <span class="comment">// we assume that the boxes are the same</span>

            <span class="comment">// we have to check who has children</span>

            <span class="comment">// if both are leaves we can just return a node based on say lhs</span>
             <span class="comment">// if only rhs is leaf, lhs is not a leaf, return a node based on lhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; rhs-&gt;isLeaf()) {
                newNode = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">SPSVnode::strippedConstructor</a>(lhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// if only lhs is leaf, rhs is not a leaf, return a node based on rhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs-&gt;isLeaf() &amp;&amp; !rhs-&gt;isLeaf()) {
                newNode = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0e051b28a89645eb09e8bbccc7b13780">SPSVnode::strippedConstructor</a>(rhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// if neither are leaves</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; !lhs-&gt;isLeaf() &amp;&amp; !rhs-&gt;isLeaf()) {
                <span class="comment">// make a node based on one of them, and add on the results of</span>
                <span class="comment">// recursing on the children</span>
                ivector* newPermBox = <span class="keyword">new</span> ivector(lhs-&gt;getBox());
                newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>(*newPermBox);
                newNode-&gt;nodeAdoptRight(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ab79e2b1aa783e2df56abf8279c5dc564">unionNoData</a>(lhs-&gt;getRightChild(),
                                                            rhs-&gt;getRightChild()));
                newNode-&gt;nodeAdoptLeft(<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ab79e2b1aa783e2df56abf8279c5dc564">unionNoData</a>(lhs-&gt;getLeftChild(),
                                                            rhs-&gt;getLeftChild()));
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newNode;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad61518c409809cca73c262dbd17d320f"></a><!-- doxytag: member="subpavings::SPSVnode::unionTreeStructure" ref="ad61518c409809cca73c262dbd17d320f" args="(const SPSVnode *const lhs, const SPSVnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad61518c409809cca73c262dbd17d320f">subpavings::SPSVnode::unionTreeStructure</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the non-minimal union of two tree as a new tree with no data.</p>
<p>Adds two pavings together as the union of the two but discards the actual data. The tree manager should provide new data.</p>
<p>Renames nodes from new root downwards.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to root of first <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>pointer to root of second <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to root of a new <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree whose leaves are the union of the leaves of lhs, rhs and which has no data. </dd></dl>

<p>Definition at line <a class="el" href="spsvnode_8cpp_source.shtml#l02220">2220</a> of file <a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">subpavings::SPnode::recursiveRename()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00503">unionNoData()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml#a1fac8007420cae9fb27af8e7c81eaa52" title="Default constructor.">SPSVnode</a>* newNode = NULL;

        <span class="keywordflow">if</span> ((lhs != NULL) &amp;&amp; (rhs != NULL) &amp;&amp; (lhs-&gt;getBox() != rhs-&gt;getBox()))
        {
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Union unequal subpavings&quot;</span>);
        }
        <span class="keywordflow">else</span> {
            <span class="keywordflow">try</span> {

                newNode = <a class="code" href="classsubpavings_1_1SPSVnode.shtml#ab79e2b1aa783e2df56abf8279c5dc564">unionNoData</a>(lhs, rhs);
                newNode-&gt;recursiveRename();
            }
            <span class="keywordflow">catch</span> (bad_alloc&amp; a) {
                cerr &lt;&lt; a.what() &lt;&lt; endl;
                cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
                <span class="keywordflow">throw</span>;
            }
            <span class="keywordflow">catch</span> (SPnodeException&amp; e) {
                <span class="keywordtype">string</span> msg(e.what());
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Error in union: original error &quot;</span> + msg);
            }
        }

        <span class="keywordflow">return</span> newNode;

    }
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af35e25f257c98de51097428419d0cf81"></a><!-- doxytag: member="subpavings::SPSVnode::dpVSumProducts" ref="af35e25f257c98de51097428419d0cf81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> <a class="el" href="classsubpavings_1_1SPSVnode.shtml#af35e25f257c98de51097428419d0cf81">subpavings::SPSVnode::dpVSumProducts</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container representing the sumproduct matrix of the data points covered by theBox. </p>
<p>The sumproducts matrix is used to obtain the sample variance-covariance matrix.</p>
<p>The for n-dimensional data the sample variance-covariance matrix is an nxn matrix where the element in row i, column j is the sample covariance between the ith-dimension and jth-dimension of the data, which is [sumproduct(i,j)-sum(i)sum(j)/counter]/(counter-1).</p>
<p>So by keeping the sum product and sums up to date, we can calculate a covariance on demand.</p>
<p>The sumproducts can be thought of as an nxn matrix where the element in row i, column j is the sum over all the datapoints associated with that box of the products of the ith element and jth element in the datapoints. ie for each datapoint, we take the product of the ith and jth elements and then sum the products over all the datapoints.</p>
<p>Data points are rvectors so each element is a real, and the the accumulation (sum) of products of reals is implemented here with a dotprecision accumulator.</p>
<p>The sumproduct matrix is stored here as a nxn element vector of dotprecision variables (where n is the dimensions of the rvectors or data points), using row-major order.</p>
<p>Ie the m-th element (m = 0, . . . nxn-1) is in row floor(m/n) and column m-rowxn in the matrix configuration.</p>
<p>Or, the sumproduct of elements i and j in an rvector, i,j = 0,...,n-1, is element m=(ixn+j) of the sumproducts vector. </p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00350">350</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a60f29b9bd7f1a448515c5465e5f7f1ba"></a><!-- doxytag: member="subpavings::SPSVnode::dpVSums" ref="a60f29b9bd7f1a448515c5465e5f7f1ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a60f29b9bd7f1a448515c5465e5f7f1ba">subpavings::SPSVnode::dpVSums</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container representing the sum of the data points covered by theBox. </p>
<p>The sums are used for calculating the mean and also the sample variance-covariance matrix for the data associated with a node.</p>
<p>cxsc::dotprecision accumulators are used to maintain the sum of the data in each dimension of the data because floating point arithmetic can result in inaccuracies during summation, especially in large boxes.</p>
<p>We could use Kahan summation instead with a lot more work. Kahan summation relies on adding a number of points in a sequence and recovering data lost in one summation during the next one. When we simply add two numbers, Kahan summation has no chance to recover the lost part. We would have to implement this by keeping the lost part, say having a vector of pairs, and trying to re-add the lost part each time. See <a href="http://en.wikipedia.org/wiki/Kahan_summation_algorithm">http://en.wikipedia.org/wiki/Kahan_summation_algorithm</a> . The same may apply to arguments for using gsl_mean using a simpler reccurence relation. Speed comparisons have not been performed on the three alternative possible implementations of the recursively computable sample sum or sample mean. However we get most relable and accurate sums using cxsc::dotprecision accumulators. </p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00313">313</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a288af7a8149effcb2d19e163e217e951"></a><!-- doxytag: member="subpavings::SPSVnode::justSplit" ref="a288af7a8149effcb2d19e163e217e951" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a288af7a8149effcb2d19e163e217e951">subpavings::SPSVnode::justSplit</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A boolean flag to know if this node was being split or node. </p>
<p>False (not split) by default. </p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00266">266</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l00898">getJustSplit()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l01882">nodeExpand()</a>.</p>

</div>
</div>
<a class="anchor" id="a98a73d1c8dafe1d9248aeec76c8f74ef"></a><!-- doxytag: member="subpavings::SPSVnode::spaceIndication" ref="a98a73d1c8dafe1d9248aeec76c8f74ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef">subpavings::SPSVnode::spaceIndication</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An indication of the maximum number of data points a node needs to carry. </p>
<p>This is used for efficiency only to reserve vector space and a node can have more than this maximum number of data points associated with it. Defaults to defaultMaxPts. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00260">260</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l00791">operator=()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00572">SPSVnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d0154d5c5d30fa214b8a2d9deedee12"></a><!-- doxytag: member="subpavings::SPSVnode::Vcounter" ref="a5d0154d5c5d30fa214b8a2d9deedee12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d0154d5c5d30fa214b8a2d9deedee12">subpavings::SPSVnode::Vcounter</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A counter for how many data points from the validation set that are covered by theBox. </p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00285">285</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01252">getRootVcounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00894">getVcounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01765">nodePrint()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00791">operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e6c6ea9c454b9ce280915b59c7f3647"></a><!-- doxytag: member="subpavings::SPSVnode::VdataItrs" ref="a0e6c6ea9c454b9ce280915b59c7f3647" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0e6c6ea9c454b9ce280915b59c7f3647">subpavings::SPSVnode::VdataItrs</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container for the association of validation data with a node. </p>
<p>Data is associated with a node via this container of iterators. The iterators can, very loosely, in the sense in which they are used here, be thought of as pointers to a big data collection of all data points. Only leaf nodes can have anything in this container. However, not all leaf nodes will necessarily have something in this container: the container will be empty if no data points are covered by the box represented by a leaf node. </p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00363">363</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l00907">clearData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00903">getVdata()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">insertOneFind()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">operator=()</a>, and <a class="el" href="spsvnode_8cpp_source.shtml#l00572">SPSVnode()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a></li>
<li><a class="el" href="spsvnode_8cpp_source.shtml">spsvnode.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:42 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
