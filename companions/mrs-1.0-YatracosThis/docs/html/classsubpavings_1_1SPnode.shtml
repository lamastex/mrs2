<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::SPnode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1SPnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::SPnode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::SPnode" -->
<p>SPnodes are nodes in the representation of a subpaving as a binary tree.  
 <a href="classsubpavings_1_1SPnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for subpavings::SPnode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1SPnode__inherit__graph.png" border="0" usemap="#subpavings_1_1SPnode_inherit__map" alt="Inheritance graph"/></div>
<map name="subpavings_1_1SPnode_inherit__map" id="subpavings_1_1SPnode_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::SPnode:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1SPnode__coll__graph.png" border="0" usemap="#subpavings_1_1SPnode_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1SPnode_coll__map" id="subpavings_1_1SPnode_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1SPnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54">SPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a7a1699938bb9acff0c04b07be9d64e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad43955b79e832489150c70b6aa4e3f05">SPnode</a> (const ivector &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor with box.  <a href="#ad43955b79e832489150c70b6aa4e3f05"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#acd1241250563fcabfd1fc1d069e2065d">SPnode</a> (const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor. Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> (labeled box).  <a href="#acd1241250563fcabfd1fc1d069e2065d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a41d88bc0857db595850fd2c7f1a4fa">SPnode</a> (ivector &amp;v, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor with box and optional label.  <a href="#a7a41d88bc0857db595850fd2c7f1a4fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ac91f261853f289d2ccf7102cd543a0d4">SPnode</a> (<a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor. Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> (labeled box).  <a href="#ac91f261853f289d2ccf7102cd543a0d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aeafa6189ea2d85037ab6579471a947be">SPnode</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aeafa6189ea2d85037ab6579471a947be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a87d58ed9b7f89215203195f933533aef">~SPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Declare as virtual because we will use SPNode as a base class.  <a href="#a87d58ed9b7f89215203195f933533aef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a6658537d790191fc8baae2b351cf9666">operator=</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a6658537d790191fc8baae2b351cf9666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e">recursiveRename</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively rename children based on this node's nodeName.  <a href="#a84eef536420ee82e9b6ec4eb17a0b14e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a4caf34bf9db0dc8f116797149be0cf8b">getDimension</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the dimension of theBox of a node.  <a href="#a4caf34bf9db0dc8f116797149be0cf8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac">getBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for theBox of a node.  <a href="#a8ff024c82f00ff7420ba62005a5558ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#accdcd56d02a9ff69c07aea07e16e8c8e">getLabel</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for label of a node.  <a href="#accdcd56d02a9ff69c07aea07e16e8c8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a9ef7989599f223a312a371d8fb8527db">setLabel</a> (int lab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the label of a childless root node.  <a href="#a9ef7989599f223a312a371d8fb8527db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db">getNodeName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node name.  <a href="#a930afc65b88ca963bb94d849a0e8c3db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f">setNodeName</a> (std::string newname)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node name.  <a href="#a628f03ae2795efd1135e6f4d06db987f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb">nodeVolume</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the volume of the box as a double.  <a href="#ab8a45c1ea71b3c1e90f0fd9bd23562eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347">nodeRealVolume</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if theBox is NULL.  <a href="#ad219abf12ef0e39222748004e1ff1347"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593">isEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is empty.  <a href="#a42410c54c2a5cc045ec63b26fb6ae593"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7">isLeaf</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is a leaf.  <a href="#af5ad3b1f3ca82ba135c491e99c53eda7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad">hasLCwithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this has a non-empty left child.  <a href="#a91a9483f923c30474b817c26ec8afbad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa">hasRCwithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this has a non-empty right child.  <a href="#a8127bcccc0023f632307c22f685196aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc">isSubLeaf</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">find if this node is a subleaf node.  <a href="#a079c914f2e19278844d934baad47fbfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371">getSplitDim</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the split dimension for this.  <a href="#ad04e240d9152c1a927c2ec280aa29371"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad9f203ab98f3e2766ee0acafddb5ea23">getNumberLeaves</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of leaf descendents of this.  <a href="#ad9f203ab98f3e2766ee0acafddb5ea23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a0c617b55345023a4c205603c167801b6">SPnodeConstPtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aa19d97146cec96a5a52eba91a9633897">getConstSPnodeLeaves</a> (<a class="el" href="namespacesubpavings.shtml#a0c617b55345023a4c205603c167801b6">SPnodeConstPtrs</a> &amp;leaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointers to const nodes.  <a href="#aa19d97146cec96a5a52eba91a9633897"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49">SPnodePtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad3548bf27557e71e7254e211e95f1878">getSPnodeLeaves</a> (<a class="el" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49">SPnodePtrs</a> &amp;leaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to all descendent leaf nodes as SPnodes.  <a href="#ad3548bf27557e71e7254e211e95f1878"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a5fe9e24f8f5cfe76e6b4a2f5ccc1f6f5">getLeafNodeVolumes</a> (<a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;vols) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in a vector of leaf node volumes.  <a href="#a5fe9e24f8f5cfe76e6b4a2f5ccc1f6f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b">getLeafNodeLevels</a> (<a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;levels) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in a vector of leaf node levels.  <a href="#aa1df5c8572870d22d59c852b458c892b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ab2d91d997064dccc3c1a6f80bd27c6ef">getLeafNodeLevels</a> (const int level, <a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;levels) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in a vector of leaf node levels based on a given root level.  <a href="#ab2d91d997064dccc3c1a6f80bd27c6ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a2e0b22fea0d547f34660cd9870b34ae7">getLeafNodeLevelsJ</a> (<a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;levels, int level=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in a vector of leaf node levels.  <a href="#a2e0b22fea0d547f34660cd9870b34ae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7ea8cd3649cbf13d5743d3cb23315d72">getLeafNodeLevelsString</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string of leaf node levels.  <a href="#a7ea8cd3649cbf13d5743d3cb23315d72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a07ebbebeb298c88963207afea4be3a81">getNodeDepth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node depth.  <a href="#a07ebbebeb298c88963207afea4be3a81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a55f98392efb2d28542610a65a6b00864">getDepth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get depth of the tree descended from this node.  <a href="#a55f98392efb2d28542610a65a6b00864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a91d46ee80958c0bed9fe972cf3cdea2d">getSmallestLeafVol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the volume of the leaf with the smallest volume.  <a href="#a91d46ee80958c0bed9fe972cf3cdea2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a1c60de6474783d65d1603eae6ab9a9ae">getLargestLeafVol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the volume of the leaf with the largest volume.  <a href="#a1c60de6474783d65d1603eae6ab9a9ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#afde5e15be5259cf61821f175452d165f">checkTreeStateLegal</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check tree rooted at this is legal with respect to <a class="el" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode()</a>.  <a href="#afde5e15be5259cf61821f175452d165f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e">hasLeafSibling</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this has a leaf sibling.  <a href="#a0b8af2e1f907279d8a153129aa37aa8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aa075a030c63ffaf0accddc5161852da3">accept</a> (<a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a> &amp;visitor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a visitor of the type <a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a>.  <a href="#aa075a030c63ffaf0accddc5161852da3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a2cedd2483f8546bb24e8990f7312f591">collectRange</a> (<a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a> &amp;visitor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range collection of the vistitor of the type <a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a>.  <a href="#a2cedd2483f8546bb24e8990f7312f591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a53cc083de0b60fc7e8b163cffd7428fe">acceptSPCheckVisitor</a> (const <a class="el" href="classsubpavings_1_1SPCheckVisitor.shtml">SPCheckVisitor</a> &amp;visitor) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept an <a class="el" href="classsubpavings_1_1SPCheckVisitor.shtml">SPCheckVisitor</a>.  <a href="#a53cc083de0b60fc7e8b163cffd7428fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aaf14185437d50e955c5ea938dc6e7559">nodePrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output details of a specific node in a tree.  <a href="#aaf14185437d50e955c5ea938dc6e7559"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814">leafOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a0f2381175b37224a185eedbe9601d814"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aaaf0891a67e056e19f8e086c0139fd96">outputGraphDot</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a .dot graph file from an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> tree structure.  <a href="#aaaf0891a67e056e19f8e086c0139fd96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aaefe6100d8c62dc84849cd2adb733ffb">nodeContains</a> (const rvector &amp;p, <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a> childInd=<a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the box a node represents contains a datapoint p.  <a href="#aaefe6100d8c62dc84849cd2adb733ffb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aa90c047beb6a8b6a4beb74342ad593a3">spContains</a> (const ivector &amp;z) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if ivector z is contained in this or children.  <a href="#aa90c047beb6a8b6a4beb74342ad593a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a56f98ed5bc26b9b11dfce51f3e667e2b">spContains</a> (const rvector &amp;p) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if rvector p is contained in this node or any of its children.  <a href="#a56f98ed5bc26b9b11dfce51f3e667e2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">nodeExpand</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to make two leaves as children.  <a href="#ac27ee8ea1399ed0121ed970c8fd51543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55">nodeExpand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to have two children and pass data down to the children with no further splitting.  <a href="#a0540c55967e7f35843fac029b450ab55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a3b16d632897f3a4fb11f36db1e9004bf">nodeExpand</a> (bool boolVal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to make two leaves as children.  <a href="#a3b16d632897f3a4fb11f36db1e9004bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ab92c1accdfd155898e63e26a112b8e36">nodeReabsorbChildren</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reabsorbs both children of the node.  <a href="#ab92c1accdfd155898e63e26a112b8e36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a56e03a33b576732f09a12d8b25c48acc">nodeReunite</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *lChild, <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to reunite nodes.  <a href="#a56e03a33b576732f09a12d8b25c48acc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f">nodeAddLeft</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *lChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree downwards.  <a href="#a7124dae3fa53ae2d0061deebe9787d7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26">nodeAddRight</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree downwards.  <a href="#ab826f2bf3a9c492c61ca260c16d99c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a42b4b4686ea981149fd7b25a9d720c16">nodeAdoptLeft</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *lChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#a42b4b4686ea981149fd7b25a9d720c16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a43d542d7c5227d52dfb7b5de97d2b676">nodeAdoptRight</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#a43d542d7c5227d52dfb7b5de97d2b676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5">getChildNodeNames</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string of child nodes names.  <a href="#a0e7556ec8e2ba5174777c0f6b32573d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a1113235b4bedd4a2849cc8e6dae719dc">reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of another tree.  <a href="#a1113235b4bedd4a2849cc8e6dae719dc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a62e9df1a7c96af8f0796a6ea211b38ea">splitRootToShape</a> (std::string instruction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a root paving to a specified shape.  <a href="#a62e9df1a7c96af8f0796a6ea211b38ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb">swap</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this and another node.  <a href="#a08eac7d3d3f57b9d6e56a84f14e9f4fb"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors for links between the nodes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="note"><dt><b>Note:</b></dt><dd>Pointers for parent, leftChild, and rightChild are not reference counted so there could potentially be problems with the use of returned pointers (for instance, being used to delete nodes). These pointers might be better implemented with boost::shared_ptr. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the parent of a node.  <a href="#ad25db2635b9fa09515a3cb75f4a7ccef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3">getLeftChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the left child of a node.  <a href="#a2ae7370c24e6c51a99c8bd29b2ffcec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689">getRightChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the right child of a node.  <a href="#a9477b1cfe157f5730a5514c944953689"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Output for for &lt;b&gt;all leaves&lt;/b&gt; of a binary tree.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Output intended for a txt file, in numeric form only.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">leavesOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ac0d9484691c21a316308b4713e6e8bba">leavesOutputTabs</a> (std::ostream &amp;os, int prec) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Output for &lt;b&gt;all nodes&lt;/b&gt; in binary tree.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Output for all nodes in binary tree representing a subpaving in tab-delimited form.</p>
<p>Output intended for console output. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ab75be88517039e1b426333dbc3764f10">nodesAllOutput</a> (std::ostream &amp;os, int level) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7408768856a7c988d9784b6172d74310">nodesAllOutput</a> (std::ostream &amp;os, int level, int prec) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a2f68ecee896eb24708a4a3045ddc38b4">vecLeafBoxOuterJacket</a> (<a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;boxes, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad7fd31c8579c501476dcc7004e52c1d6">spLeafBoxOuterJacket</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a57f1a92689c116edcf2bf6a62497970f">volOuterJacket</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#afb2b268ccd3ddfa61cdcadb866933351">vecLeafBoxIntersection</a> (<a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;boxes, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#abe8c17244a31a4003e59f48a56e61ac4">spLeafBoxIntersection</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aff141c8fe2b44b5da47319563f335fd3">volIntersection</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a8df2c2330b8da545a013d87cf1619e2b">vecLeafBoxDifference</a> (<a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;boxes, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a10a7bea8a44da192fe174d1d04284d3b">vecBoxNodeDifference</a> (<a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;boxes, ivector box1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a5de03ca047d5250c8b2f42f8b29f2a3e">spLeafBoxDifference</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a474c6fe9f99ba63eb6eff5c0577cc63a">volDifference</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn1, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a28c48af012e0a5b96236dcf12ffbae93">makeTreeFromLeaves</a> (ivector &amp;root, <a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a> &amp;leafList)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a minimal <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> subpaving from leaf boxes.  <a href="#a28c48af012e0a5b96236dcf12ffbae93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a4e11f6bd7a176b33a25f3700751c4a08">makeTreeFromVoxels</a> (ivector &amp;root, <a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a> &amp;leafList, double spacing, size_t dim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a minimal <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> subpaving from voxel boxes.  <a href="#a4e11f6bd7a176b33a25f3700751c4a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#aa42de2dd7951c3fa60ab9e95ebf0c4aa">vtkPaving</a> (const std::string filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a subpaving from vtk file data.  <a href="#aa42de2dd7951c3fa60ab9e95ebf0c4aa"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a44aaa22ba1f62c17775a96071c05ad8b">splitLeft</a> (std::string instruction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">splitting according to instruction string.  <a href="#a44aaa22ba1f62c17775a96071c05ad8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7ac37cce7f65b0f4c71d37b06d581d17">_reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape the tree rooted at this so that it has the shape that is the non-minimal union of the tree orginally rooted at this and the tree rooted at the node pointed to by <em>other</em>.  <a href="#a7ac37cce7f65b0f4c71d37b06d581d17"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832">theBox</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the interval vector the node represents.  <a href="#a2c09d2f687401550468bad6a6dae9832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e">dimension</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimensions in which we are working.  <a href="#ac28ce64cdc1aed5e545659699a38c16e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb">label</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The label for the box.  <a href="#a4add69f42780515a4f817f02770e38cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8">parent</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The node's parent.  <a href="#ad39c8dad1a8fa89110da4bad250521d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646">leftChild</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The node's left child.  <a href="#a5c047856140d3143bec18abc584c2646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd">rightChild</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The node's right child.  <a href="#a4d5e29412292750e36196b55e186b6dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610">nodeName</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The name given to the node.  <a href="#a90803dc066d955d4aec89c00879ff610"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a75618e8e46f82b309f744fc12927b2a9">constructor_error_handler</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle exceptions in the construction of a node.  <a href="#a75618e8e46f82b309f744fc12927b2a9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93">Sivia</a> (<a class="el" href="namespacesubpavings.shtml#a4ca48fac31a3dcc26d5b51b1ee3cd0d9">PIBT</a> BoolTest, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const toInvert, <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const search, const double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Inversion Via Interval Analysis.  <a href="#ace7e46329dbdb96110f7f24bba46ee93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#a5e79ff65a692b09c98ff53264ddfba9f">ImageSp</a> (<a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *spn, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of image subpaving with Interval Analysis.  <a href="#a5e79ff65a692b09c98ff53264ddfba9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml#adda5afc72873dc3875f341ecbb947b23">ImageSpNonMinimal</a> (<a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *spn, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation of non-minimal image subpaving with Interval Analysis.  <a href="#adda5afc72873dc3875f341ecbb947b23"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>SPnodes are nodes in the representation of a subpaving as a binary tree. </p>
<p>A node represents a box (interval vector). SPnodes are linked together to form the tree. The initial box of the subpaving is the box represented by the root node of the tree. A box which has been split will be represented as node with one or two children.</p>
<p>A subpaving of [<b>x</b>] (union of non-overlapping subboxes of [<b>x</b>]) is represented by the leaves (degenerate/ child-less) nodes in the tree.</p>
<p>SPnodes are an adaptation of the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class [from Jaulin, Kieffer, Didrit and Walter, Applied Interval Analysis, Springer, 2001, p. 336-348] including changes in coding, class members, and class structure. SPnodes are implemented under C-XSC.</p>
<p>This class replicates the set computation functionality of the subpaving nodes developed by [Jaulin, Kieffer, Didrit and Walter, Applied Interval Analysis, Springer, 2001] but also provides additional functionality to allow the class to become the basis for derived classes of subpaving nodes that can be used for <b>statistical set processing</b>. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00076">76</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7a1699938bb9acff0c04b07be9d64e54"></a><!-- doxytag: member="subpavings::SPnode::SPnode" ref="a7a1699938bb9acff0c04b07be9d64e54" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54">subpavings::SPnode::SPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00188">188</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l02032">makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">makeTreeFromVoxels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00268">SPnode()</a>.</p>
<div class="fragment"><pre class="fragment">                   :  <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>(0), <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>(0),
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>(<span class="stringliteral">&quot;X&quot;</span>)
        {}
</pre></div>
</div>
</div>
<a class="anchor" id="ad43955b79e832489150c70b6aa4e3f05"></a><!-- doxytag: member="subpavings::SPnode::SPnode" ref="ad43955b79e832489150c70b6aa4e3f05" args="(const ivector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54">subpavings::SPnode::SPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor with box. </p>
<p>Throws a <a class="el" href="classsubpavings_1_1MalconstructedBox__Error.shtml">MalconstructedBox_Error</a> if <em>v</em> has no practical (0 or negative) dimensions.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>interval vector for the box this represents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>v should be a proper ivector, with length &gt;= 1. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00195">195</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00064">constructor_error_handler()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">                               : <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>(NULL),
  <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>(<span class="stringliteral">&quot;X&quot;</span>)
{
  <span class="keywordflow">try</span> {
    <span class="keywordtype">int</span> d = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(v) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(v) + 1; 
    <span class="keywordflow">if</span> (d &lt; 1) {
      <span class="keywordflow">throw</span> MalconstructedBox_Error(
                <span class="stringliteral">&quot;SPnode::SPnode(const ivector&amp;, int)&quot;</span>);
    }
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(v);
  }
  <span class="keywordflow">catch</span> (exception <span class="keyword">const</span>&amp; e) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a75618e8e46f82b309f744fc12927b2a9" title="Handle exceptions in the construction of a node.">constructor_error_handler</a>();
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acd1241250563fcabfd1fc1d069e2065d"></a><!-- doxytag: member="subpavings::SPnode::SPnode" ref="acd1241250563fcabfd1fc1d069e2065d" args="(const LabBox &amp;lb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54">subpavings::SPnode::SPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> (labeled box). </p>
<p>Throws a <a class="el" href="classsubpavings_1_1MalconstructedBox__Error.shtml">MalconstructedBox_Error</a> if <em>v</em> has no practical (0 or negative) dimensions.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lb</td><td>a labeled box which supplies information about box for this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>the box of the labeled box should be a proper box, with length &gt;= 1. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00214">214</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="SmallClasses_8hpp_source.shtml#l00075">LabBox::Box</a>, <a class="el" href="spnode_8cpp_source.shtml#l00064">constructor_error_handler()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">                               : <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>(NULL),
  <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>(<span class="stringliteral">&quot;X&quot;</span>)
{
  <span class="keywordflow">try</span> {
    ivector v = lb.<a class="code" href="classLabBox.shtml#a65253d570e3236bde747ddfabc7c6849" title="specifies the box as cxsc::ivector Box of the labeled box LabBox">Box</a>;
    <span class="keywordtype">int</span> d = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(v) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(v) + 1; 
    <span class="keywordflow">if</span> (d &lt; 1) {
      <span class="keywordflow">throw</span> MalconstructedBox_Error(
            <span class="stringliteral">&quot;SPnode::SPnode(const LabBox&amp;)&quot;</span>);
    }
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(v);
  }
  <span class="keywordflow">catch</span> (exception <span class="keyword">const</span>&amp; e) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a75618e8e46f82b309f744fc12927b2a9" title="Handle exceptions in the construction of a node.">constructor_error_handler</a>();
  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a7a41d88bc0857db595850fd2c7f1a4fa"></a><!-- doxytag: member="subpavings::SPnode::SPnode" ref="a7a41d88bc0857db595850fd2c7f1a4fa" args="(ivector &amp;v, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54">subpavings::SPnode::SPnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor with box and optional label. </p>
<p>Initialised with one interval vector for the box and optionally initialised with a label. Label defaults to 0 if not specified. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00237">237</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">dimension</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">                                      : <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>(lab),
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>(<span class="stringliteral">&quot;X&quot;</span>)
    {
        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(v);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(v) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(v) + 1;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac91f261853f289d2ccf7102cd543a0d4"></a><!-- doxytag: member="subpavings::SPnode::SPnode" ref="ac91f261853f289d2ccf7102cd543a0d4" args="(LabBox &amp;lb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54">subpavings::SPnode::SPnode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> (labeled box). </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00251">251</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="SmallClasses_8hpp_source.shtml#l00075">LabBox::Box</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">dimension</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">                             : <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>(lb.<a class="code" href="classLabBox.shtml#a4f0197d8aaeb58676d6c50f0f229a63b" title="specifies the label L of the labeled box LabBox">L</a>), <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>(NULL),
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>(<span class="stringliteral">&quot;X&quot;</span>)
    {
        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(lb.<a class="code" href="classLabBox.shtml#a65253d570e3236bde747ddfabc7c6849" title="specifies the box as cxsc::ivector Box of the labeled box LabBox">Box</a>);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(lb.<a class="code" href="classLabBox.shtml#a65253d570e3236bde747ddfabc7c6849" title="specifies the box as cxsc::ivector Box of the labeled box LabBox">Box</a>) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(lb.<a class="code" href="classLabBox.shtml#a65253d570e3236bde747ddfabc7c6849" title="specifies the box as cxsc::ivector Box of the labeled box LabBox">Box</a>) + 1;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="aeafa6189ea2d85037ab6579471a947be"></a><!-- doxytag: member="subpavings::SPnode::SPnode" ref="aeafa6189ea2d85037ab6579471a947be" args="(const SPnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54">subpavings::SPnode::SPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00268">268</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l00188">SPnode()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>
<div class="fragment"><pre class="fragment">                                      : <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>(other.dimension),
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>(other.label), <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>(NULL), <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>(other.nodeName)
    {
        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(*other.theBox);

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (other.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*other.leftChild);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (other.rightChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*other.rightChild);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a87d58ed9b7f89215203195f933533aef"></a><!-- doxytag: member="subpavings::SPnode::~SPnode" ref="a87d58ed9b7f89215203195f933533aef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml#a87d58ed9b7f89215203195f933533aef">subpavings::SPnode::~SPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. Declare as virtual because we will use SPNode as a base class. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00295">295</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {<span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7ac37cce7f65b0f4c71d37b06d581d17"></a><!-- doxytag: member="subpavings::SPnode::_reshapeToUnion" ref="a7ac37cce7f65b0f4c71d37b06d581d17" args="(const SPnode *const other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a7ac37cce7f65b0f4c71d37b06d581d17">subpavings::SPnode::_reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reshape the tree rooted at this so that it has the shape that is the non-minimal union of the tree orginally rooted at this and the tree rooted at the node pointed to by <em>other</em>. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00157">157</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02192">subpavings::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l00621">subpavings::SPSnode::_reshapeToUnion()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01532">reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> ( other != NULL &amp;&amp; !(other-&gt;isEmpty()) ) {

    <span class="comment">// this is not a leaf, other is a leaf</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; other-&gt;isLeaf()) {

      <span class="comment">// no need to do anything</span>
    }

    <span class="comment">// this is a leaf, other is not a leaf</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !other-&gt;isLeaf()) {

      <span class="comment">/* we need to expand this, */</span>
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55" title="Expand a leaf node to have two children and pass data down to the children with no further splitting...">nodeExpand</a>();
      
    }

    <span class="comment">// now recurse on the children if both have children</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !other-&gt;isLeaf()) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a7ac37cce7f65b0f4c71d37b06d581d17" title="Reshape the tree rooted at this so that it has the shape that is the non-minimal union of the tree or...">_reshapeToUnion</a>(other-&gt;getLeftChild());
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a7ac37cce7f65b0f4c71d37b06d581d17" title="Reshape the tree rooted at this so that it has the shape that is the non-minimal union of the tree or...">_reshapeToUnion</a>(other-&gt;getRightChild());
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa075a030c63ffaf0accddc5161852da3"></a><!-- doxytag: member="subpavings::SPnode::accept" ref="aa075a030c63ffaf0accddc5161852da3" args="(SPnodeVisitor &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#aa075a030c63ffaf0accddc5161852da3">subpavings::SPnode::accept</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept a visitor of the type <a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>The visitor to accept. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00858">858</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnodevisitor_8hpp_source.shtml#l00049">subpavings::SPnodeVisitor::visit()</a>.</p>

<p>Referenced by <a class="el" href="Ex1D_8cpp_source.shtml#l00038">main()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        visitor.visit(<span class="keyword">this</span>);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a53cc083de0b60fc7e8b163cffd7428fe"></a><!-- doxytag: member="subpavings::SPnode::acceptSPCheckVisitor" ref="a53cc083de0b60fc7e8b163cffd7428fe" args="(const SPCheckVisitor &amp;visitor) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a53cc083de0b60fc7e8b163cffd7428fe">subpavings::SPnode::acceptSPCheckVisitor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPCheckVisitor.shtml">SPCheckVisitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept an <a class="el" href="classsubpavings_1_1SPCheckVisitor.shtml">SPCheckVisitor</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>a visitor capable of performing some check on this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is unchanged. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00870">870</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1SPCheckVisitor.shtml#ad5fd0bde6d256676290e790c6387f01a">subpavings::SPCheckVisitor::visit()</a>.</p>
<div class="fragment"><pre class="fragment">{
  visitor.visit(<span class="keyword">this</span>);
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="afde5e15be5259cf61821f175452d165f"></a><!-- doxytag: member="subpavings::SPnode::checkTreeStateLegal" ref="afde5e15be5259cf61821f175452d165f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#afde5e15be5259cf61821f175452d165f">subpavings::SPnode::checkTreeStateLegal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check tree rooted at this is legal with respect to <a class="el" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode()</a>. </p>
<p>'Legal' means that all non-leaf nodes in the tree are splittable, ie return <a class="el" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode()</a> = true;</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all non-leaf nodes in the tree rooted at this are splittable, false if any non-leaf node in the tree rooted at this is not splittable. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00820">820</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00372">isSplittableNode()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01532">reshapeToUnion()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02372">subpavings::SPSnode::reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// check current state is legal by looking at everything not a leaf</span>
  <span class="keywordtype">bool</span> legal = <span class="keyword">true</span>;
  <span class="keywordflow">if</span> ( !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
    legal = <a class="code" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode</a>();
    <span class="keywordflow">if</span> (legal &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() ) {
        legal = <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#afde5e15be5259cf61821f175452d165f" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal</a>();
    }
    <span class="keywordflow">if</span> (legal &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() ) {
        legal = <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#afde5e15be5259cf61821f175452d165f" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal</a>();
    }
  }
  
  <span class="keywordflow">return</span> legal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2cedd2483f8546bb24e8990f7312f591"></a><!-- doxytag: member="subpavings::SPnode::collectRange" ref="a2cedd2483f8546bb24e8990f7312f591" args="(SPnodeVisitor &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a2cedd2483f8546bb24e8990f7312f591">subpavings::SPnode::collectRange</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the range collection of the vistitor of the type <a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>the visitor to get the range from </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00864">864</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnodevisitor_8hpp_source.shtml#l00051">subpavings::SPnodeVisitor::tellMe()</a>.</p>

<p>Referenced by <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00107">subpavings::MappedSPnodeVisitorExpand::priorityVisit()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        visitor.tellMe(<span class="keyword">this</span>);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a75618e8e46f82b309f744fc12927b2a9"></a><!-- doxytag: member="subpavings::SPnode::constructor_error_handler" ref="a75618e8e46f82b309f744fc12927b2a9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a75618e8e46f82b309f744fc12927b2a9">subpavings::SPnode::constructor_error_handler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle exceptions in the construction of a node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00064">64</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00195">SPnode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">try</span> {
      <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>;
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = NULL;
  }
  <span class="keywordflow">catch</span> (std::exception&amp; ee) {} <span class="comment">// catch and swallow</span>
  <span class="keywordflow">try</span> {
      <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>;
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
  }
  <span class="keywordflow">catch</span> (std::exception&amp; ee) {} <span class="comment">// catch and swallow</span>
  <span class="keywordflow">try</span> {
      <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
  }
  <span class="keywordflow">catch</span> (std::exception&amp; ee) {} <span class="comment">// catch and swallow</span>
  
  <span class="keywordflow">throw</span>; <span class="comment">// rethrow the original exception</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8ff024c82f00ff7420ba62005a5558ac"></a><!-- doxytag: member="subpavings::SPnode::getBox" ref="a8ff024c82f00ff7420ba62005a5558ac" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac">subpavings::SPnode::getBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for theBox of a node. </p>
<p>Returns a copy of the object pointed to by theBox of a node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00387">387</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">subpavings::CollatorSPnode::_marginalise()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00731">subpavings::RealMappedSPnode::_start_marginalise()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00100">subpavings::AdaptiveHistogram::AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00098">subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00912">subpavings::CollatorSPnode::addPavings()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01181">subpavings::CollatorSPVnode::addPavings()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">subpavings::CollatorSPnode::dotDiffPaving()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00174">subpavings::Evaluate()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00484">subpavings::RealMappedSPnode::getL1Distance()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01170">subpavings::SPSnode::getLeftCountIfSplit()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00508">subpavings::RealMappedSPnode::getLogLikelihood()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00932">subpavings::SPSVnode::getRightCountIfSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">subpavings::AdaptiveHistogram::getRootBox()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01067">subpavings::AdaptiveHistogramVCollator::getScheffeSetAll()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">getSplitDim()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01698">subpavings::CollatorSPnode::getSplitDim()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01346">subpavings::CollatorSPVnode::getSplitNodePtrCSPV()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01356">subpavings::SPSVnode::getUniformMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01528">subpavings::SPSnode::getUniformMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01739">subpavings::SPSVnode::getUniformVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01969">subpavings::SPSnode::getUniformVarCovar()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00372">isSplittableNode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01122">subpavings::SPSnode::isSplittableNode()</a>, <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01636">subpavings::CollatorSPnode::marginalise()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">subpavings::Mince()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01043">nodeContains()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02184">subpavings::SPSVnode::nodeContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02568">subpavings::SPSnode::nodeContains()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01873">subpavings::SPSVnode::nodeExpand()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02853">subpavings::SPSnode::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00465">nodeRealVolume()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">nodeVolume()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">subpavings::RealMappedSPnode::oneLineOutput()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">subpavings::MappedSPnode&lt; cxsc::real &gt;::oneLineOutput()</a>, <a class="el" href="nodecompobjmapped_8hpp_source.shtml#l00070">subpavings::CompSPArea::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00217">subpavings::CompHellingerDist1DMassDiamVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00256">subpavings::CompHellingerDistMassDiamVal::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00385">subpavings::CompHellingerDist1DMassDiam::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00428">subpavings::CompHellingerDistMassDiam::operator()()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00764">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator*=()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00340">subpavings::AdaptiveHistogramCollator::operator+()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01166">subpavings::AdaptiveHistogram::operator+()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00617">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator+=()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00233">subpavings::AdaptiveHistogramVCollator::operator-()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00422">subpavings::AdaptiveHistogramCollator::operator-()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00690">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator-=()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00842">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator/=()</a>, <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00107">subpavings::MappedSPnodeVisitorExpand::priorityVisit()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01532">reshapeToUnion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02372">subpavings::SPSnode::reshapeToUnion()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">subpavings::Sivia()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01591">subpavings::MappedSPnode&lt; cxsc::real &gt;::sliceCheck()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">spContains()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01802">spLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01699">spLeafBoxIntersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01614">spLeafBoxOuterJacket()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02613">subpavings::SPSnode::spsContains()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">subpavings::SPSnode::strippedConstructor()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00984">subpavings::CollatorSPnode::subtractPavings()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01243">subpavings::CollatorSPVnode::subtractPavings()</a>, <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00071">subpavings::MappedSPnodeVisitorExpand::tellMe()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00503">subpavings::SPSVnode::unionNoData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00554">subpavings::SPSnode::unionNoData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02220">subpavings::SPSVnode::unionTreeStructure()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03160">subpavings::SPSnode::unionTreeStructure()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01568">vecLeafBoxOuterJacket()</a>, and <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00043">subpavings::MappedSPnodeVisitorExpand::visit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a0e7556ec8e2ba5174777c0f6b32573d5"></a><!-- doxytag: member="subpavings::SPnode::getChildNodeNames" ref="a0e7556ec8e2ba5174777c0f6b32573d5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5">subpavings::SPnode::getChildNodeNames</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a string of child nodes names. </p>
<p>Left to right order.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string of child nodes names in pairs, left to right. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01496">1496</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01496">getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">getNodeName()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00100">subpavings::AdaptiveHistogram::AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00098">subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">getChildNodeNames()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">subpavings::AdaptiveHistogramValidation::insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">subpavings::AdaptiveHistogram::insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogram::insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">subpavings::AdaptiveHistogram::mergeUp()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">subpavings::AdaptiveHistogramValidation::operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">subpavings::AdaptiveHistogram::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01005">outputGraphDot()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03255">subpavings::AdaptiveHistogramValidation::splitToShape()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02971">subpavings::AdaptiveHistogram::splitToShape()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        std::string retStr = <span class="stringliteral">&quot;&quot;</span>;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a> * LChild =  <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>();
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a> * RChild =  <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>();

        <span class="keywordflow">if</span> (LChild != NULL) {
            retStr += <span class="stringliteral">&quot; &quot;</span>;
            retStr += LChild-&gt;getNodeName();
        }
        <span class="keywordflow">if</span> (RChild != NULL) {
            retStr += <span class="stringliteral">&quot; &quot;</span>;
            retStr += RChild-&gt;getNodeName();
        }
        <span class="keywordflow">if</span> (LChild != NULL) {
            retStr += LChild-&gt;getChildNodeNames();
        }
        <span class="keywordflow">if</span> (RChild != NULL) {
            retStr += RChild-&gt;getChildNodeNames();
        }
        <span class="keywordflow">return</span> retStr;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa19d97146cec96a5a52eba91a9633897"></a><!-- doxytag: member="subpavings::SPnode::getConstSPnodeLeaves" ref="aa19d97146cec96a5a52eba91a9633897" args="(SPnodeConstPtrs &amp;leaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a0c617b55345023a4c205603c167801b6">SPnodeConstPtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#aa19d97146cec96a5a52eba91a9633897">subpavings::SPnode::getConstSPnodeLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a0c617b55345023a4c205603c167801b6">SPnodeConstPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return pointers to const nodes. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00582">582</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00582">getConstSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00582">getConstSPnodeLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//if children, recurse on the children</span>
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa19d97146cec96a5a52eba91a9633897" title="Return pointers to const nodes.">getConstSPnodeLeaves</a>(leaves);
  }

  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa19d97146cec96a5a52eba91a9633897" title="Return pointers to const nodes.">getConstSPnodeLeaves</a>(leaves);
  }

  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) { <span class="comment">// this is a leaf</span>
    leaves.push_back(<span class="keyword">this</span>);
  }
  <span class="keywordflow">return</span> leaves;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a55f98392efb2d28542610a65a6b00864"></a><!-- doxytag: member="subpavings::SPnode::getDepth" ref="a55f98392efb2d28542610a65a6b00864" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPnode.shtml#a55f98392efb2d28542610a65a6b00864">subpavings::SPnode::getDepth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get depth of the tree descended from this node. </p>
<p>Depth of this node is 0. Returns the depth of the deepest leaf child descendent of this node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00730">730</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> depth = 0;

        <span class="comment">// if this is a leaf the depth is 0</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is not a leaf</span>
            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49" title="Define type SPnodePtrs as container of pointers to SPnodes.">SPnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad3548bf27557e71e7254e211e95f1878" title="Return a reference to all descendent leaf nodes as SPnodes.">getSPnodeLeaves</a>(leaves);

            <span class="comment">// find the deepest leaf child</span>
            <a class="code" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6" title="Define type SPnodePtrsItr as an iterator over SPnodePtrs.">SPnodePtrsItr</a> it;

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;getNodeDepth() &gt; depth) {

                    depth = (*it)-&gt;getNodeDepth();
                }
            }
        } <span class="comment">// end if not a leaf</span>

        <span class="keywordflow">return</span> depth;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4caf34bf9db0dc8f116797149be0cf8b"></a><!-- doxytag: member="subpavings::SPnode::getDimension" ref="a4caf34bf9db0dc8f116797149be0cf8b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPnode.shtml#a4caf34bf9db0dc8f116797149be0cf8b">subpavings::SPnode::getDimension</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the dimension of theBox of a node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00382">382</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">dimension</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeStringSummary()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02175">subpavings::operator&lt;=()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01591">subpavings::MappedSPnode&lt; cxsc::real &gt;::sliceCheck()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="accdcd56d02a9ff69c07aea07e16e8c8e"></a><!-- doxytag: member="subpavings::SPnode::getLabel" ref="accdcd56d02a9ff69c07aea07e16e8c8e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPnode.shtml#accdcd56d02a9ff69c07aea07e16e8c8e">subpavings::SPnode::getLabel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for label of a node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00391">391</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">subpavings::CollatorSPnode::_marginalise()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">subpavings::CollatorSPnode::dotDiffPaving()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a1c60de6474783d65d1603eae6ab9a9ae"></a><!-- doxytag: member="subpavings::SPnode::getLargestLeafVol" ref="a1c60de6474783d65d1603eae6ab9a9ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPnode.shtml#a1c60de6474783d65d1603eae6ab9a9ae">subpavings::SPnode::getLargestLeafVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the volume of the leaf with the largest volume. </p>
<p>Returns the volume of the largest (by vol) leaf node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00789">789</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">nodeVolume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">double</span> largestVol = 0.0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            largestVol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>

            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49" title="Define type SPnodePtrs as container of pointers to SPnodes.">SPnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <span class="comment">// could be just this if no children</span>
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad3548bf27557e71e7254e211e95f1878" title="Return a reference to all descendent leaf nodes as SPnodes.">getSPnodeLeaves</a>(leaves);

            <span class="comment">// find the largest child by volume</span>
            <a class="code" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6" title="Define type SPnodePtrsItr as an iterator over SPnodePtrs.">SPnodePtrsItr</a> it;
            largestVol = (*(leaves.begin()))-&gt;nodeVolume();

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;nodeVolume() &gt; largestVol) {
                    largestVol = (*it)-&gt;nodeVolume();
                }
            }
        }

        <span class="keywordflow">return</span> largestVol;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa1df5c8572870d22d59c852b458c892b"></a><!-- doxytag: member="subpavings::SPnode::getLeafNodeLevels" ref="aa1df5c8572870d22d59c852b458c892b" args="(IntVec &amp;levels) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b">subpavings::SPnode::getLeafNodeLevels</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;&#160;</td>
          <td class="paramname"><em>levels</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill in a vector of leaf node levels. </p>
<p>Levels are taken from length of node name. nodeName for root is X.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">levels</td><td>a container in which to store levels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the container of levels. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00621">621</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00621">getLeafNodeLevels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03323">subpavings::AdaptiveHistogramValidation::getLeafLevels()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03502">subpavings::AdaptiveHistogram::getLeafLevels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00621">getLeafNodeLevels()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00692">getLeafNodeLevelsString()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.length() &gt; 0) {

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(levels);
            }
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(levels);
            }
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

                levels.push_back(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.length()-1);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// nodeName.length() == 0</span>
            <span class="keywordtype">int</span> level = 0;

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(level+1, levels);
            }
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(level+1, levels);
            }
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

                levels.push_back(level);
            }
        }
        <span class="keywordflow">return</span> levels;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab2d91d997064dccc3c1a6f80bd27c6ef"></a><!-- doxytag: member="subpavings::SPnode::getLeafNodeLevels" ref="ab2d91d997064dccc3c1a6f80bd27c6ef" args="(const int level, IntVec &amp;levels) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b">subpavings::SPnode::getLeafNodeLevels</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;&#160;</td>
          <td class="paramname"><em>levels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill in a vector of leaf node levels based on a given root level. </p>
<p>Levels are taken given 'base' or root level.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>a level to use for this node. </td></tr>
    <tr><td class="paramname">levels</td><td>a container in which to store levels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the container of levels. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00656">656</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00621">getLeafNodeLevels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(level+1, levels);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(level+1, levels);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

            levels.push_back(level);
        }
        <span class="keywordflow">return</span> levels;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2e0b22fea0d547f34660cd9870b34ae7"></a><!-- doxytag: member="subpavings::SPnode::getLeafNodeLevelsJ" ref="a2e0b22fea0d547f34660cd9870b34ae7" args="(IntVec &amp;levels, int level=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a2e0b22fea0d547f34660cd9870b34ae7">subpavings::SPnode::getLeafNodeLevelsJ</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;&#160;</td>
          <td class="paramname"><em>levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill in a vector of leaf node levels. </p>
<p>Levels are taken from length of node name. nodeName for root is X.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">levels</td><td>a container in which to store levels. </td></tr>
    <tr><td class="paramname">level</td><td>the level to allocate to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the container of levels. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00674">674</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00674">getLeafNodeLevelsJ()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00674">getLeafNodeLevelsJ()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2e0b22fea0d547f34660cd9870b34ae7" title="Fill in a vector of leaf node levels.">getLeafNodeLevelsJ</a>(levels, level+1);
  }
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2e0b22fea0d547f34660cd9870b34ae7" title="Fill in a vector of leaf node levels.">getLeafNodeLevelsJ</a>(levels, level+1);
  }
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

    levels.push_back(level);
  }
  <span class="keywordflow">return</span> levels;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7ea8cd3649cbf13d5743d3cb23315d72"></a><!-- doxytag: member="subpavings::SPnode::getLeafNodeLevelsString" ref="a7ea8cd3649cbf13d5743d3cb23315d72" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1SPnode.shtml#a7ea8cd3649cbf13d5743d3cb23315d72">subpavings::SPnode::getLeafNodeLevelsString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a string of leaf node levels. </p>
<p>Levels start at 0 for root.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a comma-separated string of levels. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00692">692</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00621">getLeafNodeLevels()</a>.</p>

<p>Referenced by <a class="el" href="multitreemanager_8hpp_source.shtml#l00099">MultiTreeManager::getLeafLevelsString()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00579">subpavings::AdaptiveHistogramValidation::getLeafLevelsString()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">subpavings::AdaptiveHistogram::getLeafLevelsString()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> levels;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(levels); <span class="comment">// fill container of leaf levels</span>
        <a class="code" href="namespacesubpavings.shtml#ac37614ffc671c9e95013493ff9dc5137" title="Define type IntVecItr as iterator over IntVec.">IntVecItr</a> it;

        std::string str = <span class="stringliteral">&quot;&quot;</span>;

        <span class="keywordflow">for</span> (it = levels.begin(); it &lt; levels.end(); it++) {
            stringstream out;
            out &lt;&lt; (*it);
            str = str + out.str() + <span class="stringliteral">&quot;,&quot;</span>;
        };
        <span class="comment">// trim off any lead or trailing &quot;, &quot;</span>
        <span class="keywordtype">size_t</span> startpos = str.find_first_not_of(<span class="stringliteral">&quot; ,&quot;</span>);
        <span class="keywordtype">size_t</span> endpos = str.find_last_not_of(<span class="stringliteral">&quot; ,&quot;</span>);
        <span class="comment">// if all commas or empty return an empty string</span>
        <span class="keywordflow">if</span>(( std::string::npos == startpos ) || ( std::string::npos == endpos)) {
            str = <span class="stringliteral">&quot;&quot;</span>;
        }
        <span class="keywordflow">else</span> {
            str = str.substr( startpos, endpos-startpos+1 );
        }
        <span class="keywordflow">return</span> str;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5fe9e24f8f5cfe76e6b4a2f5ccc1f6f5"></a><!-- doxytag: member="subpavings::SPnode::getLeafNodeVolumes" ref="a5fe9e24f8f5cfe76e6b4a2f5ccc1f6f5" args="(RealVec &amp;vols) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a5fe9e24f8f5cfe76e6b4a2f5ccc1f6f5">subpavings::SPnode::getLeafNodeVolumes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td>
          <td class="paramname"><em>vols</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill in a vector of leaf node volumes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vols</td><td>a container in which to store volumes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the container of volumes to which the volumes of all leaves descended from this have been added. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00603">603</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00603">getLeafNodeVolumes()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00603">getLeafNodeVolumes()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a5fe9e24f8f5cfe76e6b4a2f5ccc1f6f5" title="Fill in a vector of leaf node volumes.">getLeafNodeVolumes</a>(vols);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a5fe9e24f8f5cfe76e6b4a2f5ccc1f6f5" title="Fill in a vector of leaf node volumes.">getLeafNodeVolumes</a>(vols);
        }

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// this is a leaf</span>
            vols.push_back(<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>());
        }
        <span class="keywordflow">return</span> vols;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2ae7370c24e6c51a99c8bd29b2ffcec3"></a><!-- doxytag: member="subpavings::SPnode::getLeftChild" ref="a2ae7370c24e6c51a99c8bd29b2ffcec3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3">subpavings::SPnode::getLeftChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the left child of a node. </p>
<p>Returns a copy of the pointer to leftChild node. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce">subpavings::CollatorSPVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82">subpavings::CollatorSPnode</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093">subpavings::MappedSPnode&lt; T &gt;</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>, and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00401">401</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00157">_reshapeToUnion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00629">subpavings::SPSnode::_reshapeToUnion()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00174">subpavings::Evaluate()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00582">getConstSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00621">getLeafNodeLevels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00674">getLeafNodeLevelsJ()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00603">getLeafNodeVolumes()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00493">getNumberLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">getSplitDim()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00443">isSubLeaf()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">subpavings::Mince()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00960">nodesAllOutput()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02155">subpavings::operator&lt;&lt;()</a>, <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00107">subpavings::MappedSPnodeVisitorExpand::priorityVisit()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">subpavings::Sivia()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02236">subpavings::spLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02257">subpavings::spTotalNodes()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02214">subpavings::spVolume()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01782">vecBoxNodeDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01568">vecLeafBoxOuterJacket()</a>, and <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00043">subpavings::MappedSPnodeVisitorExpand::visit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a07ebbebeb298c88963207afea4be3a81"></a><!-- doxytag: member="subpavings::SPnode::getNodeDepth" ref="a07ebbebeb298c88963207afea4be3a81" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPnode.shtml#a07ebbebeb298c88963207afea4be3a81">subpavings::SPnode::getNodeDepth</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the node depth. </p>
<p>Root has depth 0 </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00720">720</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> depth = 0;
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.length() &gt; 1)
            depth = <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.length() - 1;
        <span class="keywordflow">return</span> depth;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a930afc65b88ca963bb94d849a0e8c3db"></a><!-- doxytag: member="subpavings::SPnode::getNodeName" ref="a930afc65b88ca963bb94d849a0e8c3db" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db">subpavings::SPnode::getNodeName</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the node name. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00424">424</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">subpavings::RealMappedSPnode::_getL1distance()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">subpavings::RealMappedSPnode::_getLogLikelihood()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00100">subpavings::AdaptiveHistogram::AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00098">subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">subpavings::AdaptiveHistogram::decisionMCMCSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">getChildNodeNames()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">subpavings::SPSVnode::getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">subpavings::SPSnode::getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01820">subpavings::SPSnode::getHellingerDist1D()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">subpavings::AdaptiveHistogramValidation::haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">subpavings::AdaptiveHistogram::haveMadePaving()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">subpavings::RealMappedSPnode::nodeL1Distance()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeStringSummary()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">subpavings::RealMappedSPnode::oneLineOutput()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">subpavings::MappedSPnode&lt; cxsc::real &gt;::oneLineOutput()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">subpavings::AdaptiveHistogramValidation::operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">subpavings::AdaptiveHistogram::operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00447">subpavings::RealMappedSPnode::slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00519">subpavings::MappedSPnode&lt; cxsc::real &gt;::slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01591">subpavings::MappedSPnode&lt; cxsc::real &gt;::sliceCheck()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03255">subpavings::AdaptiveHistogramValidation::splitToShape()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02971">subpavings::AdaptiveHistogram::splitToShape()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad9f203ab98f3e2766ee0acafddb5ea23"></a><!-- doxytag: member="subpavings::SPnode::getNumberLeaves" ref="ad9f203ab98f3e2766ee0acafddb5ea23" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPnode.shtml#ad9f203ab98f3e2766ee0acafddb5ea23">subpavings::SPnode::getNumberLeaves</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of leaf descendents of this. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of leaf descendents of this (1 if this is a leaf). </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00493">493</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00493">getNumberLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00493">getNumberLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">size_t</span> retVal=0;
  
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) retVal = 1; <span class="comment">// leaf</span>

  <span class="keywordflow">else</span> {

    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) 
      retVal += <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad9f203ab98f3e2766ee0acafddb5ea23" title="Get number of leaf descendents of this.">getNumberLeaves</a>();
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) 
      retVal += <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad9f203ab98f3e2766ee0acafddb5ea23" title="Get number of leaf descendents of this.">getNumberLeaves</a>();

  }

  <span class="keywordflow">return</span> retVal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad25db2635b9fa09515a3cb75f4a7ccef"></a><!-- doxytag: member="subpavings::SPnode::getParent" ref="ad25db2635b9fa09515a3cb75f4a7ccef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef">subpavings::SPnode::getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the parent of a node. </p>
<p>Returns a copy of the pointer to parent node. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a635b2b0884e6d8fc328e058bd3fadbcc">subpavings::CollatorSPVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aed3cb2aceae3c384eed427a404a6c8f6">subpavings::CollatorSPnode</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef">subpavings::MappedSPnode&lt; T &gt;</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>, and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00396">396</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01043">nodeContains()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00411">setLabel()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a9477b1cfe157f5730a5514c944953689"></a><!-- doxytag: member="subpavings::SPnode::getRightChild" ref="a9477b1cfe157f5730a5514c944953689" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689">subpavings::SPnode::getRightChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the right child of a node. </p>
<p>Returns a copy of the pointer to rightChild node. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b">subpavings::CollatorSPVnode</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9">subpavings::MappedSPnode&lt; T &gt;</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6">subpavings::CollatorSPnode</a>, and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00406">406</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00157">_reshapeToUnion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00629">subpavings::SPSnode::_reshapeToUnion()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00174">subpavings::Evaluate()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00582">getConstSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00621">getLeafNodeLevels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00674">getLeafNodeLevelsJ()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00603">getLeafNodeVolumes()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00493">getNumberLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">getSplitDim()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00443">isSubLeaf()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">subpavings::Mince()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00960">nodesAllOutput()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02155">subpavings::operator&lt;&lt;()</a>, <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00107">subpavings::MappedSPnodeVisitorExpand::priorityVisit()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">subpavings::Sivia()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02236">subpavings::spLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02257">subpavings::spTotalNodes()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02214">subpavings::spVolume()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01782">vecBoxNodeDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01568">vecLeafBoxOuterJacket()</a>, and <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00043">subpavings::MappedSPnodeVisitorExpand::visit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a91d46ee80958c0bed9fe972cf3cdea2d"></a><!-- doxytag: member="subpavings::SPnode::getSmallestLeafVol" ref="a91d46ee80958c0bed9fe972cf3cdea2d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPnode.shtml#a91d46ee80958c0bed9fe972cf3cdea2d">subpavings::SPnode::getSmallestLeafVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the volume of the leaf with the smallest volume. </p>
<p>Returns the volume of the smallest (by vol) leaf node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00757">757</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">nodeVolume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">double</span> smallestVol = 0.0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            smallestVol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>
            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49" title="Define type SPnodePtrs as container of pointers to SPnodes.">SPnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad3548bf27557e71e7254e211e95f1878" title="Return a reference to all descendent leaf nodes as SPnodes.">getSPnodeLeaves</a>(leaves);

            <span class="comment">// find the smallest child by volume</span>
            <a class="code" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6" title="Define type SPnodePtrsItr as an iterator over SPnodePtrs.">SPnodePtrsItr</a> it;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* smallest = *(leaves.begin());

            smallestVol = smallest-&gt;nodeVolume();

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;nodeVolume() &lt; smallestVol) {

                    smallestVol = (*it)-&gt;nodeVolume();
                }
            }
        } <span class="comment">// end else not a leaf</span>

        <span class="keywordflow">return</span> smallestVol;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad04e240d9152c1a927c2ec280aa29371"></a><!-- doxytag: member="subpavings::SPnode::getSplitDim" ref="ad04e240d9152c1a927c2ec280aa29371" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371">subpavings::SPnode::getSplitDim</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the split dimension for this. </p>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000014">Todo:</a></b></dt><dd>We could just keep the splitDim for all spnode types. But then we'd have to adjust this when nodes were marginalised etc. but this is expensive ... See RealMappedSPnodeSingleRange etc as well </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab374777116b7e0af8e7100f303e1f97b">subpavings::CollatorSPnode</a>, and <a class="el" href="classsubpavings_1_1SPSnode.shtml#afe262ee997e6ac57a15193a7d585f0ac">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00515">515</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01043">nodeContains()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> splitDim = -1;  
  
  <span class="keywordflow">if</span> ( !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
  
    ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
    <span class="keywordtype">int</span> dim = VecLen(box);
    <span class="keywordtype">int</span> boxLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
    
    ivector boxChild;
    
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) boxChild = <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) boxChild = <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
    <span class="keywordflow">else</span> <span class="keywordflow">throw</span> std::logic_error(
      <span class="stringliteral">&quot;SPnode::getSplitDim() :Cannot find split dimension&quot;</span>);            
    
    <span class="keywordtype">int</span> index = 0;
    <span class="keywordtype">int</span> boxChildLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(boxChild);
    <span class="keywordflow">while</span> (splitDim &lt; 1 &amp;&amp; index &lt; dim) {
      <span class="keywordflow">if</span> ((Inf(box[boxLB + index]) 
          != Inf(boxChild[boxChildLB + index]))
        ||
        (Sup(box[boxLB + index]) != 
          Sup(boxChild[boxChildLB + index]))) {
            <span class="comment">// found splitDim</span>
            splitDim = boxLB + index;
      }
      index ++;
    } <span class="comment">// end while</span>
    
    <span class="keywordflow">if</span> (splitDim &lt; 0) {
      <span class="keywordflow">throw</span> std::logic_error(
      <span class="stringliteral">&quot;SPnode::getSplitDim() :Cannot find split dimension&quot;</span>);
    }
  } <span class="comment">// end !isLeaf</span>
            
  <span class="keywordflow">return</span> splitDim;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad3548bf27557e71e7254e211e95f1878"></a><!-- doxytag: member="subpavings::SPnode::getSPnodeLeaves" ref="ad3548bf27557e71e7254e211e95f1878" args="(SPnodePtrs &amp;leaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49">SPnodePtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#ad3548bf27557e71e7254e211e95f1878">subpavings::SPnode::getSPnodeLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49">SPnodePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to all descendent leaf nodes as SPnodes. </p>
<p>Will be just this if this is a leaf.</p>
<p>When this function is inherited in derived classes it will return the leaf nodes of a tree of the derived class nodes as plain SPnodes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of node pointers. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00560">560</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00730">getDepth()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00789">getLargestLeafVol()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00757">getSmallestLeafVol()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad3548bf27557e71e7254e211e95f1878" title="Return a reference to all descendent leaf nodes as SPnodes.">getSPnodeLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad3548bf27557e71e7254e211e95f1878" title="Return a reference to all descendent leaf nodes as SPnodes.">getSPnodeLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
            leaves.push_back(const_cast&lt;SPnode*&gt;(<span class="keyword">this</span>));
        }
        <span class="keywordflow">return</span> leaves;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a91a9483f923c30474b817c26ec8afbad"></a><!-- doxytag: member="subpavings::SPnode::hasLCwithBox" ref="a91a9483f923c30474b817c26ec8afbad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad">subpavings::SPnode::hasLCwithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if this has a non-empty left child. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00483">483</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01288">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarAdd()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01343">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarDiv()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01325">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarMult()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01306">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarSubtract()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">subpavings::MappedSPnode&lt; cxsc::real &gt;::allocateRanges()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01048">subpavings::SPSnode::checkTreeStateLegal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">subpavings::RealMappedSPnode::findContainingNode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">subpavings::SPSVnode::gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">subpavings::SPSnode::gatherData()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">subpavings::CollatorSPVnode::getAllNodes()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">subpavings::CollatorSPnode::getAllNodes()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01123">subpavings::SPSVnode::getAllNodes()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01348">subpavings::SPSnode::getAllNodes()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">subpavings::RealMappedSPnode::getConstLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00582">getConstSPnodeLeaves()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00603">getLeafNodeVolumes()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00911">subpavings::CollatorSPVnode::getLeaves()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01440">subpavings::CollatorSPnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">subpavings::RealMappedSPnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00493">getNumberLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">getSplitDim()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01103">subpavings::SPSVnode::getSubLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">subpavings::SPSnode::getSubLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00443">isSubLeaf()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">subpavings::CollatorSPVnode::nodeNegate()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">subpavings::SPSVnode::nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">subpavings::SPSnode::nodeReabsorbChildren()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">subpavings::CollatorSPVnode::nodesReunite()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00118">normHeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">subpavings::RealMappedSPnode::oneLineOutput()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">subpavings::MappedSPnode&lt; cxsc::real &gt;::oneLineOutput()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">spContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02613">subpavings::SPSnode::spsContains()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">subpavings::CollatorSPnode::totaliseSummaries()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>.</p>
<div class="fragment"><pre class="fragment">    {<span class="keywordflow">return</span> ( (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>!=NULL) &amp;&amp; ((<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>)!=NULL)); }
</pre></div>
</div>
</div>
<a class="anchor" id="a0b8af2e1f907279d8a153129aa37aa8e"></a><!-- doxytag: member="subpavings::SPnode::hasLeafSibling" ref="a0b8af2e1f907279d8a153129aa37aa8e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e">subpavings::SPnode::hasLeafSibling</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if this has a leaf sibling. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00838">838</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00396">getParent()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">subpavings::AdaptiveHistogram::decisionMCMCSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">subpavings::AdaptiveHistogram::mergeUp()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> != NULL) {
            <span class="comment">// check the final letter on my name</span>
            std::string mySide = <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.substr(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.length()-1);

            <span class="comment">// siblings cannot be assumed to exist</span>
            <span class="keywordflow">if</span>((mySide == <span class="stringliteral">&quot;R&quot;</span> &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                    &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>())
                ||
                (mySide == <span class="stringliteral">&quot;L&quot;</span> &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()
                    &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>())) {

                retValue = <span class="keyword">true</span>;
            }
        }
        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8127bcccc0023f632307c22f685196aa"></a><!-- doxytag: member="subpavings::SPnode::hasRCwithBox" ref="a8127bcccc0023f632307c22f685196aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa">subpavings::SPnode::hasRCwithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if this has a non-empty right child. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00487">487</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01288">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarAdd()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01343">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarDiv()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01325">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarMult()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01306">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarSubtract()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">subpavings::MappedSPnode&lt; cxsc::real &gt;::allocateRanges()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01048">subpavings::SPSnode::checkTreeStateLegal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">subpavings::RealMappedSPnode::findContainingNode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">subpavings::SPSVnode::gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">subpavings::SPSnode::gatherData()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">subpavings::CollatorSPVnode::getAllNodes()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">subpavings::CollatorSPnode::getAllNodes()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01123">subpavings::SPSVnode::getAllNodes()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01348">subpavings::SPSnode::getAllNodes()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">subpavings::RealMappedSPnode::getConstLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00582">getConstSPnodeLeaves()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00603">getLeafNodeVolumes()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00911">subpavings::CollatorSPVnode::getLeaves()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01440">subpavings::CollatorSPnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">subpavings::RealMappedSPnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00493">getNumberLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">getSplitDim()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01103">subpavings::SPSVnode::getSubLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">subpavings::SPSnode::getSubLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00443">isSubLeaf()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">subpavings::CollatorSPVnode::nodeNegate()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">subpavings::SPSVnode::nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">subpavings::SPSnode::nodeReabsorbChildren()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">subpavings::CollatorSPVnode::nodesReunite()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00118">normHeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">subpavings::RealMappedSPnode::oneLineOutput()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">subpavings::MappedSPnode&lt; cxsc::real &gt;::oneLineOutput()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">spContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02613">subpavings::SPSnode::spsContains()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">subpavings::CollatorSPnode::totaliseSummaries()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>.</p>
<div class="fragment"><pre class="fragment">    {<span class="keywordflow">return</span> ( (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>!=NULL) &amp;&amp;
        ((<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>)!=NULL)); }
</pre></div>
</div>
</div>
<a class="anchor" id="a42410c54c2a5cc045ec63b26fb6ae593"></a><!-- doxytag: member="subpavings::SPnode::isEmpty" ref="a42410c54c2a5cc045ec63b26fb6ae593" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593">subpavings::SPnode::isEmpty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if this <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is empty. </p>
<p>Can only check if an actual subpaving object is empty, not if it is null. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00475">475</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01180">subpavings::MappedSPnode&lt; cxsc::real &gt;::_addNonMinimalUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01263">subpavings::MappedSPnode&lt; cxsc::real &gt;::_divideNonMinimalUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01237">subpavings::MappedSPnode&lt; cxsc::real &gt;::_multiplyNonMinimalUnion()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00949">subpavings::RealMappedSPnode::_normalise()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00157">_reshapeToUnion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00629">subpavings::SPSnode::_reshapeToUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01288">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarAdd()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01343">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarDiv()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01325">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarMult()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01306">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarSubtract()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00731">subpavings::RealMappedSPnode::_start_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01211">subpavings::MappedSPnode&lt; cxsc::real &gt;::_subtractNonMinimalUnion()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">subpavings::RealMappedSPnode::findContainingNode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">subpavings::CollatorSPVnode::getAllNodes()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">subpavings::CollatorSPnode::getAllNodes()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01123">subpavings::SPSVnode::getAllNodes()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01348">subpavings::SPSnode::getAllNodes()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02543">subpavings::SPSnode::getEMPSumAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02519">subpavings::SPSnode::getEMPSumCOPERR()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00484">subpavings::RealMappedSPnode::getL1Distance()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00508">subpavings::RealMappedSPnode::getLogLikelihood()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">subpavings::CollatorSPVnode::getScheffeSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">subpavings::CollatorSPnode::getScheffeSet()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">subpavings::CollatorSPVnode::getYatSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">subpavings::CollatorSPnode::getYatSet()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">subpavings::SPSVnode::insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">subpavings::SPSnode::insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">subpavings::isEmpty()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">subpavings::CollatorSPVnode::leavesAbsAccumulationMultVol()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">subpavings::CollatorSPVnode::leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">subpavings::CollatorSPnode::leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">subpavings::CollatorSPVnode::leavesAverageOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">subpavings::CollatorSPnode::leavesAverageOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">subpavings::CollatorSPVnode::leavesDifferenceOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">subpavings::CollatorSPnode::leavesMakeNewFhat()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">subpavings::CollatorSPVnode::leavesOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">subpavings::CollatorSPnode::leavesOutputTabs()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01795">subpavings::SPSVnode::leavesOutputTabs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02403">subpavings::SPSnode::leavesOutputTabs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">subpavings::SPSnode::leavesOutputTabsWithEMPs()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01828">subpavings::SPSVnode::leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02466">subpavings::SPSnode::leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02488">subpavings::SPSnode::leavesOutputTabsWithHistHeightAndEMPs()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00465">nodeRealVolume()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00960">nodesAllOutput()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00118">normHeights()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00764">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator*=()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00617">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator+=()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00690">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator-=()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00842">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator/=()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01532">reshapeToUnion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02372">subpavings::SPSnode::reshapeToUnion()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">spContains()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00223">subpavings::SPSVnode::splitData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00223">subpavings::SPSnode::splitData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02613">subpavings::SPSnode::spsContains()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">subpavings::SPSnode::strippedConstructor()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00503">subpavings::SPSVnode::unionNoData()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00554">subpavings::SPSnode::unionNoData()</a>.</p>
<div class="fragment"><pre class="fragment">    {<span class="keywordflow">return</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>==NULL) ; }
</pre></div>
</div>
</div>
<a class="anchor" id="af5ad3b1f3ca82ba135c491e99c53eda7"></a><!-- doxytag: member="subpavings::SPnode::isLeaf" ref="af5ad3b1f3ca82ba135c491e99c53eda7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7">subpavings::SPnode::isLeaf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if this <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is a leaf. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00479">479</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01076">subpavings::MappedSPnode&lt; cxsc::real &gt;::_addRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01154">subpavings::MappedSPnode&lt; cxsc::real &gt;::_divRanges()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">subpavings::RealMappedSPnode::_getL1distance()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">subpavings::RealMappedSPnode::_getLogLikelihood()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">subpavings::CollatorSPnode::_marginalise()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01128">subpavings::MappedSPnode&lt; cxsc::real &gt;::_multRanges()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00157">_reshapeToUnion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00629">subpavings::SPSnode::_reshapeToUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01038">subpavings::MappedSPnode&lt; cxsc::real &gt;::_reshapeTreesToUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01102">subpavings::MappedSPnode&lt; cxsc::real &gt;::_subtractRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="auto__tools_8cpp_source.shtml#l00035">subpavings::checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">subpavings::AdaptiveHistogram::checkNodeCountForSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01048">subpavings::SPSnode::checkTreeStateLegal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">subpavings::CollatorSPnode::dotDiffPaving()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">subpavings::RealMappedSPnode::findContainingNode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">subpavings::SPSVnode::gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">subpavings::SPSnode::gatherData()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02169">subpavings::SPSnode::getBestSplitChangeEMPAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02134">subpavings::SPSnode::getBestSplitChangeEMPCOPERR()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">subpavings::RealMappedSPnode::getConstLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00582">getConstSPnodeLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00703">subpavings::RealMappedSPnode::getConstSubLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00730">getDepth()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02543">subpavings::SPSnode::getEMPSumAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02519">subpavings::SPSnode::getEMPSumCOPERR()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01207">subpavings::SPSVnode::getLargestLeafCount()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01454">subpavings::SPSnode::getLargestLeafCount()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00789">getLargestLeafVol()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">subpavings::RealMappedSPnode::getLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00392">subpavings::RealMappedSPnode::getMaxRangeForLeavesInTree()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01212">subpavings::SPSnode::getMinChildCountIfSplitNEW()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00493">getNumberLeaves()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">subpavings::CollatorSPVnode::getScheffeSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">subpavings::CollatorSPnode::getScheffeSet()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01175">subpavings::SPSVnode::getSmallestLeafCount()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01422">subpavings::SPSnode::getSmallestLeafCount()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00757">getSmallestLeafVol()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">getSplitDim()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01698">subpavings::CollatorSPnode::getSplitDim()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00680">subpavings::RealMappedSPnode::getSubLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01147">subpavings::SPSVnode::getSumLeafCountOverVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01394">subpavings::SPSnode::getSumLeafCountOverVol()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00595">subpavings::RealMappedSPnode::getTotalDotPrecisionAbsLeafAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00572">subpavings::RealMappedSPnode::getTotalDotPrecisionLeafAreaRangeWithBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">subpavings::CollatorSPVnode::getYatSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">subpavings::CollatorSPnode::getYatSet()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">subpavings::RealMappedSPnode::hasInfiniteRangeInTree()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00227">subpavings::RealMappedSPnode::hasNegativeRangeInTree()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">subpavings::SPSVnode::insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">subpavings::SPSnode::insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02192">subpavings::isLeaf()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00443">isSubLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">subpavings::CollatorSPVnode::leavesAbsAccumulationMultVol()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">subpavings::CollatorSPVnode::leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">subpavings::CollatorSPnode::leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">subpavings::CollatorSPVnode::leavesAverageOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">subpavings::CollatorSPnode::leavesAverageOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">subpavings::CollatorSPVnode::leavesDifferenceOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">subpavings::CollatorSPnode::leavesMakeNewFhat()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">subpavings::CollatorSPVnode::leavesOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">subpavings::CollatorSPnode::leavesOutputTabs()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01795">subpavings::SPSVnode::leavesOutputTabs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02403">subpavings::SPSnode::leavesOutputTabs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">subpavings::SPSnode::leavesOutputTabsWithEMPs()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01828">subpavings::SPSVnode::leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02466">subpavings::SPSnode::leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02488">subpavings::SPSnode::leavesOutputTabsWithHistHeightAndEMPs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">subpavings::AdaptiveHistogram::mergeUp()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">subpavings::RealMappedSPnode::nodeL1Distance()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">subpavings::CollatorSPnode::nodeReunite()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01377">nodeReunite()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01960">subpavings::SPSVnode::nodeReunite()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02925">subpavings::SPSnode::nodeReunite()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">subpavings::CollatorSPVnode::nodesReunite()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00411">setLabel()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">spContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02613">subpavings::SPSnode::spsContains()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00503">subpavings::SPSVnode::unionNoData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00554">subpavings::SPSnode::unionNoData()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01782">vecBoxNodeDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01568">vecLeafBoxOuterJacket()</a>.</p>
<div class="fragment"><pre class="fragment">    {<span class="keywordflow">return</span> ( (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>==NULL) &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>==NULL)); }
</pre></div>
</div>
</div>
<a class="anchor" id="ac3e8e3499bcb0acb42181b781d7796b3"></a><!-- doxytag: member="subpavings::SPnode::isSplittableNode" ref="ac3e8e3499bcb0acb42181b781d7796b3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">subpavings::SPnode::isSplittableNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return boolean to indicate if node is splittable.</p>
<p>A node is splittable if there is at least one value in the basic number screen between the inf and sup of the interval on the coordinate with maximum diameter (ie, the box can be split into two child boxes which will both be considered smaller than the parent box) <b>and</b> the node volume is &gt;= 2 * cxsc::MinReal (the smallest representable real number). </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00372">372</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00159">MaxDiamComp()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00285">realVolume()</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
    interval maxD = box[<a class="code" href="toolz_8cpp.shtml#af7098b26cfe9466d751176b29c67342c" title="Return the first dimension with maximal diameter.">MaxDiamComp</a>(box)];
    
    <span class="keywordflow">return</span> ( (succ(succ(Inf(maxD))) &lt;= Sup(maxD))
      &amp;&amp; (<a class="code" href="toolz_8cpp.shtml#acdd3d20a2f2c8114e1195f5e6baa078f" title="Return the volume of box x as a real.">realVolume</a>(box) &gt;= 2*cxsc::MinReal) );
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a079c914f2e19278844d934baad47fbfc"></a><!-- doxytag: member="subpavings::SPnode::isSubLeaf" ref="a079c914f2e19278844d934baad47fbfc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc">subpavings::SPnode::isSubLeaf</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find if this node is a subleaf node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00443">443</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02239">subpavings::SPSnode::getBestMergeChangeEMPAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02204">subpavings::SPSnode::getBestMergeChangeEMPCOPERR()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00703">subpavings::RealMappedSPnode::getConstSubLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01103">subpavings::SPSVnode::getSubLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00680">subpavings::RealMappedSPnode::getSubLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">subpavings::SPSnode::getSubLeaves()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// has two children</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                retValue = <span class="keyword">true</span>;
            }
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) { <span class="comment">// only has left child</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) retValue = <span class="keyword">true</span>;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// only has right child</span>
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) retValue = <span class="keyword">true</span>;
        }
        <span class="comment">// default return value false</span>

        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0f2381175b37224a185eedbe9601d814"></a><!-- doxytag: member="subpavings::SPnode::leafOutputTabs" ref="a0f2381175b37224a185eedbe9601d814" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814">subpavings::SPnode::leafOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data.</p>
<p>The format for an n-dimensional interval vector is:</p>
<p>label [tab] volume [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[n]) [tab] Sup(ivector[n] </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#a3cc0c8bb64c854ef16ba03891f5945d6">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aa35a5e2e8518004e8feefb3bdea98d53">subpavings::MappedSPnode&lt; T &gt;</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aa35a5e2e8518004e8feefb3bdea98d53">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a01b35db8ce4b99460ff352f6d25a529c">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab2e1cd11ef3dd4424cf491e529ed0fd8">subpavings::CollatorSPnode</a>, and <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a60e3798526abbe3db915b8a9a9d0aa19">subpavings::CollatorSPVnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00899">899</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">nodeVolume()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00960">nodesAllOutput()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            <span class="comment">// output the label, nodeVolume</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();

            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i]) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>
                    &lt;&lt; Sup(thisBox[i]);
            }

        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3663133a2c9f0fce79f3f551c1d163de"></a><!-- doxytag: member="subpavings::SPnode::leavesOutputTabs" ref="a3663133a2c9f0fce79f3f551c1d163de" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">subpavings::SPnode::leavesOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#abcac815b9e5e60a3d18fa3534a12c518">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ad54a1befc9cff87c02237caeabe84ea5">subpavings::CollatorSPnode</a>, and <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4">subpavings::CollatorSPVnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00923">923</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00899">leafOutputTabs()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>, and <a class="el" href="Ex1D_8cpp_source.shtml#l00021">output()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// uses  member function leafOutputTabs to generate node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs</a>(os);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">leavesOutputTabs</a>(os);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">leavesOutputTabs</a>(os);
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac0d9484691c21a316308b4713e6e8bba"></a><!-- doxytag: member="subpavings::SPnode::leavesOutputTabs" ref="ac0d9484691c21a316308b4713e6e8bba" args="(std::ostream &amp;os, int prec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">subpavings::SPnode::leavesOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#af432d9c3c95ad16f40274a0ab35948b8">subpavings::CollatorSPVnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00945">945</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00923">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  os &lt;&lt; cxsc::SaveOpt;
  os &lt;&lt; cxsc::Variable &lt;&lt; cxsc::SetPrecision(prec+2,prec);

  <a class="code" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">leavesOutputTabs</a>(os);
  os &lt;&lt; cxsc::RestoreOpt;
  
  <span class="keywordflow">return</span> os;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a28c48af012e0a5b96236dcf12ffbae93"></a><!-- doxytag: member="subpavings::SPnode::makeTreeFromLeaves" ref="a28c48af012e0a5b96236dcf12ffbae93" args="(ivector &amp;root, ImageList &amp;leafList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#a28c48af012e0a5b96236dcf12ffbae93">subpavings::SPnode::makeTreeFromLeaves</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a> &amp;&#160;</td>
          <td class="paramname"><em>leafList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forms a minimal <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> subpaving from leaf boxes. </p>
<p>Make a minimal subpaving tree from a list of interval vectors which are represented by leaves of the tree. The root of the subpaving tree will have Box = root, and the leaves in the list will be formable by a series of bisections of the given root.</p>
<p>MakeTreeFromLeaves is applied recursively on bisected halves of root and new lists there are no boxes in the list.</p>
<p>Uses <a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec" title="Tries to reunite two nodes into to form a single leaf.">Reunite()</a> and recursive calls to MakeTreeFromLeaves() to work upwards to form a minimal subpaving tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the tree. </td></tr>
    <tr><td class="paramname">leafList</td><td>a collection of non-overlapping interval vector leaves each of which can be formed by series of bisections of the given root. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a regular minimal subpaving with rootbox root. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02032">2032</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00188">SPnode()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00450">subpavings::volCompare()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01802">spLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01699">spLeafBoxIntersection()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01614">spLeafBoxOuterJacket()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* newNode = NULL;  <span class="comment">// for return value</span>

        <span class="keywordflow">if</span> (!leafList.empty())
        {
            <span class="comment">//sort using the volCompare function</span>
            leafList.sort(<a class="code" href="namespacesubpavings.shtml#a19b79319876fc25305936396f24e5a6c" title="A function for comparing ivectors based on volume.">volCompare</a>);   <span class="comment">// sorts smallest to largest</span>

            <span class="comment">// test if root is equal to the largest image element, ie the last</span>
            <span class="keywordtype">bool</span> isRootEqual = (root == *leafList.rbegin());

            <span class="keywordtype">double</span> smallestVol = <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(*leafList.begin());

            <span class="comment">//is root smaller than twice the size of the smallest box in it</span>
            <span class="keywordtype">bool</span> isRootSmall = (<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(root) &lt; 2*smallestVol);

            <span class="comment">// if the list has some images in it</span>
            <span class="comment">// and if the root is equal to the largest box in the list</span>
            <span class="comment">// or the root is close enough</span>
            <span class="comment">// return a new node based on root</span>
            <span class="keywordflow">if</span> (isRootEqual || isRootSmall) {

                <span class="keywordflow">try</span> {
                    newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(root);
                }
                <span class="keywordflow">catch</span> (bad_alloc&amp;)
                {
                    std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot;in makeTreeFromVoxels(...)&quot;</span> &lt;&lt; std::endl;
                    <span class="keywordflow">throw</span>;
                }
            }
            <span class="comment">// if the list has some images in it</span>
            <span class="comment">// and the root is not equal to the largest box in the list</span>
            <span class="comment">// and the root is not small</span>
            <span class="comment">// bisect the root, divide up the list, and recurse</span>

            <span class="keywordflow">if</span> (!isRootEqual &amp;&amp; !isRootSmall) {

                <span class="keywordtype">int</span> maxdiamcomp = 0;
                <span class="keywordtype">double</span> rootDiam = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(root, maxdiamcomp);
                <span class="comment">// new ivectors from splitting root along its biggest dimension</span>
                ivector leftbox = <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(root, maxdiamcomp);
                ivector rightbox = <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(root, maxdiamcomp);

                <span class="comment">// create two empty lists for the left and right side</span>
                <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> leftlist, rightlist;

                <a class="code" href="namespacesubpavings.shtml#a8553bcc272ba9d0b7b9b6bd991b3bc00" title="Define type iterator over ImageList.">ImageListItr</a> it; <span class="comment">// iterator to for the list</span>

                <span class="comment">// iterate through the current list, put the intersection of any</span>
                <span class="comment">// element with the leftbox into new left list, &amp; intersection</span>
                <span class="comment">// of any element with the new right box into new right list</span>
                <span class="comment">// but only put in whole leaves, ie with vol &gt;= smallest vol</span>
                <span class="keywordflow">for</span> (it=leafList.begin(); it!=leafList.end(); it++) {
                    ivector interLeft;  <span class="comment">// intersection with left hull</span>
                    ivector interRight;  <span class="comment">// intersection with right hull</span>

                    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interLeft, *it, leftbox)) {
                        <span class="keywordflow">if</span> (<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(interLeft) &gt; 0.5*smallestVol)
                            leftlist.push_back(interLeft);
                    }

                    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interRight, *it, rightbox)) {
                        <span class="keywordflow">if</span> (<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(interRight) &gt; 0.5*smallestVol)
                            rightlist.push_back(interRight);
                    }

                } <span class="comment">// end of iteration through list elements</span>

                <span class="comment">// recursively call makeTreeFromLeaves with leftbox, leftlist</span>
                <span class="comment">// and rightbox, rightlist</span>
                <span class="comment">// reunite the results using root as the box for parent node</span>
                <span class="comment">// makeTreeFromLeavess creates a minimal subpaving</span>
                <span class="comment">// (no sibling child nodes) on the root</span>

                newNode = Reunite&lt;SPnode&gt;(<a class="code" href="classsubpavings_1_1SPnode.shtml#a28c48af012e0a5b96236dcf12ffbae93" title="Forms a minimal SPnode subpaving from leaf boxes.">makeTreeFromLeaves</a>(leftbox,leftlist),
                                    <a class="code" href="classsubpavings_1_1SPnode.shtml#a28c48af012e0a5b96236dcf12ffbae93" title="Forms a minimal SPnode subpaving from leaf boxes.">makeTreeFromLeaves</a>(rightbox, rightlist),
                                                                root);

            } <span class="comment">// end of is list has elements and first box not root</span>
        }

        <span class="comment">// if there is nothing in the list we return the default</span>
            <span class="comment">// initialisation value of NULL</span>

        <span class="keywordflow">return</span> newNode;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4e11f6bd7a176b33a25f3700751c4a08"></a><!-- doxytag: member="subpavings::SPnode::makeTreeFromVoxels" ref="a4e11f6bd7a176b33a25f3700751c4a08" args="(ivector &amp;root, ImageList &amp;leafList, double spacing, size_t dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#a4e11f6bd7a176b33a25f3700751c4a08">subpavings::SPnode::makeTreeFromVoxels</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a> &amp;&#160;</td>
          <td class="paramname"><em>leafList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forms a minimal <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> subpaving from voxel boxes. </p>
<p>Make a minimal subpaving tree from a list of interval vectors which approximate the leaves of the tree. The root of the subpaving tree will have Box = root, and the leaves in the list will have the same width in each dimension and be formable by a series of bisections of the given root. i.e. each leaf will be the same size as each other leaf and will be a equal-sided hypercube.</p>
<p>MakeTreeFromVoxels is applied recursively on bisected halves of root and new lists until either there are no boxes in the list or the largest diameter of the root the smallest we would expect given spacing or the root is equal to the largest box in the list.</p>
<p>Uses <a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec" title="Tries to reunite two nodes into to form a single leaf.">Reunite()</a> and recursive calls to MakeTreeFromVoxels() to work upwards to form a minimal subpaving tree</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>the root of the tree. </td></tr>
    <tr><td class="paramname">leafList</td><td>a collection of non-overlapping interval vector leaves each of which is approximately the same as the boxes formed by series of bisections of the given root. </td></tr>
    <tr><td class="paramname">spacing</td><td>is the spacing from the voxel data, ie the number of voxels in any dimension (assumed to be the same for all dimensions). </td></tr>
    <tr><td class="paramname">dim</td><td>is the number of dimensions we are using. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a regular minimal subpaving with rootbox root. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01851">1851</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00188">SPnode()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00450">subpavings::volCompare()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01957">vtkPaving()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* newNode = NULL;  <span class="comment">// for return value</span>

        <span class="keywordflow">if</span> (!leafList.empty())
        {
            <span class="comment">//sort using the volCompare function</span>
            leafList.sort(<a class="code" href="namespacesubpavings.shtml#a19b79319876fc25305936396f24e5a6c" title="A function for comparing ivectors based on volume.">volCompare</a>);   <span class="comment">// sorts smallest to largest</span>

           <span class="comment">// test if root is equal to the largest image element, ie the last</span>
            <span class="keywordtype">bool</span> isRootEqual = (root == *leafList.rbegin());

            <span class="comment">// with given spacing, max width in any should be 1/spacing</span>
            <span class="comment">// so as soon as max root dimension is below 2/spacing, it should</span>
            <span class="comment">// be in the subpaving if it has any image data in it</span>
            <span class="comment">// so be conservative and take 1.5/spacing (between 1/ and 2/)</span>
            <span class="keywordtype">double</span> eps = 1.5/spacing;
            <span class="keywordtype">int</span> maxdiamcomp = 0;  <span class="comment">// to take value calculated from MaxDiam</span>
            <span class="comment">// find the maximum diameter, put the max dimension into maxdiamcomp</span>
            <span class="keywordtype">double</span> maxDiamRoot = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(root, maxdiamcomp);

            <span class="comment">// test if maximum root width is smaller than eps</span>
            <span class="keywordtype">bool</span> isRootSmall = (maxDiamRoot &lt; eps);

            <span class="comment">// if the list has some images in it</span>
            <span class="comment">// and either if the root is equal to the largest box in the list</span>
            <span class="comment">// or if the root max diameter is &lt; eps</span>
            <span class="comment">// return a new node based on root</span>
            <span class="keywordflow">if</span> (isRootEqual || isRootSmall) {

               <span class="keywordflow">try</span> {
                    newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(root);
               }
                <span class="keywordflow">catch</span> (bad_alloc&amp;)
                {
                    std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot;in makeTreeFromVoxels(...)&quot;</span> &lt;&lt; std::endl;
                    <span class="keywordflow">throw</span>;
                }
            }
            <span class="comment">// if the list has some images in it</span>
            <span class="comment">// and the root is not equal to the largest box in the list</span>
            <span class="comment">// and the root is not small</span>
            <span class="comment">// bisect the root, divide up the list, and recurse</span>
            <span class="keywordflow">else</span> {

                <span class="comment">// new ivectors from splitting root along its biggest dimension</span>
                ivector leftbox = <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(root, maxdiamcomp);
                ivector rightbox = <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(root, maxdiamcomp);

                <span class="comment">// create two empty lists for the left and right side</span>
                <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> leftlist, rightlist;

                <a class="code" href="namespacesubpavings.shtml#a8553bcc272ba9d0b7b9b6bd991b3bc00" title="Define type iterator over ImageList.">ImageListItr</a> it; <span class="comment">// iterator to for the list</span>

                <span class="comment">// find a conservative minimum expected volume for a leaf as</span>
                <span class="comment">// half of the product of 1/spacing over all dimensions</span>
                <span class="comment">// we expect leaves to be the result of successive bisections so</span>
                <span class="comment">// if the volume of the intersection is not what we expect</span>
                <span class="comment">// then the intersection will be just the boundary</span>
                real minVol = 0.5;
                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; dim; i++) minVol /= spacing;

                <span class="comment">// iterate through the current list, put the intersection of any</span>
                <span class="comment">// element with the leftbox into new left list, &amp; intersection</span>
                <span class="comment">// of any element with the new right box into new right list</span>
                <span class="keywordflow">for</span> (it=leafList.begin(); it!=leafList.end(); it++) {
                    ivector interLeft;  <span class="comment">// intersection with left hull</span>
                    ivector interRight;  <span class="comment">// intersection with right hull</span>

                    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interLeft, *it, leftbox)) {
                        <span class="keywordflow">if</span> (<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(interLeft) &gt; minVol)
                            leftlist.push_back(interLeft);
                    }

                    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interRight, *it, rightbox)) {
                        <span class="keywordflow">if</span> (<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(interRight) &gt; minVol)
                            rightlist.push_back(interRight);
                    }

                } <span class="comment">// end of iteration through list elements</span>

                <span class="comment">// recursively call makeTreeFromVoxels with leftbox, leftlist</span>
                <span class="comment">// and rightbox, rightlist</span>
                <span class="comment">// reunite the results using root as the box for parent node</span>
                <span class="comment">// makeTreeFromVoxels creates a minimal subpaving</span>
                <span class="comment">// (no sibling child nodes) on the root</span>

                newNode = Reunite&lt;SPnode&gt;(<a class="code" href="classsubpavings_1_1SPnode.shtml#a4e11f6bd7a176b33a25f3700751c4a08" title="Forms a minimal SPnode subpaving from voxel boxes.">makeTreeFromVoxels</a>(leftbox,
                                                leftlist, spacing, dim),
                                    <a class="code" href="classsubpavings_1_1SPnode.shtml#a4e11f6bd7a176b33a25f3700751c4a08" title="Forms a minimal SPnode subpaving from voxel boxes.">makeTreeFromVoxels</a>(rightbox,
                                                rightlist, spacing, dim), root);

            } <span class="comment">// end of is list has elements and first box does not contain root</span>
        }

        <span class="comment">// if there is nothing in the list we return the default</span>
            <span class="comment">// initialisation value of NULL</span>

        <span class="keywordflow">return</span> newNode;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7124dae3fa53ae2d0061deebe9787d7f"></a><!-- doxytag: member="subpavings::SPnode::nodeAddLeft" ref="a7124dae3fa53ae2d0061deebe9787d7f" args="(SPnode *lChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f">subpavings::SPnode::nodeAddLeft</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a tree downwards. </p>
<p>Adds a left node on to this as leftChild. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01411">1411</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00827">subpavings::CollatorSPnode::nodeAdoptLeft()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00958">subpavings::CollatorSPVnode::nodeAdoptLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01473">nodeAdoptLeft()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02036">subpavings::SPSVnode::nodeAdoptLeft()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03000">subpavings::SPSnode::nodeAdoptLeft()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">subpavings::SPSnode::SPSnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00960">subpavings::SPSnode::strippedConstructor()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// check that the labels match and exit if not</span>
        <span class="keywordflow">if</span> (lChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>) {
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Labels on boxes do not match&quot;</span>);

        }

        <span class="comment">// check  box for this is union of boxes of proposed children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Cannot adopt left with existing left child&quot;</span>);

        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <span class="comment">// check that this new box fits with the current box</span>
            <span class="keywordflow">if</span> (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> !=
                (*(lChild-&gt;theBox) | *(<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>))) {
                    <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Child boxes do not fit together&quot;</span>);
            }

        }

        this-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = lChild;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab826f2bf3a9c492c61ca260c16d99c26"></a><!-- doxytag: member="subpavings::SPnode::nodeAddRight" ref="ab826f2bf3a9c492c61ca260c16d99c26" args="(SPnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26">subpavings::SPnode::nodeAddRight</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a tree downwards. </p>
<p>Adds a right node onto this as rightChild. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01440">1440</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00872">subpavings::CollatorSPnode::nodeAdoptRight()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01003">subpavings::CollatorSPVnode::nodeAdoptRight()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01486">nodeAdoptRight()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02085">subpavings::SPSVnode::nodeAdoptRight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03048">subpavings::SPSnode::nodeAdoptRight()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">subpavings::SPSnode::SPSnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00960">subpavings::SPSnode::strippedConstructor()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// check that the labels match and exit if not</span>
        <span class="keywordflow">if</span> (rChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>) {
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Box labels do not match&quot;</span>);

        }

        <span class="comment">// check  box for this is union of boxes of proposed children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Cannot adopt right with existing right child&quot;</span>);

        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <span class="comment">// check that this new box fits with the current box</span>
            <span class="keywordflow">if</span> (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> !=
                (*(rChild-&gt;theBox) | *(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>))) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Child boxes do not fit together&quot;</span>);
            }

        }

        this-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = rChild;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a42b4b4686ea981149fd7b25a9d720c16"></a><!-- doxytag: member="subpavings::SPnode::nodeAdoptLeft" ref="a42b4b4686ea981149fd7b25a9d720c16" args="(SPnode *lChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a42b4b4686ea981149fd7b25a9d720c16">subpavings::SPnode::nodeAdoptLeft</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a left child rather than attempting. to reunite two children into this. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01473">1473</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01377">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddLeft() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(lChild);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a43d542d7c5227d52dfb7b5de97d2b676"></a><!-- doxytag: member="subpavings::SPnode::nodeAdoptRight" ref="a43d542d7c5227d52dfb7b5de97d2b676" args="(SPnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a43d542d7c5227d52dfb7b5de97d2b676">subpavings::SPnode::nodeAdoptRight</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a right child rather than attempting. to reunite two children into this. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01486">1486</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01377">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddRight() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(rChild);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aaefe6100d8c62dc84849cd2adb733ffb"></a><!-- doxytag: member="subpavings::SPnode::nodeContains" ref="aaefe6100d8c62dc84849cd2adb733ffb" args="(const rvector &amp;p, OPERATIONS_ON childInd=ON_PARENT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#aaefe6100d8c62dc84849cd2adb733ffb">subpavings::SPnode::nodeContains</a> </td>
          <td>(</td>
          <td class="paramtype">const rvector &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a>&#160;</td>
          <td class="paramname"><em>childInd</em> = <code><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the box a node represents contains a datapoint p. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the value of the data point being tested for containment in the box represented by this node. </td></tr>
    <tr><td class="paramname">childInd</td><td>indicates whether this should be considered to be a left child or a right child (ie where we need to take splitting dimension and value into account) or as a parent node (default).</td></tr>
  </table>
  </dd>
</dl>
<p>If a node is being considered as a child node (ie childInd is ON_RIGHT or ON_LEFT) and actaully has a parent node, then is is assumed that the data point would have been in the box associated with the parent node, and the question now is just whether it falls into the left or right child. Thus no test for full containment of the data point in the box is carried out, and this method just checks whether the data point would have fallen from the parent into the left or right child.</p>
<p>If childInd is ON_PARENT, or if the node has no parent node, then the method checks for full containment of the data point within the box associated with this node.</p>
<p>Note that the interval on the parent's split dimension of the right child's box is closed at the split value and the interval of the left child's box is open. A datapoint whose element in the split dimension is exactly the split value should be assessed to be in the right child's box but not the left child's box. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#a918067afb150c053f7450fd18c6ecd22">subpavings::SPSnode</a>, and <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a803d11f31d86f0565dbe682a33099698">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01043">1043</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00396">getParent()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">getSplitDim()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_RIGHT</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">subpavings::RealMappedSPnode::findContainingNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
  
  <span class="comment">// only check for total containment if this is a parent node</span>
  <span class="comment">// or to be treated as such</span>
  <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) || (childInd == <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>)) {
  
    <span class="comment">// cast p to an ivector</span>
    ivector pvec = _ivector(p);
  
    <span class="comment">//find if p is in the box</span>
    <span class="keywordflow">if</span> (pvec &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) {
      retValue = <span class="keyword">true</span>;
    }
  }
  <span class="comment">// if not to be treated as a whole box, we assume it was in the parent</span>
  <span class="comment">// and only check ourselves with respect to the split dimension</span>
  <span class="comment">// and if this is a right child it can be anywhere </span>
  <span class="comment">// but  this is a left child,</span>
  <span class="comment">// we need to check the split</span>
  <span class="comment">// find what dimension the parent was split on and what</span>
  <span class="comment">// the split value was</span>
  <span class="comment">// pvector must be strictly less than parentSplitValue</span>
  <span class="comment">// on the split dimension</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> != NULL) { <span class="comment">// truly not a parent node</span>
  
    <span class="keywordtype">int</span> parentSplitDim = (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef" title="Accessor for the parent of a node.">getParent</a>())-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371" title="Get the split dimension for this.">getSplitDim</a>();
    
    <span class="keywordflow">if</span> (childInd == <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>) { 
      retValue = (p[parentSplitDim] &lt; Sup(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()[parentSplitDim]));
    }
    <span class="keywordflow">if</span> (childInd == <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>) { 
      retValue = !(p[parentSplitDim] &lt; Inf(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()[parentSplitDim]));
    }
  }
  
  <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac27ee8ea1399ed0121ed970c8fd51543"></a><!-- doxytag: member="subpavings::SPnode::nodeExpand" ref="ac27ee8ea1399ed0121ed970c8fd51543" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">subpavings::SPnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to make two leaves as children. </p>
<p>Equivalent to bisecting a box in a regular subpaving. Makes two new sibling child nodes of this one and grafts them on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>is the dimension on which to bisect theBox. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf0575b58b84a0910a8d5b67b6ec0f48">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a817b05cc2d60ff0ee1a98b0addf54131">subpavings::MappedSPnode&lt; T &gt;</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a817b05cc2d60ff0ee1a98b0addf54131">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>, <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae6555e847a720e43c07ad0c56788f9b6">subpavings::CollatorSPVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#af0789230e2a9612f9b0644113e318f37">subpavings::CollatorSPnode</a>, and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4d0129dda149a950a06e9d2e3ff802c4">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01305">1305</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">setNodeName()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00188">SPnode()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">subpavings::Expand()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00335">subpavings::ExpandWithValid()</a>, <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00107">subpavings::MappedSPnodeVisitorExpand::priorityVisit()</a>, and <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00043">subpavings::MappedSPnodeVisitorExpand::visit()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span>
        {
            <span class="comment">// only do something if this SPnode is a leaf</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {

                <span class="comment">// ivectors to be new boxes for new children</span>
                ivector lC, rC;

                <span class="comment">// Call Lower() and Upper() to put split boxes</span>
                <span class="comment">// into lC and rC respectively</span>
                <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lC, comp);
                <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rC, comp);

                <span class="comment">// make children and make this their parent</span>
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(lC, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(rC, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;

                <span class="comment">//name the new children</span>
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);

            }
        }

        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {

            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;in SPnode::nodeExpand()&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0540c55967e7f35843fac029b450ab55"></a><!-- doxytag: member="subpavings::SPnode::nodeExpand" ref="a0540c55967e7f35843fac029b450ab55" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">subpavings::SPnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to have two children and pass data down to the children with no further splitting. </p>
<p>Finds the splitting dimension and then uses <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543" title="Expand a leaf node to make two leaves as children.">nodeExpand(int comp)</a> to split. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#ae432186483a5ec950dab0eb00b08a9bc">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0eb85efd74fa770f3259d6ba948b65b8">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a26af7ee7d7e9c00623dea9e6aed02d92">subpavings::MappedSPnode&lt; T &gt;</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a26af7ee7d7e9c00623dea9e6aed02d92">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>, <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a43e370d7120f8cc8c1cde489f61e7fc5">subpavings::CollatorSPVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ad54fcce3c5c904f7ecf0f5042515e1a5">subpavings::CollatorSPnode</a>, and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ad60865bacd8a43978cf2da02419cbf8f">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01344">1344</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01354">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55" title="Expand a leaf node to have two children and pass data down to the children with no further splitting...">nodeExpand</a>(maxdiamcomp); <span class="comment">// complete nodeExpand</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3b16d632897f3a4fb11f36db1e9004bf"></a><!-- doxytag: member="subpavings::SPnode::nodeExpand" ref="a3b16d632897f3a4fb11f36db1e9004bf" args="(bool boolVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">subpavings::SPnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boolVal</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to make two leaves as children. </p>
<p>Has parameter boolVal for validation data (ingeritance polymorphism) </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a4846c8d9c7d29d0f0850a7a9c30eec2b">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01354">1354</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01344">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55" title="Expand a leaf node to have two children and pass data down to the children with no further splitting...">nodeExpand</a>(maxdiamcomp);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aaf14185437d50e955c5ea938dc6e7559"></a><!-- doxytag: member="subpavings::SPnode::nodePrint" ref="aaf14185437d50e955c5ea938dc6e7559" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#aaf14185437d50e955c5ea938dc6e7559">subpavings::SPnode::nodePrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output details of a specific node in a tree. </p>
<p>This is intended for console output or output to a mixed alpha and numeric file. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#aba02715cb75f803df7c3ffd1eaf027e8">subpavings::SPSnode</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a798b65086b8c8042522fc317e73247a7">subpavings::MappedSPnode&lt; T &gt;</a>, <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a798b65086b8c8042522fc317e73247a7">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>, <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a51715ef7b6e370006e914fee15061cfc">subpavings::SPSVnode</a>, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab58b8d4c3a8a879930da943dbe2dd62d">subpavings::CollatorSPnode</a>, and <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a782737eae50163bbae2dc9c4b5e23aec">subpavings::CollatorSPVnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00877">877</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l02155">subpavings::operator&lt;&lt;()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="comment">// output in form: box</span>

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
                os &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(thisBox[i]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>
                    &lt;&lt; Sup(thisBox[i]) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span>;
                <span class="keywordflow">if</span> (i &lt; <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ) {
                    os &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>;
                }
            }
            os &lt;&lt; std::endl;
        }
        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab92c1accdfd155898e63e26a112b8e36"></a><!-- doxytag: member="subpavings::SPnode::nodeReabsorbChildren" ref="ab92c1accdfd155898e63e26a112b8e36" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#ab92c1accdfd155898e63e26a112b8e36">subpavings::SPnode::nodeReabsorbChildren</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reabsorbs both children of the node. </p>
<p>Effectively cancels any split of the node. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2">subpavings::SPSnode</a>, and <a class="el" href="classsubpavings_1_1SPSVnode.shtml#aed19a06dc479c2edc865243d2c131c30">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01363">1363</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>.</p>

<p>Referenced by <a class="el" href="MappedSPTesting__Framework_8hpp_source.shtml#l00030">mappedAdditionTest()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>;
        <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad219abf12ef0e39222748004e1ff1347"></a><!-- doxytag: member="subpavings::SPnode::nodeRealVolume" ref="ad219abf12ef0e39222748004e1ff1347" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347">subpavings::SPnode::nodeRealVolume</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if theBox is NULL. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the volume of the box associated with the node. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!isEmpty(). </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00465">465</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00285">realVolume()</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00551">subpavings::RealMappedSPnode::getDotPrecisionAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00543">subpavings::RealMappedSPnode::getRealAreaRangeWithBox()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01005">subpavings::MappedSPnode&lt; cxsc::real &gt;::leafOutputTabs()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">subpavings::RealMappedSPnode::nodeL1Distance()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00108">subpavings::RealMappedSPnode::RealMappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">  { 
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() ) {
      <span class="keywordflow">throw</span> NoBox_Error(<span class="stringliteral">&quot;SPnode::nodeRealVolume()&quot;</span>);
    }
    <span class="keywordflow">return</span> <a class="code" href="toolz_8cpp.shtml#acdd3d20a2f2c8114e1195f5e6baa078f" title="Return the volume of box x as a real.">realVolume</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()); 
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a56e03a33b576732f09a12d8b25c48acc"></a><!-- doxytag: member="subpavings::SPnode::nodeReunite" ref="a56e03a33b576732f09a12d8b25c48acc" args="(SPnode *lChild, SPnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a56e03a33b576732f09a12d8b25c48acc">subpavings::SPnode::nodeReunite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to reunite nodes. </p>
<p>Note that the nodes provided, lChild and rChild, are not the actual children of this, they are potential children which we are trying to either totally bring into this (if there are two of them) or to graft onto this if there is only one of them. This is typically a new, part-formed node whose formation can be completed by reuniting already two already-formed nodes into it or by adding on one child if only one is available. nodeReunite is used in building a tree upwards (rather than in pruning leaves of formed tree from the bottom up).</p>
<p>If two potential children are provided and they are both leaves, it combines the two leaf siblings into this. If the potential children are not leaves or if only one potential child is provided, it grafts the potential child/children onto this as its child/children. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01377">1377</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>, <a class="el" href="spnode_8cpp_source.shtml#l01473">nodeAdoptLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01486">nodeAdoptRight()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// check that the labels match and exit if not</span>
        <span class="keywordflow">if</span> ((lChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> ) || (rChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>)) {
             <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Box labels do not match&quot;</span>);
        }

        <span class="comment">// if both subpavings are leaves and hull of boxes is x,</span>
        <span class="comment">// discard them: *this is a leaf</span>
        <span class="keywordflow">if</span> (lChild-&gt;isLeaf() &amp;&amp; rChild-&gt;isLeaf()) {
            <span class="keywordflow">if</span> (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> !=
                (*(lChild-&gt;theBox) | *(rChild-&gt;theBox))) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes to reunite not = this box&quot;</span>);
            }

            <span class="comment">//discard the two subpavings given</span>
            <span class="keyword">delete</span> lChild;
            <span class="keyword">delete</span> rChild;

        }

        <span class="keywordflow">else</span> {  <span class="comment">// at least one of the children is not a leaf</span>
            <span class="comment">// this has to adopt them rather than reuniting them</span>
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a42b4b4686ea981149fd7b25a9d720c16" title="Builds a higher level of a tree from existing nodes.">nodeAdoptLeft</a>(lChild);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a43d542d7c5227d52dfb7b5de97d2b676" title="Builds a higher level of a tree from existing nodes.">nodeAdoptRight</a>(rChild);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>(); <span class="comment">// recursively rename child branches</span>
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab75be88517039e1b426333dbc3764f10"></a><!-- doxytag: member="subpavings::SPnode::nodesAllOutput" ref="ab75be88517039e1b426333dbc3764f10" args="(std::ostream &amp;os, int level) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#ab75be88517039e1b426333dbc3764f10">subpavings::SPnode::nodesAllOutput</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00960">960</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00899">leafOutputTabs()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00960">nodesAllOutput()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00960">nodesAllOutput()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01955">subpavings::operator&lt;&lt;()</a>, and <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01423">outputAllNodesToTxtTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs</a>(os);
            os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
        }

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; level; i++) {
                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
            }
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ab75be88517039e1b426333dbc3764f10">nodesAllOutput</a>(os, (level+1));
        }

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; level; i++) {
                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
            }
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ab75be88517039e1b426333dbc3764f10">nodesAllOutput</a>(os, (level+1));
        }

        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7408768856a7c988d9784b6172d74310"></a><!-- doxytag: member="subpavings::SPnode::nodesAllOutput" ref="a7408768856a7c988d9784b6172d74310" args="(std::ostream &amp;os, int level, int prec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#ab75be88517039e1b426333dbc3764f10">subpavings::SPnode::nodesAllOutput</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00991">991</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00960">nodesAllOutput()</a>.</p>
<div class="fragment"><pre class="fragment">{
  os &lt;&lt; cxsc::SaveOpt;
  os &lt;&lt; cxsc::Variable &lt;&lt; cxsc::SetPrecision(prec+2,prec);

  <a class="code" href="classsubpavings_1_1SPnode.shtml#ab75be88517039e1b426333dbc3764f10">nodesAllOutput</a>(os, level);
  os &lt;&lt; cxsc::RestoreOpt;
  
  <span class="keywordflow">return</span> os;

}
</pre></div>
</div>
</div>
<a class="anchor" id="ab8a45c1ea71b3c1e90f0fd9bd23562eb"></a><!-- doxytag: member="subpavings::SPnode::nodeVolume" ref="ab8a45c1ea71b3c1e90f0fd9bd23562eb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb">subpavings::SPnode::nodeVolume</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the volume of the box as a double. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00437">437</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">subpavings::AdaptiveHistogramValidation::checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">subpavings::AdaptiveHistogram::checkNodeCountForSplit()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02272">subpavings::SPSnode::getEMPContributionCOPERR()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00789">getLargestLeafVol()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00603">getLeafNodeVolumes()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02028">subpavings::SPSnode::getLogLik()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02331">subpavings::SPSnode::getMergeChangeEMPCOPERR()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01448">subpavings::CollatorSPVnode::getNodeDelta()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01833">subpavings::CollatorSPnode::getNodeDelta()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00757">getSmallestLeafVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02297">subpavings::SPSnode::getSplitChangeEMPCOPERR()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01147">subpavings::SPSVnode::getSumLeafCountOverVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01394">subpavings::SPSnode::getSumLeafCountOverVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01100">subpavings::SPSnode::isSplittableNode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01348">subpavings::CollatorSPnode::leafAccumulationOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">subpavings::CollatorSPVnode::leafOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00607">subpavings::CollatorSPnode::leafOutputTabs()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00899">leafOutputTabs()</a>, <a class="el" href="AirTraffic_8cpp_source.shtml#l00043">main()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00726">subpavings::CollatorSPVnode::nodePrint()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00677">subpavings::CollatorSPnode::nodePrint()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01765">subpavings::SPSVnode::nodePrint()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00977">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodePrint()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01995">subpavings::SPSnode::nodePrint()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00069">subpavings::CompVolVal::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00070">subpavings::CompVol::operator()()</a>, <a class="el" href="nodecompobjmapped_8hpp_source.shtml#l00070">subpavings::CompSPArea::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00091">subpavings::CompHeightVal::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00103">subpavings::CompAreaVal::operator()()</a>, <a class="el" href="splitdecisionobj_8hpp_source.shtml#l00134">subpavings::SplitOnVolDivK::operator()()</a>, <a class="el" href="splitdecisionobj_8hpp_source.shtml#l00196">subpavings::SplitOnKandVol::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00199">subpavings::CompHeight::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00210">subpavings::CompArea::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00247">subpavings::CompExtArea::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00451">subpavings::CompVolInv::operator()()</a>, <a class="el" href="mappedspnodevisitor__expand_8cpp_source.shtml#l00107">subpavings::MappedSPnodeVisitorExpand::priorityVisit()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02214">subpavings::spVolume()</a>.</p>
<div class="fragment"><pre class="fragment">        { <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()); }
</pre></div>
</div>
</div>
<a class="anchor" id="a6658537d790191fc8baae2b351cf9666"></a><!-- doxytag: member="subpavings::SPnode::operator=" ref="a6658537d790191fc8baae2b351cf9666" args="(const SPnode &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp; subpavings::SPnode::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00301">301</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">dimension</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l00188">SPnode()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">try</span> {

            <span class="comment">// delete the current children (deletes their children as well)</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
            }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
            }
            <span class="comment">// and delete the current box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = NULL;
            }
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>=NULL;

            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(*rhs.theBox);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = rhs.dimension;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = rhs.label;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = rhs.nodeName;

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (rhs.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*rhs.leftChild);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (rhs.rightChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*rhs.rightChild);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> *<span class="keyword">this</span>;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="aaaf0891a67e056e19f8e086c0139fd96"></a><!-- doxytag: member="subpavings::SPnode::outputGraphDot" ref="aaaf0891a67e056e19f8e086c0139fd96" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#aaaf0891a67e056e19f8e086c0139fd96">subpavings::SPnode::outputGraphDot</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a .dot graph file from an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> tree structure. </p>
<p>Makes a simple .dot graph from the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> tree using node names and the .png image for this graph.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>a constructed <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> tree </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>a .dot file and a .png in the same directory as the program creating it was run in. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01005">1005</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01496">getChildNodeNames()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="namespacesubpavings.shtml#abb4671c14005974aeea8f0dd39600ec6">subpavings::makeDotImage()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, and <a class="el" href="namespacesubpavings.shtml#a0973b1623e6e12ba060db40d9cceece1">subpavings::parseForGraphDot()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03349">subpavings::AdaptiveHistogramValidation::outputGraphDot()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03528">subpavings::AdaptiveHistogram::outputGraphDot()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;

        std::string toParse = <a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

        std::string baseFileName = <span class="stringliteral">&quot;graph&quot;</span>;
        std::string suffix = <span class="stringliteral">&quot;.dot&quot;</span>;
        std::string s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName, suffix);
        <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <span class="stringliteral">&quot;digraph G {&quot;</span>); <span class="comment">// opening line</span>

        <span class="keywordflow">if</span> (toParse.length() &gt; 0) {

            success = <a class="code" href="namespacesubpavings.shtml#a0973b1623e6e12ba060db40d9cceece1" title="Parse a string to make lines for a dot graph.">parseForGraphDot</a>(s, toParse);

        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.length() &gt; 0) {
            <span class="comment">// only the root node</span>
            std::string line = <span class="stringliteral">&quot;\t &quot;</span> + <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;;&quot;</span>;
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, line);
            success = <span class="keyword">true</span>;

       }

        <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <span class="stringliteral">&quot;}&quot;</span>); <span class="comment">// closing line</span>

        <span class="comment">// make the image from the dot file</span>
        <a class="code" href="namespacesubpavings.shtml#abb4671c14005974aeea8f0dd39600ec6" title="make a Dot graph png image given a dot file.">makeDotImage</a>(s);

        <span class="keywordflow">return</span> success;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a84eef536420ee82e9b6ec4eb17a0b14e"></a><!-- doxytag: member="subpavings::SPnode::recursiveRename" ref="a84eef536420ee82e9b6ec4eb17a0b14e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e">subpavings::SPnode::recursiveRename</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively rename children based on this node's nodeName. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00351">351</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00430">setNodeName()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01636">subpavings::CollatorSPnode::marginalise()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">subpavings::CollatorSPnode::nodeReunite()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01377">nodeReunite()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01960">subpavings::SPSVnode::nodeReunite()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02925">subpavings::SPSnode::nodeReunite()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01802">spLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01699">spLeafBoxIntersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01614">spLeafBoxOuterJacket()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02220">subpavings::SPSVnode::unionTreeStructure()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03160">subpavings::SPSnode::unionTreeStructure()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01957">vtkPaving()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>();
        }
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>();
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a1113235b4bedd4a2849cc8e6dae719dc"></a><!-- doxytag: member="subpavings::SPnode::reshapeToUnion" ref="a1113235b4bedd4a2849cc8e6dae719dc" args="(const SPnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a1113235b4bedd4a2849cc8e6dae719dc">subpavings::SPnode::reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of another tree. </p>
<p>Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if this has no box or if <em>other</em> has no box.</p>
<p>Throws an <a class="el" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a> if boxes of this and <em>other</em> are not the same.</p>
<p>Throws an std::runtime_error if <em>other</em> has an illegal state (see <a class="el" href="classsubpavings_1_1SPnode.shtml#afde5e15be5259cf61821f175452d165f" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal()</a>).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is the tree to make the union against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This has a box and that box is identical to the box of <em>other</em>. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the tree rooted at this has shape that is the union of the shape of this before the operation and the shape of <em>other</em>. <em>other</em> is unchanged. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad128b1715d294a65c905579ab43890d2">subpavings::SPSnode</a>.</p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01532">1532</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00157">_reshapeToUnion()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00820">checkTreeStateLegal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || other.isEmpty()) {
      <span class="keywordflow">throw</span> NoBox_Error(
      <span class="stringliteral">&quot;SPnode::reshapeToUnion(const SPnode&amp;)&quot;</span>);
    }
    <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != other.getBox() )  {
      <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
      <span class="stringliteral">&quot;SPnode::reshapeToUnion(const SPnode&amp;)&quot;</span>);
    }
    <span class="keywordflow">if</span> ( !other.checkTreeStateLegal() )
      <span class="keywordflow">throw</span> runtime_error(
      <span class="stringliteral">&quot;SPnode::reshapeToUnion(const SPnode&amp;) : other has illegal tree state&quot;</span>);
    
    this-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a7ac37cce7f65b0f4c71d37b06d581d17" title="Reshape the tree rooted at this so that it has the shape that is the non-minimal union of the tree or...">_reshapeToUnion</a>(&amp;other);
    
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a9ef7989599f223a312a371d8fb8527db"></a><!-- doxytag: member="subpavings::SPnode::setLabel" ref="a9ef7989599f223a312a371d8fb8527db" args="(int lab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a9ef7989599f223a312a371d8fb8527db">subpavings::SPnode::setLabel</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the label of a childless root node. </p>
<p>Prints an error message to console if this is not a childless root node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00411">411</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00396">getParent()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00109">label</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef" title="Accessor for the parent of a node.">getParent</a>()==NULL)) {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = lab;
        }
        <span class="keywordflow">else</span> {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Cannot set label for node which &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;is not a childless root node&quot;</span>
                &lt;&lt; std::endl;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a628f03ae2795efd1135e6f4d06db987f"></a><!-- doxytag: member="subpavings::SPnode::setNodeName" ref="a628f03ae2795efd1135e6f4d06db987f" args="(std::string newname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f">subpavings::SPnode::setNodeName</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the node name. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00430">430</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01802">spLeafBoxDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01699">spLeafBoxIntersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01614">spLeafBoxOuterJacket()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01957">vtkPaving()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = newname;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa90c047beb6a8b6a4beb74342ad593a3"></a><!-- doxytag: member="subpavings::SPnode::spContains" ref="aa90c047beb6a8b6a4beb74342ad593a3" args="(const ivector &amp;z) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a> <a class="el" href="classsubpavings_1_1SPnode.shtml#aa90c047beb6a8b6a4beb74342ad593a3">subpavings::SPnode::spContains</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if ivector z is contained in this or children. </p>
<p>Note that this checks not only the box represented by this node but the children as well. Returns a BOOL_INTERVAL type, ie can be true, false, or indeterminate (indeterminate if the ivector covers the border of the subpaving). </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01088">1088</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_FALSE</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_INDET</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_TRUE</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// z is assumed not to be empty</span>
        <span class="comment">// nb Intersection() gives error if unequal index sets passed</span>

        <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>; <span class="comment">// for the return value</span>

        <span class="comment">// case of a non-empty leaf</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {

            ivector r; <span class="comment">// temporary,to be passed to Intersection</span>

            <span class="keywordflow">if</span> (z&lt;=<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) {
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>;
            }

            <span class="comment">// result is indeterminate if there is an</span>
            <span class="comment">// intersection but z is not wholly in theBox</span>
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(r, z, <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
            }

            <span class="comment">// Case that there is no intersection</span>
            <span class="keywordflow">else</span> retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;

        } <span class="comment">// end (!isEmpty() &amp;&amp; isLeaf())</span>

        <span class="comment">//case of an non-empty non-leaf</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
        <span class="comment">//</span>

            ivector Lz, Rz; <span class="comment">// ivectors passed to Intersection()</span>
            <span class="comment">// will contain intersection after Intersection() call</span>

            <span class="comment">// to hold results of tests on left and right children</span>
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> Ltest = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> Rtest = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;

            <span class="comment">// indicators for tested left and right sides</span>
            <span class="keywordtype">bool</span> LtestSuccess = <span class="keyword">false</span>;
            <span class="keywordtype">bool</span> RtestSuccess = <span class="keyword">false</span>;

            <span class="comment">// Find if there is a leftChild with a box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp;
                <a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Lz, z, <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {
                <span class="comment">// Lz contains intersctn of z &amp; leftChild box</span>

                <span class="comment">// test Lz and left child node</span>
                Ltest = ((*leftChild).spContains(Lz));
                LtestSuccess = <span class="keyword">true</span>;
            }


            <span class="comment">// Find if there is a rightChild with a box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp;
                <a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz, z, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {
                <span class="comment">// Rz contains intersctn of z &amp; rightChild box</span>

                <span class="comment">// test Rz and right child node</span>
                Rtest = ((*rightChild).spContains(Rz));
                RtestSuccess = <span class="keyword">true</span>;
            }

            <span class="comment">// if both children tested</span>
            <span class="keywordflow">if</span> (LtestSuccess &amp;&amp; RtestSuccess) {
                <span class="comment">//return value is the result of both tests</span>
                    <span class="comment">// if the same or BI_INDET if diff</span>
                Ltest==Rtest ?
                    retValue = Ltest : retValue=<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
            }

            <span class="comment">// if has two children but neither was tested</span>
            <span class="comment">// ie neither Intersection() returned true</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                &amp;&amp; !LtestSuccess &amp;&amp; !RtestSuccess) {
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
                <span class="comment">// note that the AIA book has BI_TRUE here</span>
                <span class="comment">// but this can&#39;t be correct</span>
            }

            <span class="comment">// if has two children but only right was tested</span>
            <span class="comment">// ie left Intersection() returned false</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                &amp;&amp; !LtestSuccess &amp;&amp; RtestSuccess) {
                retValue = Rtest;
                <span class="comment">// return value result of test of right side</span>
            }

            <span class="comment">// if has two children but only left was tested</span>
            <span class="comment">// ie right Intersection() returned false</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                &amp;&amp; LtestSuccess &amp;&amp; !RtestSuccess) {
                retValue = Ltest;
                <span class="comment">// return value result of test of left side</span>
            }

            <span class="comment">// if has right child only and that child was tested</span>
            <span class="comment">// ie Intersection() returned true</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()
                &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; RtestSuccess) {
                <span class="comment">// if all of z contained in right child&#39;s box</span>
                <span class="keywordflow">if</span> (Rz==z) {
                    retValue = Rtest;
                }
                <span class="comment">// return false if Rtest false, else INDET</span>
                <span class="keywordflow">else</span> {
                    Rtest==<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a> ? retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>
                        : retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
                }
            }

            <span class="comment">// if has right child only and that child not tested</span>
            <span class="comment">// ie Intersection() returned false</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()
                &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !RtestSuccess) {
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
            }

            <span class="comment">// if has left child only and that child was tested</span>
            <span class="comment">// ie Intersection() returned true</span>
            <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                &amp;&amp; LtestSuccess) {
                <span class="comment">// if whole of z contained in left child&#39;s box</span>
                <span class="keywordflow">if</span> (Lz==z) {
                    retValue = Ltest;
                }
                <span class="comment">// return false if Ltest false, otherwise INDET</span>
                <span class="keywordflow">else</span> {
                    Ltest==<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a> ?
                        retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a> :
                        retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
                }
            }

            <span class="comment">// if has left child only &amp; that child was not tested</span>
            <span class="comment">// ie Intersection() returned false</span>
            <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                &amp;&amp; !LtestSuccess) {
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
            }

            <span class="comment">// case no children covered by isLeaf() block above</span>

        } <span class="comment">// end of (!isEmpty() &amp;&amp; !isLeaf())</span>

        <span class="comment">// case of isEmpty() being true is take care of</span>
        <span class="comment">// by default return value being BI_FALSE</span>

        <span class="keywordflow">return</span> retValue;

    } <span class="comment">// end of spContains for ivector</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a56f98ed5bc26b9b11dfce51f3e667e2b"></a><!-- doxytag: member="subpavings::SPnode::spContains" ref="a56f98ed5bc26b9b11dfce51f3e667e2b" args="(const rvector &amp;p) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a> <a class="el" href="classsubpavings_1_1SPnode.shtml#aa90c047beb6a8b6a4beb74342ad593a3">subpavings::SPnode::spContains</a> </td>
          <td>(</td>
          <td class="paramtype">const rvector &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if rvector p is contained in this node or any of its children. </p>
<p>Note that this checks not only the box represented by this node but the children as well. Returns a BOOL_INTERVAL type but this can actually only be BI_TRUE or BI_FALSE (not BI_INDET = indeterminate). </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01242">1242</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_FALSE</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_TRUE</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// p is assumed not to be empty</span>
        <span class="comment">// nb Intersection() gives error if unequal index sets passed</span>

        <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>; <span class="comment">// for the return value</span>

        <span class="comment">//cast p to an ivector</span>
        ivector pvector = _ivector(p);

        <span class="comment">// case of a non-empty leaf</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {


            <span class="comment">//find if p is in the box</span>
            <span class="keywordflow">if</span> (pvector &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) {
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>;
            }
            <span class="comment">//else retValue keeps default value of BI_FALSE</span>


        } <span class="comment">// end (!isEmpty() &amp;&amp; isLeaf())</span>

        <span class="comment">//case of an non-empty non-leaf</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {

            <span class="comment">// to hold results of tests on left and right children</span>
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> Ltest = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> Rtest = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;

            <span class="comment">// Find if there is a leftChild with a box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
                <span class="comment">// test left child node</span>
                Ltest = ((*leftChild).spContains(p));
            }


            <span class="comment">// Find if there is a rightChild with a box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
                <span class="comment">// test Rz and right child node</span>
                Rtest = ((*rightChild).spContains(p));
            }

            <span class="keywordflow">if</span> ((Ltest==<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>) || (Rtest==<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>)) {
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>;
            }
            <span class="comment">//else retValue keeps default value of BI_FALSE</span>

            <span class="comment">// case no children taken care of by isLeaf() above</span>

        } <span class="comment">// end of (!isEmpty() &amp;&amp; !isLeaf())</span>

        <span class="comment">// case isEmpty() true covered by default retValue = BI_FALSE</span>

        <span class="keywordflow">return</span> retValue;

    } <span class="comment">// end of spContains for rvector</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a5de03ca047d5250c8b2f42f8b29f2a3e"></a><!-- doxytag: member="subpavings::SPnode::spLeafBoxDifference" ref="a5de03ca047d5250c8b2f42f8b29f2a3e" args="(const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#a5de03ca047d5250c8b2f42f8b29f2a3e">subpavings::SPnode::spLeafBoxDifference</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a tree representing difference between two subpavings.</p>
<p>The difference is the boxes covering space that is represented by spn1 but is not in the subpaving represented by spn2. This function ignores labels.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a root of a tree representing a subpaving which is the space represented by spn1 that is not represented by spn2. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01802">1802</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">setNodeName()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* diffSP = NULL;
        <a class="code" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623" title="Define type BoxVec as a container of boxes.">BoxVec</a> diffBoxes;
        diffBoxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8df2c2330b8da545a013d87cf1619e2b">vecLeafBoxDifference</a>(diffBoxes, spn1, spn2);
        <span class="keywordflow">if</span> (!diffBoxes.empty()) {

            <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> listBoxes;
            listBoxes.insert(listBoxes.end(), diffBoxes.begin(),
                                                diffBoxes.end());
            ivector root = spn1-&gt;getBox();

            diffSP = <a class="code" href="classsubpavings_1_1SPnode.shtml#a28c48af012e0a5b96236dcf12ffbae93" title="Forms a minimal SPnode subpaving from leaf boxes.">makeTreeFromLeaves</a>(root, listBoxes);

            <span class="keywordflow">if</span> (diffSP != NULL) {
                diffSP-&gt;setNodeName(<span class="stringliteral">&quot;X&quot;</span>);
                diffSP-&gt;recursiveRename();
            }
        }

        <span class="keywordflow">return</span> diffSP;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="abe8c17244a31a4003e59f48a56e61ac4"></a><!-- doxytag: member="subpavings::SPnode::spLeafBoxIntersection" ref="abe8c17244a31a4003e59f48a56e61ac4" args="(const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#abe8c17244a31a4003e59f48a56e61ac4">subpavings::SPnode::spLeafBoxIntersection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return subpaving representing intersection of two subpavings.</p>
<p>The intersection is the boxes covering space that that is represented by both trees. This function ignores labels.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>root of a tree whose leaves represent the boxes that cover space in common between both subpavings. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01699">1699</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">setNodeName()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* interSP = NULL;
        <a class="code" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623" title="Define type BoxVec as a container of boxes.">BoxVec</a> interBoxes;
        interBoxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#afb2b268ccd3ddfa61cdcadb866933351">vecLeafBoxIntersection</a>(interBoxes,
                        spn1, spn2);
        <span class="keywordflow">if</span> (!interBoxes.empty()) {

            <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> listBoxes;
            listBoxes.insert(listBoxes.end(), interBoxes.begin(),
                                                interBoxes.end());
            ivector root = spn1-&gt;getBox();

            interSP = <a class="code" href="classsubpavings_1_1SPnode.shtml#a28c48af012e0a5b96236dcf12ffbae93" title="Forms a minimal SPnode subpaving from leaf boxes.">makeTreeFromLeaves</a>(root, listBoxes);

            <span class="keywordflow">if</span> (interSP != NULL) {
                interSP-&gt;setNodeName(<span class="stringliteral">&quot;X&quot;</span>);
                interSP-&gt;recursiveRename();
            }
        }

        <span class="keywordflow">return</span> interSP;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad7fd31c8579c501476dcc7004e52c1d6"></a><!-- doxytag: member="subpavings::SPnode::spLeafBoxOuterJacket" ref="ad7fd31c8579c501476dcc7004e52c1d6" args="(const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#ad7fd31c8579c501476dcc7004e52c1d6">subpavings::SPnode::spLeafBoxOuterJacket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> tree representing the outer jacket of 2 subpavings.</p>
<p>The outer jacket tree is the nodes in common between two <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> trees. i.e. the 'outer jacket' that fits both of the subpavings represented by the given trees.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>root of a tree whose leaves represent the boxes that cover both subpavings. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01614">1614</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">setNodeName()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01568">vecLeafBoxOuterJacket()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* jacketSP = NULL;
        <a class="code" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623" title="Define type BoxVec as a container of boxes.">BoxVec</a> jacketBoxes;
        jacketBoxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a2f68ecee896eb24708a4a3045ddc38b4">vecLeafBoxOuterJacket</a>(jacketBoxes,
                        spn1, spn2);
        <span class="keywordflow">if</span> (!jacketBoxes.empty()) {

            <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> listBoxes;
            listBoxes.insert(listBoxes.end(), jacketBoxes.begin(),
                                                jacketBoxes.end());
            ivector root = spn1-&gt;getBox();

            jacketSP = <a class="code" href="classsubpavings_1_1SPnode.shtml#a28c48af012e0a5b96236dcf12ffbae93" title="Forms a minimal SPnode subpaving from leaf boxes.">makeTreeFromLeaves</a>(root, listBoxes);

            <span class="keywordflow">if</span> (jacketSP != NULL) {
                jacketSP-&gt;setNodeName(<span class="stringliteral">&quot;X&quot;</span>);
                jacketSP-&gt;recursiveRename();
            }

        }

        <span class="keywordflow">return</span> jacketSP;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a44aaa22ba1f62c17775a96071c05ad8b"></a><!-- doxytag: member="subpavings::SPnode::splitLeft" ref="a44aaa22ba1f62c17775a96071c05ad8b" args="(std::string instruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1SPnode.shtml#a44aaa22ba1f62c17775a96071c05ad8b">subpavings::SPnode::splitLeft</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>instruction</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>splitting according to instruction string. </p>
<p>Gets the first level in the string, checks if it is already at that level, if not splits and recurses to children in order left then right, if it is already at that level strips this off the string and returns the remaining string to the caller. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instruction</td><td>is a string specifiying shape, eg "3, 3, 2, 1" </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l00088">88</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02192">subpavings::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01551">splitRootToShape()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        std::string errorCode = <span class="stringliteral">&quot;XX&quot;</span>;
        <span class="comment">// parse string to get first level out</span>
        std::string comma = <span class="stringliteral">&quot;, &quot;</span>;
        <span class="keywordtype">size_t</span> startpos = instruction.find_first_not_of(comma);
        <span class="keywordtype">size_t</span> endpos = std::string::npos;
        <span class="keywordtype">size_t</span> newstartpos = std::string::npos;
        <span class="keywordtype">int</span> depth = 0;
        std::string str = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (startpos != std::string::npos) {
            endpos = instruction.find_first_of(comma, startpos);
            <span class="comment">//not the last digit</span>
            <span class="keywordflow">if</span> (endpos != std::string::npos) {
                str = instruction.substr(startpos, endpos-startpos);
                newstartpos = instruction.find_first_not_of(comma,
                                                        endpos + 1);
            }
            <span class="comment">//last digit</span>
            <span class="keywordflow">else</span> {
                str = instruction.substr(startpos);
            }
        }
        depth = atoi(str.c_str()); <span class="comment">// 0 if not valid integer</span>
        <span class="keywordflow">if</span> (depth == 0) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Problem in parsing string&quot;</span> &lt;&lt; endl;
            instruction = errorCode;
        }
        <span class="keywordflow">else</span> { <span class="comment">// depth should be &gt; 0</span>
            <span class="keywordtype">int</span> myDepth = <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>.length() - 1;
            <span class="keywordflow">if</span> (myDepth &lt; depth) { <span class="comment">// need to go down more</span>

                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                    <span class="comment">// split, using the nodeExpand for this subtype if not base</span>
                    <a class="code" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55" title="Expand a leaf node to have two children and pass data down to the children with no further splitting...">nodeExpand</a>();
                }

                <span class="comment">// send splitLeft instruction down to the left</span>
                instruction = <a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a44aaa22ba1f62c17775a96071c05ad8b" title="splitting according to instruction string.">splitLeft</a>(instruction);
                <span class="keywordflow">if</span> (instruction != errorCode) {
                    <span class="comment">// send splitLeft instruction to right child</span>
                    instruction = <a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a44aaa22ba1f62c17775a96071c05ad8b" title="splitting according to instruction string.">splitLeft</a>(instruction);
                }
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (myDepth == depth) {     <span class="comment">// split enough</span>
                <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                    std::cerr &lt;&lt; <span class="stringliteral">&quot;Problem with instruction string:&quot;</span> &lt;&lt; std::endl;
                    std::cerr &lt;&lt; <span class="stringliteral">&quot;cannot use with current histogram&quot;</span> &lt;&lt; std::endl;
                    instruction = errorCode;
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newstartpos != std::string::npos) {
                    instruction = instruction.substr(newstartpos);
                }
                <span class="keywordflow">else</span> instruction = <span class="stringliteral">&quot;&quot;</span>;
            }
            <span class="keywordflow">else</span> { <span class="comment">// myDepth is &gt; depth</span>
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Problem with instruction string:&quot;</span> &lt;&lt; std::endl;
                std::cerr &lt;&lt; <span class="stringliteral">&quot;cannot use with current histogram&quot;</span> &lt;&lt; std::endl;
                instruction = errorCode;
            }
        }

        <span class="keywordflow">return</span> instruction;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a62e9df1a7c96af8f0796a6ea211b38ea"></a><!-- doxytag: member="subpavings::SPnode::splitRootToShape" ref="a62e9df1a7c96af8f0796a6ea211b38ea" args="(std::string instruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPnode.shtml#a62e9df1a7c96af8f0796a6ea211b38ea">subpavings::SPnode::splitRootToShape</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>instruction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a root paving to a specified shape. </p>
<p>The instruction specifies the required shape in terms of the depth of the leaf nodes, in left to right order. The depth of a leaf node is equivalent to the number of bisections of the root box required to make the box represented by that leaf. i.e., the root has depth 0 and if that were bisected, the root node would have two child nodes each of level 1. Bisection of any one of the boxes represented by a child would give two more children, each of level 2 (2 bisections), etc.</p>
<p>For example, an instruction string "3, 3, 2, 1" would give an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree with 4 leaves, 2 of which would be level 3 (i.e. representing boxes resulting from 3 bisections of the root box, each of which would have volume 1/8 the size of the root box). Another leaf would represent a box resulting from 2 bisections of the root box (volume 1/4 that of the root box) and the 'right-most' leaf (in a drawing of the tree) would be the result of a single bisection of the root box and would have half the volume of the root box. This is a valid instruction string because it is possible to get leaves of those levels by a series of successive bisections of the root box and the volume of the leaves adds up to the volume of the root box.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instruction</td><td>specifies the required shape, eg "3, 3, 2, 1". </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the instruction could be successfully carried out, false if the instruction could not be carried out successfully. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01551">1551</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00088">splitLeft()</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00373">subpavings::MappedSPnode&lt; cxsc::real &gt;::splitToShape()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03255">subpavings::AdaptiveHistogramValidation::splitToShape()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02971">subpavings::AdaptiveHistogram::splitToShape()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) {
            std::string res = <a class="code" href="classsubpavings_1_1SPnode.shtml#a44aaa22ba1f62c17775a96071c05ad8b" title="splitting according to instruction string.">splitLeft</a>(instruction);
            <span class="keywordflow">if</span> (res == <span class="stringliteral">&quot;&quot;</span>) success = <span class="keyword">true</span>;
        }
        <span class="keywordflow">else</span> {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Sorry, not a root paving&quot;</span> &lt;&lt; std::endl;
        }
        <span class="keywordflow">return</span> success;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a08eac7d3d3f57b9d6e56a84f14e9f4fb"></a><!-- doxytag: member="subpavings::SPnode::swap" ref="a08eac7d3d3f57b9d6e56a84f14e9f4fb" args="(SPnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb">subpavings::SPnode::swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this and another node. </p>
<p>Swaps all the data members of this with the other node.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>a reference to the node to swap with </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is identical,in terms of its data members, to spn before the swap, and spn is identical to this after the swap. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02125">2125</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">leftChild</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">theBox</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00958">subpavings::MappedSPnode&lt; cxsc::real &gt;::swapMSPSR()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">subpavings::SPSnode::swapSPS()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>, spn.theBox); <span class="comment">// theBox is a pointer</span>
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>, spn.nodeName);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>, spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>);
    <span class="comment">// can just swap child pointers</span>
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>, spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>, spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>);
    <span class="comment">// children have to be repointed to the new swapped parents</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> != NULL) <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> != NULL) <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = <span class="keyword">this</span>;
    <span class="keywordflow">if</span> (spn.leftChild != NULL) spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = &amp;spn;
    <span class="keywordflow">if</span> (spn.rightChild != NULL) spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = &amp;spn;
    
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a10a7bea8a44da192fe174d1d04284d3b"></a><!-- doxytag: member="subpavings::SPnode::vecBoxNodeDifference" ref="a10a7bea8a44da192fe174d1d04284d3b" args="(BoxVec &amp;boxes, ivector box1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a10a7bea8a44da192fe174d1d04284d3b">subpavings::SPnode::vecBoxNodeDifference</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>box1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return boxes of space that is difference between box and subpaving.</p>
<p>The difference is the boxes covering space that is in box1 but is not in the subpaving represented by spn2. This function ignores labels.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>is a reference to a container of boxes to be filled. </td></tr>
    <tr><td class="paramname">box1</td><td>a box. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing a subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>boxes in box1 that is not in subpaving represented by spn2. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01782">1782</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00159">MaxDiamComp()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (spn2 == NULL) boxes.push_back(box1);

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!(spn2-&gt;isLeaf())) {
            <span class="comment">// bisect box1</span>
            <span class="keywordtype">int</span> maxdiamcomp = <a class="code" href="toolz_8cpp.shtml#af7098b26cfe9466d751176b29c67342c" title="Return the first dimension with maximal diameter.">MaxDiamComp</a>(box1);
            <span class="comment">// new ivectors from splitting root along its biggest dimension</span>
            ivector leftbox = <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(box1, maxdiamcomp);
            ivector rightbox = <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(box1, maxdiamcomp);
            boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a10a7bea8a44da192fe174d1d04284d3b">vecBoxNodeDifference</a>(boxes, leftbox, spn2-&gt;getLeftChild());
            boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a10a7bea8a44da192fe174d1d04284d3b">vecBoxNodeDifference</a>(boxes, rightbox, spn2-&gt;getRightChild());
        }
        <span class="comment">// else spn2 must be a leaf so there is no difference</span>

        <span class="keywordflow">return</span> boxes;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8df2c2330b8da545a013d87cf1619e2b"></a><!-- doxytag: member="subpavings::SPnode::vecLeafBoxDifference" ref="a8df2c2330b8da545a013d87cf1619e2b" args="(BoxVec &amp;boxes, const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a8df2c2330b8da545a013d87cf1619e2b">subpavings::SPnode::vecLeafBoxDifference</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return boxes of space that is the difference between two subpavings.</p>
<p>The difference is the boxes covering space that is represented by spn1 but is not in the subpaving represented by spn2. This function ignores labels.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>is a reference to a container of boxes to be filled. </td></tr>
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>boxes of space represented by spn1 that is not represented by spn2. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01741">1741</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01782">vecBoxNodeDifference()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01802">spLeafBoxDifference()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01827">volDifference()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (spn1 != NULL &amp;&amp; spn2 == NULL) {

            <a class="code" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49" title="Define type SPnodePtrs as container of pointers to SPnodes.">SPnodePtrs</a> leaves1;
            spn1-&gt;getSPnodeLeaves(leaves1);
            <a class="code" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6" title="Define type SPnodePtrsItr as an iterator over SPnodePtrs.">SPnodePtrsItr</a> it;
            <span class="keywordflow">for</span> (it = leaves1.begin(); it &lt; leaves1.end(); it++) {
                boxes.push_back((*it)-&gt;getBox());
            }
        }

        <span class="keywordflow">if</span> (spn1 != NULL &amp;&amp; spn2 != NULL
                &amp;&amp; (spn1-&gt;getBox() == spn2-&gt;getBox())) {

            <span class="keywordflow">if</span> (spn1-&gt;isLeaf() &amp;&amp; !(spn2-&gt;isLeaf())) {
                <span class="comment">// now we want to get any part of the box of spn1 that is</span>
                <span class="comment">// not represented by whatever boxes hang off spn2</span>
                boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a10a7bea8a44da192fe174d1d04284d3b">vecBoxNodeDifference</a>(boxes, spn1-&gt;getBox(), spn2);
            }

            <span class="comment">// if spn1 is not a leaf but spn2 is, then there is nothing</span>
            <span class="comment">// represented in spn1 that is not already represented in spn2</span>

            <span class="keywordflow">if</span> (!(spn1-&gt;isLeaf()) &amp;&amp; !(spn2-&gt;isLeaf())) {
                <span class="comment">// recurse on the children</span>
                boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8df2c2330b8da545a013d87cf1619e2b">vecLeafBoxDifference</a>(boxes, spn1-&gt;getLeftChild(),
                            spn2-&gt;getLeftChild());
                boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8df2c2330b8da545a013d87cf1619e2b">vecLeafBoxDifference</a>(boxes, spn1-&gt;getRightChild(),
                            spn2-&gt;getRightChild());
            }
        }

        <span class="comment">// if spn1 is null and spn2 is not null we don&#39;t do anything</span>
        <span class="comment">// if both not null but the boxes don&#39;t match we don&#39;t do anything</span>
        <span class="keywordflow">return</span> boxes;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="afb2b268ccd3ddfa61cdcadb866933351"></a><!-- doxytag: member="subpavings::SPnode::vecLeafBoxIntersection" ref="afb2b268ccd3ddfa61cdcadb866933351" args="(BoxVec &amp;boxes, const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#afb2b268ccd3ddfa61cdcadb866933351">subpavings::SPnode::vecLeafBoxIntersection</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return container of boxes represented by intersection of 2 subpavings.</p>
<p>The intersection is the boxes covering space in the subpavings represented by both trees. This function ignores labels.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>is a reference to a container of boxes to be filled. </td></tr>
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving (can be NULL). </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving (can be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a container of boxes that is the intersection of the boxes represented by the leaves of spn1 and the boxes represented by the leaves ofspn2. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01656">1656</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00560">getSPnodeLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01699">spLeafBoxIntersection()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01725">volIntersection()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// only do something if both nodes are non-null and boxes match</span>
        <span class="keywordflow">if</span> (spn1 != NULL &amp;&amp; spn2 != NULL &amp;&amp;
                        (spn1-&gt;getBox() == spn2-&gt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {

            <span class="comment">// if both are leaves (and boxes match), push back the matching box</span>
            <span class="keywordflow">if</span> (spn1-&gt;isLeaf() &amp;&amp; spn2-&gt;isLeaf()) boxes.push_back(spn1-&gt;getBox());

            <span class="comment">// if one is a leaf and one is not, the children of the non-leaf</span>
            <span class="comment">// are all in the intersection</span>
            <span class="keywordflow">if</span> (!(spn1-&gt;isLeaf()) &amp;&amp; spn2-&gt;isLeaf()) {
                <a class="code" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49" title="Define type SPnodePtrs as container of pointers to SPnodes.">SPnodePtrs</a> leaves1;
                spn1-&gt;getSPnodeLeaves(leaves1);
                <a class="code" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6" title="Define type SPnodePtrsItr as an iterator over SPnodePtrs.">SPnodePtrsItr</a> it;
                <span class="keywordflow">for</span> (it = leaves1.begin(); it &lt; leaves1.end(); it++) {
                    boxes.push_back((*it)-&gt;getBox());
                }
            }

            <span class="keywordflow">if</span> (spn1-&gt;isLeaf() &amp;&amp; !(spn2-&gt;isLeaf())) {
                <a class="code" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49" title="Define type SPnodePtrs as container of pointers to SPnodes.">SPnodePtrs</a> leaves2;
                spn2-&gt;getSPnodeLeaves(leaves2);
                <a class="code" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6" title="Define type SPnodePtrsItr as an iterator over SPnodePtrs.">SPnodePtrsItr</a> it;
                <span class="keywordflow">for</span> (it = leaves2.begin(); it &lt; leaves2.end(); it++) {
                    boxes.push_back((*it)-&gt;getBox());
                }
            }

            <span class="comment">// if both have children, recurse on the children</span>
            <span class="keywordflow">if</span> (spn1-&gt;hasRCwithBox() &amp;&amp; spn2-&gt;hasRCwithBox())
                boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#afb2b268ccd3ddfa61cdcadb866933351">vecLeafBoxIntersection</a>(boxes, spn1-&gt;getRightChild(),
                                                        spn2-&gt;getRightChild());
            <span class="keywordflow">if</span> (spn1-&gt;hasLCwithBox() &amp;&amp; spn2-&gt;hasLCwithBox())
                boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#afb2b268ccd3ddfa61cdcadb866933351">vecLeafBoxIntersection</a>(boxes, spn1-&gt;getLeftChild(),
                                                        spn2-&gt;getLeftChild());
        }

        <span class="keywordflow">return</span> boxes;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2f68ecee896eb24708a4a3045ddc38b4"></a><!-- doxytag: member="subpavings::SPnode::vecLeafBoxOuterJacket" ref="a2f68ecee896eb24708a4a3045ddc38b4" args="(BoxVec &amp;boxes, const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp; <a class="el" href="classsubpavings_1_1SPnode.shtml#a2f68ecee896eb24708a4a3045ddc38b4">subpavings::SPnode::vecLeafBoxOuterJacket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a> &amp;&#160;</td>
          <td class="paramname"><em>boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return container of boxes represented by commonality of 2 subpavings.</p>
<p>Finds the boxes represented by the deepest common level of nodes between two <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> trees i.e. the 'outer jacket' that is the finest subpaving that fits around both of the subpavings represented by the given trees.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boxes</td><td>is a reference to a container of boxes to be filled. </td></tr>
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a container of boxes that is the outer jacket of spn1, spn2. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01568">1568</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01614">spLeafBoxOuterJacket()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01641">volOuterJacket()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// only do something if both nodes are non-null and boxes match</span>
        <span class="keywordflow">if</span> (spn1 != NULL &amp;&amp; spn2 != NULL &amp;&amp;
                        (spn1-&gt;getBox() == spn2-&gt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {

            <span class="comment">// if both are leaves or</span>
            <span class="comment">// one of them does not have a child that the other has</span>
            <span class="comment">// then push back the box of the node we are in now</span>
            <span class="keywordflow">if</span> (spn1-&gt;isLeaf() &amp;&amp; spn2-&gt;isLeaf()) {
                boxes.push_back(spn1-&gt;getBox());
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((spn1-&gt;getLeftChild() != NULL
                        &amp;&amp; spn2-&gt;getLeftChild() == NULL)
                        || (spn1-&gt;getLeftChild() == NULL
                        &amp;&amp; spn2-&gt;getLeftChild() != NULL)
                        || (spn1-&gt;getRightChild() != NULL
                        &amp;&amp; spn2-&gt;getRightChild() == NULL)
                        || (spn1-&gt;getRightChild() == NULL
                        &amp;&amp; spn2-&gt;getRightChild() != NULL)) {
                boxes.push_back(spn1-&gt;getBox());
            }

            <span class="keywordflow">else</span> {
                <span class="comment">// we recurse on the children if both have both children</span>
                <span class="keywordflow">if</span> (spn1-&gt;getLeftChild() != NULL
                            &amp;&amp; spn2-&gt;getLeftChild() != NULL) {
                    boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a2f68ecee896eb24708a4a3045ddc38b4">vecLeafBoxOuterJacket</a>(boxes,
                                spn1-&gt;getLeftChild(), spn2-&gt;getLeftChild());
                }
                <span class="keywordflow">if</span> (spn1-&gt;getRightChild() != NULL
                            &amp;&amp; spn2-&gt;getRightChild() != NULL) {

                    boxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a2f68ecee896eb24708a4a3045ddc38b4">vecLeafBoxOuterJacket</a>(boxes,
                                spn1-&gt;getRightChild(), spn2-&gt;getRightChild());
                }
            }
        }
        <span class="keywordflow">return</span> boxes;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a474c6fe9f99ba63eb6eff5c0577cc63a"></a><!-- doxytag: member="subpavings::SPnode::volDifference" ref="a474c6fe9f99ba63eb6eff5c0577cc63a" args="(const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPnode.shtml#a474c6fe9f99ba63eb6eff5c0577cc63a">subpavings::SPnode::volDifference</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the sum of the volume of the difference between 2 subpavings.</p>
<p>The difference is taken on leaf nodes using vecLeafBoxDifference.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total volume of the space represented by spn1 that is not represented by spn2. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01827">1827</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01741">vecLeafBoxDifference()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623" title="Define type BoxVec as a container of boxes.">BoxVec</a> diffBoxes;
        diffBoxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8df2c2330b8da545a013d87cf1619e2b">vecLeafBoxDifference</a>(diffBoxes,
                        spn1, spn2);
        <a class="code" href="namespacesubpavings.shtml#a8ea214a381f9c2027d0f605f2af25483" title="Define type BoxVecItr as iterator over BoxVec.">BoxVecItr</a> bit;
        <span class="keywordtype">double</span> diffVol = 0;
        <span class="keywordflow">for</span> (bit = diffBoxes.begin(); bit &lt; diffBoxes.end(); bit++) {
            diffVol += <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a> (*bit);
        }
        <span class="keywordflow">return</span> diffVol;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aff141c8fe2b44b5da47319563f335fd3"></a><!-- doxytag: member="subpavings::SPnode::volIntersection" ref="aff141c8fe2b44b5da47319563f335fd3" args="(const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPnode.shtml#aff141c8fe2b44b5da47319563f335fd3">subpavings::SPnode::volIntersection</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the sum of the volume of intersection between two subpavings.</p>
<p>The intersection is taken on leaf nodes using vecLeafBoxIntersection.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn1</td><td>first subpaving to intersect, can be NULL. </td></tr>
    <tr><td class="paramname">spn2</td><td>second subpaving to intersect, can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total volume of the space in common between the two subpavings. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01725">1725</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01656">vecLeafBoxIntersection()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623" title="Define type BoxVec as a container of boxes.">BoxVec</a> interBoxes;
        interBoxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#afb2b268ccd3ddfa61cdcadb866933351">vecLeafBoxIntersection</a>(interBoxes,
                        spn1, spn2);
        <a class="code" href="namespacesubpavings.shtml#a8ea214a381f9c2027d0f605f2af25483" title="Define type BoxVecItr as iterator over BoxVec.">BoxVecItr</a> bit;
        <span class="keywordtype">double</span> interVol = 0;
        <span class="keywordflow">for</span> (bit = interBoxes.begin(); bit &lt; interBoxes.end(); bit++) {
            interVol += <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a> (*bit);
        }
        <span class="keywordflow">return</span> interVol;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a57f1a92689c116edcf2bf6a62497970f"></a><!-- doxytag: member="subpavings::SPnode::volOuterJacket" ref="a57f1a92689c116edcf2bf6a62497970f" args="(const SPnode *const spn1, const SPnode *const spn2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPnode.shtml#a57f1a92689c116edcf2bf6a62497970f">subpavings::SPnode::volOuterJacket</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the sum of the volume of outer jacket of two subpavings.</p>
<p>The outerjacket is found using vecLeafBoxOuterJacket.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn1</td><td>root of tree representing a subpaving. </td></tr>
    <tr><td class="paramname">spn2</td><td>root of tree representing another subpaving. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the volume of the smallest subpaving containing both subpavings. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01641">1641</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01568">vecLeafBoxOuterJacket()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623" title="Define type BoxVec as a container of boxes.">BoxVec</a> jacketBoxes;
        jacketBoxes = <a class="code" href="classsubpavings_1_1SPnode.shtml#a2f68ecee896eb24708a4a3045ddc38b4">vecLeafBoxOuterJacket</a>(jacketBoxes,
                        spn1, spn2);
        <a class="code" href="namespacesubpavings.shtml#a8ea214a381f9c2027d0f605f2af25483" title="Define type BoxVecItr as iterator over BoxVec.">BoxVecItr</a> bit;
        <span class="keywordtype">double</span> jacketVol = 0;
        <span class="keywordflow">for</span> (bit = jacketBoxes.begin(); bit &lt; jacketBoxes.end(); bit++) {
            jacketVol += <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a> (*bit);
        }
        <span class="keywordflow">return</span> jacketVol;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa42de2dd7951c3fa60ab9e95ebf0c4aa"></a><!-- doxytag: member="subpavings::SPnode::vtkPaving" ref="aa42de2dd7951c3fa60ab9e95ebf0c4aa" args="(const std::string filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#aa42de2dd7951c3fa60ab9e95ebf0c4aa">subpavings::SPnode::vtkPaving</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a subpaving from vtk file data. </p>
<p>Expects a file of structured point vtk data, with 10 header lines, spacing on 4th line, and 255 signifying voxel in the image. Uses MakeTreeFromVoxels(...)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>is the name of the file to get the vtk data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the root node of a new tree (can be null). </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l01957">1957</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="namespacesubpavings.shtml#ab55a3f1bfa1cae218886328f19b2208f">subpavings::getCoordinatesFromVtk()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">makeTreeFromVoxels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">setNodeName()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* newTree = NULL;

        <span class="keywordtype">size_t</span> expectedDims = 3;

        <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> Xs;
        <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> Ys;
        <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> Zs;

        <span class="comment">// get the spacing and fill in the coordinates vectors using</span>
        <span class="comment">// getCoordinatesFromVtk.</span>
        <span class="comment">// getCoordinatesFromVtk expects 10 header lines with spacings on 4th</span>
        <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> spacing = <a class="code" href="namespacesubpavings.shtml#ab55a3f1bfa1cae218886328f19b2208f" title="Get coordinates from a .vtk file.">getCoordinatesFromVtk</a>(Xs, Ys, Zs, filename);
        <span class="keywordtype">bool</span> success = ((spacing.size() == expectedDims) &amp;&amp; (spacing[0] &gt; 0)
                                &amp;&amp; (spacing[0] == spacing[1])
                                &amp;&amp; (spacing[0] == spacing[2]));

        <span class="keywordflow">if</span> (success) {

            ivector rootbox(expectedDims);

            <span class="keywordtype">double</span> maxXYZ = spacing[0] * 1.0;

            <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> boxes;

            <span class="keywordtype">double</span> totalListVol = 0;

            <a class="code" href="namespacesubpavings.shtml#ac37614ffc671c9e95013493ff9dc5137" title="Define type IntVecItr as iterator over IntVec.">IntVecItr</a> xIt = Xs.begin();
            <a class="code" href="namespacesubpavings.shtml#ac37614ffc671c9e95013493ff9dc5137" title="Define type IntVecItr as iterator over IntVec.">IntVecItr</a> yIt = Ys.begin();
            <a class="code" href="namespacesubpavings.shtml#ac37614ffc671c9e95013493ff9dc5137" title="Define type IntVecItr as iterator over IntVec.">IntVecItr</a> zIt = Zs.begin();

            <span class="keywordflow">for</span> (xIt = Xs.begin(); xIt &lt; Xs.end(); xIt++, yIt++, zIt++) {
                ivector box(expectedDims);
                <span class="comment">// make the box so that its boundaries are on the inner edges</span>
                <span class="comment">// of the voxel</span>
                interval xdim(Sup(_interval(*xIt/maxXYZ)),
                            Inf(_interval(*xIt + 1.0)/maxXYZ));
                interval ydim(Sup(_interval(*yIt/maxXYZ)),
                            Inf(_interval(*yIt + 1.0)/maxXYZ));
                interval zdim(Sup(_interval(*zIt/maxXYZ)),
                            Inf(_interval(*zIt + 1.0)/maxXYZ));
                box[1] = xdim;
                box[2] = ydim;
                box[3] = zdim;
                boxes.push_back(box);
                totalListVol += <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(box);

            }

            rootbox[1] = interval(0.0, 1.0);
            rootbox[2] = interval(0.0, 1.0);
            rootbox[3] = interval(0.0, 1.0);


            newTree = <a class="code" href="classsubpavings_1_1SPnode.shtml#a4e11f6bd7a176b33a25f3700751c4a08" title="Forms a minimal SPnode subpaving from voxel boxes.">makeTreeFromVoxels</a>(rootbox, boxes,
                                        maxXYZ, expectedDims);
        }

        <span class="keywordflow">if</span> (newTree != NULL) {
            newTree-&gt;setNodeName(<span class="stringliteral">&quot;X&quot;</span>);
            newTree-&gt;recursiveRename();
        }


        <span class="keywordflow">return</span> newTree;
    }
</pre></div>
</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a5e79ff65a692b09c98ff53264ddfba9f"></a><!-- doxytag: member="subpavings::SPnode::ImageSp" ref="a5e79ff65a692b09c98ff53264ddfba9f" args="(PIVF f, SPnode *spn, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#a5e79ff65a692b09c98ff53264ddfba9f">ImageSp</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creation of image subpaving with Interval Analysis. </p>
<p>ImageSp uses <a class="el" href="namespacesubpavings.shtml#a9d7eaadb31b3f9c2a28ad4af1f977a15" title="Mince up a subpaving.">Mince()</a> to chop up spn and then <a class="el" href="namespacesubpavings.shtml#aa47cfd8c78e0be2e255006d743ffd214" title="Evalutes images of subpaving.">Evaluate()</a> and <a class="el" href="namespacesubpavings.shtml#a331c50e79d716580fed8a900bfee2b1a" title="Forms a minimal image subpaving.">Regularize()</a> to find a regular minimal subpaving covering the set of images of the boxes of the minced spn.</p>
<p>ImageSp is now a non-friend non-member function (compare to <a class="el" href="classAIASPnode.shtml#aa860838286031ef8164937725092a2c2" title="Creation of an image subpaving (ImageSp) with Interval Analysis from AIA2001.">AIASPnode::ImageSp()</a>) which now uses public member functions in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a (*PIVF) which specifies the inclusion function of f and returns the inclusion function image [f][x] of an interval vector [x]. </td></tr>
    <tr><td class="paramname">spn</td><td>the subpaving for which we wish to find a subpaving covering the image under f. </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal regular subpaving covering the image of a subpaving under some function f. </dd></dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00214">214</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> images;
        ivector hull;

        <span class="keywordflow">try</span> {

            <a class="code" href="namespacesubpavings.shtml#a9d7eaadb31b3f9c2a28ad4af1f977a15" title="Mince up a subpaving.">Mince</a>(spn, eps);

            <a class="code" href="namespacesubpavings.shtml#aa47cfd8c78e0be2e255006d743ffd214" title="Evalutes images of subpaving.">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, spn, images, hull);

            <span class="comment">/* the output of eval is not included in the AIA examples,</span>
<span class="comment">            but it makes an interesting comparison to final subpaving */</span>
            ofstream os2(<span class="stringliteral">&quot;eval.txt&quot;</span>);            <span class="comment">// Filename</span>
            list&lt;ivector&gt;::iterator it;
            <span class="keywordflow">for</span> (it=images.begin(); it!=images.end(); it++) {
                ivector box = *it;
                os2 &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(box[1]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(box[1])
                    &lt;&lt; <span class="stringliteral">&quot; ] , [ &quot;</span> &lt;&lt; Inf(box[2]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>
                    &lt;&lt; Sup(box[2]) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span> &lt;&lt;  endl;
            }
            <span class="comment">// end of difference from AIA examples</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
        {
            <span class="keywordtype">string</span> msg(ba.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in ImageSp&quot;</span> &lt;&lt; std::endl;
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
        }
        <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
            <span class="keywordtype">string</span> msg(spe.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in ImageSp: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordtype">string</span> msg(e.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in ImageSp: original error &quot;</span> &lt;&lt; msg &lt;&lt; endl;
        }

        <span class="comment">// make a minimal subpaving out of images, with root box hull</span>
        <span class="keywordflow">return</span> (Regularize&lt;SPnode&gt;(hull, images, eps));

    }
</pre></div>
</div>
</div>
<a class="anchor" id="adda5afc72873dc3875f341ecbb947b23"></a><!-- doxytag: member="subpavings::SPnode::ImageSpNonMinimal" ref="adda5afc72873dc3875f341ecbb947b23" args="(PIVF f, SPnode *spn, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#adda5afc72873dc3875f341ecbb947b23">ImageSpNonMinimal</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creation of non-minimal image subpaving with Interval Analysis. </p>
<p>ImageSpNonMinimal uses <a class="el" href="namespacesubpavings.shtml#a9d7eaadb31b3f9c2a28ad4af1f977a15" title="Mince up a subpaving.">Mince()</a> to chop up spn and then <a class="el" href="namespacesubpavings.shtml#aa47cfd8c78e0be2e255006d743ffd214" title="Evalutes images of subpaving.">Evaluate()</a> and <a class="el" href="namespacesubpavings.shtml#ab59f7407c562f2b1b4f051e479c9736f" title="Forms a non-minimal image subpaving.">RegularizeNonMinimal()</a> to find a regular non-minimal subpaving covering the set of images of the boxes of the minced spn. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a (*PIVF) which specifies the inclusion function of f and returns the inclusion function image [f][x] of an interval vector [x]. </td></tr>
    <tr><td class="paramname">spn</td><td>the subpaving for which we wish to find a subpaving covering the image under f. </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non-minimal regular subpaving covering the image of a subpaving under some function f. </dd></dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00263">263</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> images;
        ivector hull;

        <span class="keywordflow">try</span> {

            <a class="code" href="namespacesubpavings.shtml#a9d7eaadb31b3f9c2a28ad4af1f977a15" title="Mince up a subpaving.">Mince</a>(spn, eps);

            <a class="code" href="namespacesubpavings.shtml#aa47cfd8c78e0be2e255006d743ffd214" title="Evalutes images of subpaving.">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, spn, images, hull);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
        {
            <span class="keywordtype">string</span> msg(ba.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in ImageSpNonMinimal&quot;</span>
                                                &lt;&lt; std::endl;
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
        }
        <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
            <span class="keywordtype">string</span> msg(spe.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in ImageSpNonMinimal: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordtype">string</span> msg(e.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in ImageSpNonMinimal: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }

        <span class="comment">// make a non-minimal subpaving from images,</span>
        <span class="comment">// with root box hull</span>
        <span class="keywordflow">return</span> (RegularizeNonMinimal&lt;SPnode&gt;(hull, images, eps));

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ace7e46329dbdb96110f7f24bba46ee93"></a><!-- doxytag: member="subpavings::SPnode::Sivia" ref="ace7e46329dbdb96110f7f24bba46ee93" args="(PIBT BoolTest, const SPnode *const toInvert, SPnode *const search, const double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * <a class="el" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93">Sivia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a4ca48fac31a3dcc26d5b51b1ee3cd0d9">PIBT</a>&#160;</td>
          <td class="paramname"><em>BoolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>toInvert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set Inversion Via Interval Analysis. </p>
<p>SIVIA progressively subdivides the boxes of the initial search subpaving and calls itself recursively to select or reject or retest the resulting subpavings until the desired level of precision, specified by eps, in forming the subpaving to be returned has been achieved.</p>
<p>Sivia is now a non-friend non-member function (compare to <a class="el" href="classAIASPnode.shtml#a7ca818aa239136500bfc1020684160de" title="Set Inversion Via Interval Analysis method taken from AIA2001.">AIASPnode::Sivia()</a>) which now uses public member functions in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">BoolTest</td><td>a (*PIBT)() which specifies the inclusion function of f and tests the inclusion function image [f][x] of an interval vector [x] for containment in an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>. </td></tr>
    <tr><td class="paramname">toInvert</td><td>the subpaving we are attempting to find the reciprocal image of, the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> passed to BoolTest </td></tr>
    <tr><td class="paramname">search</td><td>a subpaving whose box forms the interval vector passed to BoolTest. </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal regular subpaving covering the reciprocal image of toInvert under some function f. </dd></dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">97</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">Sivia()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>* newNode = NULL;  <span class="comment">// for return value</span>

        <span class="keywordflow">try</span> {
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> test = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;

            <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>(search)) { <span class="comment">// if search is not null or empty</span>

                <span class="comment">// test the box of the given searchsubpaving</span>
                <span class="comment">// using given test (gives f) and given image to invert</span>
                test = BoolTest(search-&gt;getBox(), toInvert);
            }

            <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>(search) &amp;&amp; test!=<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>) {

                <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// for MaxDiam() below</span>

                <span class="keywordtype">double</span> boxMaxDiam = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(search-&gt;getBox(), maxdiamcomp);

                <span class="comment">// we know that the test was not BI_FALSE,</span>
                <span class="comment">// so it could be BI_TRUE or BI_INDET</span>
                <span class="comment">// if it is BI_INDET and the box maximum diameter</span>
                <span class="comment">// is &gt;= eps then we keep trying to expand</span>
                <span class="keywordflow">if</span> (test==<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a> || boxMaxDiam &lt; eps) {

                    newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*search);
                }

                <span class="comment">// if test is BI_INDET and the box maximum diameter</span>
                <span class="comment">// is &gt;= eps then we keep trying to expand</span>
                <span class="keywordflow">else</span>  {

                    <span class="comment">// expand search if search is a leaf</span>
                    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>(search)) <a class="code" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a" title="Expand a leaf node to have two child nodes.">Expand</a>(search,
                                            maxdiamcomp);

                    <span class="comment">// ReUnite is used to get a minimal subpaving</span>
                    <span class="comment">// from merging two subpavings</span>
                    newNode = Reunite&lt;SPnode&gt;(
                                <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(BoolTest, toInvert,
                                search-&gt;getLeftChild(), eps),
                            <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(BoolTest, toInvert,
                            search-&gt;getRightChild(), eps),
                                            search-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>());
                }


            } <span class="comment">// end !isEmpty(search) &amp;&amp; test!=BI_FALSE</span>

            <span class="comment">// if isEmpty(search) or test==BI_FALSE,</span>
            <span class="comment">// newNode will be the initialisation value of NULL</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
        {
            <span class="keywordtype">string</span> msg(ba.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in Sivia&quot;</span> &lt;&lt; std::endl;
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
        }
        <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
            <span class="keywordtype">string</span> msg(spe.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in Sivia: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordtype">string</span> msg(e.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in Sivia: original error &quot;</span> &lt;&lt; msg &lt;&lt; endl;
        }

        <span class="keywordflow">return</span> newNode;
    }
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ac28ce64cdc1aed5e545659699a38c16e"></a><!-- doxytag: member="subpavings::SPnode::dimension" ref="ac28ce64cdc1aed5e545659699a38c16e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e">subpavings::SPnode::dimension</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The dimensions in which we are working. </p>
<p>ie the dimensions of theBox.</p>
<p>This data member is not present in the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00098">98</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01389">subpavings::SPSVnode::getChebDistCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01561">subpavings::SPSnode::getChebDistCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01370">subpavings::SPSVnode::getChebDistMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01542">subpavings::SPSnode::getChebDistMean()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00382">getDimension()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">subpavings::SPSVnode::getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">subpavings::SPSnode::getHellingerDist()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01267">subpavings::SPSVnode::getMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01499">subpavings::SPSnode::getMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01356">subpavings::SPSVnode::getUniformMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01528">subpavings::SPSnode::getUniformMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01739">subpavings::SPSVnode::getUniformVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01969">subpavings::SPSnode::getUniformVarCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01294">subpavings::SPSVnode::getVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01903">subpavings::SPSnode::getVarCovar()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00237">SPnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a4add69f42780515a4f817f02770e38cb"></a><!-- doxytag: member="subpavings::SPnode::label" ref="a4add69f42780515a4f817f02770e38cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb">subpavings::SPnode::label</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The label for the box. </p>
<p>Box labels are used if we need to distinguish between boxes generated by/for different situations. The label defaults to 0 if it is not specified. This allows us to have model-label specific processes.</p>
<p>This data member is not present in the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00109">109</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">getLabel()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00899">leafOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">subpavings::CollatorSPnode::nodeReunite()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01377">nodeReunite()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01960">subpavings::SPSVnode::nodeReunite()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02925">subpavings::SPSnode::nodeReunite()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00411">setLabel()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00960">subpavings::SPSnode::strippedConstructor()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c047856140d3143bec18abc584c2646"></a><!-- doxytag: member="subpavings::SPnode::leftChild" ref="a5c047856140d3143bec18abc584c2646" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>* <a class="el" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646">subpavings::SPnode::leftChild</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The node's left child. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00120">120</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">subpavings::CollatorSPnode::dotDiffPaving()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">subpavings::RealMappedSPnode::getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">subpavings::CollatorSPnode::getLeftChild()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00225">subpavings::MappedSPnode&lt; cxsc::real &gt;::getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">subpavings::CollatorSPVnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">getLeftChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">subpavings::SPSVnode::insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">subpavings::SPSnode::insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01363">nodeReabsorbChildren()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">subpavings::SPSVnode::nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">subpavings::SPSnode::nodeReabsorbChildren()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">subpavings::CollatorSPVnode::nodesReunite()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">spContains()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00268">SPnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">subpavings::SPSnode::SPSnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02125">swap()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00295">~SPnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a90803dc066d955d4aec89c00879ff610"></a><!-- doxytag: member="subpavings::SPnode::nodeName" ref="a90803dc066d955d4aec89c00879ff610" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610">subpavings::SPnode::nodeName</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The name given to the node. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00128">128</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00621">getLeafNodeLevels()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00720">getNodeDepth()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">getNodeName()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01122">subpavings::SPSnode::isSplittableNode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01348">subpavings::CollatorSPnode::leafAccumulationOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">subpavings::CollatorSPVnode::leafOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00607">subpavings::CollatorSPnode::leafOutputTabs()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01005">subpavings::MappedSPnode&lt; cxsc::real &gt;::leafOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">subpavings::CollatorSPnode::makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">subpavings::CollatorSPVnode::makeAverageCollation()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">subpavings::CollatorSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">subpavings::CollatorSPVnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00977">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodePrint()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01005">outputGraphDot()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">recursiveRename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">setNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">subpavings::SPSnode::SPSnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">subpavings::SPSnode::strippedConstructor()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02125">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ad39c8dad1a8fa89110da4bad250521d8"></a><!-- doxytag: member="subpavings::SPnode::parent" ref="ad39c8dad1a8fa89110da4bad250521d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>* <a class="el" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8">subpavings::SPnode::parent</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The node's parent. </p>
<p>This data member is not present in the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class. This allows us to go up from the child node to its parent. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00116">116</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00211">subpavings::RealMappedSPnode::getParent()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00218">subpavings::MappedSPnode&lt; cxsc::real &gt;::getParent()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00548">subpavings::CollatorSPnode::getParent()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00498">subpavings::CollatorSPVnode::getParent()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00396">getParent()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00915">subpavings::SPSVnode::getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01029">subpavings::SPSnode::getParent()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01238">subpavings::SPSVnode::getRootCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">subpavings::SPSnode::getRootCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01252">subpavings::SPSVnode::getRootVcounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">hasLeafSibling()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">subpavings::SPSnode::leavesOutputTabsWithEMPs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02488">subpavings::SPSnode::leavesOutputTabsWithHistHeightAndEMPs()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01043">nodeContains()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02184">subpavings::SPSVnode::nodeContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02568">subpavings::SPSnode::nodeContains()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01551">splitRootToShape()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00373">subpavings::MappedSPnode&lt; cxsc::real &gt;::splitToShape()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00268">SPnode()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02125">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d5e29412292750e36196b55e186b6dd"></a><!-- doxytag: member="subpavings::SPnode::rightChild" ref="a4d5e29412292750e36196b55e186b6dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>* <a class="el" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd">subpavings::SPnode::rightChild</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The node's right child. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00124">124</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">subpavings::RealMappedSPnode::_marginalise()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">subpavings::CollatorSPnode::dotDiffPaving()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">subpavings::RealMappedSPnode::getRightChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">subpavings::CollatorSPnode::getRightChild()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00232">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRightChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">subpavings::CollatorSPVnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">getRightChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">subpavings::SPSVnode::insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">subpavings::SPSnode::insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">isLeaf()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01305">nodeExpand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01363">nodeReabsorbChildren()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">subpavings::SPSVnode::nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">subpavings::SPSnode::nodeReabsorbChildren()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">subpavings::CollatorSPVnode::nodesReunite()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01088">spContains()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00268">SPnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">subpavings::SPSnode::SPSnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02125">swap()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00295">~SPnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c09d2f687401550468bad6a6dae9832"></a><!-- doxytag: member="subpavings::SPnode::theBox" ref="a2c09d2f687401550468bad6a6dae9832" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector* <a class="el" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832">subpavings::SPnode::theBox</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to the interval vector the node represents. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00090">90</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">subpavings::CollatorSPnode::addPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">getBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01346">subpavings::CollatorSPVnode::getSplitNodePtrCSPV()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">isEmpty()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01348">subpavings::CollatorSPnode::leafAccumulationOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01408">subpavings::CollatorSPnode::leafMakeNewFhat()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">subpavings::CollatorSPVnode::leafOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00607">subpavings::CollatorSPnode::leafOutputTabs()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00899">leafOutputTabs()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01005">subpavings::MappedSPnode&lt; cxsc::real &gt;::leafOutputTabs()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">nodeAddRight()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">subpavings::RealMappedSPnode::nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00726">subpavings::CollatorSPVnode::nodePrint()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00677">subpavings::CollatorSPnode::nodePrint()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00877">nodePrint()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01765">subpavings::SPSVnode::nodePrint()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00977">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodePrint()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01995">subpavings::SPSnode::nodePrint()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">subpavings::CollatorSPnode::nodeReunite()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01377">nodeReunite()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01960">subpavings::SPSVnode::nodeReunite()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02925">subpavings::SPSnode::nodeReunite()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeStringSummary()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">subpavings::CollatorSPnode::operator=()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">subpavings::CollatorSPVnode::operator=()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00301">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">subpavings::SPSnode::operator=()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00373">subpavings::MappedSPnode&lt; cxsc::real &gt;::splitToShape()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00195">SPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02125">swap()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00295">~SPnode()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a></li>
<li><a class="el" href="spalgorithms_8hpp_source.shtml">spalgorithms.hpp</a></li>
<li><a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:41 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
