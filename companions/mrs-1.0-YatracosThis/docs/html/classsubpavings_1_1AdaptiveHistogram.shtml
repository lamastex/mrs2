<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::AdaptiveHistogram Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1AdaptiveHistogram.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::AdaptiveHistogram Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::AdaptiveHistogram" -->
<p>A wrapper or manager for an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> aka StatsSubPaving in conjunction with massive amounts of sample data.  
 <a href="classsubpavings_1_1AdaptiveHistogram.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::AdaptiveHistogram:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1AdaptiveHistogram__coll__graph.png" border="0" usemap="#subpavings_1_1AdaptiveHistogram_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1AdaptiveHistogram_coll__map" id="subpavings_1_1AdaptiveHistogram_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1AdaptiveHistogram-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa863ff24ef4af6b084f515f702bbe09e">AdaptiveHistogram</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aa863ff24ef4af6b084f515f702bbe09e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8155be0403adb23fe8c4232f95eb47f6">AdaptiveHistogram</a> (bool as)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a8155be0403adb23fe8c4232f95eb47f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a54d9dd37b5a2d71ee4e94f2154140b44">AdaptiveHistogram</a> (ivector &amp;v, bool as=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a54d9dd37b5a2d71ee4e94f2154140b44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a512fa91574e1dbb992a6edcb77bf56c1">AdaptiveHistogram</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a512fa91574e1dbb992a6edcb77bf56c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3adb7a4fce51ec497ef30dea633249fd">operator=</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a3adb7a4fce51ec497ef30dea633249fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a962f179df0a65d5f179930d00e65b70e">operator+</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded addition operator.  <a href="#a962f179df0a65d5f179930d00e65b70e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa11b3ed173c858fec6234c7e0b9d9829">~AdaptiveHistogram</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa11b3ed173c858fec6234c7e0b9d9829"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb">getSubPaving</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> this manages.  <a href="#aecbdfe366fa381c0b3f7a7b00447dedb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adc2a97bb7f8fc3c543f90ba876515ca1">getLabel</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the label for this.  <a href="#adc2a97bb7f8fc3c543f90ba876515ca1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a95d9506c9ceea0359b99b0e36f1eff91">getRootPavingMean</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mean from the root box of the paving this manages.  <a href="#a95d9506c9ceea0359b99b0e36f1eff91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2bbfcf884ee91c2457eb2e9d2b81e31f">getRootPavingVarCovar</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets variance covariance vector from root box of rootpaving.  <a href="#a2bbfcf884ee91c2457eb2e9d2b81e31f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a7386f85d1182ae6e3f32766c4a208c11">getRootCounter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets count in the root paving.  <a href="#a7386f85d1182ae6e3f32766c4a208c11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35">getRootLeaves</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of leaf nodes in the root paving.  <a href="#ae4a71d928009eda0a6332f20fd951e35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ac7f7cb4d5aea17c967afec84e1159f9b">getRootSumLeafCountOverVol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sum of leaf count over volume in root paving.  <a href="#ac7f7cb4d5aea17c967afec84e1159f9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb0bda49b3a39ab8aa53737de810afec">getEMPScoreCOPERR</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the EMP part of the COPERR score.  <a href="#afb0bda49b3a39ab8aa53737de810afec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a71b9bb96936f8e5f6a298c6d1a382e0b">getEMPScoreAIC</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the EMP part of the AIC score.  <a href="#a71b9bb96936f8e5f6a298c6d1a382e0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a94e90e67d767c5e0ad7b4378e0a72cad">getScoreCOPERR</a> (const <a class="el" href="classsubpavings_1_1PenObj.shtml">PenObj</a> &amp;pen, bool verbose=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the COPERR score.  <a href="#a94e90e67d767c5e0ad7b4378e0a72cad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8333360139bee06eb9c661b8a47cb4a3">getScoreAIC</a> (const <a class="el" href="classsubpavings_1_1PenObj.shtml">PenObj</a> &amp;pen, bool verbose=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get AIC score.  <a href="#a8333360139bee06eb9c661b8a47cb4a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765">getPENValue</a> (const <a class="el" href="classsubpavings_1_1PenObj.shtml">PenObj</a> &amp;pen, int deltaLeaf=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the PEN value.  <a href="#acb7aa3bb3a7b4d4691e9b5b9c9d4a765"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0ef2d251d61753086a358bdd9bda057f">getMinVol</a> (double minVolB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of the minimum volume for a splittable node.  <a href="#a0ef2d251d61753086a358bdd9bda057f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae90ad88f52691280d18f4b6f2e3b7ad1">getHoldAllStats</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of holdAllStats field.  <a href="#ae90ad88f52691280d18f4b6f2e3b7ad1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaf5eac63bd232e3e76f20a27587c8784">hasSubPaving</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether this has a subpaving to manage.  <a href="#aaf5eac63bd232e3e76f20a27587c8784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a936a3426494278163afada104df26ecc">getRootBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the box of the subpaving managed by this.  <a href="#a936a3426494278163afada104df26ecc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a70f9af80f0ee875d6dcbfd4cafb53813">getLeafLevels</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaffb116a24a6de03482a8bfd9625b07f">getLeafCounts</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f">outputLog</a> (const std::string &amp;s, const int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append current state of histogram to a txt log file.  <a href="#a8e1ee4de108b97c04c38ccb16c392e5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aafef86d6e4482aef11de75b83cfb4345">insertOne</a> (rvector newdata, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a single data point into <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object.  <a href="#aafef86d6e4482aef11de75b83cfb4345"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4c8d2603da121585e049548baca3c712">priorityMerge</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority merge to reduce number of leaves in histogram.  <a href="#a4c8d2603da121585e049548baca3c712"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a745b6edb93463e227edb9c9aa1dcb505">mergeUp</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a multileaf histogram up to just root box.  <a href="#a745b6edb93463e227edb9c9aa1dcb505"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afac8c0cb4ed44f27e7a3adf1855af676">splitToShape</a> (std::string instruction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a histogram to a specified shape.  <a href="#afac8c0cb4ed44f27e7a3adf1855af676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a733cc04938b2236087cbbe0384985c3d">MCMC</a> (unsigned int loops, unsigned int burnin, unsigned int thinout, <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;proposal, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior, size_t minPoints=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputting MCMC samples from histogram state space.  <a href="#a733cc04938b2236087cbbe0384985c3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aac9ce6681faa011b3c314ff400056dd9">MCMCsamples</a> (std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;samples, unsigned int loops, unsigned int burnin, unsigned int thinout, <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;proposal, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior, size_t minPoints, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generating MCMC samples from histogram state space.  <a href="#aac9ce6681faa011b3c314ff400056dd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0163eb023d0db24e0d91864a38acd562">publicOutputMCMCStateSample</a> (int ci, int i, bool confirm=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af41faeb2742df1aaa5108f17dee54d71">publicLogMCMCSample</a> (std::string s, int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2e95f7f1a9dab963a28a7d3a655e0e8f">changeMCMCState</a> (<a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;nodes, size_t &amp;numLeaves, size_t &amp;numCherries, <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;proposal, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior, size_t minPoints, gsl_rng *rgsl, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, std::string s, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the state of this Adaptive Histogram using MCMC process.  <a href="#a2e95f7f1a9dab963a28a7d3a655e0e8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a845c591145a1abc86d7d0e1d33c26e22">outputGraphDot</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a .dot graph file from histogram structure.  <a href="#a845c591145a1abc86d7d0e1d33c26e22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a49a8ff01e1398420cd45642d5b1d3106">outputToTxtTabs</a> (const std::string &amp;s, bool confirm=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the subpaving managed by this to a txt file.  <a href="#a49a8ff01e1398420cd45642d5b1d3106"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2fb89e060574b8c935191cd3afd91290">outputToTxtTabsWithEMPs</a> (const std::string &amp;s, bool confirm=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the subpaving managed by this to a txt file.  <a href="#a2fb89e060574b8c935191cd3afd91290"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a35416eefb965755a846e1bb64c882439">outputRootToTxt</a> (const std::string &amp;s, bool confirm=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output details of full sample (from root) to txt tile.  <a href="#a35416eefb965755a846e1bb64c882439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1cb13fa570de75efab3b9c4b862d200e">reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml">PiecewiseConstantFunction</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change this so that the subpaving it manages is the union of this's subpaving and the subpaving of that of a <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a>.  <a href="#a1cb13fa570de75efab3b9c4b862d200e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a9e30e2969e3ad675b8659470200219d4">reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml">PiecewiseConstantFunction</a> &amp;other, size_t minChildPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change this so that the subpaving it manages is as close as possible to the union of this's subpaving and the subpaving of that of a <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a>.  <a href="#a9e30e2969e3ad675b8659470200219d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8f3844b0b56fb1aaa96c44558dd8e4a4">makeEmpty</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the histogram's data and counters.  <a href="#a8f3844b0b56fb1aaa96c44558dd8e4a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa0b81dd06668d2ce34e3fe983a2a2913">findDensityRegion</a> (double cov, double weightPM, vector&lt; <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * &gt; &amp;covNodes, string covFileName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the coverage of the boxes in an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>.  <a href="#aa0b81dd06668d2ce34e3fe983a2a2913"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa73a46279c3f591d298a0180d99723a5">outputLogPlain</a> (const std::string &amp;s, const int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append current state of histogram to a txt log file.  <a href="#aa73a46279c3f591d298a0180d99723a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a438e2252f954f0556fa2bd7c2e105dbe">checkStopCrit</a> (double StopCritCurrent, double StopCritPrevious, int &amp;Prev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a809928eec642c22761a2f9b3b8061d47">swap</a> (<a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;adh)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the contents of this and another histogram.  <a href="#a809928eec642c22761a2f9b3b8061d47"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert 1-d data from txt file into AdaptiveHistogram object.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A group of overloaded versions of a functions which read in lines of data representing doubles or integers from a txt file.</p>
<p>Expects one integer or double per line. No input validation or checking. Rejects lines with input that cannot be converted to integer or double. Ignore any extra 'words' on the line (anything after first white space)</p>
<p>For example, a string "12.04 1.00005e-10 -30.0006" will be read as a 12.04. A string "30 abc 12.04.0006" will be read as 30, and a string "abc 30 12.04.0006" will be rejected.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to read data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A file with filename s in the same directory as <a class="el" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> or with the filename incorporating directory location. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">headerlines</td><td>is number of headerlines to skip before reading data. Defaults to 0. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false if txt file cannot be read, is empty, or if something failed in after data is read and when it is being inserted. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a11051ee818f2d6fb2631573e47ed73b8">insertOneDimDataFromTxt</a> (const std::string &amp;s, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aef10187eeb8d449b8692c355960aefe0">insertOneDimDataFromTxt</a> (const std::string &amp;s, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert doubles in a txt file into AdaptiveHistogram object.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A group of overloaded versions of a functions which read in lines of data representing doubles from a txt file.</p>
<p>Expects one integer or double per line. No input validation or checking. Can deal with doubles with no decimal point. Rejects lines with input that cannot be converted to double. Ignore any extra 'words' on the line (anything after first white space)</p>
<p>For example, a string "12.04 1.00005e-10 -30.0006" will be read as a 12.04. A string "30 abc 12.04.0006" will be read as 30, and a string "abc 30 12.04.0006" will be rejected.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.shtml#_deprecated000001">Deprecated:</a></b></dt><dd>Function kept for backwards compatibility, effectively replaced by insertOneDimDataFromTxt.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to read data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A file with filename s in the same directory as <a class="el" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> or with the filename incorporating directory location. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">headerlines</td><td>is number of headerlines to skip before reading data. Defaults to 0. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false if txt file cannot be read, is empty, or if something failed in after data is read and when it is being inserted. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3705758c35dbfe8745a2e34c83b7f619">insertDoublesFromTxt</a> (const std::string &amp;s, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3e03076ea91599538bcc69f47084f649">insertDoublesFromTxt</a> (const std::string &amp;s, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert rvectors in a txt file into AdaptiveHistogram object.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A group of overloaded functions which read in lines of data representing rvectors from a txt file. The dimensions of the rvector are deduced from the input format and all the data then expected to have the same dimension. Any data not matching the expected dimensions, based on assessing the first valid line found, will be rejected. Expects one line per rvector with the elements separated by white space (space or tabs), with no non-numeric characters. Carries out some basic data checking through <a class="el" href="namespacesubpavings.shtml#af62c725dd362922c15d45983e2d8f6cf" title="A quick check on a data string: expecting only numbers white space or decimal points.">checkString()</a>. Input lines which do not pass are printed to standard output with an error message but the entire file will continue to be processed and valid lines converted to rvectors which are stored in theData. Conversion to rvectors is via the cxsc::operator&lt;&lt; which allows an rvector to be constructed from a stream.</p>
<p>Can read 1-d rvector data from doubles or floats but insists on a decimal point in each number (otherwise the number is rejected).</p>
<p>For example, a string "12.04 1.00005e-10 -30.0006" will be read as a 3-dimensional rvector, a string "-30.0006" will be read as a 1-dimensional rvector and a string "30" will be rejected.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to read data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">headerlines</td><td>is number of headerlines to skip before reading data. Defaults to 0. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging) </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A file with filename s in the same directory as <a class="el" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> or with the filename incorporating directory location. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false if txt file cannot be read, is empty, or contains no valid data, or if something failed after data is read and when it is being inserted. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aff1b74eb52546adb9d7d64a84d739efe">insertRvectorsFromTxt</a> (const std::string &amp;s, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5decf91161cbddd77c21e3b25dd12689">insertRvectorsFromTxt</a> (const std::string &amp;s, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert all rvectors from a container of rvectors.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rvec</td><td>is the container of rvectors to get data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false if there are no labeled points with the specified label in the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b8604eb7b87dd03d09736a2f9e4b96a">insertFromRVec</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert a set number of rvectors from a container.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The overloaded versions which take a random number generator as a parameter can be used to take successive samples from the same container. Otherwise the random number generator is created and destroyed during the scope of the function and repeating the identical function call will produce an identical sample from the container.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">samplesize</td><td>the size of the sample to draw. </td></tr>
    <tr><td class="paramname">gsl_rng</td><td>* rgsl is a random number generator. </td></tr>
    <tr><td class="paramname">seed</td><td>is a seed for a random number generator. </td></tr>
    <tr><td class="paramname">rvec</td><td>the container to get data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false otherwise. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">insertSampleFromRVec</a> (size_t samplesize, gsl_rng *rgsl, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a754142aca6681e39debd7167146a7e1c">insertSampleFromRVec</a> (size_t samplesize, int seed, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aeca515a5f969a1f368ba1fe0390aa047">insertSampleFromRVec</a> (size_t samplesize, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2f6d7ee0d83ea148f57543f64905170d">insertSampleFromRVec</a> (size_t samplesize, gsl_rng *rgsl, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8db299e8725f5170475a4c77524140dc">insertSampleFromRVec</a> (size_t samplesize, int seed, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab889a33f8caa8fb44836f756c0be342d">insertSampleFromRVec</a> (size_t samplesize, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert all rvectors from an RSSample object.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Insert rvectors from the labeled point Samples of an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object where the label for the point matches the label specified as a argument to the function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rss</td><td>the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object to get data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file. </td></tr>
    <tr><td class="paramname">label</td><td>the label for the labeled points in the rss.Samples that we want to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false if there are no labeled points with the specified label in the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">insertFromRSSample</a> (const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a20ee07940112174415c391b4ed385ba1">insertFromRSSample</a> (const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert a set number of rvectors from an RSSample object.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Insert a set number of rvectors from the labeled point Samples of an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object where the label for the point matches the label specified as a argument to the function. Sampling is random with replacement.</p>
<p>The overloaded versions which take a random number generator as a parameter can be used to take successive samples from the same <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. Otherwise the random number generator is created and destroyed during the scope of the function and repeating the identical function call will produce an identical sample from the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">samplesize</td><td>the size of the sample to draw. </td></tr>
    <tr><td class="paramname">gsl_rng</td><td>* rgsl is a random number generator. </td></tr>
    <tr><td class="paramname">seed</td><td>is a seed for a random number generator. </td></tr>
    <tr><td class="paramname">rss</td><td>the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object to get data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">label</td><td>is the label for the labeled points in the rss.Samples which we want to sample from. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false if there are no labeled points with the specified label in the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">insertSampleFromRSSample</a> (size_t samplesize, gsl_rng *rgsl, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab41e19cc570fa35d9c867413a7398edc">insertSampleFromRSSample</a> (size_t samplesize, int seed, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a9468b46a614470017cc09cadd7699af8">insertSampleFromRSSample</a> (size_t samplesize, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad002844c2b0ef25eeb5fbc845fd8a000">insertSampleFromRSSample</a> (size_t samplesize, gsl_rng *rgsl, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8437c7aa645e4edc21a5bc4ec02db5ef">insertSampleFromRSSample</a> (size_t samplesize, int seed, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a78dd377090622826dd80734395fba635">insertSampleFromRSSample</a> (size_t samplesize, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, int label=0)</td></tr>
<tr><td colspan="2"><div class="groupHeader">prioritySplit methods.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods takes a histogram and progressively split using a priority queue to determine which node to split first. Splitting continues until some criteria applying either to individual nodes or to the histogram as a whole is satisfied, or there are no more splittable nodes.</p>
<p>Nodes are not considered to be splittable if they satisfy two criteria: First, their volume is greater than the minimum volume specified for the histogram as a whole, minVolB. Second if both prospective children would have at least the parameter minChildPoints data points associated with them.</p>
<p>If more than one node is equally 'large', on the basis of the node comparison compTest used, then a random choice is made between all equally large nodes to find the node which will be split.</p>
<p>The random number generator used for random selection between equally 'large' nodes uses a default seed to ensure that results can be replicated. If you are looking at distributions of results across mulitple histograms, supply the random number generator to the priority queue to ensure that each histogram will make different random choices.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compTest</td><td>is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. </td></tr>
    <tr><td class="paramname">he</td><td>is an instance of a class which provides a function to determine when to stop splitting. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points any prospective child must have for a leaf node to be splittable. </td></tr>
    <tr><td class="paramname">minVolB</td><td>is a multiplier applied to (log n)^2/n to give the the minimum volume for a splittable node. A node with volume &lt; minVolB(log n)^2/n is not splittable. Important with AIC or COPERR. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a gls random number generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the priority split was successful, false otherwise. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a123e69c185cb450a05ecdc7101c71548">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a04219b243723859e2939216181cbaddc">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab28cddbe199adccec104b223f8848712">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aea0d424449b7d93babef81d49bbbdb70">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad6a946d5c729b0f49d78962680d5d659">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a630b400683794cd527173b18eb126f84">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, gsl_rng *rgsl, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2154185722cd1d4f61f65c7d84d77f2b">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Distribution-free Likelihood Estimation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">RVecData</td><td>the observed data or </td></tr>
    <tr><td class="paramname"><a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a></td><td>the observed data </td></tr>
    <tr><td class="paramname">dx</td><td>is a user-defined dx - see AHABC meeting notes </td></tr>
    <tr><td class="paramname">WeightHist</td><td>weight for the histogram in model 1 </td></tr>
    <tr><td class="paramname">WeightsPM</td><td>weights for model 0 </td></tr>
    <tr><td class="paramname">wt</td><td>is the mass added to the histogram to ensure positive probability everywhere</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(log)-likelihood estimate </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a513472c79b4a9337dcb5445be825a8f3">getEstLogLikelihoodFromRSSample</a> (<a class="el" href="classRSSample.shtml">RSSample</a> &amp;labSampledData, double dx, double wt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca5143d5da261357d7f8d7eec45d1a5c">getEstLogLikelihoodFromRSSample</a> (<a class="el" href="classRSSample.shtml">RSSample</a> &amp;labSampledData, double dx, double wt, double WeightHist, std::map&lt; rvector, double, std::less&lt; rvector &gt; &gt; &amp;WeightsPM)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get the IAE of a distribution</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the integrated absolute error of the specified distribution. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">distr</td><td>is an integer that indicates which distribution is used. 1: bivariate gaussian distribution (not implemented yet) 2: Levy 2D distribution (not implemented yet) 3: Rosenbrock 2D distribution (not implemented yet) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the integrated absolute error for this realization </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a28b0435b5ee65b27b2459d3dc3fc224d">getIAE</a> (int distr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a368e5e9ed8cf0a3e82b30291c4a54d24">getFinMixIAE</a> (<a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#abf4e34e57ff3c76828457efaecbf4510">getFinMixIntervalIAE</a> (<a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, double tol, int deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b0b0c19870f67a07704458237cf19d0">get2DIAE</a> (<a class="el" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a>(*testpnt)(<a class="el" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a>, interval))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af7cf1131373c3e547a23d2db624ce8cf">getUnifIAE</a> (<a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3d403e99c1c471552303b2a7fd7e7d3e">getUnifIAE</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2427c16c05dc17a5d7ecb1e58f0d35ca">getLaplaceIntervalIAE</a> (double tol, int deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa595732ddb587933a166aee6cc0877f6">getLognormalIntervalIAE</a> (double tol, int deg)</td></tr>
<tr><td colspan="2"><div class="groupHeader">prioritySplit and getting the states using index from a distr</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Returns a <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> from the <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab3416e49bbb37e982e2e2f6a1ef13850">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3eab9e09fee0aa81bd19bf170cf23aea">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afee0931f38335b1d797680a0c9b6cfe5">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af4e1c9c71ca8835f8ee3a78204f63d49">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a761f68d3b8f183d4fda926732fda70f9">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8654a1a779b1c0e6d0dcec82f436efd6">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a36a5db0649767e9045cf985f52f985ca">prioritySplitGet</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;<a class="el" href="CatalanCoeff_8hpp.shtml#ac525a0f6dc3802f95ee1ea51f9be6826">States</a>, std::vector&lt; size_t &gt; &amp;Sampled)</td></tr>
<tr><td colspan="2"><div class="groupHeader">prioritySplit and getting likelihood*prior (which is proportional</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>to posterior) </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a024499e93cb4ca592c78b860d09cef79">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4c890ee5d86fc4cfd45c0ea2667b4a4f">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab4acf5596236ac6fa272cb3abe80bee8">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab38788117602e87f4e53a72b6c62747a">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8e2052a043fc9969084719da4338678">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af6cd725ab063a5c3af80d42315d99ddc">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5e8e56baf547e75fe1701b455fa92efb">prioritySplitMCMC</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td colspan="2"><div class="groupHeader">prioritySplitWithTotalVar methods.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4c7ccb75b629b131c7a448579386c6a9">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a435e13db001d1b919489507b81cb49ad">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae7e68baa3f16fafe3774df1f570aadcc">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the IAE between an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object and a <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>.  <a href="#ae7e68baa3f16fafe3774df1f570aadcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae80f3d62957c9c70a2b7eed4b1e11810">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a508b13326647eaa46806ca7999d303f2">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a39888154b396a7eb5fd6be1ff200a414">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#acab027b9f4718b0ba077b142375a05cb">prioritySplitWithTotalVar</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;HistAtValley, int simNum)</td></tr>
<tr><td colspan="2"><div class="groupHeader">prioritySplitWithSwitches methods.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0cd2e3af29feaad65d4a0a36738dcc15">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a39ff221f6d3dad036ba6d4f5ec0ae819">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa1b1ab0c522e46bc4bd0ab45547dea6b">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5299ade7c1d409621b2204a1986dabd8">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad2ae1c64a519c1d5f32f81d39210b738">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af9317b285f9a4f2753b1c9099347fe6f">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6eb39e1e4524e415b8eff1ba4a4fc4b0">prioritySplitWithSwitches</a> (const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a40e81bf270e245055b487e3f9fa28a7f">AdaptiveHistogram</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *spn, bool as)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Private initialised constructor.  <a href="#a40e81bf270e245055b487e3f9fa28a7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7">completeDataInsertionFromVec</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete insertion of data from a vector container.  <a href="#a929e006a5a2a0f40c68d77bc7dff70e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab5d45e2f1966bd43a7bb8bf041ea29db">haveMadePaving</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const size_t dim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if we need to make root paving for the histogram object.  <a href="#ab5d45e2f1966bd43a7bb8bf041ea29db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0eaca3eebf10b3d251ed284f0317c593">insertDataFromContainer</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data from a container.  <a href="#a0eaca3eebf10b3d251ed284f0317c593"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6456652ee831cee0ec4184440cd84ec9">recalcScaledEMPSumCOPERR</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate the scaled EMP part of COPERR score.  <a href="#a6456652ee831cee0ec4184440cd84ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8a546d8d85be0ffac955f7886d5c7aa">recalcScaledEMPSumAIC</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate the unscaled EMP part of AIC score.  <a href="#ab8a546d8d85be0ffac955f7886d5c7aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a71122bfe1d3dfad1f2b55585326334ac">updateScaledEMPSumCOPERR</a> (dotprecision change) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the scaled EMP part COPERR score given change.  <a href="#a71122bfe1d3dfad1f2b55585326334ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a79fe01c35fba2bbdb1df5e8eb1d3a78b">updateScaledEMPSumAIC</a> (dotprecision change) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the the scaled EMP part AIC score given change.  <a href="#a79fe01c35fba2bbdb1df5e8eb1d3a78b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad2360173a5963ecbca37e0a78ce98879">outputLogEMPCOPERR</a> (const std::string &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add COPERR EMP score to log file.  <a href="#ad2360173a5963ecbca37e0a78ce98879"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9">outputLogEMPAIC</a> (const std::string &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add AIC EMP score to log file.  <a href="#a602b8b4081d3cae20308aa6644a83fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b">outputLogStart</a> (const std::string &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opening line of a txt log file.  <a href="#ad847a4add7e72eac564daa44835dba5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adf589f52a0cd3e2371c288aa6bca7d37">MCMCStartLogFile</a> (std::string s, int i, const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;proposal, const <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Put header in a log file for MCMC.  <a href="#adf589f52a0cd3e2371c288aa6bca7d37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4e7d34aea502906cb2230c0732d752b3">outputMCMCStateSample</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the state of this histogram as an MCMC sample.  <a href="#a4e7d34aea502906cb2230c0732d752b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a10fc830a1dd32fe83aa3846a6fb2af35">MCMCLogFinalState</a> (std::string s, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Capture the final state of this histogram after MCMC.  <a href="#a10fc830a1dd32fe83aa3846a6fb2af35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a89aa9c37916fcac47cf273f512bca019">decisionMCMCSplit</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *target, const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;proposal, const <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior, gsl_rng *rgsl, size_t numLeaves, size_t numCherries, size_t minPoints, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, const std::string &amp;s, int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to split a node to get a new MCMC state.  <a href="#a89aa9c37916fcac47cf273f512bca019"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae2df56ec733843dffcc6af094637758d">decisionMCMCMerge</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *target, const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;proposal, const <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;logPrior, gsl_rng *rgsl, size_t numLeaves, size_t numCherries, size_t minPoints, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, const std::string &amp;s, int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether to merge a node to get a new MCMC state.  <a href="#ae2df56ec733843dffcc6af094637758d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1544712de53718450f5f13fee5738a92">changeStateForSplit</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *target, <a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;nodes, size_t &amp;numLeaves, size_t &amp;numCherries, size_t minPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the state of this Adaptive Histogram by splitting a node.  <a href="#a1544712de53718450f5f13fee5738a92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4ff31f6b6d944c0c1e71ae4e7586cc2a">changeStateForMerge</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *target, <a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;nodes, size_t &amp;numLeaves, size_t &amp;numCherries, size_t minPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the state of this Adaptive Histogram by merging cherry.  <a href="#a4ff31f6b6d944c0c1e71ae4e7586cc2a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4e40497a24ce0807235196e17ca21456">makeBox</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const size_t dim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a box to contain all the data.  <a href="#a4e40497a24ce0807235196e17ca21456"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aedb9ab3c2240403c63f2f5c1d0218350">logMCMCDeltas</a> (std::string s, int i, real deltaL, real deltaP, real deltaQ, real deltaPi, double randChange)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a collection of changes in MCMC probabilities to log file.  <a href="#aedb9ab3c2240403c63f2f5c1d0218350"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2">SPSnodeListItr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae7f23176e9afea24c51c6a37cbcc4b0a">proposeChangeMCMCState</a> (const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;proposal, <a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;nodes, size_t numLeaves, size_t numCherries, gsl_rng *rgsl, bool &amp;haveNode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the node to target for change in MCMC on <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> trees.  <a href="#ae7f23176e9afea24c51c6a37cbcc4b0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a">checkNodeCountForSplit</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const spn, bool volChecking, double minVol, size_t minChildPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to do checking for whether a node is splittable.  <a href="#a8a997f746bf62c847990542daf7c5a6a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a">rootPaving</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root node of the subpaving tree.  <a href="#a88a104768020c02deb2a7df9e2b4cb3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6">rootBox</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The root box used to form the subpaving tree.  <a href="#a5afac4246153fef0b383f6eb2e9d23a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">BigDataCollection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214">dataCollection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for all sample data passed to this.  <a href="#afb02d0a6fe2258620130b97b7901e214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17">holdAllStats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether all available statistics are maintained in the rootPaving. If set to false (default) only counts are maintained.  <a href="#a3f9319019a75ea477804d02762602d17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59">creationString</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A string showing the order of creation of the rootPaving.  <a href="#a1211a42d1f428d73db9ba3c035239c59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96">scaledEMPSumCOPERR</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A value for the unscaled EMP part of COPERR score.  <a href="#acd3c0bacd5148b82188cc129b3a59e96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89">scaledEMPSumAIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A value for the unscaled EMP part of AIC score.  <a href="#ad5748390a25f398475bb60575f0e9a89"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a73e006381e43e152b7dbb63211a3ac09">padding</a> = 0.000005</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a constant for padding a box if it is tailor-made for data.  <a href="#a73e006381e43e152b7dbb63211a3ac09"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A wrapper or manager for an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> aka StatsSubPaving in conjunction with massive amounts of sample data. </p>
<p>Here sample data is multi-dimensional point-valued data in a cxsc::rvector container. The <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> class manages <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode </a> objects (<a class="el" href="namespacesubpavings.shtml#ace6b16f0adf0db13eeb38e124d5328c6">StatsSubPavings </a>) for the purpose of creating adaptive histograms from sample data and also manages the container for the sample data itself.</p>
<p>An <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> (a pointer to an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> is aliased as StatsSubPaving) is a binary tree representation of a regular subpaving which can be used for processing statistical sample data. SPSnodes do not actually hold data, they only need to know where the data they are associated with is stored. The leaf nodes in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree controlled by an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object have a vector of iterators into the <a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">BigDataCollection</a>, a dataCollection managed by that <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object.</p>
<p>The <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> class uses the C-XSC library class rvector for sample data points. rvectors can have 1 or many dimensions. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00076">76</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a40e81bf270e245055b487e3f9fa28a7f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::AdaptiveHistogram" ref="a40e81bf270e245055b487e3f9fa28a7f" args="(SPSnode *spn, bool as)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a40e81bf270e245055b487e3f9fa28a7f">AdaptiveHistogram::AdaptiveHistogram</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Private initialised constructor. </p>
<p>Initialised with pointer to subpaving and value for holdAllStats. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00100">100</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(as),
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>(0.0), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>(0.0)
{
    <span class="keywordflow">if</span> (NULL == spn) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Cannot use null SPSnode pointer in constructor&quot;</span>);
    }
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = spn;
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a> = spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();

    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa863ff24ef4af6b084f515f702bbe09e"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::AdaptiveHistogram" ref="aa863ff24ef4af6b084f515f702bbe09e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a40e81bf270e245055b487e3f9fa28a7f">AdaptiveHistogram::AdaptiveHistogram</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>By default, only counts are maintained in subpaving this manages, rather than all available stats. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01019">1019</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(<span class="keyword">false</span>), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a>(<span class="stringliteral">&quot;&quot;</span>),
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>(0.0), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>(0.0)
{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = NULL;
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a> = ivector();    <span class="comment">// ivector with length 1 and undefined elements</span>


    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8155be0403adb23fe8c4232f95eb47f6"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::AdaptiveHistogram" ref="a8155be0403adb23fe8c4232f95eb47f6" args="(bool as)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a40e81bf270e245055b487e3f9fa28a7f">AdaptiveHistogram::AdaptiveHistogram</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with parameter controlling whether all available statistics be maintained in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> (true for all stats, false for counts only). </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01032">1032</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(as), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a>(<span class="stringliteral">&quot;&quot;</span>),
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>(0.0), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>(0.0)
{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = NULL;
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a> = ivector();    <span class="comment">// ivector with length 1 and undefined elements</span>


    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a54d9dd37b5a2d71ee4e94f2154140b44"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::AdaptiveHistogram" ref="a54d9dd37b5a2d71ee4e94f2154140b44" args="(ivector &amp;v, bool as=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a40e81bf270e245055b487e3f9fa28a7f">AdaptiveHistogram::AdaptiveHistogram</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with domain box. By default, only counts are maintained as stats in the in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>.</p>
<p>Ideal constructor when the support domain of data is known a priori or has been transformed to a known domain but splitting criteria have not been determined a priori. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01046">1046</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(as),
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>(0.0), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>(0.0)
{
    <span class="keywordflow">try</span> {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>(v, !as);
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();

        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a> = v;
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor:&quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor:&quot;</span> + msg);
    }

    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a512fa91574e1dbb992a6edcb77bf56c1"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::AdaptiveHistogram" ref="a512fa91574e1dbb992a6edcb77bf56c1" args="(const AdaptiveHistogram &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a40e81bf270e245055b487e3f9fa28a7f">AdaptiveHistogram::AdaptiveHistogram</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01079">1079</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00104">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">recalcScaledEMPSumCOPERR()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>)
{
    <span class="keywordflow">try</span> {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>(*(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>));
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

        <span class="comment">//copy dataCollection from other to this</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a> = other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>;

        other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8a546d8d85be0ffac955f7886d5c7aa" title="Recalculate the unscaled EMP part of AIC score.">recalcScaledEMPSumAIC</a>();
        other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6456652ee831cee0ec4184440cd84ec9" title="Recalculate the scaled EMP part of COPERR score.">recalcScaledEMPSumCOPERR</a>();
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a> = other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>;
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a> = other.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>;
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std:: endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;SPnodeException in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor: &quot;</span> + msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa11b3ed173c858fec6234c7e0b9d9829"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::~AdaptiveHistogram" ref="aa11b3ed173c858fec6234c7e0b9d9829" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa11b3ed173c858fec6234c7e0b9d9829">AdaptiveHistogram::~AdaptiveHistogram</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01209">1209</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2e95f7f1a9dab963a28a7d3a655e0e8f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::changeMCMCState" ref="a2e95f7f1a9dab963a28a7d3a655e0e8f" args="(SPSnodeList &amp;nodes, size_t &amp;numLeaves, size_t &amp;numCherries, MCMCProposal &amp;proposal, LogMCMCPrior &amp;logPrior, size_t minPoints, gsl_rng *rgsl, LOGGING_LEVEL logging, std::string s, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2e95f7f1a9dab963a28a7d3a655e0e8f">AdaptiveHistogram::changeMCMCState</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numCherries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;&#160;</td>
          <td class="paramname"><em>proposal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the state of this Adaptive Histogram using MCMC process. </p>
<p>This method proposes and probabilistically accepts a single-step change in the histogram state represented by this Adaptive Histogram, i.e a change in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by the histogram and representing the partion of the data space into histogram 'bins'. A single-step change in state is the change in state resulting from a single split of a leaf node or merge of a cherry node.</p>
<p>Proposals are made by selecting a leaf or cherry at random. If a cherry is chosen the proposed change in state is to merge the two leaf children of that cherry; if a leaf is chosen the proposal is to split (bisect) the leaf.</p>
<p>minPoints &gt; 0 restricts the leaves which can be selected for change: if splitting a leaf would result in the children having less than minPoints data points associated with them, the leaf cannot be selected for the proposed change unless that child leaf node has 0 points and its sibling has all the parent's points (&gt;= minPoints). The final condition allows a node to be split when all the data goes to just one child provided that the number of points in the node &gt;= minPoints so that the process can 'home in' on small peaks of data.. Note however that minPoints has no effect on the cherries which can be proposed for merging. A leaf whose split would result in both children having at least minPoints points in it, or where the split would give all the data to one child, is referred to as a 'splittable leaf'.</p>
<p>Thus the implementation of the MCMC algorithm for generating a new state in the chain needs to maintain separately the overall state of the tree and the set of <b>splittable leaf nodes</b>.</p>
<p>The log-likelihood of a state given the data is given by sum over leaves of (counts in leaf x -ln(count in leaf / (n x vol of leaf))) where n is the total number of data points in the histogram.</p>
<p>The posterior distribution is proportional to the prior x likelihood.</p>
<p>The Metropolis-Hastings algorithm also requires a proposal density which depends on the current state m to generate a proposed state m'.</p>
<p>Q(m' | m) is the transition probability from state m to state m'.</p>
<p>This proposal is accepted if u drawn from Uniform(0,1) is such that u &lt; (posterior probability of m' x Q(m | m'))/(posterior probability of m x Q(m' | m). In this implementation, natural logs are used to simplify calculation, ie a proposal is accepted if log(u) &lt; log [(posterior probability of m' x Q(m | m'))/(posterior probability of m x Q(m' | m)].</p>
<p>If the proposal is accepted the state is changed to m', otherwise it stays at m.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree representing some histogram state, a container of pointers to the splittable leaf and cherry nodes of the tree in its current state, ordered with the leaves first followed by the cherries, the number of splittable leaf nodes and the number of cherry nodes. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree in some state which is either in the same state as the pre-state or in a new state reachable by a single-step change (i.e. through the split of one splittable leaf or the merge of one cherry of the pre-state), the container of splittable leaf and cherry nodes updated for any change in state, and the number of splittable leaves and cherries updated similarly.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that the container of splittable leaf nodes and cherries is maintained separately from the overall state of the tree to save having to repeatedly assess whether a leaf can be split (given minPoints). The number of splittable leaves and cherries is maintained for convenience to avoid repeatedly counting nodes of different types in the container.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>is a reference to a container of pointers to the leaf and cherry nodes of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>, which will be updated if the method results in change in tree state. </td></tr>
    <tr><td class="paramname">numLeaves</td><td>is a reference to a variable storing the number of leaves in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree, which will be updated if the method results in change in tree state. </td></tr>
    <tr><td class="paramname">numCherries</td><td>is a reference to a variable storing the number of cherries in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree, which will be updated if the method results in a change in tree state. </td></tr>
    <tr><td class="paramname">proposal</td><td>is a reference to a proposal distribution object. </td></tr>
    <tr><td class="paramname">logPrior</td><td>is a reference to a log prior object. </td></tr>
    <tr><td class="paramname">minPoints</td><td>is the minimum number of points allowed in a box. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a uniform random number generator. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to log files (defaults to no logging). TXT gives logging to a txt file, TXTANDGRAPH gives txt file logging and graphs. </td></tr>
    <tr><td class="paramname">s</td><td>is the name of the filename to send logging output to. </td></tr>
    <tr><td class="paramname">i</td><td>is an integer for keeping track of the index for this link in a Markov Chain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there has been a successful proposal and successful probabilistic acceptance/rejection of the change in state, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">3368</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">changeStateForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">decisionMCMCMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">decisionMCMCSplit()</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00538">proposeChangeMCMCState()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXT</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXTANDGRAPH</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> success = <span class="keyword">true</span>; <span class="comment">// start by assuming that all will be well...</span>
    <span class="comment">//bool success = false;</span>
  
  <span class="comment">//cout &lt;&lt; &quot;change mcmc state called for &quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;node list size: &quot; &lt;&lt; nodes.size() &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;#leaves: &quot; &lt;&lt; numLeaves &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;#cherries: &quot; &lt;&lt; numCherries &lt;&lt; endl;</span>

    <span class="keywordflow">try</span> {

      <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
        
        <span class="keywordtype">bool</span> haveNode = <span class="keyword">false</span>;

        <span class="comment">// use proposal to fill the proposal probabilities</span>

        <span class="comment">// this changes haveNode as well</span>
        <span class="comment">//cout &lt;&lt; &quot;proposing&quot; &lt;&lt; endl;</span>
        <a class="code" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2" title="Define type SPSnodeListItr as an iterator over SPSnodeList.">SPSnodeListItr</a> it = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae7f23176e9afea24c51c6a37cbcc4b0a" title="Finds the node to target for change in MCMC on SPSnode trees.">proposeChangeMCMCState</a> (proposal, nodes,
                                numLeaves, numCherries,
                                rgsl, haveNode);
      
      <span class="comment">/*if (haveNode) </span>
<span class="comment">      { </span>
<span class="comment">        cout &lt;&lt; &quot;a node is proposed&quot;  &lt;&lt; (*it)-&gt;getNodeName() &lt;&lt; endl;</span>
<span class="comment">      }</span>
<span class="comment">      else {cout &lt;&lt; &quot;nothing proposed. stay.&quot; &lt;&lt; endl;}</span>
<span class="comment">      */</span>
      
        <span class="comment">// only do more if haveNode is true, which means that it points to something</span>
        <span class="keywordflow">if</span> (haveNode &amp;&amp; (*it)-&gt;isLeaf()) {

            <span class="comment">//grab the leaf</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* target = *it; <span class="comment">// don&#39;t change where it points until erased</span>


            <span class="comment">// leaf so we are splitting</span>
            <span class="keywordtype">bool</span> willSplit = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a89aa9c37916fcac47cf273f512bca019" title="Determines whether to split a node to get a new MCMC state.">decisionMCMCSplit</a>(target, proposal, logPrior, rgsl,
                            numLeaves, numCherries, minPoints,
                            logging, s, i);            

            <span class="keywordflow">if</span> (willSplit) {
                <span class="comment">// take the target out of the list</span>
          <span class="comment">//cout &lt;&lt; &quot;split and remove from list &quot; &lt;&lt; (*it)-&gt;getNodeName() &lt;&lt; endl;</span>
               nodes.erase(it);

                <span class="comment">// try to change the state according to the proposed split</span>
                <span class="comment">// nodes, numLeaves and numCherries are passed by reference</span>
                success = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1544712de53718450f5f13fee5738a92" title="Changes the state of this Adaptive Histogram by splitting a node.">changeStateForSplit</a>(target, nodes,
                            numLeaves, numCherries, minPoints);
            } <span class="comment">// end of willSplit</span>

        } <span class="comment">// end of isLeaf</span>

        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (haveNode &amp;&amp; (*it)-&gt;isSubLeaf()) {

            <span class="comment">// grab the cherry</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* target = *it; <span class="comment">// don&#39;t change where it points until deleted</span>

            <span class="keywordtype">bool</span> willMerge = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae2df56ec733843dffcc6af094637758d" title="Determines whether to merge a node to get a new MCMC state.">decisionMCMCMerge</a>(target, proposal, logPrior, rgsl,
                            numLeaves, numCherries, minPoints, logging, s, i);

            <span class="keywordflow">if</span> (willMerge) {
                <span class="comment">// take the target out of the list of cherries</span>
          <span class="comment">//cout &lt;&lt; &quot;merge and remove from list &quot; &lt;&lt; (*it)-&gt;getNodeName() &lt;&lt; endl;</span>
               nodes.erase(it);

               success = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4ff31f6b6d944c0c1e71ae4e7586cc2a" title="Changes the state of this Adaptive Histogram by merging cherry.">changeStateForMerge</a>(target,
                            nodes, numLeaves, numCherries, minPoints);

            } <span class="comment">// end willMerge</span>
        } <span class="comment">// end if cherry</span>


        <span class="keywordflow">if</span> (((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>)) &amp;&amp; !haveNode) {

            std::string line = <span class="stringliteral">&quot;No node grabbed (possible if proposal has fixed &quot;</span>;
            line += <span class="stringliteral">&quot;probability of split): state stays the same&quot;</span>;

            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, line, <span class="keyword">true</span>); <span class="comment">// append to log file</span>
        }

        <span class="keywordflow">if</span> (success) {
            <span class="comment">// is it worth doing this?  on balance I think yes</span>
            success = (nodes.size() == (numLeaves+numCherries));
            <span class="comment">//cout &lt;&lt; &quot;successful state change/stay.&quot; &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; &quot;---------------------------------&quot; &lt;&lt; endl;</span>
        }
        
        <span class="keywordflow">else</span> {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Nodes muddled in changeMCMCstate&quot;</span>);

        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in MCMC.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error  in MCMC.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException  in MCMC.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error  in MCMC.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4ff31f6b6d944c0c1e71ae4e7586cc2a"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::changeStateForMerge" ref="a4ff31f6b6d944c0c1e71ae4e7586cc2a" args="(SPSnode *target, SPSnodeList &amp;nodes, size_t &amp;numLeaves, size_t &amp;numCherries, size_t minPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4ff31f6b6d944c0c1e71ae4e7586cc2a">AdaptiveHistogram::changeStateForMerge</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numCherries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the state of this Adaptive Histogram by merging cherry. </p>
<p>This method carries out a move to a new state in the histogram MCMC state chain by merging the target cherry node.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree representing some histogram state, a container of pointers to the splittable leaf and cherry nodes of the tree in its current state, ordered with the leaves first followed by the cherries, the number of splittable leaf nodes and the number of cherry nodes. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree changed as a result of the merge, the container of splittable leaf and cherry nodes updated for any change in state, and the number of splittable leaves and cherries updated similarly.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>is a pointer to the target node proposed for merging. </td></tr>
    <tr><td class="paramname">nodes</td><td>is a reference to a container of pointers to the splittable leaf and cherry nodes of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>, which will be updated by the method. </td></tr>
    <tr><td class="paramname">numLeaves</td><td>is a reference to a variable storing the number of splittable leaf nodes in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree, which will be updated by the method. </td></tr>
    <tr><td class="paramname">numCherries</td><td>is a reference to a variable storing the number of cherries in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree, which will be updated by the method. </td></tr>
    <tr><td class="paramname">minPoints</td><td>is the minimum number of points allowed in a box, which is needed to be able to tell which, if any, of the merged nodes children need to be taken out of the nodes container on the merge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if has been a successful change in state, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">881</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01198">subpavings::SPSnode::getMinChildCountIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01029">subpavings::SPSnode::getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">subpavings::SPnode::hasLeafSibling()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">subpavings::SPSnode::nodeReabsorbChildren()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">changeMCMCState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;

    <span class="keywordtype">size_t</span> points = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// need to recalculate COPERR EMP</span>

    <span class="comment">// accumulate the changes in scaled EMP sums that will result</span>
    <span class="comment">// from this expansion</span>
    <span class="comment">//updateScaledEMPSumCOPERR(target-&gt;getMergeChangeEMPCOPERR(points));</span>
    <span class="comment">//updateScaledEMPSumAIC(target-&gt;getMergeChangeEMPAIC());</span>

    <span class="comment">// subtract the child names from the creation string</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += (<span class="stringliteral">&quot; -(&quot;</span> + target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>() + <span class="stringliteral">&quot;)&quot;</span>);

    <span class="comment">// take the children out of the list of leaves if they are there</span>
    <span class="comment">// each child will only be in the list of leaves if splitting that child</span>
    <span class="comment">// would give children with at least the minimum number of data points</span>
    <span class="comment">// associated with them, or if the child itself has enough points but</span>
    <span class="comment">// and splitting would give one child with 0 points were minPoints &gt; 0</span>
    std::string lcName = target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
    std::string rcName = target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
    <span class="keywordtype">int</span> lcPos = 0;
    <span class="keywordtype">bool</span> foundLeft = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> foundRight = <span class="keyword">false</span>;

    <a class="code" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2" title="Define type SPSnodeListItr as an iterator over SPSnodeList.">SPSnodeListItr</a> it;

    <span class="keywordflow">if</span> ((target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() &gt;= minPoints)
        || (minPoints &gt; 0 &amp;&amp; target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt;= minPoints
            &amp;&amp; target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() == 0)) {
        std::string lcName = target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
        <a class="code" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2" title="Define type SPSnodeListItr as an iterator over SPSnodeList.">SPSnodeListItr</a> it;
        <span class="comment">// break out of loop if we find left child or get to cherries</span>
        <span class="keywordflow">for</span> (it=nodes.begin() ; it != nodes.end(); it++ ) {

            <span class="keywordflow">if</span> ((*it)-&gt;isSubLeaf()) <span class="keywordflow">break</span>;
            <span class="keywordflow">if</span> ((*it)-&gt;getNodeName() == lcName) {
                nodes.erase(it); <span class="comment">// can&#39;t keep using iterator now</span>
                numLeaves--;
                foundLeft = <span class="keyword">true</span>;
                <span class="keywordflow">break</span>;
            }
            lcPos++;  <span class="comment">// gives position at which lc was found</span>
        }
    }
    <span class="keywordflow">else</span> foundLeft = <span class="keyword">true</span>;

    <span class="comment">// now try to find right child - could be immediately after left</span>
    <span class="keywordflow">if</span> ((target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() &gt;= minPoints)
        || (minPoints &gt; 0 &amp;&amp; target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt;= minPoints
            &amp;&amp; target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() == 0)) {

        <span class="keywordflow">if</span> (foundLeft) {
            <a class="code" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2" title="Define type SPSnodeListItr as an iterator over SPSnodeList.">SPSnodeListItr</a> git = nodes.begin();
            advance(git, lcPos);
            <span class="comment">// break out of loop if we find right child or get to cherries</span>
            <span class="keywordflow">for</span> (it=git ; it != nodes.end(); it++ ) {

                <span class="keywordflow">if</span> ((*it)-&gt;isSubLeaf()) <span class="keywordflow">break</span>;
                <span class="keywordflow">if</span> ((*it)-&gt;getNodeName() == rcName) {
                    nodes.erase(it);
                    numLeaves--;
                    foundRight = <span class="keyword">true</span>;
                    <span class="keywordflow">break</span>;
                }
            } <span class="comment">// just in case right child was before left</span>
            <span class="keywordflow">if</span> (!foundRight) {
                <span class="comment">// break out of loop if we find right child</span>
                <span class="comment">// or get to cherries</span>
                <span class="keywordflow">for</span> (it=nodes.begin() ; it != nodes.end(); it++ ) {
                    <span class="keywordflow">if</span> ((*it)-&gt;isSubLeaf()) <span class="keywordflow">break</span>;
                    <span class="keywordflow">if</span> ((*it)-&gt;getNodeName() == rcName) {
                        nodes.erase(it);
                        numLeaves--;
                        foundRight = <span class="keyword">true</span>;
                        <span class="keywordflow">break</span>;
                    }
                }
            }
        }
    }
    <span class="keywordflow">else</span> foundRight = <span class="keyword">true</span>;

    success = foundRight;

    <span class="comment">// merge the target</span>
    target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2" title="Reabsorbs both children of the node.">nodeReabsorbChildren</a>();
    numCherries--;

    <span class="comment">// insert the new leaf ptr into the list at the beginning</span>
    nodes.push_front(target);
    numLeaves++;

    <span class="comment">// if sibling was a leaf, add parent to cherries, at end</span>
    <span class="keywordflow">if</span>(target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e" title="Check if this has a leaf sibling.">hasLeafSibling</a>()) { <span class="comment">// returns false if no parent</span>
     
        nodes.push_back(target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4" title="Accessor for the parent of a node.">getParent</a>());
        numCherries++;
    }

    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1544712de53718450f5f13fee5738a92"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::changeStateForSplit" ref="a1544712de53718450f5f13fee5738a92" args="(SPSnode *target, SPSnodeList &amp;nodes, size_t &amp;numLeaves, size_t &amp;numCherries, size_t minPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1544712de53718450f5f13fee5738a92">AdaptiveHistogram::changeStateForSplit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numCherries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the state of this Adaptive Histogram by splitting a node. </p>
<p>This method carries out a move to a new state in the histogram MCMC state chain by splitting the target splittable leaf node.</p>
<p>minPoints restricts the pointers to new leaves resulting from the split which can be put into the container of pointers to splittable leaves and cherry nodes. A pointer to a new leaf can only be put into the container if splitting that leaf would result in the children having less than minPoints data points associated with them.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree representing some histogram state, a container of pointers to the splittable leaf and cherry nodes of the tree in its current state, ordered with the leaves first followed by the cherries, the number of splittable leaf nodes and the number of cherry nodes. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree changed as a result of the split, the container of splittable leaf and cherry nodes updated for any change in state, and the number of splittable leaves and cherries updated similarly.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>is a pointer to the target node proposed for splitting. </td></tr>
    <tr><td class="paramname">nodes</td><td>is a reference to a container of pointers to the leaf and cherry nodes of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>, which will be updated by the method. </td></tr>
    <tr><td class="paramname">numLeaves</td><td>is a reference to a variable storing the number of splittable leaves in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree, which will be updated by the method. </td></tr>
    <tr><td class="paramname">numCherries</td><td>is a reference to a variable storing the number of cherries in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree, which will be updated by the method. </td></tr>
    <tr><td class="paramname">minPoints</td><td>is the minimum number of points allowed in a box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if has been a successful change in state, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">804</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">subpavings::Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01198">subpavings::SPSnode::getMinChildCountIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01029">subpavings::SPSnode::getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">subpavings::SPnode::hasLeafSibling()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">changeMCMCState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;

    <span class="keywordtype">size_t</span> points = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// need to recalculate COPERR EMP</span>

    <span class="comment">// accumulate the changes in scaled EMP sums that will result</span>
    <span class="comment">// from this expansion</span>
   <span class="comment">// updateScaledEMPSumCOPERR(target-&gt;getSplitChangeEMPCOPERR(points));</span>
   <span class="comment">// updateScaledEMPSumAIC(target-&gt;getSplitChangeEMPAIC());</span>

    <span class="comment">// split the target and divvie up its data</span>
    <a class="code" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a" title="Expand a leaf node to have two child nodes.">Expand</a>(target);
    numLeaves--;

    <span class="comment">// add the new child names to the creation string</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

    <span class="comment">// but only put the children into the container if they can be split, which</span>
    <span class="comment">// means if their children would have more than minPoints points in them</span>
    <span class="comment">// or if minPoints &gt; 0 and right child has enough points and splitting it would</span>
    <span class="comment">// give all its points to one child, none to the other</span>
    <span class="keywordflow">if</span> ((target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() &gt;= minPoints)
        ||
        ((minPoints &gt; 0) &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt;= minPoints)
        &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() == 0))
        ) {

        <span class="comment">// insert the new children ptrs into the list at the beginning</span>
        nodes.push_front(target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
        numLeaves++;
    }

    <span class="keywordflow">if</span> ((target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() &gt;= minPoints)
        ||
        ((minPoints &gt; 0) &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt;= minPoints)
        &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() == 0))
        ) {
        <span class="comment">// insert the new children ptrs into the list at the beginning</span>
        nodes.push_front(target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());<span class="comment">// left goes first</span>
        numLeaves++;
    }

    <span class="comment">// if sibling was a leaf, take parent out of cherries</span>
    <span class="keywordflow">if</span>(target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e" title="Check if this has a leaf sibling.">hasLeafSibling</a>()) {

        <span class="comment">// how to find parent? - search the cherries?</span>
        <span class="keywordtype">bool</span> foundParent = <span class="keyword">false</span>;
        std::string nodeParent = target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();

        <a class="code" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2" title="Define type SPSnodeListItr as an iterator over SPSnodeList.">SPSnodeListItr</a> git = nodes.begin();
        advance(git, numLeaves); <span class="comment">// advance to the cherries</span>
        <span class="comment">// break out of loop if we find parent</span>
        <a class="code" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2" title="Define type SPSnodeListItr as an iterator over SPSnodeList.">SPSnodeListItr</a> it;
        <span class="keywordflow">for</span> (it = git ; it != nodes.end(); it++ ) {
            <span class="keywordflow">if</span> ((*it)-&gt;getNodeName() == nodeParent) {
                nodes.erase(it);
                numCherries--;
                foundParent = <span class="keyword">true</span>;
                <span class="keywordflow">break</span>;
            }
        }
        success = foundParent;

    }

    <span class="comment">// put this node ptr into the cherries, ie at end of list</span>
    nodes.push_back(target);

    numCherries++;

    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8a997f746bf62c847990542daf7c5a6a"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::checkNodeCountForSplit" ref="a8a997f746bf62c847990542daf7c5a6a" args="(const SPSnode *const spn, bool volChecking, double minVol, size_t minChildPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a">AdaptiveHistogram::checkNodeCountForSplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>volChecking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to do checking for whether a node is splittable. </p>
<p>Decides whether a node is splittable based on checking volume and number of points that would result in child nodes on split.</p>
<p>Node volume must be &gt;=minVol to split and If there is a minChildPoints&gt;0 specified, then either the node must have at least minChildPoints and all the points go to one of the children (the other getting none) or the smallest number of points which would go to the either of the prospective new children must be &gt;= minChildPoints</p>
<p>Thus in general the method will only return true if the given node satisfies both the minVol test and, if it were to be split, both children would have at least minChildPoints data points, but if all the data points would go to one child (none) to the other, this is considered to also satisfy the minChildPoints test.</p>
<p>If the node has already been split, the test will use the actual numbers of points in the children; if the node is a leaf (ie not split) then the test will consider the number of points that would go to the each child if it were to be split.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>is a pointer to the target node. </td></tr>
    <tr><td class="paramname">volChecking</td><td>indicates whether volume is being checked </td></tr>
    <tr><td class="paramname">minVol</td><td>is the minimum volume allowed to be tested for. </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points that there would be in the children if the node were to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if has been a test conditions satisfied, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">986</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01198">subpavings::SPSnode::getMinChildCountIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
  
  <span class="keywordtype">size_t</span> minChildCount = 0;
  <span class="keywordtype">size_t</span> counter = spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
  <span class="keywordflow">if</span> (spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) minChildCount = spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>();
  <span class="keywordflow">else</span> {
    <span class="keywordtype">size_t</span> lcCount = spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    <span class="keywordtype">size_t</span> rcCount = counter - lcCount;
    minChildCount = (lcCount &lt; rcCount ? lcCount : rcCount);
  }
  
  <span class="keywordflow">if</span> ((!volChecking || (volChecking &amp;&amp; (spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>() &gt;= minVol)))
        &amp;&amp; ((minChildPoints == 0)
            || (minChildPoints &gt; 0
                &amp;&amp;
                ((counter &gt;= minChildPoints) &amp;&amp;
                    ((minChildCount == 0)
                    ||
                    (minChildCount &gt;= minChildPoints))
                ))
            )
        ) { retValue = <span class="keyword">true</span>; }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a438e2252f954f0556fa2bd7c2e105dbe"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::checkStopCrit" ref="a438e2252f954f0556fa2bd7c2e105dbe" args="(double StopCritCurrent, double StopCritPrevious, int &amp;Prev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a438e2252f954f0556fa2bd7c2e105dbe">AdaptiveHistogram::checkStopCrit</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>StopCritCurrent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>StopCritPrevious</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>Prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if we should stop splitting using total variation distance </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05762">5762</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> valley = <span class="keyword">false</span>;
  <span class="comment">//cout &lt;&lt; &quot;current: &quot; &lt;&lt; stopCritCurrent &lt;&lt; &quot;\t previous: &quot; &lt;&lt; stopCritPrevious &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;Prev before checks: &quot; &lt;&lt; Prev &lt;&lt; endl;</span>
  
  <span class="comment">// check if it is a local minimum</span>
  <span class="keywordflow">if</span> ( (stopCritCurrent &gt; stopCritPrevious) &amp;&amp; (Prev == 1) ) {
    <span class="comment">//cout &lt;&lt; &quot;larger: &quot; &lt;&lt; (stopCritCurrent &gt; stopCritPrevious) &lt;&lt; &quot;\t Prev: &quot; &lt;&lt; Prev &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; &quot;!!! Local minima previously !!! &quot; &lt;&lt; endl;</span>
    Prev = 0;
    valley = <span class="keyword">true</span>;
  }
  
  <span class="comment">// check if stopCrit is decreasing</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stopCritCurrent &lt; stopCritPrevious) {
    Prev = 1;
    valley = <span class="keyword">false</span>;
  }

  <span class="keywordflow">else</span> { 
    valley = <span class="keyword">false</span>; }

  <span class="comment">//cout &lt;&lt; &quot;Prev after checks: &quot; &lt;&lt; Prev &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> valley;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a929e006a5a2a0f40c68d77bc7dff70e7"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::completeDataInsertionFromVec" ref="a929e006a5a2a0f40c68d77bc7dff70e7" args="(const RVecData &amp;theData, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7">AdaptiveHistogram::completeDataInsertionFromVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complete insertion of data from a vector container. </p>
<p>First checks if the box exists and makes it otherwise, then checks box dimensions against data dimensions if box already exists, and finally inserts the data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether a log file is created for histogram creation process; set to TXT for logging to a txt file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData containing at least one rvector. </dd>
<dd>
this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object may have an initialised <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> pointed to by rootPaving, but rootPaving can also be NULL. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>If the rootPaving was NULL when the function was entered, then rootPaving is pointed to a new <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> object whose root node has a box tailored to contain all the data read in. </dd>
<dd>
The data in theData has been put into the <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>'s dataCollection and also associated with rootPaving's leaves via iterators to dataCollection. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if data successfully put into a dataCollection and associated with the rootPaving's leaves, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">119</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01817">insertFromRSSample()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01568">insertFromRVec()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01458">insertOneDimDataFromTxt()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01517">insertRvectorsFromTxt()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01875">insertSampleFromRSSample()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01635">insertSampleFromRVec()</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="comment">//find the data dimensions from the first datapoint</span>
    <span class="keywordtype">int</span> dataDim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*theData.begin()) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*theData.begin()) + 1;

    <span class="comment">// ensure the paving exists</span>
    <span class="keywordtype">bool</span> hadToMakePaving = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab5d45e2f1966bd43a7bb8bf041ea29db" title="Checks if we need to make root paving for the histogram object.">haveMadePaving</a>(theData, dataDim);

    <span class="comment">// if we did not make the paving we have to check data dimensions</span>
    <span class="keywordflow">if</span> (!hadToMakePaving) {
        <span class="keywordflow">if</span>(dataDim != (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>)) + 1) {

            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Dimensions of data do not match paving&quot;</span>);
        }
    }

    <span class="comment">// insert the data</span>
    <span class="keywordtype">size_t</span> dataCountInserted
            = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0eaca3eebf10b3d251ed284f0317c593" title="Insert data from a container.">insertDataFromContainer</a>(theData, boolTest, logging);

    <span class="keywordflow">if</span> (dataCountInserted &gt; 0) {
        retValue = <span class="keyword">true</span>;
        <span class="comment">// switch on for more output during histogram creation &quot;</span>
        <span class="comment">/*</span>
<span class="comment">        std::cout &lt;&lt; &quot;End of inserting data: &quot; &lt;&lt; dataCountInserted</span>
<span class="comment">            &lt;&lt; &quot; data points inserted to dataCollection &quot;</span>
<span class="comment">            &lt;&lt; std:: endl;</span>
<span class="comment">        std::cout &lt;&lt; &quot;and associated with the tree if &quot;</span>
<span class="comment">            &lt;&lt; &quot;they fit into the root box&quot; &lt;&lt; std::endl;</span>
<span class="comment">        std::cout &lt;&lt; &quot;(check console output for possible records &quot;</span>
<span class="comment">            &lt;&lt; &quot;of datapoints which did not fit)&quot; &lt;&lt; std::endl;</span>
<span class="comment">        */</span>
        }

    <span class="keywordflow">if</span> (dataCountInserted == 0) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No data inserted&quot;</span>);

    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae2df56ec733843dffcc6af094637758d"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::decisionMCMCMerge" ref="ae2df56ec733843dffcc6af094637758d" args="(SPSnode *target, const MCMCProposal &amp;proposal, const LogMCMCPrior &amp;logPrior, gsl_rng *rgsl, size_t numLeaves, size_t numCherries, size_t minPoints, LOGGING_LEVEL logging, const std::string &amp;s, int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae2df56ec733843dffcc6af094637758d">AdaptiveHistogram::decisionMCMCMerge</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;&#160;</td>
          <td class="paramname"><em>proposal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numCherries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether to merge a node to get a new MCMC state. </p>
<p>This method probabilistically accepts or rejects a single-step change n the histogram state represented by this Adaptive Histogram resulting from merging the leaf children of a target cherry node back into the target.</p>
<p>Q(m' | m) is the transition probability from state m to state m'.</p>
<p>This proposal is accepted if u drawn from Uniform(0,1) is such that u &lt; (posterior probability of m' x Q(m | m'))/(posterior probability of m x Q(m' | m). In this implementation, natural logs are used to simplify calculation, ie a proposal is accepted if log(u) &lt; log [(posterior probability of m' x Q(m | m'))/(posterior probability of m x Q(m' | m)].</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>is a pointer to the target node proposed for merging. </td></tr>
    <tr><td class="paramname">proposal</td><td>is a reference to a proposal distribution object. </td></tr>
    <tr><td class="paramname">logPrior</td><td>is a reference to a log prior object. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a uniform random number generator. </td></tr>
    <tr><td class="paramname">numLeaves</td><td>is the number of splittable leaf nodes in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree. </td></tr>
    <tr><td class="paramname">numCherries</td><td>is the number of cherries in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree. </td></tr>
    <tr><td class="paramname">minPoints</td><td>is the minimum number of points allowed in a box. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether decision making output is sent to the log file. </td></tr>
    <tr><td class="paramname">s</td><td>is the name of the filename to send logging output to. </td></tr>
    <tr><td class="paramname">i</td><td>is an integer for keeping track of the index for this link in a Markov Chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the proposal is accepted (the target will be merged), false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">725</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="classsubpavings_1_1MCMCProposal.shtml#ae39f9b3d8afbc8be9a10d6947f59798e">subpavings::MCMCProposal::getLogQRatioMergeProposal()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02090">subpavings::SPSnode::getMergeChangeLogLik()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01198">subpavings::SPSnode::getMinChildCountIfSplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">subpavings::SPnode::hasLeafSibling()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00423">logMCMCDeltas()</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXT</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXTANDGRAPH</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">changeMCMCState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> willMerge = <span class="keyword">false</span>;

  <span class="comment">//cout &lt;&lt; &quot;merge or not merge?&quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; target-&gt;getLeftChild()-&gt;getCounter() &lt;&lt; &quot;\t&quot; &lt;&lt; </span>
  <span class="comment">//target-&gt;getRightChild()-&gt;getCounter() &lt;&lt; endl;</span>

    <span class="comment">// cherry so we are merging</span>
    <span class="keywordflow">if</span> ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>))
        <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s,<span class="stringliteral">&quot;grabbing cherry &quot;</span> + target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>());

    <span class="comment">// change in log likelihood on merge is getMergeChangeLogLik</span>
    <span class="comment">// for this node</span>
    real deltaL = rnd(target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a9fd3a2a06ee14b5d5c307a2c7d795cef" title="Get change in log likelihood on merge of this&#39; leaf chidren.">getMergeChangeLogLik</a>());

    <span class="keywordtype">size_t</span> realNumLeaves = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>();

    real deltaP = logPrior(realNumLeaves - 2) - logPrior(realNumLeaves - 1);

    <span class="comment">// posterior is proportional to likelihood * prior</span>
    real deltaPi = deltaL + deltaP;

    <span class="comment">// calculate the number of leaves and cherries after proposed merge</span>
    <span class="comment">// we have to take into account minPoints and the effect that this will have</span>
    <span class="comment">// had on whether the target&#39;s children are in the nodes container</span>
    <span class="keywordtype">size_t</span> newNumLeaves = numLeaves + 1; <span class="comment">// current number of leaves plus target</span>
    <span class="comment">// but decrement newNumLeaves for each of the target&#39;s children that comes</span>
    <span class="comment">// out of the container</span>
    <span class="keywordflow">if</span> (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() &gt;= minPoints) {
        newNumLeaves--;
    }
    <span class="comment">// the left child would also have been in the container if it had enough</span>
    <span class="comment">// points and all of them went to one child, the other getting nothing</span>
    <span class="keywordflow">if</span> ((minPoints &gt; 0)
        &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt;= minPoints)
        &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() == 0)) {
            newNumLeaves--;
    }

    <span class="keywordflow">if</span> (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() &gt;= minPoints) {
        newNumLeaves--;
    }
    <span class="comment">// the right child would also have been in the container if it had enough</span>
    <span class="comment">// points and all of them went to one child, the other getting nothing</span>
    <span class="keywordflow">if</span> ((minPoints &gt; 0)
        &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt;= minPoints)
        &amp;&amp; (target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() == 0)) {
            newNumLeaves--;
    }

    <span class="keywordtype">size_t</span> newNumCherries = numCherries;
    <span class="keywordflow">if</span> (!(target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e" title="Check if this has a leaf sibling.">hasLeafSibling</a>())) { 
     
     <span class="comment">//cout &lt;&lt; &quot;only remove cherry if it doesn&#39;t have a sibling leaf node&quot; &lt;&lt; endl;</span>
     newNumCherries = numCherries - 1; }

    <span class="comment">// Using proposal distribution object</span>
    real deltaQ = proposal.<a class="code" href="classsubpavings_1_1MCMCProposal.shtml#ae39f9b3d8afbc8be9a10d6947f59798e">getLogQRatioMergeProposal</a>(numLeaves, numCherries,
                                                newNumLeaves, newNumCherries);
    <span class="comment">//get another random number</span>
    <span class="keywordtype">double</span> randChange = gsl_rng_uniform(rgsl);
    <span class="keywordflow">if</span> (log(randChange) &lt; deltaPi + deltaQ) willMerge = <span class="keyword">true</span>;

    <span class="keywordflow">if</span> ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>)) {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aedb9ab3c2240403c63f2f5c1d0218350" title="Send a collection of changes in MCMC probabilities to log file.">logMCMCDeltas</a>(s, i, deltaL, deltaP, deltaQ, deltaPi, randChange);
        <span class="keywordflow">if</span> (willMerge) <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <span class="stringliteral">&quot;Merging&quot;</span>);
        <span class="keywordflow">else</span> <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <span class="stringliteral">&quot;Not merging&quot;</span>);
    }

    <span class="keywordflow">return</span> willMerge;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a89aa9c37916fcac47cf273f512bca019"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::decisionMCMCSplit" ref="a89aa9c37916fcac47cf273f512bca019" args="(SPSnode *target, const MCMCProposal &amp;proposal, const LogMCMCPrior &amp;logPrior, gsl_rng *rgsl, size_t numLeaves, size_t numCherries, size_t minPoints, LOGGING_LEVEL logging, const std::string &amp;s, int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a89aa9c37916fcac47cf273f512bca019">AdaptiveHistogram::decisionMCMCSplit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;&#160;</td>
          <td class="paramname"><em>proposal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numCherries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether to split a node to get a new MCMC state. </p>
<p>This method probabilistically accepts or rejects a single-step change in the histogram state represented by this Adaptive Histogram resulting from a single split of a target splittable leaf node.</p>
<p>Q(m' | m) is the transition probability from state m to state m'.</p>
<p>This proposal is accepted if u drawn from Uniform(0,1) is such that u &lt; (posterior probability of m' x Q(m | m'))/(posterior probability of m x Q(m' | m). In this implementation, natural logs are used to simplify calculation, ie a proposal is accepted if log(u) &lt; log [(posterior probability of m' x Q(m | m'))/(posterior probability of m x Q(m' | m)].</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>is a pointer to the target node proposed for splitting. </td></tr>
    <tr><td class="paramname">proposal</td><td>is a reference to a proposal distribution object. </td></tr>
    <tr><td class="paramname">logPrior</td><td>is a reference to a log prior object. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a uniform random number generator. </td></tr>
    <tr><td class="paramname">numLeaves</td><td>is the number of splittable leaves in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree. </td></tr>
    <tr><td class="paramname">numCherries</td><td>is the number of cherries inthe <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree. </td></tr>
    <tr><td class="paramname">minPoints</td><td>is the minimum number of points allowed in a box. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether decision making output is sent to the log file. </td></tr>
    <tr><td class="paramname">s</td><td>is the name of the filename to send logging output to. </td></tr>
    <tr><td class="paramname">i</td><td>is an integer for keeping track of the index for this link in a Markov Chain </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the proposal is accepted (the target will be split), false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">630</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01238">subpavings::SPSnode::getChildrensLeftAndRightCountsIfSplit()</a>, <a class="el" href="classsubpavings_1_1MCMCProposal.shtml#acd6dda5380192dfc3bd38a28925dd1ce">subpavings::MCMCProposal::getLogQRatioSplitProposal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02044">subpavings::SPSnode::getSplitChangeLogLik()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">subpavings::SPnode::hasLeafSibling()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00423">logMCMCDeltas()</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXT</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXTANDGRAPH</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">changeMCMCState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> willSplit = <span class="keyword">false</span>;

  <span class="comment">//cout &lt;&lt; &quot;split or not split with minpoints = &quot; &lt;&lt; minPoints &lt;&lt; endl;</span>
  
    <span class="keywordflow">if</span> ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>))
        <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <span class="stringliteral">&quot;grabbing leaf &quot;</span> + target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>());

    <span class="comment">// change in contribution to log likelihood for this node on split</span>
    real deltaL = rnd(target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab28c35298b721467721228a33a194433" title="Get change in log likelihood on split of this node.">getSplitChangeLogLik</a>());

    <span class="keywordtype">size_t</span> realNumLeaves = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>(); <span class="comment">// realNumLeaves is the number of </span>
                            <span class="comment">//leaf nodes of the &#39;old&#39; state</span>

    <span class="comment">// use the prior distribution object to find the change in prior</span>
    <span class="comment">// here realNumLeaves = #leaves in new state - 1 </span>
    real deltaP = logPrior(realNumLeaves) - logPrior(realNumLeaves - 1);

    <span class="comment">// posterior is proportional to likelihood * prior</span>
    real deltaPi = deltaL + deltaP;

    <span class="comment">// new numbers of leaves and cherries under proposal depends on minPoints</span>
    <span class="comment">// because this determines whether the new leaf children will go into the</span>
    <span class="comment">// nodes container</span>
    <span class="keywordtype">size_t</span> newNumLeaves = numLeaves - 1; <span class="comment">// current number of leaves less this</span>
    <span class="comment">// increase the number of new leaves for each new child that can</span>
    <span class="comment">// go into the nodes container</span>

    <span class="comment">//childrensSpread will be a container of the number of points the children</span>
    <span class="comment">// of each child of target might have, in order</span>
    <span class="comment">// [0] = left child&#39;s left child count, [1] = left child&#39;s rght child count,</span>
    <span class="comment">// [2] = rght child&#39;s left child count, [3] = rght child&#39;s rght child count,</span>
    <a class="code" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81" title="Define type Size_tVec as a container for size_t.">Size_tVec</a> childrensSpread;
    childrensSpread =
                target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acbe47754c218f0c895a900330491cbb3" title="return a container of counts for prospective grandchildren.">getChildrensLeftAndRightCountsIfSplit</a>(childrensSpread);

    <span class="keywordflow">if</span> ((childrensSpread[2] &gt;= minPoints) &amp;&amp;
    (childrensSpread[3] &gt;= minPoints)) {
     <span class="comment">//   cout &lt;&lt; childrensSpread[2] &lt;&lt; &quot;\t&quot; &lt;&lt; childrensSpread[3] &lt;&lt; endl;        </span>
        newNumLeaves++;
    } <span class="comment">// this will add one to the leaf numbers if minPoints == 0</span>

    <span class="comment">// we will also be prepared to put the right child into the container if</span>
    <span class="comment">// there is a minPoints &gt; 0 but one of its</span>
    <span class="comment">// children would take all the points, the other getting none</span>
    <span class="keywordtype">size_t</span> rightChildCount = childrensSpread[2] + childrensSpread[3];
    <span class="keywordflow">if</span> ((minPoints &gt; 0) &amp;&amp; (rightChildCount &gt;= minPoints) &amp;&amp;
        ((childrensSpread[2] == 0) || (childrensSpread[3] == 0))) {
        <span class="comment">//cout &lt;&lt; rightChildCount &lt;&lt; endl;</span>
        newNumLeaves++;
    }

    <span class="keywordflow">if</span> ((childrensSpread[0] &gt;= minPoints) &amp;&amp;
    (childrensSpread[1] &gt;= minPoints)) {
     
      <span class="comment">//cout &lt;&lt; childrensSpread[0] &lt;&lt; &quot;\t&quot; &lt;&lt; childrensSpread[1] &lt;&lt; endl;</span>
        newNumLeaves++;
    }  <span class="comment">// this will add one to the leaf numbers if minPoints == 0</span>

    <span class="comment">// we would also be prepared to put the left child into the container if</span>
    <span class="comment">// there is a minPoints &gt; 0 but one of its</span>
    <span class="comment">// children would take all the points, the other getting none</span>
    <span class="keywordtype">size_t</span> leftChildCount = childrensSpread[0] + childrensSpread[1];
    <span class="keywordflow">if</span> ((minPoints &gt; 0) &amp;&amp; (leftChildCount &gt;= minPoints) &amp;&amp;
        ((childrensSpread[0] == 0) || (childrensSpread[1] == 0))) {
        newNumLeaves++;
    }

    <span class="keywordtype">size_t</span> newNumCherries = numCherries;
    <span class="keywordflow">if</span> (!(target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e" title="Check if this has a leaf sibling.">hasLeafSibling</a>())) newNumCherries = numCherries + 1;

    <span class="comment">// Using proposal distribution object</span>
    real deltaQ = proposal.<a class="code" href="classsubpavings_1_1MCMCProposal.shtml#acd6dda5380192dfc3bd38a28925dd1ce">getLogQRatioSplitProposal</a>(numLeaves, numCherries,
                                                newNumLeaves, newNumCherries);
    <span class="comment">//get another random number</span>
    <span class="keywordtype">double</span> randChange = gsl_rng_uniform(rgsl);
<span class="comment">//  cout &lt;&lt; log(randChange) &lt;&lt; &quot;\t&quot; &lt;&lt; (deltaPi + deltaQ) &lt;&lt; endl;</span>

    <span class="keywordflow">if</span> (log(randChange) &lt; deltaPi + deltaQ) { willSplit = <span class="keyword">true</span>; }

    <span class="keywordflow">if</span> ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>)) { <span class="comment">// log these values</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aedb9ab3c2240403c63f2f5c1d0218350" title="Send a collection of changes in MCMC probabilities to log file.">logMCMCDeltas</a>(s, i, deltaL, deltaP, deltaQ, deltaPi, randChange);
        <span class="keywordflow">if</span> (willSplit) <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <span class="stringliteral">&quot;Splitting&quot;</span>);
        <span class="keywordflow">else</span> <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <span class="stringliteral">&quot;Not splitting&quot;</span>);
    }

    <span class="keywordflow">return</span> willSplit;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa0b81dd06668d2ce34e3fe983a2a2913"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::findDensityRegion" ref="aa0b81dd06668d2ce34e3fe983a2a2913" args="(double cov, double weightPM, vector&lt; SPSnode * &gt; &amp;covNodes, string covFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa0b81dd06668d2ce34e3fe983a2a2913">AdaptiveHistogram::findDensityRegion</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weightPM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>covNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>covFileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the coverage of the boxes in an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04629">4629</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">try</span> {
      <span class="keywordflow">if</span> ( (cov - weightPM) &lt;= 0) {
        cout &lt;&lt; cov &lt;&lt; <span class="stringliteral">&quot; percent of the mass are already covered by the point masses&quot;</span> &lt;&lt; endl;
      }
      <span class="keywordflow">else</span> {
        <span class="comment">// put the leaves into a vector and sort it, smallest to largest</span>
        <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
        <a class="code" href="classsubpavings_1_1CompHeight.shtml" title="Class comparing on count/volume (ie histogram height) of box of node.">CompHeight</a> compheight;
        <span class="comment">//sort according to average height</span>
        sort(leaves.begin(), leaves.end(), <a class="code" href="classMyCompare.shtml">MyCompare</a>(compheight));
        
        <span class="comment">//start iterating from the largest</span>
        SPSnodePtrs::reverse_iterator rit = leaves.rbegin();
        <span class="keywordtype">bool</span> found = FALSE; <span class="comment">//found the boxes that gives cov density region</span>
        
        dotprecision totalCov;
        totalCov = 0.0;
        
        <span class="keywordtype">size_t</span> totalN = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a7386f85d1182ae6e3f32766c4a208c11" title="Gets count in the root paving.">getRootCounter</a>();
        
        <span class="keywordflow">while</span> (!found &amp;&amp; rit &lt; leaves.rend()) {
          <span class="comment">//accumulate the height * box vo\l </span>
          accumulate(totalCov, (1.0*(*rit)-&gt;getCounter())/(1.0*totalN), 1); 

          <span class="comment">//push back the node that fulfill the condition totalCov &lt;= cov </span>
          <span class="comment">//into the container covNodes</span>
          <span class="keywordflow">if</span> (totalCov &lt;= (cov - weightPM) ) { 
            covNodes.push_back((*rit)); 
          } 
          
          <span class="comment">// check that totalCov is at most cov</span>
          <span class="keywordflow">if</span> (totalCov &gt;= (cov - weightPM) ) { found = TRUE; } <span class="comment">// break out of loop</span>
          ++rit;        
        } <span class="comment">// end while </span>
      
      <span class="comment">//output covNodes to .txt </span>
        ofstream os;
        os.open(covFileName.c_str());   
        <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> vit;
        <span class="keywordflow">for</span> (vit = covNodes.begin(); vit &lt; covNodes.end(); vit++) {
          ivector thisBox = (*vit)-&gt;getBox(); <span class="comment">// copy theBox         </span>
          <span class="keywordtype">double</span> vol = (*vit)-&gt;nodeVolume();
          <span class="comment">// output the nodeName, nodeVolume</span>
          os &lt;&lt; (*vit)-&gt;getNodeName();
          os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
          <span class="comment">// followed by the height</span>
          os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; (1.0*(*vit)-&gt;getCounter())/(1.0*totalN)/vol;
          <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
          <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
             os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i]) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
          }
          os &lt;&lt; endl;
        }
        os &lt;&lt; flush;
        os.close();
      } <span class="comment">//end of going through the continuous part</span>
    } <span class="comment">// end of try     </span>
  <span class="keywordflow">catch</span> (exception&amp; e) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(
    <span class="stringliteral">&quot;Error in AdaptiveHistogram::findDensityRegion :\n&quot;</span>
    + <span class="keywordtype">string</span>( e.what() ) );
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b0b0c19870f67a07704458237cf19d0"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::get2DIAE" ref="a2b0b0c19870f67a07704458237cf19d0" args="(taylor::dim2taylor(*testpnt)(taylor::dim2taylor_vector, interval))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b0b0c19870f67a07704458237cf19d0">AdaptiveHistogram::get2DIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a>(*)(<a class="el" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a>, interval)&#160;</td>
          <td class="paramname"><em>testpnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE of a bivariate gaussian/Levy 2D/Rosen 2D distribution.</p>
<p>Get the IAE for 2D distribution </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04597">4597</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="Int_8h.shtml#a0de7ac342c4093f00c8fd6b899e54d87">integrateWithSplitting()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03748">getIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//number of points</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
   
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  (*this).getSubPaving()-&gt;getLeaves(leaves); <span class="comment">// fill the container</span>
  real tol=1e-6;
  <span class="keywordtype">int</span> o=16;
  real result = 0; 
  <span class="keywordflow">for</span> (it=leaves.begin(); it &lt; leaves.end(); it++)
  { 
      <span class="comment">//get domain</span>
    ivector domain = (*it)-&gt;getBox();
    cout &lt;&lt; <span class="stringliteral">&quot;Get IAE for node &quot;</span> &lt;&lt; domain &lt;&lt; endl;
    <span class="comment">//get fhat  </span>
    cout &lt;&lt; <span class="stringliteral">&quot;fhat:&quot;</span> &lt;&lt; endl;
     interval fhat = interval(real((*it)-&gt;getCounter()/
                             (((*it)-&gt;nodeVolume())*1.0*n))); 
     
     <span class="comment">// get the integrated absolute error at this box</span>
    interval resultInt = <a class="code" href="Int_8h.shtml#a0de7ac342c4093f00c8fd6b899e54d87">integrateWithSplitting</a>(testpnt, fhat, domain, o, tol);    
     <span class="comment">//add the errors    </span>
     result += Sup(resultInt);
   }
  <span class="comment">//accounting for boundaries - will have to think about this later perhaps</span>
  <span class="comment">//accumulate(dpIAE,gsl_cdf_ugaussian_P(xlow[0]),1.0);</span>
  <span class="comment">//accumulate(dpIAE,gsl_cdf_ugaussian_Q(xupp[nLeaves-1]),1.0);</span>
  <span class="keywordflow">return</span> result;  
}
</pre></div>
</div>
</div>
<a class="anchor" id="a71b9bb96936f8e5f6a298c6d1a382e0b"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getEMPScoreAIC" ref="a71b9bb96936f8e5f6a298c6d1a382e0b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a71b9bb96936f8e5f6a298c6d1a382e0b">AdaptiveHistogram::getEMPScoreAIC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the EMP part of the AIC score. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01272">1272</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>.</p>

<p>Referenced by <a class="el" href="ScoreTest_8cpp_source.shtml#l00037">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//recalcScaledEMPSumAIC();</span>
    <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
    <span class="keywordflow">return</span> rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="afb0bda49b3a39ab8aa53737de810afec"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getEMPScoreCOPERR" ref="afb0bda49b3a39ab8aa53737de810afec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb0bda49b3a39ab8aa53737de810afec">AdaptiveHistogram::getEMPScoreCOPERR</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the EMP part of the COPERR score. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01264">1264</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>.</p>

<p>Referenced by <a class="el" href="ScoreTest_8cpp_source.shtml#l00037">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//recalcScaledEMPSumCOPERR();</span>
    <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
    <span class="keywordflow">return</span> rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a513472c79b4a9337dcb5445be825a8f3"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getEstLogLikelihoodFromRSSample" ref="a513472c79b4a9337dcb5445be825a8f3" args="(RSSample &amp;labSampledData, double dx, double wt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a513472c79b4a9337dcb5445be825a8f3">subpavings::AdaptiveHistogram::getEstLogLikelihoodFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>labSampledData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the estimated log likelihood from <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a>. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01629">1629</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>
<div class="fragment"><pre class="fragment">  { <span class="keywordtype">double</span> WeightHist = 1.0;
    std::map&lt;rvector, double, std::less&lt;rvector&gt; &gt; WeightsPM;
    <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a513472c79b4a9337dcb5445be825a8f3">getEstLogLikelihoodFromRSSample</a>(labSampledData,
                    dx, wt, WeightHist, WeightsPM); } 
</pre></div>
</div>
</div>
<a class="anchor" id="aca5143d5da261357d7f8d7eec45d1a5c"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getEstLogLikelihoodFromRSSample" ref="aca5143d5da261357d7f8d7eec45d1a5c" args="(RSSample &amp;labSampledData, double dx, double wt, double WeightHist, std::map&lt; rvector, double, std::less&lt; rvector &gt; &gt; &amp;WeightsPM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a513472c79b4a9337dcb5445be825a8f3">AdaptiveHistogram::getEstLogLikelihoodFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>labSampledData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>WeightHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; rvector, double, std::less&lt; rvector &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>WeightsPM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Distribution-free Likelihood Estimation </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03650">3650</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01023">insertFromRSSample()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03638">makeEmpty()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01396">N()</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>.</p>
<div class="fragment"><pre class="fragment">{
    dotprecision dpEstLogLik;
    dpEstLogLik = 0.0;
      
    <span class="comment">//Get log-likelihoods for points in model 1, </span>
    <span class="comment">//and points both in model 0 and 1</span>
    
    <span class="comment">//first multiply the box heights with the weight corresponding to the</span>
    <span class="comment">// histogram model</span>
    vector&lt;double&gt; fhat; <span class="comment">//container to store heights</span>
    <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
      <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
      <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>
      <span class="keywordtype">size_t</span> <a class="code" href="errorfunc_8cpp.shtml#abcd464084d71d1ca5caf89793fa1d050">N</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a7386f85d1182ae6e3f32766c4a208c11" title="Gets count in the root paving.">getRootCounter</a>();
    <span class="comment">// add wt to the heights at each box</span>
    <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
      fhat.push_back(WeightHist*
      (((1-wt)*(*it)-&gt;getCounter()/(N*1.0)/(*it)-&gt;nodeVolume()) + wt));
    }
    
    
    <span class="comment">// clear the current histogram&#39;s data and counters and </span>
    <span class="comment">// insert new data into the histogram </span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> tempHist = (*this);
    tempHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8f3844b0b56fb1aaa96c44558dd8e4a4" title="Clear the histogram&#39;s data and counters.">makeEmpty</a>(); 
    
    <span class="comment">//cout &lt;&lt; &quot;insert from model 1&quot; &lt;&lt; endl;    </span>
    <span class="comment">// insert data from model 1 into the empty hist </span>
     <span class="keywordtype">bool</span> hasData = <span class="keyword">false</span>;
    hasData = tempHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">insertFromRSSample</a>(labSampledData, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>, 1);
    <span class="keywordflow">if</span> (hasData) {
      <span class="comment">//now get the estimated likelihood</span>
      <span class="keywordtype">size_t</span> pos = 0;
      <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leavesTemp; <span class="comment">// set up empty container for leaf node pointers</span>
      tempHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leavesTemp); <span class="comment">// fill the container</span>
      <span class="keywordflow">for</span>(it = leavesTemp.begin(); it &lt; leavesTemp.end(); it++) {
        <span class="keywordflow">if</span> ((*it)-&gt;getCounter() != 0) {       
          <span class="comment">//cout &lt;&lt; fhat[pos] &lt;&lt; &quot;\t&quot; &lt;&lt; (*it)-&gt;getCounter() &lt;&lt;&quot;\t&quot; &lt;&lt; dx*fhat[pos] &lt;&lt; &quot;\t&quot; &lt;&lt; ((*it)-&gt;getCounter())*log(dx*fhat[pos]) &lt;&lt; endl;</span>
          accumulate(dpEstLogLik, ((*it)-&gt;getCounter())*log(dx*fhat[pos]), 1);
          <span class="comment">//cout &lt;&lt; dpEstLogLik &lt;&lt; endl;</span>
        }
        pos++; 
      }   
    } <span class="comment">// end of if hasData for label 1</span>
    
    <span class="comment">//make tempHist empty again</span>
    tempHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8f3844b0b56fb1aaa96c44558dd8e4a4" title="Clear the histogram&#39;s data and counters.">makeEmpty</a>();
    <span class="comment">//insert data from model 0</span>
    <span class="comment">//cout &lt;&lt; &quot;inserting from model 0&quot; &lt;&lt; endl;</span>
    hasData = <span class="keyword">false</span>;
    hasData =tempHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">insertFromRSSample</a>(labSampledData, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>, 0);
     <span class="keywordflow">if</span> (hasData) {
       <span class="keywordtype">size_t</span> pos = 0;
      <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leavesTemp; <span class="comment">// set up empty container for leaf node pointers</span>
      tempHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leavesTemp); <span class="comment">// fill the container</span>
      <span class="keywordflow">for</span>(it = leavesTemp.begin(); it &lt; leavesTemp.end(); it++) {
        <span class="keywordflow">if</span> ((*it)-&gt;getCounter() != 0) {       
          <span class="comment">//get the node&#39;s data</span>
          <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> nodeData = (*it)-&gt;getData();
          <span class="comment">//go through each data in node</span>
          <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dit;
          <span class="keywordflow">for</span> (dit = nodeData.begin(); dit != nodeData.end(); dit++){
            <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *dit; 
                  rvector theData = *bigIt;  <span class="comment">// convert NodeData to rvector</span>
            
            <span class="comment">//get the EMF</span>
             <span class="keywordflow">if</span> ( WeightsPM[theData] != 0 ) {
            <span class="comment">//the check for WeightsPM[theData] is needed because there </span>
            <span class="comment">//may be point mass in the sampled data but not in the </span>
            <span class="comment">//histogram that you are observing the data with</span>
              <span class="comment">//cout &lt;&lt; (*it)-&gt;getCounter() &lt;&lt; &quot;\t&quot; &lt;&lt; (*bigIt) &lt;&lt; endl;</span>
              <span class="comment">//cout &lt;&lt; dx*fhat[pos] &lt;&lt; &quot;\t&quot; &lt;&lt; WeightsPM[theData] &lt;&lt; endl; </span>
              accumulate(dpEstLogLik, log(dx*fhat[pos] + WeightsPM[theData]), 1);
              <span class="comment">//cout &lt;&lt; dpEstLogLik &lt;&lt; endl;</span>
            } <span class="comment">// end of weight check</span>
            <span class="keywordflow">else</span> {
              <span class="comment">//cout &lt;&lt; (*it)-&gt;getCounter() &lt;&lt; &quot;\t&quot; &lt;&lt; (*bigIt) &lt;&lt; endl;</span>
              <span class="comment">//cout &lt;&lt; dx*fhat[pos] &lt;&lt; endl; </span>
              accumulate(dpEstLogLik, log(dx*fhat[pos]), 1);
              <span class="comment">//cout &lt;&lt; dpEstLogLik &lt;&lt; endl;</span>
            }
          } <span class="comment">// end of going through node&#39;s data     </span>
        } <span class="comment">// if counter &lt; 0</span>
        pos++; 
      } <span class="comment">// end of iterating over leaves     </span>
    } <span class="comment">// end of if hasData for label 0   </span>
        
    real estLogLik = rnd(dpEstLogLik);
    <span class="keywordflow">return</span> estLogLik;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a368e5e9ed8cf0a3e82b30291c4a54d24"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getFinMixIAE" ref="a368e5e9ed8cf0a3e82b30291c4a54d24" args="(FinMix &amp;mixt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a368e5e9ed8cf0a3e82b30291c4a54d24">AdaptiveHistogram::getFinMixIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a finite gaussian mixture distribution.</p>
<p>Get the IAE for a finite mixture distribution </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03895">3895</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAEBoun</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00223">FinMix::fhat</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00191">FinMixAbs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">{
  cout &lt;&lt; <span class="stringliteral">&quot;GEtting IAE for Finite Mixture: &quot;</span> &lt;&lt; endl; 

  <span class="comment">//---------fill in containers for names, volumes and heights of leaves</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  (*this).getSubPaving()-&gt;getLeaves(leaves); <span class="comment">// fill the container</span>
  <span class="comment">//a container for the counts</span>
  <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> counts;  <span class="comment">// IntVec is a typedef for vector&lt;int&gt;</span>
  <span class="comment">//a container for the boxes</span>
  vector&lt;ivector&gt; boxes; vector&lt;ivector&gt;::iterator itBoxes;
  <span class="comment">//a container for the volumes</span>
  vector&lt;double&gt; volumes;
  <span class="comment">// a container for fhat</span>
  vector&lt;double&gt; fhat; vector&lt;double&gt;::iterator itFhat;
  <span class="comment">//number of points</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
            
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    <span class="comment">// remember that it points to a pointer, so *it is still a ptr</span>
    <span class="comment">// get the counts in all the leaves</span>
     counts.push_back((*it)-&gt;getCounter());
     <span class="comment">// get the boxes from all the leaves</span>
     boxes.push_back((*it)-&gt;getBox());
     <span class="comment">// get the volumes of all the leaves</span>
     volumes.push_back((*it)-&gt;nodeVolume());
     <span class="comment">// get fhat for all leaves</span>
     fhat.push_back(((*it)-&gt;getCounter())/((*it)-&gt;nodeVolume())/n);
  } <span class="comment">// end of iterating through leaves </span>
  
  <span class="comment">//----------------get the IAE-----------------------------------------------</span>
  dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>, <a class="code" href="HoldOutFinMix_8cpp.shtml#a97e24d3d1886f2162f0daa315bc812a7">dpIAEBoun</a>;
  dpIAE = 0.0;
  <span class="keywordtype">int</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>=counts.size();
  
  gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
  <span class="keywordtype">double</span> result = 0.0;
  <span class="keywordtype">double</span> error;
  gsl_function <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>;
  
  F.function = &amp;<a class="code" href="errorfunc_8cpp.shtml#a0350bc07337b5abac1dca82fb195940d" title="Get the absolute error of a finite mixture at x.">FinMixAbs</a>;
  F.params =  &amp;mixt;
  
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; j++){
    mixt.<a class="code" href="structFinMix.shtml#a7d058312162e6b9ccb408ddc688a274f">fhat</a> = fhat[j];
    rvector xuppVec = Sup(boxes[j]);
    <span class="keywordtype">double</span> xupp = _double(xuppVec[1]);
    rvector xlowVec = Inf(boxes[j]);
    <span class="keywordtype">double</span> xlow = _double(xlowVec[1]);
    gsl_integration_qags(&amp;F, xlow, xupp, 0, 1e-7, 1000, w, &amp;result, &amp;error);
    accumulate(dpIAE, result, 1.0);
  }
  
  <span class="comment">/*</span>
<span class="comment">  // Accounting for the boundaries</span>
<span class="comment">  rvector xuppVec1 = Sup(boxes[Nbin-1]);</span>
<span class="comment">  double xupp1 = _double(xuppVec1[1]);</span>
<span class="comment">  rvector xlowVec1 = Inf(boxes[0]);</span>
<span class="comment">  double xlow1 = _double(xlowVec1[1]);</span>
<span class="comment">  dpIAEBoun = dpFinMixIAEBoun(xlow1, xupp1, mixt);</span>
<span class="comment">  dpIAE += dpIAEBoun;</span>
<span class="comment">  */</span>
  
  <span class="comment">// cast dot precision to real</span>
  real FinMixIAE = rnd(dpIAE);
  
  <span class="comment">// free the workspace</span>
  gsl_integration_workspace_free (w);
  
  <span class="keywordflow">return</span> FinMixIAE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abf4e34e57ff3c76828457efaecbf4510"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getFinMixIntervalIAE" ref="abf4e34e57ff3c76828457efaecbf4510" args="(FinMix &amp;mixt, double tol, int deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::interval <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#abf4e34e57ff3c76828457efaecbf4510">AdaptiveHistogram::getFinMixIntervalIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a finite gaussian mixture distribution using interval techniques. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03970">3970</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01504">getL1error()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00221">FinMix::M</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00222">FinMix::S</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00220">FinMix::W</a>.</p>

<p>Referenced by <a class="el" href="FiniteMixture_8cpp_source.shtml#l00045">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  interval totalArea(0.0); <span class="comment">//initialize</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a7386f85d1182ae6e3f32766c4a208c11" title="Gets count in the root paving.">getRootCounter</a>();

  <span class="comment">// need to iterate through the leaves</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>
  
  <span class="comment">// container is filled by reading leaves off tree from left to right</span>
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    <span class="comment">//cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span>
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;
    
    <span class="comment">//get the height in this leaf node</span>
    <span class="keywordtype">double</span> fhat = (*it)-&gt;getCounter()/(*it)-&gt;nodeVolume()/n;
    <span class="comment">//get the box of this leaf node</span>
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout &lt;&lt; (*it)-&gt;getBox() &lt;&lt; endl;</span>
    
    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    <span class="comment">// find the root</span>
    <span class="comment">//cout &lt;&lt; &quot;finding roots at this node &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
    <a class="code" href="errorfunc_8cpp.shtml#a4a991d5ab1bd0a117e02af6f83369bab">bisect</a>(thisIntW, tol, fhat, rootVec, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>); 

    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      <span class="comment">//cout &lt;&lt; &quot;no roots at &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        <span class="comment">//cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
        <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      <span class="comment">//cout &lt;&lt; &quot;==There are &quot; &lt;&lt; uniqueRootVec.size() &lt;&lt; &quot; unique root(s)==&quot; &lt;&lt; endl;</span>

      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        <span class="comment">//cout &lt;&lt; &quot;there is only one root..&quot; &lt;&lt; endl;</span>
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the left/right boundary:&quot; &lt;&lt; rootVec[0] &lt;&lt; endl;</span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          <span class="comment">//cout &lt;&lt; &quot;no root at the boundaries&quot; &lt;&lt; endl;</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;left interval: &quot; &lt;&lt; thisSubIntLeft &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLeft, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          <span class="comment">//cout &lt;&lt; &quot;right interval: &quot; &lt;&lt; thisSubIntRight &lt;&lt; endl; </span>
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntRight, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;let&#39;s have a look at all the roots:&quot; &lt;&lt; endl;</span>
        <span class="comment">//for (size_t i = 0; i &lt; uniqueRootVec.size(); i++) {</span>
          <span class="comment">//cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//}</span>

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>

  } <span class="comment">// end of iterating through the leaf nodes</span>
  
  <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; totalArea &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> totalArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae90ad88f52691280d18f4b6f2e3b7ad1"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getHoldAllStats" ref="ae90ad88f52691280d18f4b6f2e3b7ad1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae90ad88f52691280d18f4b6f2e3b7ad1">AdaptiveHistogram::getHoldAllStats</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the value of holdAllStats field. </p>
<p>This determines whether the histrogram's rootPaving will maintain all available stats (true) or just the counts (false). </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01353">1353</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00109">holdAllStats</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01166">operator+()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a28b0435b5ee65b27b2459d3dc3fc224d"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getIAE" ref="a28b0435b5ee65b27b2459d3dc3fc224d" args="(int distr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a28b0435b5ee65b27b2459d3dc3fc224d">AdaptiveHistogram::getIAE</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE of a distribution.</p>
<p>Get the IAE of the corresponding distribution based on function arguments. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03748">3748</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l00059">BiGOP()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04597">get2DIAE()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00088">LevyOP()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l00129">RosenOP()</a>.</p>

<p>Referenced by <a class="el" href="RosenMIAE_8cpp_source.shtml#l00056">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
      real IAE = 0;
    <a class="code" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a> (*testpnt)(<a class="code" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a>, interval);
    <span class="keywordflow">switch</span>(distr)
    { 
         <span class="keywordflow">case</span> 1: <span class="comment">//bivariate gaussian mixtures</span>
         testpnt = <a class="code" href="errorfunc_8cpp.shtml#abd72fe76528917561a4e1a7fdf7890d9" title="IAE for the bivariate gaussian.">BiGOP</a>;
      IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b0b0c19870f67a07704458237cf19d0">get2DIAE</a>(testpnt);
      <span class="keywordflow">break</span>;
      
      <span class="keywordflow">case</span> 2: <span class="comment">// Levy 2D</span>
      testpnt = <a class="code" href="errorfunc_8cpp.shtml#a72f3aaf218533dc785d09b0dffacbad7" title="IAE for the Levy 2D.">LevyOP</a>;
      IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b0b0c19870f67a07704458237cf19d0">get2DIAE</a>(testpnt);
      <span class="keywordflow">break</span>;
      
      <span class="keywordflow">case</span> 3: <span class="comment">//Rosenbrock 2D</span>
      testpnt = <a class="code" href="errorfunc_8cpp.shtml#a77af86554abcee2e013b9d8631ed4c5f" title="IAE for a Rosenbrock 2D.">RosenOP</a>;
      IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b0b0c19870f67a07704458237cf19d0">get2DIAE</a>(testpnt);
      <span class="keywordflow">break</span>;
    }   
    <span class="keywordflow">return</span> IAE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adc2a97bb7f8fc3c543f90ba876515ca1"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getLabel" ref="adc2a97bb7f8fc3c543f90ba876515ca1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adc2a97bb7f8fc3c543f90ba876515ca1">AdaptiveHistogram::getLabel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the label for this. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01220">1220</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 0; <span class="comment">//this is temporarily for gat41 src</span>
  <span class="comment">//return label;</span>
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a2427c16c05dc17a5d7ecb1e58f0d35ca"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getLaplaceIntervalIAE" ref="a2427c16c05dc17a5d7ecb1e58f0d35ca" args="(double tol, int deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::interval <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2427c16c05dc17a5d7ecb1e58f0d35ca">AdaptiveHistogram::getLaplaceIntervalIAE</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for mapped function. Get the IAE for a laplace distribution with mu=0 and b=1 using interval techniques. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04206">4206</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01692">LaplaceBisect()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01777">LaplaceGetL1error()</a>.</p>

<p>Referenced by <a class="el" href="Laplace1_8cpp_source.shtml#l00038">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  interval totalArea(0.0); <span class="comment">//initialize</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a7386f85d1182ae6e3f32766c4a208c11" title="Gets count in the root paving.">getRootCounter</a>();

  <span class="comment">// need to iterate through the leaves</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>
  
  <span class="comment">// container is filled by reading leaves off tree from left to right</span>
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    cout &lt;&lt; <span class="stringliteral">&quot;-----------------&quot;</span> &lt;&lt; endl;
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;
    
    <span class="comment">//get the height in this leaf node</span>
    <span class="keywordtype">double</span> fhat = (*it)-&gt;getCounter()/(*it)-&gt;nodeVolume()/n;
    <span class="comment">//get the box of this leaf node</span>
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout &lt;&lt; (*it)-&gt;getBox() &lt;&lt; endl;</span>
    
    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    <span class="comment">// find the root</span>
    cout &lt;&lt; <span class="stringliteral">&quot;finding roots at this node &quot;</span> &lt;&lt; thisInt &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;bisection&quot;</span> &lt;&lt; endl;
    <a class="code" href="errorfunc_8cpp.shtml#a4de668d5d847a753a9a4baf05c7d8d52">LaplaceBisect</a>(thisIntW, tol, fhat, rootVec); 

    cout &lt;&lt; <span class="stringliteral">&quot;get L1 error&quot;</span> &lt;&lt; endl;
    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      cout &lt;&lt; <span class="stringliteral">&quot;no roots at &quot;</span> &lt;&lt; thisInt &lt;&lt; endl;
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisInt, deg, tol);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        cout &lt;&lt; <span class="stringliteral">&quot;root &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; rootVec[i] &lt;&lt; endl;
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
        <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      cout &lt;&lt; <span class="stringliteral">&quot;==There are &quot;</span> &lt;&lt; uniqueRootVec.size() &lt;&lt; <span class="stringliteral">&quot; unique root(s)==&quot;</span> &lt;&lt; endl;

      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        cout &lt;&lt; <span class="stringliteral">&quot;there is only one root..&quot;</span> &lt;&lt; endl;
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
        cout &lt;&lt; <span class="stringliteral">&quot;there&#39;s a root at the left/right boundary:&quot;</span> &lt;&lt; rootVec[0] &lt;&lt; endl;
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisInt, deg, tol);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          cout &lt;&lt; <span class="stringliteral">&quot;no root at the boundaries&quot;</span> &lt;&lt; endl;
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          cout &lt;&lt; <span class="stringliteral">&quot;left interval: &quot;</span> &lt;&lt; thisSubIntLeft &lt;&lt; endl; 
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLeft, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          cout &lt;&lt; <span class="stringliteral">&quot;right interval: &quot;</span> &lt;&lt; thisSubIntRight &lt;&lt; endl; 
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntRight, deg, tol);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        cout &lt;&lt; <span class="stringliteral">&quot;let&#39;s have a look at all the roots:&quot;</span> &lt;&lt; endl;
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; uniqueRootVec.size(); i++) {
          cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;
        }

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>

  } <span class="comment">// end of iterating through the leaf nodes</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;IAE: &quot;</span> &lt;&lt; totalArea &lt;&lt; endl;
  <span class="keywordflow">return</span> totalArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaffb116a24a6de03482a8bfd9625b07f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getLeafCounts" ref="aaffb116a24a6de03482a8bfd9625b07f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaffb116a24a6de03482a8bfd9625b07f">AdaptiveHistogram::getLeafCounts</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector of the leaf node counts.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of leaf counts, left to right order, </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03516">3516</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01308">subpavings::SPSnode::getLeafNodeCounts()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81" title="Define type Size_tVec as a container for size_t.">Size_tVec</a> counts; <span class="comment">// empty container</span>
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2f8ce829fd9ba3ef3838d640ae201e9e">getLeafNodeCounts</a>(counts);
        <span class="comment">//levels has now been filled in</span>
    }
    <span class="keywordflow">return</span> counts;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a70f9af80f0ee875d6dcbfd4cafb53813"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getLeafLevels" ref="a70f9af80f0ee875d6dcbfd4cafb53813" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a70f9af80f0ee875d6dcbfd4cafb53813">AdaptiveHistogram::getLeafLevels</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector of the leaf node levels.</p>
<p>Root is level 0, next level down is 1, etc.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of leaf levels, left to right order, </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03502">3502</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00621">subpavings::SPnode::getLeafNodeLevels()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="HistReport_8cpp_source.shtml#l00058">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> levels; <span class="comment">// empty container</span>

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(0, levels);
        <span class="comment">//levels has now been filled in</span>
    }
    <span class="keywordflow">return</span> levels;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aca69edc461799f9d867d7eea6cb76f8e"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getLeafLevelsString" ref="aca69edc461799f9d867d7eea6cb76f8e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">AdaptiveHistogram::getLeafLevelsString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a string of the leaf node levels.</p>
<p>Root is level 0, next level down is 1, etc. Example return string "3,3,2,1"</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a comma separated string of leaf levels, left to right order </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">1376</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00692">subpavings::SPnode::getLeafNodeLevelsString()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="HistReport_8cpp_source.shtml#l00058">main()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00484">MCMCLogFinalState()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">string</span> retValue = <span class="stringliteral">&quot;&quot;</span>;
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>)
        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a7ea8cd3649cbf13d5743d3cb23315d72" title="Get a string of leaf node levels.">getLeafNodeLevelsString</a>();

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa595732ddb587933a166aee6cc0877f6"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getLognormalIntervalIAE" ref="aa595732ddb587933a166aee6cc0877f6" args="(double tol, int deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::interval <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa595732ddb587933a166aee6cc0877f6">AdaptiveHistogram::getLognormalIntervalIAE</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a laplace distribution with mu=0 and b=1 using interval techniques. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04402">4402</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01878">LognormalBisect()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01960">LognormalGetL1error()</a>.</p>

<p>Referenced by <a class="el" href="Lognormal1_8cpp_source.shtml#l00038">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  interval totalArea(0.0); <span class="comment">//initialize</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a7386f85d1182ae6e3f32766c4a208c11" title="Gets count in the root paving.">getRootCounter</a>();

  <span class="comment">// need to iterate through the leaves</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>
  
  <span class="comment">// container is filled by reading leaves off tree from left to right</span>
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    <span class="comment">//cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span>
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;
    
    <span class="comment">//get the height in this leaf node</span>
    <span class="keywordtype">double</span> fhat = (*it)-&gt;getCounter()/(*it)-&gt;nodeVolume()/n;
    <span class="comment">//get the box of this leaf node</span>
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout &lt;&lt; (*it)-&gt;getBox() &lt;&lt; endl;</span>
    
    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    <span class="comment">// find the root</span>
    <span class="comment">//cout &lt;&lt; &quot;finding roots at this node &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
    <a class="code" href="errorfunc_8cpp.shtml#a9722cc78b34593d877ec8cbbb22ac9f2">LognormalBisect</a>(thisIntW, tol, fhat, rootVec); 

    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      <span class="comment">//cout &lt;&lt; &quot;no roots at &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisInt, deg, tol);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        <span class="comment">//cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
        <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      <span class="comment">//cout &lt;&lt; &quot;==There are &quot; &lt;&lt; uniqueRootVec.size() &lt;&lt; &quot; unique root(s)==&quot; &lt;&lt; endl;</span>

      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        <span class="comment">//cout &lt;&lt; &quot;there is only one root..&quot; &lt;&lt; endl;</span>
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the left/right boundary:&quot; &lt;&lt; rootVec[0] &lt;&lt; endl;</span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisInt, deg, tol);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          <span class="comment">//cout &lt;&lt; &quot;no root at the boundaries&quot; &lt;&lt; endl;</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;left interval: &quot; &lt;&lt; thisSubIntLeft &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLeft, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          <span class="comment">//cout &lt;&lt; &quot;right interval: &quot; &lt;&lt; thisSubIntRight &lt;&lt; endl; </span>
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntRight, deg, tol);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;let&#39;s have a look at all the roots:&quot; &lt;&lt; endl;</span>
        <span class="comment">//for (size_t i = 0; i &lt; uniqueRootVec.size(); i++) {</span>
          <span class="comment">//cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//}</span>

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea =<a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea =<a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>

  } <span class="comment">// end of iterating through the leaf nodes</span>
  
  <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; totalArea &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> totalArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0ef2d251d61753086a358bdd9bda057f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getMinVol" ref="a0ef2d251d61753086a358bdd9bda057f" args="(double minVolB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0ef2d251d61753086a358bdd9bda057f">AdaptiveHistogram::getMinVol</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the value of the minimum volume for a splittable node. </p>
<p>Minimum volume = minVolB * (log n) ^2/n where n is points in histogram. Minimum volume is used in COPERR or AIC priority queue splitting to limit which nodes can be split. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minVolB</td><td>the multiplier applied to log n) ^2/n to find the minimum allowed node volume at which a node can be split (children will half the volume of the parent node). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">1339</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">double</span> retValue = 0.0;

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {

        <span class="keywordtype">size_t</span> counter = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
        retValue = minVolB;
       <span class="comment">// retValue =  minVolB * log(1.0*counter)*log(1.0*counter)/counter;</span>
    }
    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acb7aa3bb3a7b4d4691e9b5b9c9d4a765"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getPENValue" ref="acb7aa3bb3a7b4d4691e9b5b9c9d4a765" args="(const PenObj &amp;pen, int deltaLeaf=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765">AdaptiveHistogram::getPENValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1PenObj.shtml">PenObj</a> &amp;&#160;</td>
          <td class="paramname"><em>pen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deltaLeaf</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the PEN value. </p>
<p>Get the value of the PEN given penalty function object pen.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pen</td><td>is the penalty function object </td></tr>
    <tr><td class="paramname">deltaLeaf</td><td>the number of additional leaves (can be negative) to calulate the PEN with: allows changes in histogram shape to be evaluated. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01256">1256</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01311">getScoreAIC()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01282">getScoreCOPERR()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> pen(<span class="keyword">this</span>, deltaLeaf);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a936a3426494278163afada104df26ecc"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getRootBox" ref="a936a3426494278163afada104df26ecc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::ivector <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a936a3426494278163afada104df26ecc">AdaptiveHistogram::getRootBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the box of the subpaving managed by this. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>with the present constructors, it is impossible for this to have a subpaving but for the subpaving to have no box.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>copy of the box of the subpaving managed by this. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaf5eac63bd232e3e76f20a27587c8784" title="Get whether this has a subpaving to manage.">hasSubPaving()</a> == true. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">1366</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01360">hasSubPaving()</a>.</p>

<p>Referenced by <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml#l00116">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaf5eac63bd232e3e76f20a27587c8784" title="Get whether this has a subpaving to manage.">hasSubPaving</a>()) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NullSubpavingPointer__Error.shtml">NullSubpavingPointer_Error</a>(
              <span class="stringliteral">&quot;AdaptiveHistogram::getRootBox()&quot;</span>);
  }
  <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7386f85d1182ae6e3f32766c4a208c11"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getRootCounter" ref="a7386f85d1182ae6e3f32766c4a208c11" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a7386f85d1182ae6e3f32766c4a208c11">AdaptiveHistogram::getRootCounter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets count in the root paving. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">1243</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04629">findDensityRegion()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03650">getEstLogLikelihoodFromRSSample()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03970">getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04206">getLaplaceIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04402">getLognormalIntervalIAE()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00146">subpavings::PenAIC2::operator()()</a>, and <a class="el" href="histpenalty_8hpp_source.shtml#l00185">subpavings::PenAIC3::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); }
</pre></div>
</div>
</div>
<a class="anchor" id="ae4a71d928009eda0a6332f20fd951e35"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getRootLeaves" ref="ae4a71d928009eda0a6332f20fd951e35" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35">AdaptiveHistogram::getRootLeaves</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets number of leaf nodes in the root paving. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">1247</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02236">subpavings::spLeaves()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">decisionMCMCMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">decisionMCMCSplit()</a>, <a class="el" href="FiniteMixture_8cpp_source.shtml#l00045">main()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00106">subpavings::PenAIC1::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00146">subpavings::PenAIC2::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00185">subpavings::PenAIC3::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00222">subpavings::PenAIC4::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00253">subpavings::PenAIC5::operator()()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="namespacesubpavings.shtml#acd777346441d8790899ec09af3b11d61" title="Get the number of leaves of a tree (boxes in the subpaving)">spLeaves</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>); }
</pre></div>
</div>
</div>
<a class="anchor" id="a95d9506c9ceea0359b99b0e36f1eff91"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getRootPavingMean" ref="a95d9506c9ceea0359b99b0e36f1eff91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a95d9506c9ceea0359b99b0e36f1eff91">AdaptiveHistogram::getRootPavingMean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the mean from the root box of the paving this manages. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01227">1227</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01499">subpavings::SPSnode::getMean()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00109">holdAllStats</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml#l00116">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>) std::cout &lt;&lt; <span class="stringliteral">&quot;Note, holdAllStats is false.&quot;</span>
                &lt;&lt; std::endl;
    <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#aa5ae31017fb2fdee8b9168009d8d08a6" title="Get the sample mean.">getMean</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2bbfcf884ee91c2457eb2e9d2b81e31f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getRootPavingVarCovar" ref="a2bbfcf884ee91c2457eb2e9d2b81e31f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2bbfcf884ee91c2457eb2e9d2b81e31f">AdaptiveHistogram::getRootPavingVarCovar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets variance covariance vector from root box of rootpaving. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01235">1235</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01953">subpavings::SPSnode::getVarCovar()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00109">holdAllStats</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml#l00116">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>) std::cout &lt;&lt; <span class="stringliteral">&quot;Note, holdAllStats is false.&quot;</span>
            &lt;&lt; std::endl;
    <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">getVarCovar</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac7f7cb4d5aea17c967afec84e1159f9b"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getRootSumLeafCountOverVol" ref="ac7f7cb4d5aea17c967afec84e1159f9b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ac7f7cb4d5aea17c967afec84e1159f9b">AdaptiveHistogram::getRootSumLeafCountOverVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the sum of leaf count over volume in root paving. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01251">1251</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01394">subpavings::SPSnode::getSumLeafCountOverVol()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="histpenalty_8hpp_source.shtml#l00146">subpavings::PenAIC2::operator()()</a>, and <a class="el" href="histpenalty_8hpp_source.shtml#l00185">subpavings::PenAIC3::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#adf589d16a3e20b4285f428c8dc42d75d" title="Get the sum of the count over volume in the leaf nodes.">getSumLeafCountOverVol</a>(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a8333360139bee06eb9c661b8a47cb4a3"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getScoreAIC" ref="a8333360139bee06eb9c661b8a47cb4a3" args="(const PenObj &amp;pen, bool verbose=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8333360139bee06eb9c661b8a47cb4a3">AdaptiveHistogram::getScoreAIC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1PenObj.shtml">PenObj</a> &amp;&#160;</td>
          <td class="paramname"><em>pen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get AIC score. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pen</td><td>is the penalty function object </td></tr>
    <tr><td class="paramname">verbose</td><td>option: true for extra console output (default false) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01311">1311</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01256">getPENValue()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>.</p>

<p>Referenced by <a class="el" href="ScoreTest_8cpp_source.shtml#l00037">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    dotprecision temptotal = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>;

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {

        <span class="keywordtype">size_t</span> counter = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();

        <span class="keywordflow">if</span> (verbose) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;AIC EMP is &quot;</span> &lt;&lt;
                        rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>) &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="stringliteral">&quot;AIC penalty is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765" title="get the PEN value.">getPENValue</a>(pen, 0) &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="stringliteral">&quot;Total AIC score is &quot;</span> &lt;&lt;
                        rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>) + <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765" title="get the PEN value.">getPENValue</a>(pen, 0) &lt;&lt; std::endl;

        }

        <span class="comment">// getPENValue(pen, 0) gives value of PEN under pen</span>
        accumulate(temptotal, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765" title="get the PEN value.">getPENValue</a>(pen, 0), 1.0);
        <span class="comment">// temptotal now holds scaledEMPSumAIC + PEN)</span>
    }

    <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
    <span class="keywordflow">return</span> rnd(temptotal);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a94e90e67d767c5e0ad7b4378e0a72cad"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getScoreCOPERR" ref="a94e90e67d767c5e0ad7b4378e0a72cad" args="(const PenObj &amp;pen, bool verbose=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a94e90e67d767c5e0ad7b4378e0a72cad">AdaptiveHistogram::getScoreCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1PenObj.shtml">PenObj</a> &amp;&#160;</td>
          <td class="paramname"><em>pen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the COPERR score. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pen</td><td>is the penalty function object </td></tr>
    <tr><td class="paramname">verbose</td><td>option: true for extra console output (default false) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01282">1282</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01256">getPENValue()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>.</p>

<p>Referenced by <a class="el" href="ScoreTest_8cpp_source.shtml#l00037">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    dotprecision temptotal = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>;

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {

        <span class="keywordtype">size_t</span> counter = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();

        <span class="keywordflow">if</span> (verbose) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;COPERR EMP is &quot;</span> &lt;&lt;
                        rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>) &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="stringliteral">&quot;COPERR penalty is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765" title="get the PEN value.">getPENValue</a>(pen, 0) &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="stringliteral">&quot;Total COPERR score is &quot;</span> &lt;&lt;
                        rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>) + <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765" title="get the PEN value.">getPENValue</a>(pen, 0) &lt;&lt; std::endl;

        }

       <span class="comment">// getPENValue(pen, 0) gives value of PEN under pen</span>
        accumulate(temptotal, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acb7aa3bb3a7b4d4691e9b5b9c9d4a765" title="get the PEN value.">getPENValue</a>(pen), 1.0);
        <span class="comment">// temptotal now holds scaledEMPSumCOPERR + PEN)</span>
    }

    <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
    <span class="keywordflow">return</span> rnd(temptotal);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aecbdfe366fa381c0b3f7a7b00447dedb"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getSubPaving" ref="aecbdfe366fa381c0b3f7a7b00447dedb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb">AdaptiveHistogram::getSubPaving</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> this manages. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">1216</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00256">subpavings::AdaptiveHistogramCollator::AdaptiveHistogramCollator()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00564">subpavings::AdaptiveHistogramCollator::addNegationToCollation()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramCollator::addToCollation()</a>, <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04629">findDensityRegion()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03650">getEstLogLikelihoodFromRSSample()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03970">getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04206">getLaplaceIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04402">getLognormalIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">getRootBox()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03774">getUnifIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01360">hasSubPaving()</a>, <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03638">makeEmpty()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00071">subpavings::CritLeaves_GTE::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00081">subpavings::PenLeaves::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00091">subpavings::CritLeaves_LTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00111">subpavings::CritSmallestCount_LTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00132">subpavings::CritLargestCount_LTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00152">subpavings::CritSmallestVol_LTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00172">subpavings::CritLargestVol_LTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00197">subpavings::CritCOPERRChange_GTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00227">subpavings::CritAICChange_GTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00367">subpavings::CritCOPERRMergeChange_GTE::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00395">subpavings::CritAICMergeChange_GTE::operator()()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05902">subpavings::operator&lt;&lt;()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04703">outputLogPlain()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03595">outputRootToTxt()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">outputToTxtTabs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03571">outputToTxtTabsWithEMPs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03611">reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>;}
</pre></div>
</div>
</div>
<a class="anchor" id="af7cf1131373c3e547a23d2db624ce8cf"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getUnifIAE" ref="af7cf1131373c3e547a23d2db624ce8cf" args="(AdaptiveHistogram &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af7cf1131373c3e547a23d2db624ce8cf">AdaptiveHistogram::getUnifIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a uniform mixture distribution.</p>
<p>Get the IAE for a unform mixture </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03774">3774</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">subpavings::SPSnode::getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="UniformMixture_8cpp_source.shtml#l00041">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="comment">// get the true height, f of the corresponding box in myPart</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> trueLeaves;
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> trueIt;
  <span class="comment">//AdaptiveHistogram * adhPtr;</span>
  <span class="comment">//adhPtr = &amp;myPart;</span>
  (myPart).<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(trueLeaves);

  <span class="comment">// setting up containers for the leaves</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;
  (*this).getSubPaving()-&gt;getLeaves(leaves); <span class="comment">// fill the container</span>

  <span class="keywordtype">double</span> trueF; <span class="comment">//true density</span>
  ivector temp;
  
  dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>;    <span class="comment">// use type dotprecision for summation  </span>
  dpIAE=0.0;

  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#aeac2247b4626b1adfa609d3ff109ceb2" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
  <span class="comment">//go through all the leaves in this</span>
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout &lt;&lt; &quot;====checking &quot; &lt;&lt; (*it)-&gt;getBox() &lt;&lt; endl;</span>
      
    <span class="comment">// get the height of this leaf</span>
    <span class="keywordtype">double</span> fhat = (*it)-&gt;getCounter()/(n*1.0)/(*it)-&gt;nodeVolume(); 
    
    <span class="comment">//cout &lt;&lt; &quot;fhat for box &quot; &lt;&lt; &quot;:&quot; &lt;&lt; fhat &lt;&lt; endl;</span>

    <span class="keywordtype">size_t</span> L = 0;
    <span class="keywordflow">for</span> (trueIt = trueLeaves.begin(); trueIt &lt; trueLeaves.end(); trueIt++) {
      <span class="comment">//cout &lt;&lt; &quot;----True leaf: &quot; &lt;&lt; (*trueIt)-&gt;getBox() &lt;&lt; &quot;\t&quot; &lt;&lt; endl;</span>
      ivector trueBox = (*trueIt)-&gt;getBox();

      <span class="keywordflow">if</span> (  holesLoc[L] == 0 ) { trueF = 0; }
      <span class="keywordflow">else</span> { trueF = weight/((*trueIt)-&gt;nodeVolume()); }
      <span class="comment">//cout &lt;&lt; &quot;pdf: &quot; &lt;&lt; trueF &lt;&lt; &quot;------&quot; &lt;&lt; endl;</span>
      
      <span class="comment">// if this is contained in trueBox</span>
      <span class="keywordflow">if</span> ( (*it)-&gt;getBox() &lt;= (*trueIt)-&gt;getBox() || (*it)-&gt;getBox() == (*trueIt)-&gt;getBox() ) {
        <span class="comment">//use the volume of this</span>
        real r = ((*it)-&gt;nodeVolume())*(fhat - trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
        <span class="comment">//can move on to next leaf rather than iterating thru all trueBoxes</span>
        <span class="comment">//think about this later</span>
      } <span class="comment">//end of if this box is in trueBox</span>
      
      <span class="comment">// if this contains trueBox</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*trueIt)-&gt;getBox() &lt;= (*it)-&gt;getBox()) {
        <span class="comment">//use the volume of trueBox</span>
        real r = ((*trueIt)-&gt;nodeVolume())*(fhat - trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
      } <span class="comment">//end of if trueBox is in this box</span>
      
      <span class="comment">// if this is partially contained in trueBox </span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>   (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(temp, thisBox, trueBox)) {
        <span class="keywordflow">if</span> (Inf(temp) != Sup(temp)){
          <span class="keywordtype">double</span> volume = <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(temp);
          real r = volume*(fhat - trueF);
          <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
          accumulate(dpIAE, abs(r), 1.0);
        }
      }
      L++;
    } <span class="comment">// end of going through trueBoxes</span>
  } <span class="comment">// end of going through thisBoxes</span>
  
   <span class="comment">//cast dotprecision to real</span>
   real unifIAE = rnd(dpIAE);
   <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; unifIAE &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> unifIAE;                             

}
</pre></div>
</div>
</div>
<a class="anchor" id="a3d403e99c1c471552303b2a7fd7e7d3e"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::getUnifIAE" ref="a3d403e99c1c471552303b2a7fd7e7d3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af7cf1131373c3e547a23d2db624ce8cf">AdaptiveHistogram::getUnifIAE</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a uniform distribution.</p>
<p>Get the IAE for the unform distribution </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03854">3854</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//-------setting up containers-------------------------------</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
   <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
   (*this).getSubPaving()-&gt;getLeaves(leaves); <span class="comment">// fill the container   </span>
  <span class="keywordtype">int</span> nSample = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// get total number of training </span>
                                           <span class="comment">// data</span>
   dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>;    <span class="comment">// use type dotprecision for summation  </span>
   dpIAE=0.0;
  <span class="keywordtype">double</span> <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a> = 1;
   <span class="comment">//go through all the leaves in this</span>
   <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
      <span class="comment">// get the height of this leaf</span>
      <span class="comment">//cout &lt;&lt; (*it)-&gt;getCounter() &lt;&lt; &quot;\t&quot; &lt;&lt; (*it)-&gt;nodeVolume() &lt;&lt; endl;</span>
      <span class="keywordtype">double</span> fhat = (((*it)-&gt;getCounter())*1.0)/((*it)-&gt;nodeVolume())/
                   (nSample*1.0);

      <span class="comment">//now calculate the IAE</span>
    <span class="keywordflow">if</span> ((f - fhat) &lt; 0.0){
      real r = ((*it)-&gt;nodeVolume())*(fhat - f);
      <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; endl;</span>
      accumulate(dpIAE, r, 1.0);
    }

    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((f - fhat) &gt; 0.0){
      real r = ((*it)-&gt;nodeVolume())*(f - fhat);
      <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; endl;</span>
      accumulate(dpIAE, r, 1.0);
    }

  } <span class="comment">// end of going through all the leaves in this</span>

   <span class="comment">//cast dotprecision to real</span>
   real unifIAE = rnd(dpIAE);
  <span class="keywordflow">return</span> unifIAE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aaf5eac63bd232e3e76f20a27587c8784"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::hasSubPaving" ref="aaf5eac63bd232e3e76f20a27587c8784" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaf5eac63bd232e3e76f20a27587c8784">AdaptiveHistogram::hasSubPaving</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get whether this has a subpaving to manage. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>with the present constructors, it is impossible for this to have a subpaving but for the subpaving to have no box.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this has a subpaving to manage. false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01360">1360</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">getRootBox()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03611">reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> ( <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>() != NULL );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab5d45e2f1966bd43a7bb8bf041ea29db"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::haveMadePaving" ref="ab5d45e2f1966bd43a7bb8bf041ea29db" args="(const RVecData &amp;theData, const size_t dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab5d45e2f1966bd43a7bb8bf041ea29db">AdaptiveHistogram::haveMadePaving</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if we need to make root paving for the histogram object. </p>
<p>Points rootPAving to a new <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> if rootPaving is NULL, with the box of the root node matching the dimensions of the data as given in function argument and tailored to fit the data in theData.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data. </td></tr>
    <tr><td class="paramname">dim</td><td>the dimensions of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>if return value is true, rootPaving points to a new <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> and a new ivector has been assigned to rootBox, and the rootBox ivector is the box of the root node of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> to which rootPaving points. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if function needed to make a new <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>, false if rootPaving already pointed to an SPS node. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">171</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00109">holdAllStats</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">subpavings::isEmpty()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00213">makeBox()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {

        <span class="comment">// check if we need to make the paving on the basis of the data</span>
        <span class="keywordflow">if</span> (<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>)) {

            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4e40497a24ce0807235196e17ca21456" title="Make a box to contain all the data.">makeBox</a>(theData, dim);

            <span class="comment">// point rootPaving to a new SPSnode with box myBox</span>
            <span class="comment">// and also pass in the not value of holdAllStats which controls</span>
            <span class="comment">// whether all available statistics are maintained in the</span>
            <span class="comment">// rootPaving (true) or just counts (false)</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>, !<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>);
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();

            retValue = <span class="keyword">true</span>;
        }
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; e)
    {
        <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = e.what();
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in &quot;</span>
            &lt;&lt; <span class="stringliteral">&quot;AdaptiveHistogram::haveMadePaving()&quot;</span>
            &lt;&lt; std::endl;
        <span class="keywordflow">throw</span>;
    }

    <span class="keywordflow">return</span> retValue;
    <span class="comment">// end of making the subpaving if there was not one</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0eaca3eebf10b3d251ed284f0317c593"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertDataFromContainer" ref="a0eaca3eebf10b3d251ed284f0317c593" args="(const RVecData &amp;theData, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0eaca3eebf10b3d251ed284f0317c593">AdaptiveHistogram::insertDataFromContainer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert data from a container. </p>
<p>Attempts to insert data from a container theData into this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object's dataCollection and to associate the data with the leaves of the subpaving tree pointed to by this's rootPaving. Data in theData which falls outside the boundaries of the rootBox will not be inserted and a message will be printed to standard output.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether a log file is created for histogram creation process; set to TXT for logging to a txt file. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData containing at least one rvector. </dd>
<dd>
this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object must have a rootPaving pointing to an initialised <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>; this <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> may already have data associated with it. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The data in theData which is within the boundaries of the rootBox has been put into the <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>'s dataCollection and also associated with rootPaving's leaves via iterators to dataCollection. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of datapoints for which insertion has been attempted. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">271</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00104">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">subpavings::SPSnode::insertOneFind()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">recalcScaledEMPSumCOPERR()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">size_t</span> counter = 0;    <span class="comment">// to count the input</span>

    <span class="comment">// for logging output to keep track of splits if necessary</span>
    <span class="keywordtype">int</span> i = 0;
    std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
    std::string s = <span class="stringliteral">&quot;&quot;</span>;

    <span class="comment">// if we are splitting as we go and logging, set up a log file</span>
    <span class="keywordflow">if</span> ((logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) &amp;&amp; (boolTest() == <span class="keyword">true</span>)) {
        baseFileName = <span class="stringliteral">&quot;splitOutput&quot;</span>;
        s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
        <span class="comment">// log the current state of the histogram</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
        i++;
    }

    <a class="code" href="namespacesubpavings.shtml#a0e6592215c5f3504143e6c5ac38dcfec" title="Define type RVecDataCItr as const_iterator over RVecData.">RVecDataCItr</a> cit;

    <span class="comment">// feed the data to myHist</span>
    <span class="keywordflow">for</span>(cit = theData.begin(); cit &lt; theData.end(); cit++) {

        <span class="comment">// put it into dataCollection</span>
        <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> it = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.end();
        it = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.insert(it, *cit);

        <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* insertedInto = NULL;

        <span class="comment">// try inserting</span>
        insertedInto =
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(it,<a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, boolTest);

        <span class="comment">//insertOneFind returns either NULL if no insert possible</span>
        <span class="comment">// or a pointer to the node the data goes to before that node</span>
        <span class="comment">// is split (it could be split more than once)</span>
        <span class="keywordflow">if</span> (NULL == insertedInto) { <span class="comment">// failed to insert</span>
            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to insert point &quot;</span>
                &lt;&lt; *cit &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="stringliteral">&quot;Root node of subpaving has box &quot;</span>
                &lt;&lt; <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> &lt;&lt; std::endl;
        }
        <span class="comment">// successful insertion, and we are splitting as we go</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (boolTest() == <span class="keyword">true</span>) {
            std::string newNames = insertedInto-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="keywordflow">if</span>(newNames.length() &gt; 0) { <span class="comment">// there are new nodes</span>
                <span class="comment">//add the new child names if any</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += newNames;

                <span class="keywordflow">if</span> (logging) { <span class="comment">// log the current state of the histogram</span>
                    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                    i++;
                }
            }
       }

        counter++;
    }

    <span class="keywordflow">if</span> (counter &gt; 0) { <span class="comment">// data inserted</span>
        <span class="comment">//recalculate the scaled EMP sum values;</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6456652ee831cee0ec4184440cd84ec9" title="Recalculate the scaled EMP part of COPERR score.">recalcScaledEMPSumCOPERR</a>();
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8a546d8d85be0ffac955f7886d5c7aa" title="Recalculate the unscaled EMP part of AIC score.">recalcScaledEMPSumAIC</a>();

        <span class="keywordflow">if</span> ((logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) &amp;&amp; (boolTest() == <span class="keyword">true</span>))  {
            <span class="comment">// add leaf node levels string to log</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());
        }
    }

    <span class="keywordflow">return</span> counter;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3705758c35dbfe8745a2e34c83b7f619"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertDoublesFromTxt" ref="a3705758c35dbfe8745a2e34c83b7f619" args="(const std::string &amp;s, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3705758c35dbfe8745a2e34c83b7f619">subpavings::AdaptiveHistogram::insertDoublesFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no splitting. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00837">837</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00787">insertOneDimDataFromTxt()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a11051ee818f2d6fb2631573e47ed73b8">insertOneDimDataFromTxt</a>(s, sn, headerlines, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3e03076ea91599538bcc69f47084f649"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertDoublesFromTxt" ref="a3e03076ea91599538bcc69f47084f649" args="(const std::string &amp;s, const SplitDecisionObj &amp;boolTest, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3705758c35dbfe8745a2e34c83b7f619">subpavings::AdaptiveHistogram::insertDoublesFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00846">846</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00787">insertOneDimDataFromTxt()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a11051ee818f2d6fb2631573e47ed73b8">insertOneDimDataFromTxt</a>(s, boolTest, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6f049bec17097067ae9e2a7c9f42bd60"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertFromRSSample" ref="a6f049bec17097067ae9e2a7c9f42bd60" args="(const RSSample &amp;rss, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">subpavings::AdaptiveHistogram::insertFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no splitting. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01023">1023</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03650">getEstLogLikelihoodFromRSSample()</a>, and <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">insertFromRSSample</a>(rss, sn, logging, label);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a20ee07940112174415c391b4ed385ba1"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertFromRSSample" ref="a20ee07940112174415c391b4ed385ba1" args="(const RSSample &amp;rss, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">AdaptiveHistogram::insertFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01817">1817</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>, <a class="el" href="sptools_8cpp_source.shtml#l01021">subpavings::getRvectorsFromRSSample()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {
        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="comment">// try to get data from rss.Samples and check how many data points found</span>
        <span class="keywordtype">size_t</span> numberFound = <a class="code" href="namespacesubpavings.shtml#ad435f1951db3078702d178b718018651" title="Get all rvectors from an RSSample object.">getRvectorsFromRSSample</a>(myDataRvectors, rss, label);

        <span class="keywordflow">if</span> (numberFound &gt; 0) {
            <span class="comment">/*</span>
<span class="comment">            // confirm the amount of data taken from the RSSample</span>
<span class="comment">            std::cout &lt;&lt; &quot;End of taking data from RSSample: &quot;</span>
<span class="comment">                &lt;&lt; numberFound &lt;&lt; &quot; data points with label &quot;</span>
<span class="comment">                &lt;&lt; label &lt;&lt; &quot; found&quot; &lt;&lt; std::endl;</span>
<span class="comment">            */</span>
            <span class="comment">// complete the data insertion</span>
            retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7" title="Complete insertion of data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                    boolTest, logging);

        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;

}
</pre></div>
</div>
</div>
<a class="anchor" id="ae19b382cf2c8f7f9b1d20883a7faf5c8"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertFromRVec" ref="ae19b382cf2c8f7f9b1d20883a7faf5c8" args="(const RVecData &amp;rvec, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">subpavings::AdaptiveHistogram::insertFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no splitting. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">925</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01166">operator+()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(rvec, sn, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2b8604eb7b87dd03d09736a2f9e4b96a"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertFromRVec" ref="a2b8604eb7b87dd03d09736a2f9e4b96a" args="(const RVecData &amp;rvec, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">AdaptiveHistogram::insertFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01568">1568</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00930">subpavings::getRvectorsFromRVec()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="keywordtype">size_t</span> numberFound = 0;

        <span class="keywordflow">if</span> (rvec.empty()) { <span class="comment">// no data points to get</span>
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No data to insert&quot;</span>);
        }

        <span class="keywordflow">else</span> { <span class="comment">// there is data to get</span>

            <span class="comment">// get data from the container and check how many data points found</span>
            <span class="keywordtype">size_t</span> numberFound = <a class="code" href="namespacesubpavings.shtml#a211cb10f439ff2bdb92ce92906159792" title="Get all rvectors from a container of rvectors.">getRvectorsFromRVec</a>(myDataRvectors, rvec);


            <span class="keywordflow">if</span> (numberFound &gt; 0) {
                <span class="comment">/*</span>
<span class="comment">                // confirm the amount of data taken from the container</span>
<span class="comment">                std::cout &lt;&lt; &quot;End of taking data from container of rvectors: &quot;</span>
<span class="comment">                    &lt;&lt; numberFound &lt;&lt; &quot; data points found&quot; &lt;&lt; std::endl;</span>
<span class="comment">                */</span>
                <span class="comment">// complete the data insertion</span>
                retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7" title="Complete insertion of data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                        boolTest, logging);
            }
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
         <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;

}
</pre></div>
</div>
</div>
<a class="anchor" id="aafef86d6e4482aef11de75b83cfb4345"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertOne" ref="aafef86d6e4482aef11de75b83cfb4345" args="(rvector newdata, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aafef86d6e4482aef11de75b83cfb4345">AdaptiveHistogram::insertOne</a> </td>
          <td>(</td>
          <td class="paramtype">rvector&#160;</td>
          <td class="paramname"><em>newdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a single data point into <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object. </p>
<p>A method which attempts to insert a datapoint into this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object's dataCollection and associate the datapoint with one of the leaves of the tree pointed to by this's rootPaving. If the datapoint falls outside the boundaries of the rootBox it will not be inserted and a message will be printed to standard output.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newdata</td><td>the datapoint to be inserted, an rvector. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging).</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object must have a rootPaving pointing to an initialised <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>; this <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> may already have data associated with it. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>If the datapoint is within the boundaries of the rootBox it will have been put into the <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>'s dataCollection and also associated with one of the rootPaving's leaves via an iterator to dataCollection. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">1387</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00104">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">subpavings::SPSnode::insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">subpavings::isEmpty()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">recalcScaledEMPSumCOPERR()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// make sure we have a paving and then try inserting</span>
    <span class="keywordflow">if</span> (<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>)) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Trying to insert to empty or NULL node&quot;</span>);
    }

    <span class="comment">// check the dimensions</span>
    <span class="keywordflow">if</span>((<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(newData)-<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(newData)) != (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>))) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Dimensions of data do not match paving&quot;</span>);

    }

    <span class="comment">// for logging output to keep track of splits</span>
    <span class="keywordtype">int</span> i = 0;
    std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
    std::string s = <span class="stringliteral">&quot;&quot;</span>;

    <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
        baseFileName = <span class="stringliteral">&quot;splitOutput&quot;</span>;
        s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
        <span class="comment">// log the current state of the histogram</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
        i++;
    }


    <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> it = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.end();
    it = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.insert(it, newData);

    <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* insertedInto = NULL;

    <span class="comment">// try inserting</span>
    insertedInto = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(it, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>,
                                            boolTest);

    <span class="keywordflow">if</span> (insertedInto==NULL) { <span class="comment">// failed to insert</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to insert point &quot;</span> &lt;&lt; newData &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;Root node of subpaving has box &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>
            &lt;&lt; std::endl;
    }
    <span class="keywordflow">else</span> { <span class="comment">// insertion succeeded</span>

        std::string newNames = insertedInto-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

        <span class="keywordflow">if</span>(newNames.length() &gt; 0) { <span class="comment">// there are new nodes</span>
            <span class="comment">//add the new child names if any</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += newNames;
            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// log the current state of the histogram</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                i++;
            }
        }

        <span class="comment">//recalculate the scaled EMP sum values;</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6456652ee831cee0ec4184440cd84ec9" title="Recalculate the scaled EMP part of COPERR score.">recalcScaledEMPSumCOPERR</a>();
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8a546d8d85be0ffac955f7886d5c7aa" title="Recalculate the unscaled EMP part of AIC score.">recalcScaledEMPSumAIC</a>();
    }
    <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
        <span class="comment">// add leaf node levels string to log</span>
        <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a11051ee818f2d6fb2631573e47ed73b8"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertOneDimDataFromTxt" ref="a11051ee818f2d6fb2631573e47ed73b8" args="(const std::string &amp;s, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a11051ee818f2d6fb2631573e47ed73b8">subpavings::AdaptiveHistogram::insertOneDimDataFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All data is associated with the root paving, no splitting. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00787">787</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00837">insertDoublesFromTxt()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a11051ee818f2d6fb2631573e47ed73b8">insertOneDimDataFromTxt</a>(s, sn, headerlines, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aef10187eeb8d449b8692c355960aefe0"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertOneDimDataFromTxt" ref="aef10187eeb8d449b8692c355960aefe0" args="(const std::string &amp;s, const SplitDecisionObj &amp;boolTest, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a11051ee818f2d6fb2631573e47ed73b8">AdaptiveHistogram::insertOneDimDataFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01458">1458</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>, <a class="el" href="namespacesubpavings.shtml#a535c4c5b9e6a042ec418db09ed956cda">subpavings::readOneDimDataFromTxt()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {
        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="comment">// try to read in the file</span>
        retValue = <a class="code" href="namespacesubpavings.shtml#a535c4c5b9e6a042ec418db09ed956cda" title="Read in one-dimensional data from a txt file.">readOneDimDataFromTxt</a>(myDataRvectors, s, headerlines);

        <span class="keywordflow">if</span> (retValue) {
            <span class="comment">// complete the data insertion</span>
            retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7" title="Complete insertion of data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                    boolTest, logging);
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="comment">// recalc of EMP sums takes place further down</span>

    <span class="keywordflow">return</span> retValue;

}
</pre></div>
</div>
</div>
<a class="anchor" id="aff1b74eb52546adb9d7d64a84d739efe"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertRvectorsFromTxt" ref="aff1b74eb52546adb9d7d64a84d739efe" args="(const std::string &amp;s, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aff1b74eb52546adb9d7d64a84d739efe">subpavings::AdaptiveHistogram::insertRvectorsFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no spliting. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00895">895</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="BiGTest_8cpp_source.shtml#l00038">main()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aff1b74eb52546adb9d7d64a84d739efe">insertRvectorsFromTxt</a>(s, sn, headerlines, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5decf91161cbddd77c21e3b25dd12689"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertRvectorsFromTxt" ref="a5decf91161cbddd77c21e3b25dd12689" args="(const std::string &amp;s, const SplitDecisionObj &amp;boolTest, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aff1b74eb52546adb9d7d64a84d739efe">AdaptiveHistogram::insertRvectorsFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01517">1517</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>, <a class="el" href="namespacesubpavings.shtml#a7918dddb1a8e32f72835e1e7b4442ca6">subpavings::readRvectorsFromTxt()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {
        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="comment">// try to read in the file</span>
        retValue = <a class="code" href="namespacesubpavings.shtml#a7918dddb1a8e32f72835e1e7b4442ca6" title="Read in rvectors from a txt file.">readRvectorsFromTxt</a>(myDataRvectors, s, headerlines);

        <span class="keywordflow">if</span> (retValue) {
            retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7" title="Complete insertion of data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                    boolTest, logging);
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a2549a287bc001212ea1c6f7bbe42be62"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRSSample" ref="a2549a287bc001212ea1c6f7bbe42be62" args="(size_t samplesize, gsl_rng *rgsl, const RSSample &amp;rss, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">subpavings::AdaptiveHistogram::insertSampleFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no spliting, random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01066">1066</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01934">insertSampleFromRSSample()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">insertSampleFromRSSample</a>(samplesize, rgsl, rss, sn,
                                        logging, label);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab41e19cc570fa35d9c867413a7398edc"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRSSample" ref="ab41e19cc570fa35d9c867413a7398edc" args="(size_t samplesize, int seed, const RSSample &amp;rss, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">subpavings::AdaptiveHistogram::insertSampleFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no spliting, seed for creating a random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01075">1075</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01066">insertSampleFromRSSample()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">insertSampleFromRSSample</a>(samplesize, seed, rss, sn,
                                        logging, label);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a9468b46a614470017cc09cadd7699af8"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRSSample" ref="a9468b46a614470017cc09cadd7699af8" args="(size_t samplesize, const RSSample &amp;rss, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">subpavings::AdaptiveHistogram::insertSampleFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no spliting, no random number generator supplied, default will be created. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01084">1084</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01066">insertSampleFromRSSample()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">insertSampleFromRSSample</a>(samplesize, rss, sn,
                                        logging, label);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad002844c2b0ef25eeb5fbc845fd8a000"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRSSample" ref="ad002844c2b0ef25eeb5fbc845fd8a000" args="(size_t samplesize, gsl_rng *rgsl, const RSSample &amp;rss, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">AdaptiveHistogram::insertSampleFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted, random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01875">1875</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00996">subpavings::getSampleRvectorsFromRSSample()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="comment">// try to sample data from rss.Samples and check how many data points found</span>
        <span class="keywordtype">size_t</span> numberTaken = <a class="code" href="namespacesubpavings.shtml#ae988c56fd983d75dd9f60a5ef8f87660" title="Get a sample of rvectors from an RSSample object.">getSampleRvectorsFromRSSample</a>(myDataRvectors,
                                rgsl, samplesize, rss, label);

        <span class="keywordflow">if</span> (numberTaken &gt; 0) {
            <span class="comment">/* switch on for more output during histogram creation</span>
<span class="comment">            // confirm the amount of data taken from the RSSample</span>
<span class="comment">            std::cout &lt;&lt; &quot;End of taking sample from data from RSSample: &quot;</span>
<span class="comment">                &lt;&lt; numberTaken &lt;&lt; &quot; data points used for sample&quot; &lt;&lt; std::endl;</span>
<span class="comment">            */</span>

            retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7" title="Complete insertion of data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                    boolTest, logging);
        }
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8437c7aa645e4edc21a5bc4ec02db5ef"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRSSample" ref="a8437c7aa645e4edc21a5bc4ec02db5ef" args="(size_t samplesize, int seed, const RSSample &amp;rss, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">AdaptiveHistogram::insertSampleFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted, seed for creating random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01934">1934</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01066">insertSampleFromRSSample()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {

        <span class="keyword">const</span> gsl_rng_type * tgsl;

        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>
        gsl_rng_set (rgsl, seed); <span class="comment">// change the seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">insertSampleFromRSSample</a>(samplesize, rgsl, rss, boolTest,
                logging, label);

        gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a78dd377090622826dd80734395fba635"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRSSample" ref="a78dd377090622826dd80734395fba635" args="(size_t samplesize, const RSSample &amp;rss, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging, int label=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">AdaptiveHistogram::insertSampleFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted, no random number generator supplied, default will be created. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01995">1995</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01066">insertSampleFromRSSample()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {

        <span class="keyword">const</span> gsl_rng_type * tgsl;

        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2549a287bc001212ea1c6f7bbe42be62">insertSampleFromRSSample</a>(samplesize, rgsl, rss, boolTest,
                logging, label);

        gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="adbfde654e0737aa2145d054a2c4a9a95"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRVec" ref="adbfde654e0737aa2145d054a2c4a9a95" args="(size_t samplesize, gsl_rng *rgsl, const RVecData &amp;rvec, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">subpavings::AdaptiveHistogram::insertSampleFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no splitting, random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00959">959</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00080">subpavings::AdaptiveHistogramCollator::collateFromRVec()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01694">insertSampleFromRVec()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">insertSampleFromRVec</a>(samplesize, rgsl, rvec,
                                    sn, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a754142aca6681e39debd7167146a7e1c"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRVec" ref="a754142aca6681e39debd7167146a7e1c" args="(size_t samplesize, int seed, const RVecData &amp;rvec, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">subpavings::AdaptiveHistogram::insertSampleFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no splitting, seed for creating a random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00969">969</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00959">insertSampleFromRVec()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">insertSampleFromRVec</a>(samplesize, seed, rvec,
                                    sn, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aeca515a5f969a1f368ba1fe0390aa047"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRVec" ref="aeca515a5f969a1f368ba1fe0390aa047" args="(size_t samplesize, const RVecData &amp;rvec, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">subpavings::AdaptiveHistogram::insertSampleFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no splitting, no random number generator supplied, default will be created. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00978">978</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00959">insertSampleFromRVec()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">insertSampleFromRVec</a>(samplesize, rvec, sn, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2f6d7ee0d83ea148f57543f64905170d"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRVec" ref="a2f6d7ee0d83ea148f57543f64905170d" args="(size_t samplesize, gsl_rng *rgsl, const RVecData &amp;rvec, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">AdaptiveHistogram::insertSampleFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted, random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01635">1635</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00982">subpavings::getSampleRvectorsFromRVec()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="comment">// try to sample data from the container, check how many data points found</span>
        <span class="keywordtype">size_t</span> numberTaken = <a class="code" href="namespacesubpavings.shtml#ad2d24521f44422db117d54d6287bc314" title="Get a sample of rvectors from an a container.">getSampleRvectorsFromRVec</a>(myDataRvectors,
                                rgsl, samplesize, rvec);

        <span class="comment">// complete the data insertion</span>
        <span class="keywordflow">if</span> (numberTaken &gt; 0) {
            <span class="comment">/*  Switch on for more output</span>
<span class="comment">            // confirm the amount of data taken from the RSSample</span>
<span class="comment">            std::cout &lt;&lt; &quot;End of taking sample from data from the container: &quot;</span>
<span class="comment">            &lt;&lt; numberTaken &lt;&lt; &quot; data points used for sample&quot; &lt;&lt; std::endl;</span>
<span class="comment">            */</span>
            retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a929e006a5a2a0f40c68d77bc7dff70e7" title="Complete insertion of data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                    boolTest, logging);
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }


    <span class="keywordflow">return</span> retValue;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a8db299e8725f5170475a4c77524140dc"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRVec" ref="a8db299e8725f5170475a4c77524140dc" args="(size_t samplesize, int seed, const RVecData &amp;rvec, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">AdaptiveHistogram::insertSampleFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted, seed for creating random number generator supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01694">1694</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00959">insertSampleFromRVec()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {

        <span class="keyword">const</span> gsl_rng_type * tgsl;

        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>
        gsl_rng_set (rgsl, seed); <span class="comment">// change the seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">insertSampleFromRVec</a>(samplesize, rgsl, rvec, boolTest,
            logging);

        gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>

    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }


    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab889a33f8caa8fb44836f756c0be342d"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::insertSampleFromRVec" ref="ab889a33f8caa8fb44836f756c0be342d" args="(size_t samplesize, const RVecData &amp;rvec, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">AdaptiveHistogram::insertSampleFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted, no random number generator supplied, default will be created. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01758">1758</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00959">insertSampleFromRVec()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {

        <span class="keyword">const</span> gsl_rng_type * tgsl;

        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();

        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#adbfde654e0737aa2145d054a2c4a9a95">insertSampleFromRVec</a>(samplesize, rgsl, rvec, boolTest,
                logging);

        gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aedb9ab3c2240403c63f2f5c1d0218350"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::logMCMCDeltas" ref="aedb9ab3c2240403c63f2f5c1d0218350" args="(std::string s, int i, real deltaL, real deltaP, real deltaQ, real deltaPi, double randChange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aedb9ab3c2240403c63f2f5c1d0218350">AdaptiveHistogram::logMCMCDeltas</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>deltaL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>deltaP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>deltaQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>deltaPi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>randChange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a collection of changes in MCMC probabilities to log file. </p>
<p>The probabilities being logged are the changes in the components of the probability of acceptance of a proposed state under MCMC</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">i</td><td>is a number indicating the state number in a chain or series of changes in state. </td></tr>
    <tr><td class="paramname">deltaL</td><td>is the log change in likelihood. </td></tr>
    <tr><td class="paramname">deltaP</td><td>is the log change in prior probability. </td></tr>
    <tr><td class="paramname">deltaQ</td><td>is the log change in transition probability. </td></tr>
    <tr><td class="paramname">deltaPi</td><td>is the log change in posterior probability. </td></tr>
    <tr><td class="paramname">randChange</td><td>is the draw from the Uniform (0,1) distribution which is compared to the changes in combined posterior and transition probabilities to determine whether the proposed change takes place </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00423">423</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, and <a class="el" href="sptools_8cpp_source.shtml#l00471">subpavings::tryExp()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">decisionMCMCMerge()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">decisionMCMCSplit()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> vals;
    vals.push_back(deltaL);
    vals.push_back(deltaP);
    vals.push_back(deltaQ);
    vals.push_back(deltaPi+deltaQ);
    vals.push_back(log(randChange));
    vals.push_back(<a class="code" href="namespacesubpavings.shtml#ada0daf400b54e571b4f8d83bd32861c5" title="Work arround for c-xsc math library for exponentiation of reals.">tryExp</a>(deltaL));
    vals.push_back(<a class="code" href="namespacesubpavings.shtml#ada0daf400b54e571b4f8d83bd32861c5" title="Work arround for c-xsc math library for exponentiation of reals.">tryExp</a>(deltaP));
    vals.push_back(<a class="code" href="namespacesubpavings.shtml#ada0daf400b54e571b4f8d83bd32861c5" title="Work arround for c-xsc math library for exponentiation of reals.">tryExp</a>(deltaQ));
    vals.push_back(<a class="code" href="namespacesubpavings.shtml#ada0daf400b54e571b4f8d83bd32861c5" title="Work arround for c-xsc math library for exponentiation of reals.">tryExp</a>(deltaPi+deltaQ));
    vals.push_back(randChange);
    <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, vals, i);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4e40497a24ce0807235196e17ca21456"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::makeBox" ref="a4e40497a24ce0807235196e17ca21456" args="(const RVecData &amp;theData, const size_t dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4e40497a24ce0807235196e17ca21456">AdaptiveHistogram::makeBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a box to contain all the data. </p>
<p>Used if a box has not already been provided. Makes a box tailored to contain all of the data. So all the data has to be available for input.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data </td></tr>
    <tr><td class="paramname">dim</td><td>the dimensions of the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an ivector same dimensions as the data and to fit all the data including an allowance for padding. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00213">213</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00084">padding</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">haveMadePaving()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// set up a vector of maxes</span>
    vector&lt;real&gt; maxs;

    <span class="comment">// give maxs starting values from the first element in the rvectors</span>
    rvector first = *theData.begin();

    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;=dim; i++) {
        maxs.push_back(first[i]);
    }

    <span class="comment">// make mins the same as maxes to start with</span>
    vector&lt;real&gt; mins = maxs;

    <a class="code" href="namespacesubpavings.shtml#a0e6592215c5f3504143e6c5ac38dcfec" title="Define type RVecDataCItr as const_iterator over RVecData.">RVecDataCItr</a> cit;

    <span class="comment">// go over the rest of the container</span>
    <span class="keywordflow">for</span>(cit = theData.begin()+1; cit &lt; theData.end(); cit++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;= dim; i++) {
            real r = (*cit)[i];
            <span class="comment">// vectors indexed 0 - n-1, rvectors ndexed 1 - n</span>
            <span class="keywordflow">if</span>(r &lt; mins[i-1]) {
                mins[i-1] = r;
            }
            <span class="keywordflow">if</span>(r &gt; maxs[i-1]) {
                maxs[i-1] = r;
            }
        } <span class="comment">// end going through rvector elements</span>
    } <span class="comment">// end going through rvectors</span>

    ivector retVal(dim);    <span class="comment">// set up an ivector to become the return value</span>

    <span class="comment">// and make each interval the (min, max) of the corresponding elements</span>
    <span class="comment">// of the rvectors -/+ some padding</span>

    std::cout &lt;&lt; <span class="stringliteral">&quot;A box is being made for the data.  &quot;</span>
        &lt;&lt; <span class="stringliteral">&quot;The box is &quot;</span> &lt;&lt; std::endl;  <span class="comment">// standard output message</span>

    <span class="comment">// make intervals and make them elements of the ivector</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;=dim; i++) {
        interval myInterval(mins[i-1]-<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a73e006381e43e152b7dbb63211a3ac09" title="a constant for padding a box if it is tailor-made for data.">padding</a>, maxs[i-1]+<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a73e006381e43e152b7dbb63211a3ac09" title="a constant for padding a box if it is tailor-made for data.">padding</a>);
        std::cout &lt;&lt; myInterval &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;    <span class="comment">// output</span>
        retVal[i]=myInterval;
    }
    std::cout &lt;&lt; std::endl;

    <span class="keywordflow">return</span> retVal;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f3844b0b56fb1aaa96c44558dd8e4a4"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::makeEmpty" ref="a8f3844b0b56fb1aaa96c44558dd8e4a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8f3844b0b56fb1aaa96c44558dd8e4a4">AdaptiveHistogram::makeEmpty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the histogram's data and counters. </p>
<p>Clear the histogram's data and counter </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03638">3638</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03650">getEstLogLikelihoodFromRSSample()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
   <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>
   <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    (*it)-&gt;makeEmptyNode();
  }
} 
</pre></div>
</div>
</div>
<a class="anchor" id="a733cc04938b2236087cbbe0384985c3d"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::MCMC" ref="a733cc04938b2236087cbbe0384985c3d" args="(unsigned int loops, unsigned int burnin, unsigned int thinout, MCMCProposal &amp;proposal, LogMCMCPrior &amp;logPrior, size_t minPoints=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a733cc04938b2236087cbbe0384985c3d">AdaptiveHistogram::MCMC</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>burnin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thinout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;&#160;</td>
          <td class="paramname"><em>proposal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minPoints</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Outputting MCMC samples from histogram state space. </p>
<p>The leaves of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree represent the partition of the data space (the root box of the tree). A histogram state is a particular partition of the root box which will be represented by a particular tree number and disposition of nodes of the tree.</p>
<p>The Markov-Chain Monte Carlo process considers possible histogram states, given data, as a probability distribution. In this implementation the the Metropolis-Hastings algorithm is used on the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this Adaptive Histogram to generate samples from the histogram state probability density.</p>
<p>MCMC requires a prior distribution over the state space and a likelihood of being in a particular state given the data, from which can be found (up to proportionality) a posterior distribution proportional to the likelihood x prior.</p>
<p>A change in state can take place by either splitting a leaf node (bisecting the box represesented by that leaf and sending the data associated with the box down to the two new children) or absorbing two sibling leaf nodes back into their parent so that that parent becomes a leaf of the tree. The parent node of two sibling leaf nodes is referred to as a 'cherry' and the reabsorbtion of the sibling leaf children of a cherry is referred to as 'merging' a cherry.</p>
<p>minPoints restricts the possible states by not allowing the chain to include a state where a leaf node has less than minPoints data points associated with it, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points &gt;= minPoints. The final condition allows a node to be split when all the data goes to just one child provided that the number of points in the node &gt;= minPoints so that the process can 'home in' on small peaks of data.</p>
<p>When minPoints &gt; 0, proposals are effectively drawn from set of leaf and cherry nodes which does not include any leaf which, if split, would have a child whose number of points is &lt; minPoints, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points &gt;= minPoints. Thus the implementation needs to distinguish between the overall state of the tree and the set of <b>splittable leaf nodes</b>.</p>
<p>The method can collate thinned out samples from the chain of states generated from the Markov Chain process and average them, outputting txt file represenations of the collation and the average.</p>
<p>The method can log the process, including the components of the calculation for each change in state and .dot graphs for each state in the chain.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">loops</td><td>how many states in the chain to generate altogether, (ie including burnin). </td></tr>
    <tr><td class="paramname">burnin</td><td>how many states to consider as burnin, ie the number of changes in state required for the process to forget its starting state. </td></tr>
    <tr><td class="paramname">thinout</td><td>what step size to use in sampling for averaging. If thinout &gt; 0, an average histogram is created by collating the first state in the chain after burnin states together with samples taken from the chain with thinout stepsize. Txt and .dot file representions of the sampling process and the collation and the average are output. </td></tr>
    <tr><td class="paramname">proposal</td><td>is a reference to the proposal distribution object. </td></tr>
    <tr><td class="paramname">logPrior</td><td>is a reference to the prior distribution object. </td></tr>
    <tr><td class="paramname">minPoints</td><td>is the minimum number of points to allow in a box represented by a leaf in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> tree (defaults to 0). </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to log files (defaults to no logging). TXT gives logging to a txt file, TXTANDGRAPH gives txt file logging and graphs, LOGSAMPLES does a txt log file for samples only, LOGANDGRAPHSAMPLES does a txt log file and dot graphs for samples only </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if MCMC successfully carried out for required number of states in the chain (loops through the MCMC routine), false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03044">3044</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramCollator::addToCollation()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00827">subpavings::AdaptiveHistogramCollator::outputAverageToTxtTabs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00466">outputMCMCStateSample()</a>, and <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00802">subpavings::AdaptiveHistogramCollator::outputToTxtTabs()</a>.</p>

<p>Referenced by <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">try</span> {

    <span class="keywordtype">bool</span> thinning = (thinout &gt; 0);

    std::vector &lt; AdaptiveHistogram &gt; samples;
    
    samples = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aac9ce6681faa011b3c314ff400056dd9" title="Generating MCMC samples from histogram state space.">MCMCsamples</a>(samples, 
            loops, burnin,
            thinout,
            proposal, logPrior,
            minPoints, logging);
    
    <span class="keywordtype">bool</span> good = <span class="keyword">true</span>;
    
    <span class="keywordflow">if</span> (thinning &amp;&amp; ( loops &gt; 0)
        &amp;&amp; ( samples.size() &lt; (loops - burnin)/thinout + 1) ) {
      good = <span class="keyword">false</span>;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thinning) {
      
      <span class="comment">// make a collation object, empty at present</span>
      <a class="code" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml" title="A wrapper or manager for a CollatorSPSnode.">AdaptiveHistogramCollator</a> coll;

      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; samples.size(); ++i) {
        <span class="comment">// output and collate the sample state;</span>
        (samples[i]).<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4e7d34aea502906cb2230c0732d752b3" title="Output the state of this histogram as an MCMC sample.">outputMCMCStateSample</a>(i);
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml#ade34068ac64cc1bd36781350b28a4486" title="Add an AdaptiveHistogram object to the data collation.">addToCollation</a>(samples[i]);
      }
    
        std::string collFileName = <span class="stringliteral">&quot;CollatorMCMC.txt&quot;</span>;
            coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml#aab47793e8362245a28a7ec3090da5352" title="Output the collated information to a txt file.">outputToTxtTabs</a>(collFileName); <span class="comment">// output the collation to file</span>

            <span class="comment">//  Average the sampled histograms</span>
            std::string avFileName = <span class="stringliteral">&quot;AverageMCMC.txt&quot;</span>;     <span class="comment">// provide a filename</span>

            coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml#a514f2ebc1857e531b629f0ff3508b04b" title="Output average normalised histogram over collation to a txt file.">outputAverageToTxtTabs</a>(avFileName);  <span class="comment">// output the average to file</span>
        }

    <span class="keywordflow">return</span> good;
        
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error  in MCMC:\n &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a10fc830a1dd32fe83aa3846a6fb2af35"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::MCMCLogFinalState" ref="a10fc830a1dd32fe83aa3846a6fb2af35" args="(std::string s, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a10fc830a1dd32fe83aa3846a6fb2af35">AdaptiveHistogram::MCMCLogFinalState</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Capture the final state of this histogram after MCMC. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the name of the file to log the final state to. </td></tr>
    <tr><td class="paramname">i</td><td>is a number indicating the state number in a chain or series of changes in state. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00484">484</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00500">outputLogEMPCOPERR()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
    <span class="comment">// output AIC score information</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s);
    <span class="comment">// output COPERR score information</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad2360173a5963ecbca37e0a78ce98879" title="Add COPERR EMP score to log file.">outputLogEMPCOPERR</a>(s);
    <span class="comment">// log the leaf levels line</span>
    <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());

}
</pre></div>
</div>
</div>
<a class="anchor" id="aac9ce6681faa011b3c314ff400056dd9"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::MCMCsamples" ref="aac9ce6681faa011b3c314ff400056dd9" args="(std::vector&lt; AdaptiveHistogram &gt; &amp;samples, unsigned int loops, unsigned int burnin, unsigned int thinout, MCMCProposal &amp;proposal, LogMCMCPrior &amp;logPrior, size_t minPoints, LOGGING_LEVEL logging)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aac9ce6681faa011b3c314ff400056dd9">AdaptiveHistogram::MCMCsamples</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>burnin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>thinout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;&#160;</td>
          <td class="paramname"><em>proposal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generating MCMC samples from histogram state space. </p>
<p>The leaves of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree represent the partition of the data space (the root box of the tree). A histogram state is a particular partition of the root box which will be represented by a particular tree number and disposition of nodes of the tree.</p>
<p>The Markov-Chain Monte Carlo process considers possible histogram states, given data, as a probability distribution. In this implementation the the Metropolis-Hastings algorithm is used on the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this Adaptive Histogram to generate samples from the histogram state probability density.</p>
<p>MCMC requires a prior distribution over the state space and a likelihood of being in a particular state given the data, from which can be found (up to proportionality) a posterior distribution proportional to the likelihood x prior.</p>
<p>A change in state can take place by either splitting a leaf node (bisecting the box represesented by that leaf and sending the data associated with the box down to the two new children) or absorbing two sibling leaf nodes back into their parent so that that parent becomes a leaf of the tree. The parent node of two sibling leaf nodes is referred to as a 'cherry' and the reabsorbtion of the sibling leaf children of a cherry is referred to as 'merging' a cherry.</p>
<p>minPoints restricts the possible states by not allowing the chain to include a state where a leaf node has less than minPoints data points associated with it, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points &gt;= minPoints. The final condition allows a node to be split when all the data goes to just one child provided that the number of points in the node &gt;= minPoints so that the process can 'home in' on small peaks of data.</p>
<p>When minPoints &gt; 0, proposals are effectively drawn from set of leaf and cherry nodes which does not include any leaf which, if split, would have a child whose number of points is &lt; minPoints, unless that child leaf node has 0 points and its sibling has all the parent's points and number of parent's points &gt;= minPoints. Thus the implementation needs to distinguish between the overall state of the tree and the set of <b>splittable leaf nodes</b>.</p>
<p>The method can collate thinned out samples from the chain of states generated from the Markov Chain process and average them, outputting txt file represenations of the collation and the average.</p>
<p>The method can log the process, including the components of the calculation for each change in state and .dot graphs for each state in the chain.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>is a reference to a container to add <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> samples to. </td></tr>
    <tr><td class="paramname">loops</td><td>how many states in the chain to generate altogether, (ie including burnin). </td></tr>
    <tr><td class="paramname">burnin</td><td>how many states to consider as burnin, ie the number of changes in state required for the process to forget its starting state. </td></tr>
    <tr><td class="paramname">thinout</td><td>what step size to use in sampling for averaging. If thinout &gt; 0, samples are the first state in the chain after burnin states together with samples taken from the chain with thinout stepsize. </td></tr>
    <tr><td class="paramname">proposal</td><td>is a reference to the proposal distribution object. </td></tr>
    <tr><td class="paramname">logPrior</td><td>is a reference to the prior distribution object. </td></tr>
    <tr><td class="paramname">minPoints</td><td>is the minimum number of points to allow in a box represented by a leaf in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> tree (defaults to 0). </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to log files (defaults to no logging). TXT gives logging to a txt file, TXTANDGRAPH gives txt file logging and graphs, LOGSAMPLES does a txt log file for samples only, LOGANDGRAPHSAMPLES does a txt log file and dot graphs for samples only </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the reference to the container of samples if MCMC successfully carried out for required number of states in the chain empty container otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">3102</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">changeMCMCState()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">subpavings::SPSnode::getSubLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00094">subpavings::LOGANDGRAPHSAMPLES</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00094">subpavings::LOGSAMPLES</a>, <a class="el" href="namespacesubpavings.shtml#abb4671c14005974aeea8f0dd39600ec6">subpavings::makeDotImage()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00484">MCMCLogFinalState()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00444">MCMCStartLogFile()</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03528">outputGraphDot()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXT</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXTANDGRAPH</a>.</p>

<p>Referenced by <a class="el" href="MCMC_8cpp_source.shtml#l00039">main()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03044">MCMC()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {
    
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()) {
      <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for MCMC histogram&quot;</span>);
    }
    
    <span class="keywordflow">if</span> (burnin &gt; loops) {
      <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;burnin &gt; loops&quot;</span>);
    }
    
    <span class="keywordtype">bool</span> thinning = (thinout &gt; 0);
  
    <span class="keywordflow">if</span> (thinning) {
      samples.reserve(samples.size() + (loops - burnin)/thinout + 1);
    }

        <span class="comment">// for logging</span>
        <span class="keywordtype">int</span> i = 0;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        std::string dot = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>)
                || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a09aa6a27c1d242b63005aa5d78b45aba">LOGSAMPLES</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089afec51793a7c8838aa61a4e1b21d1245d">LOGANDGRAPHSAMPLES</a>)
        || thinning) {

            <span class="comment">// pass to log output to keep track of splits</span>
            std::string baseFileName = <span class="stringliteral">&quot;MCMCOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);

            <span class="keywordflow">if</span> (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>) {

                <span class="comment">// for dot graph</span>
                baseFileName = <span class="stringliteral">&quot;graph&quot;</span>;
                std::string suffix = <span class="stringliteral">&quot;.dot&quot;</span>;
                dot = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName, suffix);
                <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(dot, <span class="stringliteral">&quot;digraph G {&quot;</span>); <span class="comment">// opening line</span>
            }
        }

        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        <span class="comment">// check input parameters</span>
        <span class="keywordflow">if</span> (loops - burnin &lt; 0) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Try again: number of loops is less than burnin&quot;</span>
                    &lt;&lt;std::endl;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thinout &gt; 0 &amp;&amp; ((loops-burnin)/thinout &lt; 1)) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Try again: thinout value means no samples will be taken&quot;</span>
                    &lt;&lt;std::endl;
        }
        <span class="keywordflow">else</span> cancontinue = <span class="keyword">true</span>;

        <span class="comment">// set up a container for the leaf children</span>
        <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leafVec;
        <span class="comment">// set up a container for the subleaf children</span>
        <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> cherryVec;
        <a class="code" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3" title="Define type SPSnodeList as a list of pointers to SPSnodes.">SPSnodeList</a> nodes;
         <span class="comment">//lists better than vectors for random access removal</span>
        <span class="keywordtype">size_t</span> numLeaves = 0;
        <span class="keywordtype">size_t</span> numCherries = 0;

        <span class="keywordflow">if</span> (cancontinue) {

            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leafVec);

            <span class="comment">// fill the container with the subleaf children</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(cherryVec);

            numCherries = cherryVec.size();

            <span class="keywordflow">if</span> (!leafVec.empty()) {
                <span class="comment">// but only put into the container the leaves which, if split,</span>
                <span class="comment">// would have at least minPoints data points associated with them</span>

                <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> lit;
                <span class="keywordflow">for</span> (lit = leafVec.begin(); lit &lt; leafVec.end(); lit++) {
                    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>((*lit), <span class="keyword">false</span>, 0.0, minPoints))
                    {
                        <span class="comment">// leaf can go into container</span>
                        nodes.push_back(*lit);
                        numLeaves++;
                    }
                }
            }

            <span class="comment">// no need to check on cherries - they can all go in</span>
            <span class="keywordflow">if</span> (numCherries &gt; 0)
                nodes.insert(nodes.end(), cherryVec.begin(),cherryVec.end());

            <span class="keywordflow">if</span> (nodes.size() == 0) {
                cancontinue = <span class="keyword">false</span>;
                std::cerr &lt;&lt; <span class="stringliteral">&quot;No changeable nodes given minPoints = &quot;</span>
                            &lt;&lt; minPoints &lt;&lt; <span class="stringliteral">&quot;. Sorry, aborting MCMC.&quot;</span> &lt;&lt; std::endl;
            }
        }

        <span class="keywordtype">bool</span> goodLoop = cancontinue;

        <span class="keywordflow">if</span> (cancontinue &amp;&amp; ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>)
                                            || thinning)) {

            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#adf589f52a0cd3e2371c288aa6bca7d37" title="Put header in a log file for MCMC.">MCMCStartLogFile</a>(s, i, proposal, logPrior);
        }

        i++;

        std::string stateNow = <span class="stringliteral">&quot;&quot;</span>;
        std::string stateAfter = <span class="stringliteral">&quot;&quot;</span>;

        <span class="comment">// make a collation object, empty at present</span>
        <span class="comment">//AdaptiveHistogramCollator coll;</span>

        <span class="comment">// loop from here conditional on good loop and cancontinue</span>
        <span class="keywordflow">while</span> (goodLoop &amp;&amp; (loops &gt; 0) ) {

            <span class="comment">// capture state now</span>
            stateNow = <span class="stringliteral">&quot;\&quot;&quot;</span> + <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>() + <span class="stringliteral">&quot;\&quot;&quot;</span>;
            loops--;

            <span class="comment">// changeMCMCState updates nodes, numLeaves, numCherries, i</span>
            goodLoop = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2e95f7f1a9dab963a28a7d3a655e0e8f" title="Changes the state of this Adaptive Histogram using MCMC process.">changeMCMCState</a>(nodes, numLeaves, numCherries, proposal,
                        logPrior, minPoints, rgsl, logging, s, i);

            <span class="keywordflow">if</span> (goodLoop) {
                <span class="keywordflow">if</span> ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>)) {
                    <span class="comment">// log the current state of the histogram</span>
                    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s);
                }

                <span class="keywordflow">if</span> (i &gt;= burnin &amp;&amp; (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>)) {
                    <span class="comment">// capture state after split or merge to graph file</span>

                    stateAfter = <span class="stringliteral">&quot;\&quot;&quot;</span> + <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>() + <span class="stringliteral">&quot;\&quot;&quot;</span>;
                    std::string line = <span class="stringliteral">&quot;\t &quot;</span> + stateNow + <span class="stringliteral">&quot; -&gt; &quot;</span> + stateAfter + <span class="stringliteral">&quot;;&quot;</span>;
                    <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(dot, line);

                    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a845c591145a1abc86d7d0e1d33c26e22" title="Make a .dot graph file from histogram structure.">outputGraphDot</a>(); <span class="comment">// and make a graph of current state</span>
                }

                <span class="keywordflow">if</span> ((numLeaves == 0 &amp;&amp; numCherries == 0)) {
                    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No more leaves or cherries in MCMC&quot;</span>);

                }

                <span class="comment">// if we are taking samples take the sample here</span>
                <span class="keywordflow">if</span> (goodLoop &amp;&amp; thinning &amp;&amp; (i &gt;= burnin) &amp;&amp;
                        ((i-burnin)%thinout == 0)) {

                    <span class="comment">// output and collate the sample state;</span>
                    <span class="comment">//outputMCMCStateSample(i);</span>
                    
                    <span class="comment">//coll.addToCollation(*this);</span>
          samples.push_back(*<span class="keyword">this</span>);
          
                    <span class="keywordflow">if</span> (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a09aa6a27c1d242b63005aa5d78b45aba">LOGSAMPLES</a> || logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089afec51793a7c8838aa61a4e1b21d1245d">LOGANDGRAPHSAMPLES</a>) {
                        <span class="comment">// log this sample to log file</span>
                        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                    }
                    <span class="keywordflow">if</span> (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089afec51793a7c8838aa61a4e1b21d1245d">LOGANDGRAPHSAMPLES</a>) <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a845c591145a1abc86d7d0e1d33c26e22" title="Make a .dot graph file from histogram structure.">outputGraphDot</a>();

                }
            }

            i++;
            <span class="comment">// back into loop</span>
        }
        <span class="comment">// finished loop</span>
        cancontinue = goodLoop;

        <span class="keywordflow">if</span> (cancontinue &amp;&amp; ((logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>) || (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>))) {
            i--; <span class="comment">// this histogram is full state from last pass</span>
            <span class="comment">// To add final state of histogram to log file</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a10fc830a1dd32fe83aa3846a6fb2af35" title="Capture the final state of this histogram after MCMC.">MCMCLogFinalState</a>(s, i);
            <span class="keywordflow">if</span> (logging == <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a>) {
                <span class="comment">// close the dot graph of the changes process</span>
                <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(dot, <span class="stringliteral">&quot;}&quot;</span>); <span class="comment">// closing line</span>

                <span class="comment">// make the graph image</span>
                <a class="code" href="namespacesubpavings.shtml#abb4671c14005974aeea8f0dd39600ec6" title="make a Dot graph png image given a dot file.">makeDotImage</a>(dot);
            }
        }

    <span class="comment">/*</span>
<span class="comment">        if (cancontinue &amp;&amp; thinning) {</span>
<span class="comment">            std::string collFileName = &quot;CollatorMCMC.txt&quot;;</span>
<span class="comment">            coll.outputToTxtTabs(collFileName); // output the collation to file</span>
<span class="comment"></span>
<span class="comment">            //  Average the sampled histograms</span>
<span class="comment">            std::string avFileName = &quot;AverageMCMC.txt&quot;;     // provide a filename</span>
<span class="comment"></span>
<span class="comment">            coll.outputAverageToTxtTabs(avFileName);  // output the average to file</span>
<span class="comment">        }</span>
<span class="comment">    */</span>
        <span class="comment">// free the random number generator</span>
        
        gsl_rng_free (rgsl);
        
        <span class="keywordflow">if</span> (!cancontinue) { <span class="comment">//empty out the samples if loop failed</span>
      std::vector&lt; AdaptiveHistogram &gt; tmp;
      tmp.swap(samples);
    }
        
        <span class="keywordflow">return</span> samples;
    }
    
    <span class="keywordflow">catch</span> (exception&amp; e) {
    <span class="keywordflow">try</span> {
      <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); 
      <span class="comment">// free the random number generator</span>
    }
    <span class="keywordflow">catch</span> (exception&amp; ee) {} <span class="comment">// catch and swallow</span>
    
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error  in MCMCsamples:\n&quot;</span> 
              + <span class="keywordtype">string</span>(e.what()));
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="adf589f52a0cd3e2371c288aa6bca7d37"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::MCMCStartLogFile" ref="adf589f52a0cd3e2371c288aa6bca7d37" args="(std::string s, int i, const MCMCProposal &amp;proposal, const LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#adf589f52a0cd3e2371c288aa6bca7d37">AdaptiveHistogram::MCMCStartLogFile</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;&#160;</td>
          <td class="paramname"><em>proposal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put header in a log file for MCMC. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the name of the file to log the final state to. </td></tr>
    <tr><td class="paramname">i</td><td>is a number indicating the state number in a chain or series of changes in state. </td></tr>
    <tr><td class="paramname">proposal</td><td>a reference to a proposal function object. </td></tr>
    <tr><td class="paramname">logPrior</td><td>a reference to a log prior function object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00444">444</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml#ace14dfa0a28927d063d091e13f9ead1c">subpavings::LogMCMCPrior::getName()</a>, <a class="el" href="classsubpavings_1_1MCMCProposal.shtml#a8b96ad3e975f60ad938d4aaf6d1009b3">subpavings::MCMCProposal::getName()</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00500">outputLogEMPCOPERR()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Start log file with filename and timestamp</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
    <span class="comment">// put in the name of the proposal and prior</span>
    std::string line = <span class="stringliteral">&quot;Prior is &quot;</span> + logPrior.<a class="code" href="classsubpavings_1_1LogMCMCPrior.shtml#ace14dfa0a28927d063d091e13f9ead1c">getName</a>();
    line += <span class="stringliteral">&quot;, proposal is &quot;</span> + proposal.<a class="code" href="classsubpavings_1_1MCMCProposal.shtml#a8b96ad3e975f60ad938d4aaf6d1009b3">getName</a>();
    <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, line);
    <span class="comment">// log the current state of the histogram</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
    <span class="comment">// output AIC score information</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s);
    <span class="comment">// output COPERR score information</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad2360173a5963ecbca37e0a78ce98879" title="Add COPERR EMP score to log file.">outputLogEMPCOPERR</a>(s);
    std::string headers = <span class="stringliteral">&quot;deltaL \t deltaP \t deltaQ \t deltaPi&amp;Q \t ln(rand)&quot;</span>;
    headers += <span class="stringliteral">&quot;\t ratioL \t ratioP \t ratioQ \t ratioPi&amp;Q \t rand&quot;</span>;
    <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, headers);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a745b6edb93463e227edb9c9aa1dcb505"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::mergeUp" ref="a745b6edb93463e227edb9c9aa1dcb505" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a745b6edb93463e227edb9c9aa1dcb505">AdaptiveHistogram::mergeUp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge a multileaf histogram up to just root box. </p>
<p>No prioritistion, just brute force </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">2875</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01029">subpavings::SPSnode::getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">subpavings::SPSnode::getSubLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">subpavings::SPnode::hasLeafSibling()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">subpavings::SPSnode::nodeReabsorbChildren()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">recalcScaledEMPSumCOPERR()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for mergeUp&quot;</span>);

    }

    <span class="keywordflow">try</span> {

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            cancontinue = <span class="keyword">false</span>;
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Nothing to be done - root paving is already a leaf &quot;</span>
                    &lt;&lt; std::endl;
        }
        <span class="keywordflow">else</span> cancontinue = <span class="keyword">true</span>;

        <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> subleaves;

        <span class="keywordflow">if</span> (cancontinue) {
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves); <span class="comment">// subleaves contains the subleaves</span>
            cancontinue = (subleaves.size()&gt;0);
        }

        <span class="keywordflow">if</span>(!cancontinue) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in mergeUp getting subleaves, aborting merge&quot;</span>);
        }

        <span class="keywordtype">bool</span> canmerge = cancontinue;

        <span class="comment">// merge until there is only one leaf</span>
        <span class="keywordflow">while</span> (canmerge) {

            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* target = *(subleaves.rbegin ()); <span class="comment">// the last in the vector</span>

            <span class="comment">// subtract the child names from the creation string</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += (<span class="stringliteral">&quot; -(&quot;</span> + target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>() + <span class="stringliteral">&quot;)&quot;</span>);

            <span class="comment">// merge the biggest one</span>
            target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2" title="Reabsorbs both children of the node.">nodeReabsorbChildren</a>();
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it = subleaves.end();
            it--;
            subleaves.erase(it, subleaves.end());<span class="comment">// take the last out of the vector</span>

            <span class="comment">// if target had a leaf sibling, target&#39;s parent is now a cherry</span>
            <span class="comment">// and should be inserted into the multiset</span>
            <span class="keywordflow">if</span> (target-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e" title="Check if this has a leaf sibling.">hasLeafSibling</a>()) {

                subleaves.push_back(target-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4" title="Accessor for the parent of a node.">getParent</a>());
           }

            canmerge = (subleaves.size()&gt;0);
        }

        <span class="keywordflow">if</span>(!canmerge) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Merged to root&quot;</span> &lt;&lt; std::endl;
        }

        <span class="comment">// EMPSums are not adjusted during the merging process</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8a546d8d85be0ffac955f7886d5c7aa" title="Recalculate the unscaled EMP part of AIC score.">recalcScaledEMPSumAIC</a>();
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6456652ee831cee0ec4184440cd84ec9" title="Recalculate the scaled EMP part of COPERR score.">recalcScaledEMPSumCOPERR</a>();
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in mergeUp.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in mergeUp.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in mergeUp.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in mergeUp.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a962f179df0a65d5f179930d00e65b70e"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::operator+" ref="a962f179df0a65d5f179930d00e65b70e" args="(const AdaptiveHistogram &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> AdaptiveHistogram::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded addition operator. </p>
<p>Makes a new histogram by adding this and rhs together. The subpaving will be the union of the subpavings of this and rhs. Data is reinserted into the new histogram so that the counts in each box of the subpaving are exactly right for that subpaving. This is in contrast to the way that the <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml" title="A wrapper or manager for a CollatorSPSnode.">AdaptiveHistogramCollator</a> works (divides a count evenly in two when apportioning it between bisected boxes). holdAllStats will be set to the logical and of the values for this and rhs. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01166">1166</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00104">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01353">getHoldAllStats()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">insertFromRVec()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03160">subpavings::SPSnode::unionTreeStructure()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (((NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) &amp;&amp; (NULL != rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>)) &amp;&amp;
    ((<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) != <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()))
    || (<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) != <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()))))
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Added histograms have unequal dimensions&quot;</span>);

    <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* newRoot = NULL;

    <span class="keywordflow">try</span> {


        newRoot = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2dfb3087cff36fdf558bf75d5ee039c9">SPSnode::unionTreeStructure</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>,
                                            rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>);
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor: original error &quot;</span>
                                    &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation rrror in constructor: &quot;</span> + msg);
    }

    <span class="keywordtype">bool</span> hold = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae90ad88f52691280d18f4b6f2e3b7ad1" title="get the value of holdAllStats field.">getHoldAllStats</a>() &amp;&amp; rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae90ad88f52691280d18f4b6f2e3b7ad1" title="get the value of holdAllStats field.">getHoldAllStats</a>());

    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> newHist(newRoot, hold);

    <span class="comment">// put all the data from the two histograms into this one.</span>
    <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> allData;

    allData.reserve( <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.size() + rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.size() );
    <span class="comment">// copy from this dataCollection into allData;</span>
    allData.assign(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.begin(), <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.end());
    allData.insert(allData.end(), rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.begin(),
            rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>.end());

    <span class="comment">// and put the data into the histogram</span>
    newHist.insertFromRVec(allData, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>);

    <span class="keywordflow">return</span> newHist;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3adb7a4fce51ec497ef30dea633249fd"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::operator=" ref="a3adb7a4fce51ec497ef30dea633249fd" args="(const AdaptiveHistogram &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp; AdaptiveHistogram::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">1119</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00104">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00109">holdAllStats</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">recalcScaledEMPSumCOPERR()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">rootBox</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {

        <span class="comment">// we have to make sure we delete the current paving</span>
        <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = NULL;
        }

        <span class="keywordflow">if</span> (NULL != rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>(*(rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>));
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">//copy dataCollection from other to this</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>;

            rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8a546d8d85be0ffac955f7886d5c7aa" title="Recalculate the unscaled EMP part of AIC score.">recalcScaledEMPSumAIC</a>();
            rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6456652ee831cee0ec4184440cd84ec9" title="Recalculate the scaled EMP part of COPERR score.">recalcScaledEMPSumCOPERR</a>();
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>;
        }
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6" title="The root box used to form the subpaving tree.">rootBox</a>;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor&quot;</span>);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor&quot;</span>);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a845c591145a1abc86d7d0e1d33c26e22"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputGraphDot" ref="a845c591145a1abc86d7d0e1d33c26e22" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a845c591145a1abc86d7d0e1d33c26e22">AdaptiveHistogram::outputGraphDot</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a .dot graph file from histogram structure. </p>
<p>Makes a simple .dot graph from the histogram using node names and the .png image for this graph.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>a constructed histogram </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>a .dot file and a .png in the same directory as the program creating it was run in. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03528">3528</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01005">subpavings::SPnode::outputGraphDot()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="ScoreTest_8cpp_source.shtml#l00037">main()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
        success = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aaaf0891a67e056e19f8e086c0139fd96" title="Make a .dot graph file from an SPnode tree structure.">outputGraphDot</a>();

    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Sorry, you can&#39;t make a graph without a root paving&quot;</span>
                &lt;&lt; std::endl;
    }
    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8e1ee4de108b97c04c38ccb16c392e5f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputLog" ref="a8e1ee4de108b97c04c38ccb16c392e5f" args="(const std::string &amp;s, const int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f">AdaptiveHistogram::outputLog</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append current state of histogram to a txt log file. </p>
<p>Format is a tab-delimited file of numeric data. Output includes node contributions to unscaled EMP under COPERR and AIC and the changes in EMP that would result from splitting the node.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">i</td><td>the number of pass (ie, 0, 1, 2, 3 etc) in process </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">383</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">subpavings::SPSnode::leavesOutputTabsWithEMPs()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00484">MCMCLogFinalState()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00444">MCMCStartLogFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03354">publicLogMCMCSample()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// To add output of the AdaptiveHistogram object to file</span>
    ofstream os(s.c_str(), ios::app);         <span class="comment">// append</span>
    <span class="keywordflow">if</span> (os.is_open()) {
        <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();

        os &lt;&lt; std::endl;
        os &lt;&lt; <span class="stringliteral">&quot;Pass &quot;</span> &lt;&lt; i &lt;&lt; std::endl; <span class="comment">// numbering</span>
        os &lt;&lt; <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> &lt;&lt; std::endl; <span class="comment">// creation string so far</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a817a8a29925937c189cc009366fe6bfb" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithEMPs</a>(n, os); <span class="comment">// the output</span>
        os.close();
    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
            &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a602b8b4081d3cae20308aa6644a83fa9"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputLogEMPAIC" ref="a602b8b4081d3cae20308aa6644a83fa9" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9">AdaptiveHistogram::outputLogEMPAIC</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add AIC EMP score to log file. </p>
<p>Tab delimited </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">518</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00484">MCMCLogFinalState()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">MCMCsamples()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00444">MCMCStartLogFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03354">publicLogMCMCSample()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// To add output of the AdaptiveHistogram object to file</span>
    ofstream os(s.c_str(), ios::app);         <span class="comment">// append</span>

    <span class="keywordflow">if</span> (os.is_open()) {
        real emp = rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>);
        os &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;AIC EMP is \t&quot;</span> &lt;&lt; emp;
        os.close();
    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
            &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad2360173a5963ecbca37e0a78ce98879"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputLogEMPCOPERR" ref="ad2360173a5963ecbca37e0a78ce98879" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad2360173a5963ecbca37e0a78ce98879">AdaptiveHistogram::outputLogEMPCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add COPERR EMP score to log file. </p>
<p>Tab delimited </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00500">500</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00484">MCMCLogFinalState()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00444">MCMCStartLogFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// To add output of the AdaptiveHistogram object to file</span>
    ofstream os(s.c_str(), ios::app);         <span class="comment">// append</span>
    <span class="keywordflow">if</span> (os.is_open()) {

        real emp = rnd(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>);
        os &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;COPERR EMP is \t&quot;</span> &lt;&lt; emp;
        os.close();
    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
            &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa73a46279c3f591d298a0180d99723a5"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputLogPlain" ref="aa73a46279c3f591d298a0180d99723a5" args="(const std::string &amp;s, const int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#aa73a46279c3f591d298a0180d99723a5">AdaptiveHistogram::outputLogPlain</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append current state of histogram to a txt log file. </p>
<p>Format is a tab-delimited file of numeric data. Output is plain: just vols, counters, and boxes.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">i</td><td>the number of pass (ie, 0, 1, 2, 3 etc) in process </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04703">4703</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02403">subpavings::SPSnode::leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// To add output of the AdaptiveHistogram object to file</span>
    ofstream os(s.c_str(), ios::app);         <span class="comment">// append</span>
    <span class="keywordflow">if</span> (os.is_open()) {
        os &lt;&lt; std::endl;
        os &lt;&lt; <span class="stringliteral">&quot;Pass &quot;</span> &lt;&lt; i &lt;&lt; std::endl; <span class="comment">// numbering</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os); <span class="comment">// the output</span>
        os.close();
    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
            &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad847a4add7e72eac564daa44835dba5b"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputLogStart" ref="ad847a4add7e72eac564daa44835dba5b" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b">AdaptiveHistogram::outputLogStart</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opening line of a txt log file. </p>
<p>Starts the log file with file name and date and time </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">404</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00444">MCMCStartLogFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Make a string with filename and timestamp to start log file</span>
    time_t rawtime;
    <span class="keyword">struct </span>tm * timeinfo;
    time ( &amp;rawtime );
    timeinfo = localtime ( &amp;rawtime );
    ofstream os(s.c_str());         <span class="comment">// replace data</span>
    <span class="keywordflow">if</span> (os.is_open()) {
        os &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot; created &quot;</span> &lt;&lt;  asctime (timeinfo) &lt;&lt; std::endl;
        os.close();
    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
            &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4e7d34aea502906cb2230c0732d752b3"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputMCMCStateSample" ref="a4e7d34aea502906cb2230c0732d752b3" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4e7d34aea502906cb2230c0732d752b3">AdaptiveHistogram::outputMCMCStateSample</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the state of this histogram as an MCMC sample. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>is a number indicating the state number in a chain or series of changes in state. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00466">466</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">outputToTxtTabs()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03044">MCMC()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// create a name for the file to output</span>
    std::string sampleFileName = <span class="stringliteral">&quot;MCMCSample&quot;</span>;
    <span class="comment">//convert i to a string</span>
    std::ostringstream stm;
    stm &lt;&lt; i;

    <span class="comment">// add the stringed i to the filename</span>
    sampleFileName += stm.str();
    sampleFileName += <span class="stringliteral">&quot;.txt&quot;</span>; <span class="comment">// and finish the filename</span>

    <span class="comment">// To realize a file output</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a49a8ff01e1398420cd45642d5b1d3106" title="Output the subpaving managed by this to a txt file.">outputToTxtTabs</a>(sampleFileName);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a35416eefb965755a846e1bb64c882439"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputRootToTxt" ref="a35416eefb965755a846e1bb64c882439" args="(const std::string &amp;s, bool confirm=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a35416eefb965755a846e1bb64c882439">AdaptiveHistogram::outputRootToTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>confirm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output details of full sample (from root) to txt tile. </p>
<p>Format is a mixture of alpha and numeric data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">confirm</td><td>is a boolean controlling whether confirmation goes to console output (defaults to false). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03595">3595</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01995">subpavings::SPSnode::nodePrint()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {

        <span class="comment">// To generate a file output of root node of the AdaptiveHistogram</span>
        ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#aba02715cb75f803df7c3ffd1eaf027e8" title="Output details of a specific node.">nodePrint</a>(os); <span class="comment">// the output</span>
        <span class="keywordflow">if</span> (confirm)
            std::cout &lt;&lt; <span class="stringliteral">&quot;Details of the root paving of the AdaptiveHistogram &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;has been written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a49a8ff01e1398420cd45642d5b1d3106"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputToTxtTabs" ref="a49a8ff01e1398420cd45642d5b1d3106" args="(const std::string &amp;s, bool confirm=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a49a8ff01e1398420cd45642d5b1d3106">AdaptiveHistogram::outputToTxtTabs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>confirm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the subpaving managed by this to a txt file. </p>
<p>Format is a tab-delimited file of numeric data starting with nodeName, then the node box volume, then the node counter, then the description of the node box as a tab-delimited list of interval upper and lower bounds.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">confirm</td><td>is a boolean controlling whether confirmation goes to console output (defaults to false). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">3546</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02403">subpavings::SPSnode::leavesOutputTabs()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00080">subpavings::AdaptiveHistogramCollator::collateFromRVec()</a>, <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00466">outputMCMCStateSample()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03341">publicOutputMCMCStateSample()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {

        <span class="comment">// To generate a file output of the AdaptiveHistogram object</span>
        ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>
        <span class="keywordflow">if</span> (os.is_open()) {

            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os); <span class="comment">// the output</span>
            <span class="keywordflow">if</span> (confirm)
                std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the AdaptiveHistogram &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;has been written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
        }
        <span class="keywordflow">else</span> {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
                &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2fb89e060574b8c935191cd3afd91290"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::outputToTxtTabsWithEMPs" ref="a2fb89e060574b8c935191cd3afd91290" args="(const std::string &amp;s, bool confirm=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2fb89e060574b8c935191cd3afd91290">AdaptiveHistogram::outputToTxtTabsWithEMPs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>confirm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the subpaving managed by this to a txt file. </p>
<p>Format is a tab-delimited file of numeric data starting with nodeName, then the node box volume, then the node counter, then node contribution to EMP under COPERR, the change that would result in the EMP under COPERR if the node were split, the node contribution to EMP under AIC, the change that would result in the EMP under AIC if the node were split, and then the node box as a tab-delimited list of interval upper and lower bounds.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">confirm</td><td>is a boolean controlling whether confirmation goes to console output (defaults to false). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03571">3571</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">subpavings::SPSnode::leavesOutputTabsWithEMPs()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>.</p>

<p>Referenced by <a class="el" href="ScoreTest_8cpp_source.shtml#l00037">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {

        <span class="comment">// To generate a file output of the AdaptiveHistogram object</span>
        ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>
        <span class="keywordflow">if</span> (os.is_open()) {
            <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a817a8a29925937c189cc009366fe6bfb" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithEMPs</a>(n, os); <span class="comment">// the output</span>
            <span class="keywordflow">if</span> (confirm)
                std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the AdaptiveHistogram with scaled EMPs &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;has been written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
        }
        <span class="keywordflow">else</span> {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
                &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4c8d2603da121585e049548baca3c712"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::priorityMerge" ref="a4c8d2603da121585e049548baca3c712" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a4c8d2603da121585e049548baca3c712">AdaptiveHistogram::priorityMerge</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Priority merge to reduce number of leaves in histogram. </p>
<p>This method takes a histogram where where all the data is associated with multiple nodes and progressively merges the children of sub-terminal leaves using a priority queue to determine which node to merge first. Merging continues until some criteria applying either to individual nodes or to the histogram as a whole is satisfied, or the histogram only has one bin.</p>
<p>If more than one node is equally 'small', on the basis of the node comparison compTest used, then a random choice is made between all equally small nodes to find the node which will be merged.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compTest</td><td>is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. </td></tr>
    <tr><td class="paramname">he</td><td>is an instance of a class which provides a function to determine when to stop merging. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the priority merge was successful, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">2698</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02360">subpavings::SPSnode::getMergeChangeEMPAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02331">subpavings::SPSnode::getMergeChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01029">subpavings::SPSnode::getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">subpavings::SPSnode::getSubLeaves()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00838">subpavings::SPnode::hasLeafSibling()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">subpavings::SPSnode::nodeReabsorbChildren()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00372">updateScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00366">updateScaledEMPSumCOPERR()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="ScoreTest_8cpp_source.shtml#l00037">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for priorityMerge&quot;</span>);
    }

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {
        <span class="keywordtype">size_t</span> n = 0; <span class="comment">// number of points in histogram</span>

        <span class="keywordtype">int</span> i = 0;
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqMergeOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            cancontinue = <span class="keyword">false</span>;
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error in priorityMerge: trying to do &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;priority merge where the rootPaving &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;has no children&quot;</span> &lt;&lt; std::endl;
        }
        <span class="keywordflow">else</span> cancontinue = <span class="keyword">true</span>;

        <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
        multiset&lt;SPSnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));

        <span class="keywordflow">if</span> (cancontinue) {
            n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// number of points in histogram</span>

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                 <span class="comment">// Start log file with filename and timestamp</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
                <span class="comment">// log the current state of the histogram</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                i++;
            }

            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> subleaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves);

            <span class="comment">// insert a copy of the current set of subleaves into the multiset</span>
            pq.insert(subleaves.begin(), subleaves.end());

            cancontinue = (pq.size()&gt;0);
        }

        <span class="keywordflow">if</span>(!cancontinue) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in priority merging, aborting merge&quot;</span>);
        }

        <span class="keywordtype">bool</span> canmerge = cancontinue;

        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        <span class="comment">// merge until the HistEvalObj he () operator returns true</span>
        <span class="keywordflow">while</span> (canmerge &amp;&amp; !he(<span class="keyword">this</span>)) {

            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* smallest = *(pq.begin ()); <span class="comment">// the first smallest in the set</span>

            <span class="comment">// find if there are any more equal to smallest around</span>
            multiset&lt;SPSnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSnode*, MyCompare&gt;::iterator&gt; equalSmallest;

            equalSmallest = pq.equal_range(smallest); <span class="comment">// everything that = smallest</span>
            <span class="keywordtype">size_t</span> numberSmallest = pq.count(smallest); <span class="comment">// number of =smallest</span>

            <span class="keywordflow">if</span> (numberSmallest &gt; 1) {
                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalSmallest.first; mit!=equalSmallest.second; ++mit) {
                    sum += 1.0/(1.0*numberSmallest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        <span class="keywordflow">break</span>;
                    }
                }
            }
            <span class="keywordflow">else</span> mit = pq.begin ();

            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* chosenSmallest = *(mit); <span class="comment">// the chosen smallest in the set</span>

            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a71122bfe1d3dfad1f2b55585326334ac" title="Update the scaled EMP part COPERR score given change.">updateScaledEMPSumCOPERR</a>(chosenSmallest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2c8cc31ffdb9c74b82cce176c8d14585" title="Get scaled change in sum term in EMP under COPERR on merge.">getMergeChangeEMPCOPERR</a>(n));
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a79fe01c35fba2bbdb1df5e8eb1d3a78b" title="Update the the scaled EMP part AIC score given change.">updateScaledEMPSumAIC</a>(chosenSmallest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a42114089fcad779bec855496154ded19" title="Get change in sum term in EMP under AIC on merge.">getMergeChangeEMPAIC</a>());

            <span class="comment">// subtract the child names from the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += (<span class="stringliteral">&quot; -(&quot;</span> + chosenSmallest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>() + <span class="stringliteral">&quot;)&quot;</span>);

            <span class="comment">// merge the biggest one</span>
            chosenSmallest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2" title="Reabsorbs both children of the node.">nodeReabsorbChildren</a>();
            pq.erase(mit);<span class="comment">// take the iterator to chosen smallest out of the set</span>

            <span class="comment">// if smallest had a leaf sibling, smallest&#39;s parent is now a cherry</span>
            <span class="comment">// and should be inserted into the multiset</span>
            <span class="keywordflow">if</span> (chosenSmallest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0b8af2e1f907279d8a153129aa37aa8e" title="Check if this has a leaf sibling.">hasLeafSibling</a>()) {

                pq.insert(chosenSmallest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4" title="Accessor for the parent of a node.">getParent</a>());
           }

            canmerge = (pq.size()&gt;0);

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                i++;
            }
        }

        <span class="keywordflow">if</span>(!canmerge) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No more subleaves left to merge&quot;</span> &lt;&lt; std::endl;
        }

        <span class="keywordflow">if</span> (cancontinue &amp;&amp; (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)) {
            <span class="comment">// log the leaf levels line</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());
        }

        <span class="comment">// EMPSums will have been adjusted during the merging process</span>
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl);
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority merge.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error  in priority merge.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException  in priority merge.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error  in priority merge.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }


    <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2b60528af3d0f583b08284e11d4ff764"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="a2b60528af3d0f583b08284e11d4ff764" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">subpavings::AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minChildPoints supplied, no minvolB, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01150">1150</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01150">prioritySplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00080">subpavings::AdaptiveHistogramCollator::collateFromRVec()</a>, <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02062">prioritySplit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes); }
</pre></div>
</div>
</div>
<a class="anchor" id="a123e69c185cb450a05ecdc7101c71548"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="a123e69c185cb450a05ecdc7101c71548" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">subpavings::AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minVolB supplied, no minChildPoints, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01157">1157</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01157">prioritySplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01157">prioritySplit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compTest, he, logging, 0, minVolB, maxLeafNodes); }
</pre></div>
</div>
</div>
<a class="anchor" id="a04219b243723859e2939216181cbaddc"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="a04219b243723859e2939216181cbaddc" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">subpavings::AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neither minVolB nor minChildPoints supplied, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01163">1163</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01163">prioritySplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01163">prioritySplit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compTest, he, logging, 0, 0.0, maxLeafNodes); }
</pre></div>
</div>
</div>
<a class="anchor" id="ab28cddbe199adccec104b223f8848712"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="ab28cddbe199adccec104b223f8848712" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02062">2062</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01150">prioritySplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aea0d424449b7d93babef81d49bbbdb70"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="aea0d424449b7d93babef81d49bbbdb70" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">subpavings::AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minChildPoints supplied, no minvolB. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01173">1173</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01173">prioritySplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01173">prioritySplit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compTest, he, logging, minChildPoints, 0.0, rgsl,
                    maxLeafNodes); }
</pre></div>
</div>
</div>
<a class="anchor" id="ad6a946d5c729b0f49d78962680d5d659"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="ad6a946d5c729b0f49d78962680d5d659" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">subpavings::AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minVolB supplied, no minChildPoints. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01181">1181</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01181">prioritySplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01181">prioritySplit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compTest, he, logging, 0, minVolB, rgsl, maxLeafNodes); }
</pre></div>
</div>
</div>
<a class="anchor" id="a630b400683794cd527173b18eb126f84"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="a630b400683794cd527173b18eb126f84" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, gsl_rng *rgsl, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">subpavings::AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Neither minVolB nor minChildPoints supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01187">1187</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01187">prioritySplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01187">prioritySplit()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compTest, he, logging, 0, 0.0, rgsl, maxLeafNodes); }
</pre></div>
</div>
</div>
<a class="anchor" id="a2154185722cd1d4f61f65c7d84d77f2b"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplit" ref="a2154185722cd1d4f61f65c7d84d77f2b" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">AdaptiveHistogram::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">2127</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">subpavings::Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">getMinVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{    
    <span class="comment">//cout &lt;&lt; minChildPoints &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; minVolB &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; maxLeafNodes &lt;&lt; endl;</span>
    
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
    
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }

    <span class="keywordflow">try</span> {

        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="keywordtype">size_t</span> n; <span class="comment">// for number of points in histogram</span>

        <span class="keywordtype">int</span> i = 0;
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }

        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0ef2d251d61753086a358bdd9bda057f" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
           volChecking = <span class="keyword">true</span>;
        }

        <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
        multiset&lt;SPSnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));

        n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// number of points in histogram</span>

        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
            <span class="comment">// log the current state of the histogram</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
            i++;
        }

        <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
        <span class="comment">// there are enough points in the whole node</span>
                <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
        <span class="comment">// or the minChildCountIfSplit test passed</span>

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootPaving pointer into the set</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> sit;
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

        cancontinue = (!pq.empty());
      
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
       TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);

        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }

      
        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out</span>
        <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {
            
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* chosenLargest;
            
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSnode*, MyCompare&gt;::iterator&gt; equalLargest;

            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {

                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {

                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }

            <span class="keywordflow">else</span> {

                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }

            <span class="comment">// accumulate the changes in scaled EMP sums that will result</span>
            <span class="comment">// from this expansion</span>
            <span class="comment">//updateScaledEMPSumCOPERR(chosenLargest-&gt;getSplitChangeEMPCOPERR(n));</span>
            <span class="comment">//updateScaledEMPSumAIC(chosenLargest-&gt;getSplitChangeEMPAIC());</span>

            <span class="comment">// split the biggest one and divvie up its data</span>

          <span class="comment">// cout &lt;&lt; &quot;chosenLargest: &quot; &lt;&lt; chosenLargest-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; chosenLargest-&gt;getCounter() &lt;&lt; endl;</span>
           
           <a class="code" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a" title="Expand a leaf node to have two child nodes.">Expand</a>(chosenLargest);

           
           <span class="comment">//cout &lt;&lt; getLeafLevelsString() &lt;&lt; endl;</span>

            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new left child into the multiset</span>
                
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new right child into the multiset</span>
               
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                i++;
            }

            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough)
                std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
        
        
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      
  }
         
         
        <span class="keywordflow">if</span> (cancontinue &amp;&amp; (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)) {
            <span class="comment">// log the leaf levels line</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());

        }

        <span class="comment">// EMPSums will have been adjusted during the splitting process</span>
   }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory iin priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1dffa971cfc56ec37449ce285a596365"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="a1dffa971cfc56ec37449ce285a596365" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">subpavings::AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minChildPoints supplied, no minvolB, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01707">1707</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01707">prioritySplitGet()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05455">prioritySplitGet()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a>(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes, States, Sampled); }
</pre></div>
</div>
</div>
<a class="anchor" id="ab3416e49bbb37e982e2e2f6a1ef13850"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="ab3416e49bbb37e982e2e2f6a1ef13850" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">subpavings::AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minVolB supplied, no minChildPoints, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01716">1716</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01716">prioritySplitGet()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01716">prioritySplitGet()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a>(compTest, he, logging, 0, minVolB, maxLeafNodes, 
                     States, Sampled); }
</pre></div>
</div>
</div>
<a class="anchor" id="a3eab9e09fee0aa81bd19bf170cf23aea"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="a3eab9e09fee0aa81bd19bf170cf23aea" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">subpavings::AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neither minVolB nor minChildPoints supplied, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01725">1725</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01725">prioritySplitGet()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01725">prioritySplitGet()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a>(compTest, he, logging, 0, 0.0, maxLeafNodes,
                     States, Sampled); }
</pre></div>
</div>
</div>
<a class="anchor" id="afee0931f38335b1d797680a0c9b6cfe5"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="afee0931f38335b1d797680a0c9b6cfe5" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05455">5455</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01707">prioritySplitGet()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a>(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes,
                                    States, Sampled);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af4e1c9c71ca8835f8ee3a78204f63d49"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="af4e1c9c71ca8835f8ee3a78204f63d49" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">subpavings::AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minChildPoints supplied, no minvolB. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01740">1740</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01740">prioritySplitGet()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01740">prioritySplitGet()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a>(compTest, he, logging, minChildPoints, 0.0, rgsl,
                    maxLeafNodes, States, Sampled); }
</pre></div>
</div>
</div>
<a class="anchor" id="a761f68d3b8f183d4fda926732fda70f9"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="a761f68d3b8f183d4fda926732fda70f9" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">subpavings::AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minVolB supplied, no minChildPoints. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01750">1750</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01750">prioritySplitGet()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01750">prioritySplitGet()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a>(compTest, he, logging, 0, minVolB, rgsl, maxLeafNodes, 
                     States, Sampled); }
</pre></div>
</div>
</div>
<a class="anchor" id="a8654a1a779b1c0e6d0dcec82f436efd6"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="a8654a1a779b1c0e6d0dcec82f436efd6" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">subpavings::AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Neither minVolB nor minChildPoints supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01759">1759</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01759">prioritySplitGet()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01759">prioritySplitGet()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">prioritySplitGet</a>(compTest, he, logging, 0, 0.0, rgsl, maxLeafNodes, 
                      States, Sampled); }
</pre></div>
</div>
</div>
<a class="anchor" id="a36a5db0649767e9045cf985f52f985ca"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitGet" ref="a36a5db0649767e9045cf985f52f985ca" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; AdaptiveHistogram &gt; &amp;States, std::vector&lt; size_t &gt; &amp;Sampled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1dffa971cfc56ec37449ce285a596365">AdaptiveHistogram::prioritySplitGet</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>States</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sampled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">5519</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">subpavings::Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">getMinVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{   
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
    
    <span class="keywordtype">int</span> removeBox = 0;
    
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }

    <span class="keywordflow">try</span> {

        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="keywordtype">size_t</span> n; <span class="comment">// for number of points in histogram</span>

        <span class="keywordtype">int</span> i = 0;
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }

        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0ef2d251d61753086a358bdd9bda057f" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
           volChecking = <span class="keyword">true</span>;
        }

        <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
        multiset&lt;SPSnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));

        n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// number of points in histogram</span>

        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
            <span class="comment">// log the current state of the histogram</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
            i++;
        }

        <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
        <span class="comment">// there are enough points in the whole node</span>
                <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
        <span class="comment">// or the minChildCountIfSplit test passed</span>

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootPaving pointer into the set</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> sit;
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

      cancontinue = (!pq.empty());
        
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);

        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }

        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out</span>
        <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {
            
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* chosenLargest;
            
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSnode*, MyCompare&gt;::iterator&gt; equalLargest;

            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {

                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {

                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }

            <span class="keywordflow">else</span> {

                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }

            <span class="comment">// accumulate the changes in scaled EMP sums that will result</span>
            <span class="comment">// from this expansion</span>
            <span class="comment">//updateScaledEMPSumCOPERR(chosenLargest-&gt;getSplitChangeEMPCOPERR(n));</span>
            <span class="comment">//updateScaledEMPSumAIC(chosenLargest-&gt;getSplitChangeEMPAIC());</span>

        <span class="comment">// collect the needed states here</span>
        <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() == (Sampled[0]+1) ) {
          States.push_back(*<span class="keyword">this</span>);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() == (Sampled[1]+1) ) {
          States.push_back(*<span class="keyword">this</span>);
          <span class="keywordflow">break</span>;
        }

            <span class="comment">// split the biggest one and divide up its data</span>
             <a class="code" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a" title="Expand a leaf node to have two child nodes.">Expand</a>(chosenLargest);

            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>

            <span class="keywordflow">if</span> (((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;getCounter() &gt; removeBox) &amp;&amp;
             <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>(),
                  volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new left child into the multiset</span>
                
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;getCounter() &gt; removeBox) &amp;&amp;
                 <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new right child into the multiset</span>
               
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                i++;
            }

            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough)
                std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
        
        
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      
      }
          

          
          <span class="keywordflow">if</span> (cancontinue &amp;&amp; (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)) {
            <span class="comment">// log the leaf levels line</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());
          }

          <span class="comment">// EMPSums will have been adjusted during the splitting process</span>
   }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory iin priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="afa5a767156398a6d29db12fcbf0a46c7"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="afa5a767156398a6d29db12fcbf0a46c7" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">subpavings::AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minChildPoints supplied, no minvolB, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01781">1781</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01781">prioritySplitMCMC()</a>.</p>

<p>Referenced by <a class="el" href="MCMCFunctionSimGaussianQueue_8cpp_source.shtml#l00046">main()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05117">prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes, Posterior, logPrior); }
</pre></div>
</div>
</div>
<a class="anchor" id="a024499e93cb4ca592c78b860d09cef79"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="a024499e93cb4ca592c78b860d09cef79" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">subpavings::AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minVolB supplied, no minChildPoints, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01789">1789</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01789">prioritySplitMCMC()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01789">prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compTest, he, logging, 0, minVolB, maxLeafNodes, 
    Posterior, logPrior); }
</pre></div>
</div>
</div>
<a class="anchor" id="a4c890ee5d86fc4cfd45c0ea2667b4a4f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="a4c890ee5d86fc4cfd45c0ea2667b4a4f" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">subpavings::AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neither minVolB nor minChildPoints supplied, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01797">1797</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01797">prioritySplitMCMC()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01797">prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compTest, he, logging, 0, 0.0, maxLeafNodes, Posterior,
    logPrior); }
</pre></div>
</div>
</div>
<a class="anchor" id="ab4acf5596236ac6fa272cb3abe80bee8"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="ab4acf5596236ac6fa272cb3abe80bee8" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05117">5117</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01781">prioritySplitMCMC()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes,
                                    Posterior, logPrior);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab38788117602e87f4e53a72b6c62747a"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="ab38788117602e87f4e53a72b6c62747a" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">subpavings::AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minChildPoints supplied, no minvolB. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01810">1810</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01810">prioritySplitMCMC()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01810">prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compTest, he, logging, minChildPoints, 0.0, rgsl,
                    maxLeafNodes, Posterior, logPrior); }
</pre></div>
</div>
</div>
<a class="anchor" id="ab8e2052a043fc9969084719da4338678"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="ab8e2052a043fc9969084719da4338678" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">subpavings::AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minVolB supplied, no minChildPoints. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01819">1819</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01819">prioritySplitMCMC()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01819">prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compTest, he, logging, 0, minVolB, rgsl, maxLeafNodes, 
    Posterior, logPrior); }
</pre></div>
</div>
</div>
<a class="anchor" id="af6cd725ab063a5c3af80d42315d99ddc"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="af6cd725ab063a5c3af80d42315d99ddc" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">subpavings::AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Neither minVolB nor minChildPoints supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01827">1827</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01827">prioritySplitMCMC()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01827">prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compTest, he, logging, 0, 0.0, rgsl, maxLeafNodes, 
    Posterior, logPrior); }
</pre></div>
</div>
</div>
<a class="anchor" id="a5e8e56baf547e75fe1701b455fa92efb"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitMCMC" ref="a5e8e56baf547e75fe1701b455fa92efb" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, std::vector&lt; real &gt; &amp;Posterior, LogMCMCPrior &amp;logPrior)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">AdaptiveHistogram::prioritySplitMCMC</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; real &gt; &amp;&#160;</td>
          <td class="paramname"><em>Posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a> &amp;&#160;</td>
          <td class="paramname"><em>logPrior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">5181</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">subpavings::Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02028">subpavings::SPSnode::getLogLik()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">getMinVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{   
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
    
    real deltaL = 0;
    real deltaP = 0;
    <span class="keywordtype">int</span> removeBox = 0;
    
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }

    <span class="keywordflow">try</span> {

        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="keywordtype">size_t</span> n; <span class="comment">// for number of points in histogram</span>

        <span class="keywordtype">int</span> i = 0;
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }

        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0ef2d251d61753086a358bdd9bda057f" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
           volChecking = <span class="keyword">true</span>;
        }

        <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
        multiset&lt;SPSnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));

        n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// number of points in histogram</span>

        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
            <span class="comment">// log the current state of the histogram</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
            i++;
        }

        <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
        <span class="comment">// there are enough points in the whole node</span>
                <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
        <span class="comment">// or the minChildCountIfSplit test passed</span>

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootPaving pointer into the set</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> sit;
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

      <span class="comment">// get the log-likelihood</span>
      <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
      <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
      <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>
        <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
        <span class="comment">//cout &lt;&lt; (*it)-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; (*it)-&gt;getCounter() &lt;&lt; endl; </span>
        deltaL += (*it)-&gt;getLogLik(n);
      }

      <span class="comment">// use the prior distribution object to find the prior </span>
      deltaP = logPrior(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>()-1);
      <span class="comment">// posterior is proportional to likelihood * prior</span>
      real deltaPi = deltaL + deltaP;
      <span class="comment">// push back into vector</span>
      Posterior.push_back(deltaPi);

      cancontinue = (!pq.empty());
        
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);

        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }

        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out</span>
        <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {
            
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* chosenLargest;
            
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSnode*, MyCompare&gt;::iterator&gt; equalLargest;

            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {

                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {

                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }

            <span class="keywordflow">else</span> {

                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }

            <span class="comment">// accumulate the changes in scaled EMP sums that will result</span>
            <span class="comment">// from this expansion</span>
            <span class="comment">//updateScaledEMPSumCOPERR(chosenLargest-&gt;getSplitChangeEMPCOPERR(n));</span>
            <span class="comment">//updateScaledEMPSumAIC(chosenLargest-&gt;getSplitChangeEMPAIC());</span>

            <span class="comment">// split the biggest one and divide up its data</span>
             <a class="code" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a" title="Expand a leaf node to have two child nodes.">Expand</a>(chosenLargest);
             
        <span class="comment">// get the log-likelihood for the children node </span>
        real changeL = chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a45f10ce1371120a0c1be29fa0ad8bac5" title="Get this leaf node&#39;s contribution to loglikelihood.">getLogLik</a>(n);
        changeL += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a45f10ce1371120a0c1be29fa0ad8bac5" title="Get this leaf node&#39;s contribution to loglikelihood.">getLogLik</a>(n);

        <span class="comment">// compute the likelihood * prior to get posterior</span>
        <span class="keywordtype">size_t</span> realNumLeaves = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>(); 
        
        <span class="comment">//cout &lt;&lt; &quot;---------------------------------------&quot; &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; &quot;Number of leaves &quot; &lt;&lt; realNumLeaves &lt;&lt; endl;</span>

        <span class="comment">// log likelihood</span>
        deltaL = deltaL - chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a45f10ce1371120a0c1be29fa0ad8bac5" title="Get this leaf node&#39;s contribution to loglikelihood.">getLogLik</a>(n) + changeL; 

        <span class="comment">// use the prior distribution object to find the prior </span>
        deltaP = logPrior(realNumLeaves-1);
        
        <span class="comment">//cout &lt;&lt; deltaL &lt;&lt; &quot;\t&quot; &lt;&lt; deltaP &lt;&lt; endl;</span>
        
        <span class="comment">// posterior is proportional to likelihood * prior</span>
        real deltaPi = deltaL + deltaP;
        
        <span class="comment">// push back into vector</span>
        Posterior.push_back(deltaPi);

            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>

            <span class="keywordflow">if</span> (((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;getCounter() &gt; removeBox) &amp;&amp;
             <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>(),
                  volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new left child into the multiset</span>
                
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;getCounter() &gt; removeBox) &amp;&amp;
                 <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new right child into the multiset</span>
               
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                i++;
            }

            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough)
                std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
        
        
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      
      }
          

          
          <span class="keywordflow">if</span> (cancontinue &amp;&amp; (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)) {
            <span class="comment">// log the leaf levels line</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());
          }

          <span class="comment">// EMPSums will have been adjusted during the splitting process</span>
   }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory iin priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a75ca6c8d7a95525b76b098c8c6e20cf8"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="a75ca6c8d7a95525b76b098c8c6e20cf8" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">subpavings::AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minChildPoints supplied, no minvolB, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01913">1913</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01913">prioritySplitWithSwitches()</a>.</p>

<p>Referenced by <a class="el" href="FiniteMixture_8cpp_source.shtml#l00045">main()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02369">prioritySplitWithSwitches()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a>(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes, removeBox); }
</pre></div>
</div>
</div>
<a class="anchor" id="a0cd2e3af29feaad65d4a0a36738dcc15"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="a0cd2e3af29feaad65d4a0a36738dcc15" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">subpavings::AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minVolB supplied, no minChildPoints, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01920">1920</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01920">prioritySplitWithSwitches()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01920">prioritySplitWithSwitches()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a>(compTest, he, logging, 0, minVolB, 
              maxLeafNodes, removeBox); }
</pre></div>
</div>
</div>
<a class="anchor" id="a39ff221f6d3dad036ba6d4f5ec0ae819"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="a39ff221f6d3dad036ba6d4f5ec0ae819" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">subpavings::AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neither minVolB nor minChildPoints supplied, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01927">1927</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01927">prioritySplitWithSwitches()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01927">prioritySplitWithSwitches()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a>(compTest, he, logging, 0, 0.0, 
                maxLeafNodes, removeBox); }
</pre></div>
</div>
</div>
<a class="anchor" id="aa1b1ab0c522e46bc4bd0ab45547dea6b"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="aa1b1ab0c522e46bc4bd0ab45547dea6b" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02369">2369</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01913">prioritySplitWithSwitches()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a>(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes,
                        removeBox);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5299ade7c1d409621b2204a1986dabd8"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="a5299ade7c1d409621b2204a1986dabd8" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">subpavings::AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minChildPoints supplied, no minvolB. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01938">1938</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01938">prioritySplitWithSwitches()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01938">prioritySplitWithSwitches()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a>(compTest, he, logging, minChildPoints, 0.0, rgsl,
                    maxLeafNodes, removeBox); }
</pre></div>
</div>
</div>
<a class="anchor" id="ad2ae1c64a519c1d5f32f81d39210b738"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="ad2ae1c64a519c1d5f32f81d39210b738" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">subpavings::AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minVolB supplied, no minChildPoints. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01946">1946</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01946">prioritySplitWithSwitches()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01946">prioritySplitWithSwitches()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a>(compTest, he, logging, 0, minVolB, rgsl, 
                maxLeafNodes, removeBox); }
</pre></div>
</div>
</div>
<a class="anchor" id="af9317b285f9a4f2753b1c9099347fe6f"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="af9317b285f9a4f2753b1c9099347fe6f" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">subpavings::AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Neither minVolB nor minChildPoints supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01954">1954</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01954">prioritySplitWithSwitches()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01954">prioritySplitWithSwitches()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">prioritySplitWithSwitches</a>(compTest, he, logging, 0, 0.0, rgsl, 
            maxLeafNodes, removeBox); }
</pre></div>
</div>
</div>
<a class="anchor" id="a6eb39e1e4524e415b8eff1ba4a4fc4b0"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithSwitches" ref="a6eb39e1e4524e415b8eff1ba4a4fc4b0" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int removeBox)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a75ca6c8d7a95525b76b098c8c6e20cf8">AdaptiveHistogram::prioritySplitWithSwitches</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>removeBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">2435</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">subpavings::Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">getMinVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{    
    <span class="comment">//cout &lt;&lt; minChildPoints &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; minVolB &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; maxLeafNodes &lt;&lt; endl;</span>

    
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
    
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }

    <span class="keywordflow">try</span> {

        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="keywordtype">size_t</span> n; <span class="comment">// for number of points in histogram</span>

        <span class="keywordtype">int</span> i = 0;
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }

        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0ef2d251d61753086a358bdd9bda057f" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
           volChecking = <span class="keyword">true</span>;
        }

        <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
        multiset&lt;SPSnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));

        n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// number of points in histogram</span>

        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
            <span class="comment">// log the current state of the histogram</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
            i++;
        }

        <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
        <span class="comment">// there are enough points in the whole node</span>
                <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
        <span class="comment">// or the minChildCountIfSplit test passed</span>

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootPaving pointer into the set</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> sit;
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

        cancontinue = (!pq.empty());
      
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
       TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);

        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }

      
        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out</span>
        
        <span class="keywordtype">size_t</span> temp = 0;
        
        <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {
            
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* chosenLargest;
            
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSnode*, MyCompare&gt;::iterator&gt; equalLargest;

            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {

                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {

                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }

            <span class="keywordflow">else</span> {

                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }

            <span class="comment">// accumulate the changes in scaled EMP sums that will result</span>
            <span class="comment">// from this expansion</span>
            <span class="comment">//updateScaledEMPSumCOPERR(chosenLargest-&gt;getSplitChangeEMPCOPERR(n));</span>
            <span class="comment">//updateScaledEMPSumAIC(chosenLargest-&gt;getSplitChangeEMPAIC());</span>

            <span class="comment">// split the biggest one and divvie up its data</span>
        <span class="comment">//cout &lt;&lt; &quot;===============&quot; &lt;&lt; endl;</span>
        
        <span class="comment">//cout &lt;&lt; &quot;chosenLargest: &quot; &lt;&lt; chosenLargest-&gt;getNodeName() &lt;&lt; </span>
        <span class="comment">//&quot;\t&quot; &lt;&lt; chosenLargest-&gt;getBox() &lt;&lt; &quot;\t&quot;</span>
        <span class="comment">//&lt;&lt; chosenLargest-&gt;getHellingerDist1D() &lt;&lt; endl;</span>
          
        <span class="comment">//rvector diffMean = chosenLargest-&gt;getMean() - chosenLargest-&gt;getUniformMean();</span>
        <span class="comment">//cout &lt;&lt; &quot;mean differences: &quot; &lt;&lt; diffMean[1] &lt;&lt; endl;</span>

        <span class="comment">//RealVec unifCovar = chosenLargest-&gt;getUniformVarCovar();</span>
        <span class="comment">//RealVec Covar = chosenLargest-&gt;getVarCovar();</span>
        <span class="comment">//cout &lt;&lt; &quot;variance difference: &quot; &lt;&lt; Covar[0] - unifCovar[0] &lt;&lt; endl;</span>
        
        <a class="code" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a" title="Expand a leaf node to have two child nodes.">Expand</a>(chosenLargest);

        <span class="comment">/*</span>
<span class="comment">        string fileName = &quot;QueueHist&quot;;</span>
<span class="comment">        ostringstream stm;</span>
<span class="comment">        stm &lt;&lt; temp;</span>
<span class="comment">        fileName += stm.str();</span>
<span class="comment">        fileName += &quot;.txt&quot;;</span>
<span class="comment">        outputToTxtTabs(fileName);</span>
<span class="comment">        cout &lt;&lt; &quot;===============&quot; &lt;&lt; endl;</span>
<span class="comment">        */</span>
        temp++;
         
            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();
            
            <span class="comment">// only insert the children into the queue if they have more than or</span>
            <span class="comment">// equal to removeBox number of points. If true, then</span>
               <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>
            
            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;getCounter() &gt; removeBox) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new left child into the multiset</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;getCounter() &gt; removeBox) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new right child into the multiset</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                i++;
            }

            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough)
                std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
        
        
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      
  }
         
         
        <span class="keywordflow">if</span> (cancontinue &amp;&amp; (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)) {
            <span class="comment">// log the leaf levels line</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());

        }

        <span class="comment">// EMPSums will have been adjusted during the splitting process</span>
   }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory iin priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6a4b39b06259e03b84b5131299334416"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="a6a4b39b06259e03b84b5131299334416" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minChildPoints supplied, no minvolB, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01846">1846</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01846">prioritySplitWithTotalVar()</a>.</p>

<p>Referenced by <a class="el" href="FiniteMixtureStats_8cpp_source.shtml#l00041">main()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04760">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a>(compTest, he, logging, minChildPoints, 0.0, 
                    maxLeafNodes, StopVal, HistAtValley, simNum); }
</pre></div>
</div>
</div>
<a class="anchor" id="a4c7ccb75b629b131c7a448579386c6a9"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="a4c7ccb75b629b131c7a448579386c6a9" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Only minVolB supplied, no minChildPoints, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01854">1854</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01854">prioritySplitWithTotalVar()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01854">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a>(compTest, he, logging, 0, minVolB, 
              maxLeafNodes, StopVal, HistAtValley, simNum); }
</pre></div>
</div>
</div>
<a class="anchor" id="a435e13db001d1b919489507b81cb49ad"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="a435e13db001d1b919489507b81cb49ad" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Neither minVolB nor minChildPoints supplied, no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01862">1862</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01862">prioritySplitWithTotalVar()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01862">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a>(compTest, he, logging, 0, 0.0, 
                maxLeafNodes, StopVal, HistAtValley, simNum); }
</pre></div>
</div>
</div>
<a class="anchor" id="ae7e68baa3f16fafe3774df1f570aadcc"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="ae7e68baa3f16fafe3774df1f570aadcc" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the IAE between an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object and a <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>. </p>
<p>minVolB and minChildPoints supplied but no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04760">4760</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01846">prioritySplitWithTotalVar()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    gsl_rng * rgsl = NULL;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a>(compTest, he, logging,
                                    minChildPoints, minVolB, rgsl, maxLeafNodes, 
                                    StopVal, HistAtValley, simNum);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae80f3d62957c9c70a2b7eed4b1e11810"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="ae80f3d62957c9c70a2b7eed4b1e11810" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minChildPoints supplied, no minvolB. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01875">1875</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01875">prioritySplitWithTotalVar()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01875">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a>(compTest, he, logging, minChildPoints, 0.0, rgsl,
                    maxLeafNodes, StopVal, HistAtValley, simNum); }
</pre></div>
</div>
</div>
<a class="anchor" id="a508b13326647eaa46806ca7999d303f2"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="a508b13326647eaa46806ca7999d303f2" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Only minVolB supplied, no minChildPoints. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01884">1884</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01884">prioritySplitWithTotalVar()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01884">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a>(compTest, he, logging, 0, minVolB, rgsl, 
                maxLeafNodes, StopVal, HistAtValley, simNum); }
</pre></div>
</div>
</div>
<a class="anchor" id="a39888154b396a7eb5fd6be1ff200a414"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="a39888154b396a7eb5fd6be1ff200a414" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. Neither minVolB nor minChildPoints supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01893">1893</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01893">prioritySplitWithTotalVar()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01893">prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">prioritySplitWithTotalVar</a>(compTest, he, logging, 0, 0.0, rgsl, 
            maxLeafNodes, StopVal, HistAtValley, simNum); }
</pre></div>
</div>
</div>
<a class="anchor" id="acab027b9f4718b0ba077b142375a05cb"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::prioritySplitWithTotalVar" ref="acab027b9f4718b0ba077b142375a05cb" args="(const NodeCompObj &amp;compTest, const HistEvalObj &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, size_t maxLeafNodes, int StopVal, std::vector&lt; AdaptiveHistogram &gt; &amp;HistAtValley, int simNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6a4b39b06259e03b84b5131299334416">AdaptiveHistogram::prioritySplitWithTotalVar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>StopVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>HistAtValley</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>simNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">4828</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05762">checkStopCrit()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">subpavings::Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">getMinVol()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00404">outputLogStart()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{    
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> shouldStop = <span class="keyword">false</span>;
    <span class="keywordtype">int</span> flagStop = 0;
    vector&lt;double&gt; TotalVarDist;
    <span class="keywordtype">int</span> Prev = 1;
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> probValley;
    <span class="keywordtype">size_t</span> split = 0;
    
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }

    <span class="keywordflow">try</span> {
        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="keywordtype">size_t</span> n; <span class="comment">// for number of points in histogram</span>

        <span class="keywordtype">int</span> i = 0;
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }

        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0ef2d251d61753086a358bdd9bda057f" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
           volChecking = <span class="keyword">true</span>;
        }

        <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
        multiset&lt;SPSnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));

        n = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>(); <span class="comment">// number of points in histogram</span>

        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad847a4add7e72eac564daa44835dba5b" title="Opening line of a txt log file.">outputLogStart</a>(s);
            <span class="comment">// log the current state of the histogram</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
            i++;
        }

        <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
        <span class="comment">// there are enough points in the whole node</span>
                <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
        <span class="comment">// or the minChildCountIfSplit test passed</span>

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootPaving pointer into the set</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> sit;
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
                    pq.insert(*sit);
                }
            }
        }

        cancontinue = (!pq.empty());
      
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
       TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);

        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }

        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out</span>
        <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {
            
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* chosenLargest;
            
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSnode*, MyCompare&gt;::iterator&gt; equalLargest;

            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {

                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);

                real sum = 0.0;

                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {

                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {

                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }

            <span class="keywordflow">else</span> {

                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }

            <span class="comment">// accumulate the changes in scaled EMP sums that will result</span>
            <span class="comment">// from this expansion</span>
            <span class="comment">//updateScaledEMPSumCOPERR(chosenLargest-&gt;getSplitChangeEMPCOPERR(n));</span>
            <span class="comment">//updateScaledEMPSumAIC(chosenLargest-&gt;getSplitChangeEMPAIC());</span>

            <span class="comment">// split the biggest one and divide up its data</span>
           cout &lt;&lt; <span class="stringliteral">&quot;===============&quot;</span> &lt;&lt; endl;
           cout &lt;&lt; <span class="stringliteral">&quot;chosenLArgest: &quot;</span> &lt;&lt; chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &lt;&lt; endl;
           <a class="code" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a" title="Expand a leaf node to have two child nodes.">Expand</a>(chosenLargest);
           cout &lt;&lt; <span class="stringliteral">&quot;===============&quot;</span> &lt;&lt; endl;
           
            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new left child into the multiset</span>
                
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8a997f746bf62c847990542daf7c5a6a" title="Method to do checking for whether a node is splittable.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new right child into the multiset</span>
               
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
                <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
                i++;
            }


        <span class="comment">// get the total variation distance</span>
        <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
        <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> leavesIt;
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

        <span class="keywordtype">double</span> totalVarDist = 0;
        <span class="keywordtype">double</span> FUnif = 1.0/leaves.size()*1.0;
        <span class="keywordflow">for</span> (leavesIt = leaves.begin(); leavesIt &lt; leaves.end(); leavesIt++) {
          <span class="keywordtype">double</span> leafVol = (*leavesIt)-&gt;nodeVolume();
          <span class="comment">//get the total variation distance</span>
          <span class="comment">//calculate \mu_n - \mu</span>
               <span class="keywordtype">double</span> fhat = ((*leavesIt)-&gt;getCounter())/leafVol/n;
               <span class="keywordtype">double</span> diffMu = fabs(fhat*leafVol - FUnif);
               <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; totalVarDist &lt;&lt; &quot;\t current: &quot; &lt;&lt; diffMu &lt;&lt; endl;</span>
          totalVarDist += diffMu;
          <span class="comment">//totalVarDist = (diffMu &gt; totalVarDist) ? diffMu : totalVarDist; </span>
        }
        split++;
        TotalVarDist.push_back(totalVarDist);
        <span class="comment">//cout &lt;&lt; &quot;---------Split &quot; &lt;&lt; split &lt;&lt; &quot;: &quot; &lt;&lt; totalVarDist &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;</span>

        <span class="keywordflow">if</span> (split == 1) { probValley = *<span class="keyword">this</span>; } <span class="comment">// keep the second state</span>

        <span class="comment">// start the checks after 1 split</span>
        <span class="keywordflow">if</span> ( split &gt; 1 ) {
          <span class="comment">// use the total var distance as stopping criteria</span>
          <span class="keywordtype">size_t</span> vecSize = TotalVarDist.size();
          shouldStop = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a438e2252f954f0556fa2bd7c2e105dbe">checkStopCrit</a>(TotalVarDist[vecSize-1], TotalVarDist[vecSize-2], Prev);
          <span class="keywordflow">if</span> (shouldStop) { 
            flagStop++; 
            HistAtValley.push_back(probValley); <span class="comment">//keep this histogram</span>
          }
          <span class="keywordflow">if</span> (flagStop == StopVal) { 
            cout &lt;&lt; <span class="stringliteral">&quot;Stopping criteria met. There are &quot;</span> &lt;&lt; StopVal &lt;&lt; <span class="stringliteral">&quot; valleys.&quot;</span> &lt;&lt; endl;
            <span class="keywordflow">break</span>; 
          }
          <span class="keywordflow">if</span> (Prev == 1) <span class="comment">// keep this histogram if prev = 1 </span>
            { probValley = *<span class="keyword">this</span>; }
        }
        
            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough)
                std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;

        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }  
      } <span class="comment">// end of while loop</span>

      <span class="comment">//output the total variation distance for plotting purposes</span>
      ofstream oss;         <span class="comment">// ofstream object</span>
      oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
      oss.precision(5);
      std::ostringstream stm;
      stm &lt;&lt; simNum;
      <span class="keywordtype">string</span> FileName = <span class="stringliteral">&quot;PQTotalVariationOutput&quot;</span>;
      FileName += stm.str();
      FileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      oss.open(FileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j &lt; TotalVarDist.size(); j++) {
        oss &lt;&lt; TotalVarDist[j] &lt;&lt; endl;
      }
      oss &lt;&lt; flush;
      oss.close();
      cout &lt;&lt; <span class="stringliteral">&quot;Total variation distance output to &quot;</span> &lt;&lt; FileName &lt;&lt; endl;

      <span class="keywordflow">if</span> (cancontinue &amp;&amp; (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)) {
            <span class="comment">// log the leaf levels line</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aca69edc461799f9d867d7eea6cb76f8e">getLeafLevelsString</a>());
      }

        <span class="comment">// EMPSums will have been adjusted during the splitting process</span>
   }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory iin priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae7f23176e9afea24c51c6a37cbcc4b0a"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::proposeChangeMCMCState" ref="ae7f23176e9afea24c51c6a37cbcc4b0a" args="(const MCMCProposal &amp;proposal, SPSnodeList &amp;nodes, size_t numLeaves, size_t numCherries, gsl_rng *rgsl, bool &amp;haveNode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2">SPSnodeListItr</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae7f23176e9afea24c51c6a37cbcc4b0a">AdaptiveHistogram::proposeChangeMCMCState</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a> &amp;&#160;</td>
          <td class="paramname"><em>proposal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a> &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numCherries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>haveNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the node to target for change in MCMC on <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> trees. </p>
<p>This method changes the value of the bool haveNode and returns an iterator into a container of <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> pointers. If, after the method has completed, haveNode is positive, then the iterator points to a pointer to a node proposed for change (split or merge) under MCMC on the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree.</p>
<p>Proposals are made by selecting a splittable leaf or cherry at random. If a cherry is chosen the proposed change in state is to merge the two leaf children of that cherry; if a splittable leaf is chosen the proposal is to split (bisect) the leaf.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>haveNode is false. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">proposal</td><td>is a reference to a proposal distribution object. </td></tr>
    <tr><td class="paramname">nodes</td><td>is a reference to a container of pointers to the splittable leaf and cherry nodes of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>, which will be updated if the method results in change in tree state. </td></tr>
    <tr><td class="paramname">numLeaves</td><td>is the number of splittable leaves in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree. in tree state. </td></tr>
    <tr><td class="paramname">numCherries</td><td>is the number of cherries in the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree. in tree state. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a uniform random number generator. </td></tr>
    <tr><td class="paramname">haveNode</td><td>is reference to a boolean which can be changes in the function, which indicates whether a proposal node is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an iterator to a container of pointers to SPSnodes. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>haveNode will have been changed to true if a node has been found for the proposal using the probabilities under proposal. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00538">538</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1MCMCProposal.shtml#a9a41619f829a7fd3c080f3f9c0bed705">subpavings::MCMCProposal::fillNodeProposalProbs()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">changeMCMCState()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//cout &lt;&lt; &quot;---&gt; calling propose change&quot; &lt;&lt; endl;</span>
    
    <a class="code" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2" title="Define type SPSnodeListItr as an iterator over SPSnodeList.">SPSnodeListItr</a> it;

    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> probs;
    <a class="code" href="namespacesubpavings.shtml#aca205cec2a67bee00aee408d0cc6f3a1" title="Define type RealVecItr as iterator over RealVec.">RealVecItr</a> pit;

    <span class="comment">// fillNodeProposalProbs returns the sum of the probabilities and</span>
    <span class="comment">// also fills in probs</span>
    <span class="comment">// the sum of the probabilities may be &lt; 1 if for instance we fix the</span>
    <span class="comment">// probability of a split or merge in advance</span>
    real psum = proposal.<a class="code" href="classsubpavings_1_1MCMCProposal.shtml#a9a41619f829a7fd3c080f3f9c0bed705">fillNodeProposalProbs</a>(numLeaves, numCherries, probs);

    <span class="comment">// check we got back the right number of probabilites</span>
    <span class="keywordflow">if</span> (!nodes.empty() &amp;&amp; nodes.size() == probs.size()) {

        <span class="comment">// pick a node at random  by drawing a random number in [0,1)</span>
        <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
       
        <span class="keywordflow">if</span> ((numLeaves &gt; 0) &amp;&amp; (numCherries &gt; 0)) {
            
          <span class="comment">//  cout &lt;&lt; &quot;----&gt; cherry and leaf &quot; &lt;&lt; endl;</span>
            
            pit = probs.begin();
            it = nodes.begin();
            real sum = 0.0;

            <span class="keywordflow">for</span> (pit = probs.begin(); pit &lt; probs.end(); pit++) {

                    sum += *pit;
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        haveNode = <span class="keyword">true</span>;
                        <span class="keywordflow">break</span>;
                    }
                    it++; <span class="comment">// using this to point to nodes relies on having got</span>
                            <span class="comment">// the right number of probabilities to match nodes</span>
             }
        }
        <span class="comment">// if we only have leaves (which should mean one leaf, no cherries)</span>
        <span class="comment">// then we&#39;ll only pick a leaf if rand &lt; psum</span>
        <span class="keywordflow">if</span> ((numLeaves &gt; 0) &amp;&amp; (numCherries == 0) &amp;&amp; (rand &lt; psum)) {
            
            
            pit = probs.begin();
            it = nodes.begin();
            real sum = 0.0;

            <span class="keywordflow">for</span> (pit = probs.begin(); pit &lt; probs.end(); pit++) {
                    
                    sum += *pit;
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        haveNode = <span class="keyword">true</span>;
                       <span class="keywordflow">break</span>;
                    }
                    it++; <span class="comment">// using this to point to nodes relies on having got</span>
                            <span class="comment">// the right number of probabilities to match nodes</span>
            }
        }
        <span class="comment">// if we only have cherries</span>
        <span class="comment">// then we&#39;ll only pick a cherry if rand &gt;= 1-psum</span>
        <span class="keywordflow">if</span> ((numLeaves == 0) &amp;&amp; (numCherries &gt; 0) &amp;&amp; (rand &gt;= 1.0-psum)) {
            
            pit = probs.begin();
            it = nodes.begin();
            real sum = 1.0-psum; <span class="comment">// note that sum starts at 1-psum</span>

            <span class="keywordflow">for</span> (pit = probs.begin(); pit &lt; probs.end(); pit++) {
         
                   
                    sum += *pit;
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        haveNode = <span class="keyword">true</span>;
                        <span class="keywordflow">break</span>;
                    }
                    it++; <span class="comment">// using this to point to nodes relies on having got</span>
                            <span class="comment">// the right number of probabilities to match nodes</span>
                   
            }
        }
        <span class="comment">// it iterator should now point to the node we want to target</span>
        <span class="comment">//else we&#39;ve not taken a node</span>

    }

    <span class="keywordflow">return</span> it;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af41faeb2742df1aaa5108f17dee54d71"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::publicLogMCMCSample" ref="af41faeb2742df1aaa5108f17dee54d71" args="(std::string s, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#af41faeb2742df1aaa5108f17dee54d71">AdaptiveHistogram::publicLogMCMCSample</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03354">3354</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a8e1ee4de108b97c04c38ccb16c392e5f" title="Append current state of histogram to a txt log file.">outputLog</a>(s, i);
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a602b8b4081d3cae20308aa6644a83fa9" title="Add AIC EMP score to log file.">outputLogEMPAIC</a>(s); <span class="comment">// add AIC scores</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0163eb023d0db24e0d91864a38acd562"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::publicOutputMCMCStateSample" ref="a0163eb023d0db24e0d91864a38acd562" args="(int ci, int i, bool confirm=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a0163eb023d0db24e0d91864a38acd562">AdaptiveHistogram::publicOutputMCMCStateSample</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>confirm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03341">3341</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">outputToTxtTabs()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// create a name for the file to output</span>
    std::ostringstream stm;
    stm &lt;&lt; <span class="stringliteral">&quot;MCMC_&quot;</span> &lt;&lt; ci &lt;&lt; <span class="stringliteral">&quot;_Sample&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;.txt&quot;</span>;

    <span class="keywordtype">string</span> sampleFileName = stm.str();

    <span class="comment">// To realize a file output</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a49a8ff01e1398420cd45642d5b1d3106" title="Output the subpaving managed by this to a txt file.">outputToTxtTabs</a>(sampleFileName, confirm);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab8a546d8d85be0ffac955f7886d5c7aa"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::recalcScaledEMPSumAIC" ref="ab8a546d8d85be0ffac955f7886d5c7aa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ab8a546d8d85be0ffac955f7886d5c7aa">AdaptiveHistogram::recalcScaledEMPSumAIC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate the unscaled EMP part of AIC score. </p>
<p>Uses whole histogram. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">358</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02543">subpavings::SPSnode::getEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01079">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">mergeUp()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// use the scaled EMP Sum from the root node&#39;s getEMPSumCOPERR()</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a26329c8ddf55f351a673fe258e5abd15" title="Get the unscaled EMP sum under AIC for tree rooted at this.">getEMPSumAIC</a>(
                        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6456652ee831cee0ec4184440cd84ec9"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::recalcScaledEMPSumCOPERR" ref="a6456652ee831cee0ec4184440cd84ec9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6456652ee831cee0ec4184440cd84ec9">AdaptiveHistogram::recalcScaledEMPSumCOPERR</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate the scaled EMP part of COPERR score. </p>
<p>Uses whole histogram </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">350</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02519">subpavings::SPSnode::getEMPSumCOPERR()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01079">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">mergeUp()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// use the scaled EMP Sum from the root node&#39;s getEMPSumCOPERR()</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ad8b17faf69caa46fcfa021b61d09e278" title="Get scaled EMP sum under COPERR for tree rooted at this.">getEMPSumCOPERR</a>(
                        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1cb13fa570de75efab3b9c4b862d200e"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::reshapeToUnion" ref="a1cb13fa570de75efab3b9c4b862d200e" args="(const PiecewiseConstantFunction &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1cb13fa570de75efab3b9c4b862d200e">AdaptiveHistogram::reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml">PiecewiseConstantFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change this so that the subpaving it manages is the union of this's subpaving and the subpaving of that of a <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a>. </p>
<p>Throws a NullSubpavings_Error if the subpaving that this manages is a NULL pointer or if the subpaving managed by <em>other</em> is a NULL pointer.</p>
<p>Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if the subpaving of this has no box or if the subpaving of <em>other</em> has no box.</p>
<p>Throws an <a class="el" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a> if the subpaving boxes of this and <em>other</em> are not identical.</p>
<p>There will be no change in this if the subpaving of  is everywhere less split than the subpaving of this.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is the PiecewiseConstantFunction to make the union against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Both this and <em>other</em> have subpavings with boxes to manage. </dd>
<dd>
The boxes of the subpavings of this and <em>other</em> are the same. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the subpaving managed by this has the shape that is the union of its shape before the operation and the shape of the subpaving managed by <em>other</em>. <em>other</em> is unchanged. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03611">3611</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad0419b40b47ffa5bb70af1f9cfe86062">subpavings::PiecewiseConstantFunction::getCopySubPaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#afecdfb659b961eab7f8d18160bea7296">subpavings::PiecewiseConstantFunction::hasSubPaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01360">hasSubPaving()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02366">subpavings::SPSnode::reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( !<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaf5eac63bd232e3e76f20a27587c8784" title="Get whether this has a subpaving to manage.">hasSubPaving</a>() || !other.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#afecdfb659b961eab7f8d18160bea7296" title="Get whether this has a subpaving to manage.">hasSubPaving</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NullSubpavingPointer__Error.shtml">NullSubpavingPointer_Error</a>(
        <span class="stringliteral">&quot;AdaptiveHistogram::reshapeToUnion(const PiecewiseConstantFunction&amp;)&quot;</span>);
  }
  
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ad128b1715d294a65c905579ab43890d2" title="Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of an...">reshapeToUnion</a>(other.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad0419b40b47ffa5bb70af1f9cfe86062" title="Get a copy of the subpaving managed by this.">getCopySubPaving</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e30e2969e3ad675b8659470200219d4"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::reshapeToUnion" ref="a9e30e2969e3ad675b8659470200219d4" args="(const PiecewiseConstantFunction &amp;other, size_t minChildPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1cb13fa570de75efab3b9c4b862d200e">AdaptiveHistogram::reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml">PiecewiseConstantFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change this so that the subpaving it manages is as close as possible to the union of this's subpaving and the subpaving of that of a <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a>. </p>
<p>If <em>other</em> has a subpaving that is more split than the subpaving managed by this at any node, this will not exactly follow the shape of <em>other</em> if the resulting nodes would not splittable according to SPSnode::isSplittableNode(size_t minChildPoints). If any node cannot be split to follow the shape of <em>other</em> due to <em>minChildPoints</em>, a message will be printed to std::cerr.</p>
<p>Throws a NullSubpavings_Error if the subpaving that this manages is a NULL pointer or if the subpaving managed by <em>other</em> is a NULL pointer.</p>
<p>Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if the subpaving of this has no box or if the subpaving of <em>other</em> has no box.</p>
<p>Throws an <a class="el" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a> if the subpaving boxes of this and <em>other</em> are not identical.</p>
<p>There will be no change in this if the subpaving of  is everywhere less split than the subpaving of this.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is the PiecewiseConstantFunction to make the union against. </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minumum child points to use to check if this can be split in order to follow <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Both this and <em>other</em> have subpavings with boxes to manage. </dd>
<dd>
The boxes of the subpavings of this and <em>other</em> are the same. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the subpaving managed by this has the shape that is as close as possible to the union of its shape before the operation and the shape of the subpaving managed by <em>other</em>, given <em>minChildPoints</em>. <em>other</em> is unchanged. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03622">3622</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad0419b40b47ffa5bb70af1f9cfe86062">subpavings::PiecewiseConstantFunction::getCopySubPaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#afecdfb659b961eab7f8d18160bea7296">subpavings::PiecewiseConstantFunction::hasSubPaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01360">hasSubPaving()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02366">subpavings::SPSnode::reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( !<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aaf5eac63bd232e3e76f20a27587c8784" title="Get whether this has a subpaving to manage.">hasSubPaving</a>() || !other.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#afecdfb659b961eab7f8d18160bea7296" title="Get whether this has a subpaving to manage.">hasSubPaving</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NullSubpavingPointer__Error.shtml">NullSubpavingPointer_Error</a>(
    <span class="stringliteral">&quot;AdaptiveHistogram::reshapeToUnion(const PiecewiseConstantFunction&amp;, size_t)&quot;</span>);
  }
  
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ad128b1715d294a65c905579ab43890d2" title="Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of an...">reshapeToUnion</a>(other.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad0419b40b47ffa5bb70af1f9cfe86062" title="Get a copy of the subpaving managed by this.">getCopySubPaving</a>(), minChildPoints);
}
</pre></div>
</div>
</div>
<a class="anchor" id="afac8c0cb4ed44f27e7a3adf1855af676"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::splitToShape" ref="afac8c0cb4ed44f27e7a3adf1855af676" args="(std::string instruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afac8c0cb4ed44f27e7a3adf1855af676">AdaptiveHistogram::splitToShape</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>instruction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a histogram to a specified shape. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instruction</td><td>specifies the required shape, eg "3, 3. 2, 1" </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02971">2971</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l01551">subpavings::SPnode::splitRootToShape()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="MCMCGR_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, and <a class="el" href="GeneralScheffe_8cpp_source.shtml#l00042">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;

    <span class="comment">// checks:  is there a root paving, is the string properly formed?</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for splitToShape&quot;</span>);
    }

   <span class="keywordflow">if</span> (instruction.length() == 0) {
      <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No instruction&quot;</span>);
    }

    std::string legal(<span class="stringliteral">&quot;, 0123456789&quot;</span>);
    <span class="keywordflow">if</span> (instruction.find_first_not_of(legal) != std::string::npos) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Illegal character in instruction&quot;</span>);
    }

    <span class="keywordflow">try</span> { <span class="comment">// all seems to be okay, we can start spliting the root paving</span>
        <span class="comment">// specify what to look for as numbers or decimal point or + or -</span>

       success = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a62e9df1a7c96af8f0796a6ea211b38ea" title="Split a root paving to a specified shape.">splitRootToShape</a>(instruction);

        <span class="keywordflow">if</span> (success) {
            <span class="comment">// update the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>()
                + <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();
        }
        <span class="keywordflow">else</span> {
            std::cerr &lt;&lt; std::endl;
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Your instruction does not describe a proper tree.&quot;</span>;
            std::cerr &lt;&lt; <span class="stringliteral">&quot;  Please check your instruction and try again.&quot;</span>
            &lt;&lt; std::endl;
       }
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in splitToShape.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in splitToShape.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in splitToShape.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in splitToShape.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a809928eec642c22761a2f9b3b8061d47"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::swap" ref="a809928eec642c22761a2f9b3b8061d47" args="(AdaptiveHistogram &amp;adh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a809928eec642c22761a2f9b3b8061d47">AdaptiveHistogram::swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>adh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the contents of this and another histogram. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>After the swap <em>adh</em> will manage the subpaving that this used to manage, and this will manage the subpaving that <em>adh</em> used to managed, and the values of the other data members of this and <em>adh</em> will also be swapped. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05790">5790</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">creationString</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00104">dataCollection</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00109">holdAllStats</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">rootPaving</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//std::swap(label, adh.label);</span>
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a809928eec642c22761a2f9b3b8061d47" title="Swap the contents of this and another histogram.">std::swap</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>, adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214" title="A container for all sample data passed to this.">dataCollection</a>); <span class="comment">// use stl specialisation of swap</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a809928eec642c22761a2f9b3b8061d47" title="Swap the contents of this and another histogram.">std::swap</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>, adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>);
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a809928eec642c22761a2f9b3b8061d47" title="Swap the contents of this and another histogram.">std::swap</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a>, adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59" title="A string showing the order of creation of the rootPaving.">creationString</a>);
    
  <span class="comment">// cxsc don&#39;t seem to have a swap for dot precisions</span>
    dotprecision tempCOPERR(adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>);
  adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a>;
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a> = tempCOPERR;
  
  dotprecision tempAIC(adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>);
  adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a>;
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a> = tempAIC;
  
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a809928eec642c22761a2f9b3b8061d47" title="Swap the contents of this and another histogram.">std::swap</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>, adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a" title="Pointer to the root node of the subpaving tree.">rootPaving</a>); <span class="comment">// just swap the pointers</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a79fe01c35fba2bbdb1df5e8eb1d3a78b"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::updateScaledEMPSumAIC" ref="a79fe01c35fba2bbdb1df5e8eb1d3a78b" args="(dotprecision change) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a79fe01c35fba2bbdb1df5e8eb1d3a78b">AdaptiveHistogram::updateScaledEMPSumAIC</a> </td>
          <td>(</td>
          <td class="paramtype">dotprecision&#160;</td>
          <td class="paramname"><em>change</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the the scaled EMP part AIC score given change. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00372">372</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">scaledEMPSumAIC</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89" title="A value for the unscaled EMP part of AIC score.">scaledEMPSumAIC</a> + change;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a71122bfe1d3dfad1f2b55585326334ac"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::updateScaledEMPSumCOPERR" ref="a71122bfe1d3dfad1f2b55585326334ac" args="(dotprecision change) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a71122bfe1d3dfad1f2b55585326334ac">AdaptiveHistogram::updateScaledEMPSumCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">dotprecision&#160;</td>
          <td class="paramname"><em>change</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the scaled EMP part COPERR score given change. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00366">366</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">scaledEMPSumCOPERR</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96" title="A value for the unscaled EMP part of COPERR score.">scaledEMPSumCOPERR</a> + change;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a1211a42d1f428d73db9ba3c035239c59"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::creationString" ref="a1211a42d1f428d73db9ba3c035239c59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a1211a42d1f428d73db9ba3c035239c59">subpavings::AdaptiveHistogram::creationString</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A string showing the order of creation of the rootPaving. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00113">113</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00100">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">changeStateForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">mergeUp()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02971">splitToShape()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05790">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="afb02d0a6fe2258620130b97b7901e214"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::dataCollection" ref="afb02d0a6fe2258620130b97b7901e214" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">BigDataCollection</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#afb02d0a6fe2258620130b97b7901e214">subpavings::AdaptiveHistogram::dataCollection</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container for all sample data passed to this. </p>
<p>The sample that has come in thus far. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00104">104</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01079">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01166">operator+()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05790">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f9319019a75ea477804d02762602d17"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::holdAllStats" ref="a3f9319019a75ea477804d02762602d17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a3f9319019a75ea477804d02762602d17">subpavings::AdaptiveHistogram::holdAllStats</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Controls whether all available statistics are maintained in the rootPaving. If set to false (default) only counts are maintained. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00109">109</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01353">getHoldAllStats()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01227">getRootPavingMean()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01235">getRootPavingVarCovar()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05790">swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a73e006381e43e152b7dbb63211a3ac09"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::padding" ref="a73e006381e43e152b7dbb63211a3ac09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const real <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a73e006381e43e152b7dbb63211a3ac09">AdaptiveHistogram::padding</a> = 0.000005<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>a constant for padding a box if it is tailor-made for data. </p>
<p>The padding if the size of the root box is obtained from the min and max of the data that is fully fed in. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00084">84</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00213">makeBox()</a>.</p>

</div>
</div>
<a class="anchor" id="a5afac4246153fef0b383f6eb2e9d23a6"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::rootBox" ref="a5afac4246153fef0b383f6eb2e9d23a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a5afac4246153fef0b383f6eb2e9d23a6">subpavings::AdaptiveHistogram::rootBox</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The root box used to form the subpaving tree. </p>
<p>We may not need this, at present it gets passed to the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> constructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00098">98</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00100">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00119">completeDataInsertionFromVec()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a88a104768020c02deb2a7df9e2b4cb3a"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::rootPaving" ref="a88a104768020c02deb2a7df9e2b4cb3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a>* <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#a88a104768020c02deb2a7df9e2b4cb3a">subpavings::AdaptiveHistogram::rootPaving</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to the root node of the subpaving tree. </p>
<p>An <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> is a binary tree representation of a subpaving, designed for processing statistical data. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00091">91</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00100">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">changeStateForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04597">get2DIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03895">getFinMixIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03516">getLeafCounts()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03502">getLeafLevels()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01376">getLeafLevelsString()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">getMinVol()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">getRootLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01227">getRootPavingMean()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01235">getRootPavingVarCovar()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01251">getRootSumLeafCountOverVol()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01311">getScoreAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01282">getScoreCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">getSubPaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03854">getUnifIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">mergeUp()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01166">operator+()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03528">outputGraphDot()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03595">outputRootToTxt()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">outputToTxtTabs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03571">outputToTxtTabsWithEMPs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">prioritySplitWithTotalVar()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">recalcScaledEMPSumCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02971">splitToShape()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05790">swap()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01209">~AdaptiveHistogram()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5748390a25f398475bb60575f0e9a89"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::scaledEMPSumAIC" ref="ad5748390a25f398475bb60575f0e9a89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#ad5748390a25f398475bb60575f0e9a89">subpavings::AdaptiveHistogram::scaledEMPSumAIC</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A value for the unscaled EMP part of AIC score. </p>
<p>pi for a histogram is c * e(-1/t * energy) energy is EMP + PEN</p>
<p>Under AIC, EMP is</p>
<ul>
<li>1 x sum over leaves of (counts in leaf x -ln(count in leaf / (n x vol of leaf))) where n is the total number of data points in the histogram</li>
</ul>
<p>scaledEMPSumAIC will default to zero until set by some method of the object.</p>
<p>Dotprecision accumulator used to mitigate rounding errors in calculations. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00148">148</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01079">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01272">getEMPScoreAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01311">getScoreAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00518">outputLogEMPAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05790">swap()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00372">updateScaledEMPSumAIC()</a>.</p>

</div>
</div>
<a class="anchor" id="acd3c0bacd5148b82188cc129b3a59e96"></a><!-- doxytag: member="subpavings::AdaptiveHistogram::scaledEMPSumCOPERR" ref="acd3c0bacd5148b82188cc129b3a59e96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml#acd3c0bacd5148b82188cc129b3a59e96">subpavings::AdaptiveHistogram::scaledEMPSumCOPERR</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A value for the unscaled EMP part of COPERR score. </p>
<p>pi for a histogram is c * e(-1/t * energy) energy is EMP + PEN</p>
<p>Under COPERR scoring, EMP is -1/n^2 x sum over leaves of (counts in leaf squared / volume of leaf) where n is the total number of data points in the histogram</p>
<p>Scaling means multiplying this unscaled Emp sum term by 1/n^2</p>
<p>scaledEMPSumCOPERR will default to zero until set by some method of the object.</p>
<p>Dotprecision accumulator used to mitigate rounding errors in calculations. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00131">131</a> of file <a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01079">AdaptiveHistogram()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01264">getEMPScoreCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01282">getScoreCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01119">operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00500">outputLogEMPCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">recalcScaledEMPSumCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05790">swap()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00366">updateScaledEMPSumCOPERR()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a></li>
<li><a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:31 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
