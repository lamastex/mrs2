<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: Subpavings as a basis for statistical set processing</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('newsubpavings.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Subpavings as a basis for statistical set processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="newsubpavings.shtml#newsec_subpavingsKd">Subpavings and kd-trees</a></li>
<li><a class="el" href="newsubpavings.shtml#newsec_reimplementation">A revised class for subpavings</a></li>
<li><a class="el" href="newsubpavings.shtml#newsec_equivalence">Equivalence to the AIASPnode class</a></li>
<li><a class="el" href="newsubpavings.shtml#newsec_extension">Extending the SPnode class</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="newsec_subpavingsKd"></a>
Subpavings and kd-trees</h2>
<p>Regular subpavings represent a special case of the general kd tree structure: a space partitioning data structure for organising points in k-dimensional space. We aim to combine interval analysis and inclusion functions with kd trees and manipulation of tree structures in order to use subpavings for statistical set processing.</p>
<hr/>
<h2><a class="anchor" id="newsec_reimplementation"></a>
A revised class for subpavings</h2>
<p>We start with a re-implemention in C++ of a subpaving-as-a-binary-tree object based on [AIA2001]. Our new class is called <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode </a>, and a pointer to an SPnode is aliased as <a class="el" href="namespacesubpavings.shtml#a7e50e3fe54ef41646fbb6155160805cc">SubPaving </a>. Again, we use C-XSC as the interval analysis library. We alter the structure of the class and functions to give us a better basis for using the class as a base class for derived classes specifically designed for various forms of statistical set processing. Our new tree has links from child to parent as well as from parent to child (ie, each child knows who its parent is); this may be used in 'shrink' the tree, absorbing children back up into the parent.</p>
<p>Other new members of the SPnode class include <a class="el" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610">nodeName </a>. The nodeName is a used as a convenient way to assist human interpretation of a tree of nodes. A <a class="anchor" id="SPnodename"></a>nodeName is based on the parent node's name suffixed with 'L' if the node is the left child of that parent and by 'R' if the node is the right child of that parent. A root node is usually named 'X'.</p>
<p>The SPnode class declarations and inline definitions are in the header file <a class="el" href="spnode_8hpp.shtml" title="SPnode (SubPaving) and associated non-member functions declarations.">spnode.hpp</a>. Other definitions are in the file <a class="el" href="spnode_8cpp.shtml" title="SPnode (SubPaving) and associated non-member function definitions.">spnode.cpp</a>. Type definitions relevant to SPnodes are in the file <a class="el" href="sptypes_8hpp.shtml" title="Includes and general typedefs for subpavings.">sptypes.hpp</a>. General tool functions useful for spnodes are in <a class="el" href="sptools_8hpp.shtml" title="General tools for subpavings.">sptools.hpp</a> and <a class="el" href="sptools_8cpp.shtml" title="Implementation of sptools functions.">sptools.cpp</a>. Algorithms used for set computation are declared in <a class="el" href="spalgorithms_8hpp.shtml" title="SPnode (SubPaving) algorithm function declarations.">spalgorithms.hpp</a> and defined in <a class="el" href="spalgorithms_8hpp.shtml" title="SPnode (SubPaving) algorithm function declarations.">spalgorithms.hpp</a>. Template functions requiring node concepts are in <a class="el" href="sptemplates_8hpp.shtml" title="Templatised functions using node type concepts.">sptemplates.hpp</a>.</p>
<hr/>
<h2><a class="anchor" id="newsec_equivalence"></a>
Equivalence to the AIASPnode class</h2>
<p>In order to demonstrate that this implementation is equivalent to that of AIA2001, we reimplement the set inversion and image evaluation functions and using our new SPnode class. However, set computation is not the primary purpose of this class.</p>
<p>For examples using the new SPnode class for set computation and demonstrating the equivalence of the results to those in <a class="el" href="AIASubPavings.shtml#AIAsec_examples">Examples from Applied Interval Analysis using AIASPnodes</a> see <a class="el" href="newsubpavings.shtml#newexamples">Example of set computation with SPnodes</a></p>
<h3><a class="anchor" id="newexamples"></a>
Example of set computation with SPnodes</h3>
<p>SPnodes are re-implemention in C++ of a subpaving-as-a-binary-tree object based on [AIA2001]. SPnodes are intended for more than set computation but here we demonstrates that, for set computation, SPnodes behave exactly as AIASPnodes do. We also highlights some of the minor changes that we have made the way that this class is coded and used.</p>
<h4><a class="anchor" id="newexamsec_3_4"></a>
Example 3.4</h4>
<p>In this example show how example 3.4 from AIA2001, pp. 61-63, can be performed using the SPnode class (for the same example using AIASPnodes, code closely based on AIA2001, see <a class="el" href="AIASubPavings.shtml#AIAexample3_4">Example 3.4 using AIAPSnodes</a>). This example uses our implementations of both Sivia (see <a class="el" href="AIASubPavings.shtml#AIAsec_SIVIA">Set inversion using interval analysis</a>) for set inversion and ImageSp (see <a class="el" href="AIASubPavings.shtml#AIAsec_imageSp">Image evaluation</a>) for image evaluation. The functions we use here are Sivia(PIBT BoolTest, const SPnode * const toInvert, SPnode * const search, const double eps) and <a class="el" href="classsubpavings_1_1SPnode.shtml#a5e79ff65a692b09c98ff53264ddfba9f" title="Creation of image subpaving with Interval Analysis.">ImageSp(PIVF f, SPnode* spn, double eps)</a>.</p>
<p>Our implementation of this example is in the file NewExm_3_4.cpp, which has header file NewExm_3_4.hpp. The header file is</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>We include headers and libraries we want to be able to use: &lt;time.h&gt; for a clock, &lt;fstream&gt; for file output, and suppavings.hpp for our class declarations. We also specify the namespaces we want to be able to use without qualification. Note that subpavings is now a namespace. If we did not specify that we are using this namespace we would have to qualify all references to entities declared within it, for example <a class="el" href="namespacesubpavings.shtml#a7e50e3fe54ef41646fbb6155160805cc" title="SubPaving is an alias for a pointer to an SPnode.">subpavings::SubPaving</a> (SubPaving is an alias for a pointer to an SPnode).</p>
<p>In NewExm_3_4.cpp we include the header file</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Then we define some functions used in our main program.</p>
<p>The first is a boolean interval test, <a class="anchor" id="NewIBT_ex3_4"></a>IBT_ex3_4.</p>
<p>The interval boolean test is the key to set inversion with interval analysis. Recall that set inversion is the computation of a reciprocal image X = <b>f</b><sup>-1</sup>(Y) where Y is regular subpaving of R<sup>m</sup> (see <a class="el" href="AIASubPavings.shtml#AIAsec_SIVIA">Set inversion using interval analysis</a>). Y is the subpaving we want to invert. The interval boolean test takes a box in 'x-space' and tests whether the image of the box in 'y-space' ie the image under the inclusion function [<b>f</b>], is in the subpaving Y. The interval boolean test can return one of the special interval boolean types BI_TRUE (the image of the box is inside Y), BI_FALSE (the image of the box is outside Y), or BI_INDET (indeterminate: the image of the box [<b>f</b>]([<b>x</b>] is partly in and partly out of the subpaving Y, ie overlaps the boundary of Y).</p>
<p>This test <a class="anchor" id="NewIBT_ex3_4"></a>IBT_ex3_4 tests the image of a box x for inclusion in a subpaving represented by the SPnode pointer spn. Values for x and spn are given by the caller as the function arguments. <b>f</b> is specified in the test as <b>f</b>: R<sup>2</sup> -&gt; R such that <b>f</b>(x<sub>1</sub>, x<sub>2</sub>) = x<sub>1</sub><sup>4</sup> - x<sub>1</sub><sup>2</sup> + 4x<sub>2</sub><sup>2</sup>.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<dl class="note"><dt><b>Note:</b></dt><dd>Interval boolean tests in the subpavings namespace take a pointer to subpaving we want to invert as a parameter. This avoids the use of global subpaving variables in these tests as in <a class="el" href="AIASubPavings.shtml#AIAglobal">example 3.4 with AIASPnodes</a> and makes the functions somewhat clearer to interpret.</dd></dl>
<p>Then we have another boolean interval test, <a class="anchor" id="NewIBTFinverse_ex3_4"></a>IBTFinverse_ex3_4. Again this specifies a function <b>f</b>, this time</p>
<p><b>f</b>: R<sup>2</sup> -&gt; R<sup>2</sup>, f<sub>1</sub>(x<sub>1</sub>, x<sub>2</sub>) = (x<sub>1</sub> - 1)<sup>2</sup> -1 + x<sub>2</sub>, f<sub>2</sub>(x<sub>1</sub>, x<sub>2</sub>) = -x<sub>1</sub><sup>2</sup> + (x<sub>2</sub> - 1)<sup>2</sup>. Values for x, the box whose image we test, and spn, a pointer to the subpaving to invert, are given by the caller as the function arguments.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The next function is an interval vector function, <a class="anchor" id="NewIVF_ex3_4"></a>IVF_ex3_4. An interval vector function returns the interval vector image of an interval vector x under <b>f</b> for <b>f</b> as specified in the function and x supplied as the function argument. In this case <b>f</b> is exactly the same as in the boolean interval test <a class="el" href="newsubpavings.shtml#NewIBTFinverse_ex3_4">IBTFinverse_ex3_4</a> above.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Then we start the main program, declare some variables, and set up an initial search box [-3.0 3.0]<sup>2</sup>. This is used to initialise a newed SPnode in dynamic memory, with A as a SubPaving or pointer to a SPnode. Creating the node object in dynamic memory allows us to use pointers to it outside the scope of the function which created the object</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>We then set up the subpaving we want to invert (again, in dynamic memory).</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>And then prepare to use SIVIA to do the set inversion. We make some standard output to say what we are doing and ask the user to enter a precision.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now we use the SIVIA algorithm (see <a class="el" href="AIASubPavings.shtml#AIAsec_SIVIA">Set inversion using interval analysis</a>) to find a 'subpaving characterisation' Sc5 of the set we want with Sivia(PIBT BoolTest, const SPnode * const toInvert, SPnode * const search, const double eps). A PIBT is a pointer to a boolean interval test, in this case <a class="el" href="newsubpavings.shtml#NewIBT_ex3_4">IBT_ex3_4</a>. The set we want is defined by the combination of the SubPaving ToInvert and the <b>f</b> specifed in the boolean interval test <a class="el" href="newsubpavings.shtml#NewIBT_ex3_4">IBT_ex3_4</a>. We are finding a characterisation for the set (x<sub>1</sub>, x<sub>2</sub>) such that <b>f</b>(x<sub>1</sub>, x<sub>2</sub>) = x<sub>1</sub><sup>4</sup> - x<sub>1</sub><sup>2</sup> + 4x<sub>2</sub><sup>2</sup> is in ToInvert, which is the interval [-0.1 0.1].</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The SIVIA algorithm works by taking an initial search box, testing it, rejecting those returning BI_FALSE, including those returning BI_TRUE in the subpaving it is building, and bisecting again if the interval boolean test returns BI_INDET, and recursively sending each subbox to SIVIA to be tested similarly. Each subbox continues to be bisected until either the test returns a clear BI_TRUE or BI_FALSE or the test is BI_INDET but the width of the box is the value given for eps, which means that it is thin enough to be included in the subpaving to be returned. The eps parameter (precision) provides a 'stopping rule' prevents SIVIA recursing endlessly. A larger value for eps will mean a thicker uncertainty layer in the outer subpaving of the area we seek to characterise.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This version of Sivia takes a parameter for the SubPaving to invert because it must pass this on to the boolean interval test.</dd></dl>
<p>Sc5 now points to the subpaving characterisation we have created. We say 'subpaving characterisation' because the subpaving is an <a class="el" href="AIASubPavings.shtml#outerpaving">outer subpaving</a> of the actual set we want.</p>
<p>We print the computing time, volume, and number of leaves of the subpaving we create to standard output.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>And send the output to a txt file.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Now we want to find the image of this set using the function specified in <a class="el" href="newsubpavings.shtml#NewIVF_ex3_4">IVF_ex3_4</a>. <b>f</b>: R<sup>2</sup> -&gt; R<sup>2</sup>, f<sub>1</sub>(x<sub>1</sub>, x<sub>2</sub>) = (x<sub>1</sub> - 1)<sup>2</sup> -1 + x<sub>2</sub>, f<sub>2</sub>(x<sub>1</sub>, x<sub>2</sub>) = -x<sub>1</sub><sup>2</sup> + (x<sub>2</sub> - 1)<sup>2</sup>.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>This function is not invertible in the usual sense and we have to use ImageSp to find the image. The version of ImageSp used is <a class="el" href="classsubpavings_1_1SPnode.shtml#a5e79ff65a692b09c98ff53264ddfba9f" title="Creation of image subpaving with Interval Analysis.">ImageSp(PIVF f, SPnode* spn, double eps)</a>. We supply the interval vector function <a class="el" href="newsubpavings.shtml#NewIVF_ex3_4">IVF_ex3_4</a>, the subpaving Sc5 and the precision input by the user as arguments in the call to ImageSp.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Sc6 now points to the root node of a tree representing the subpaving constructed with ImageSp.</p>
<p>The ImageSp algorithm works by taking an initial subpaving (represented by Sc5 in this case), mincing it up into a fine subpaving where every box has width less than the precision specified, and finding the image of each of these boxes with the specified interval vector test. It then forms a minimal regular subpaving which covers the union of all these image boxes, again with precision as specified.</p>
<p>Sc6 now points to a subpaving representation in 'y-space', the image of Sc5 under the function <b>f</b> in <a class="el" href="newsubpavings.shtml#NewIVF_ex3_4">IVF_ex3_4</a>.</p>
<p>We report computing time, volume and number of leaves and send the suppaving output to a txt file.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Subpaving A, which will have been minced and mangled in the process of forming Sc6, is now deleted and remade to provide another initial search box.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>What happens if we now use Sivia on our ImageSp-created image Sc6 in 'y-space', inverting our image to get back to 'x-space'?</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The boolean interval test <a class="el" href="newsubpavings.shtml#NewIBTFinverse_ex3_4">IBTFinverse_ex3_4</a> specifies the function. We pass a pointer to this function to Sivia by supplying it as the value for the PIBT parameter. We give Sc6 as representing the SubPaving to invert and A as reprsenting the initial search box, and we also give the precision supplied by user.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>Sc7 is now points to 'x-space' subpaving characterisation of the reciprocal image of Sc6, which was in turn a subpaving characterisation of Sc5.</p>
<p>We report computing time, volume and number of leaves and output the subpaving to a txt file.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>We delete our subpavings created in dynamic memory before we end the program</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The subpavings produced by this program run using precision 0.05 in each case are shown below.</p>
<p>As well as showing the initial subpaving, the image subpaving, and the reciprocal image of the image, we capture an intermediate step in the process of creating Sc6 from Sc5 with ImageSp. This is the evaluation step, where we have a large set of (possibly overlapping) image boxes formed from all the minced up subboxes of the initial box [-3.0 3.0]<sup>2</sup> chopped up so that each one is less than 0.05 wide. This set can be compared to the Sc6, the regular minimal subpaving characterisation of the image.</p>
<p>The most interesting comparison though is between the initial subpaving and the subpaving for a reciprocal image of the image subpaving. The initial set (characterised by Sc5) is in there but the result is fatter due to error accumulation in the process of going to 'y-space' and back, and the final subpaving has additional parts which appear because <b>f</b>(.) is only invertible in the set-theoretic sense (AIA2001, pp. 63)</p>
<div class="image">
<img src="NEWexample3_4Coarse.png" alt="NEWexample3_4Coarse.png"/>
<div class="caption">
Results for Example 3.4 using precision 0.05</div></div>
 <p>We can rerun the program to explore the effect of the precision. The image below was created using a precision of 0.001 for the initial subpaving and then precisions of 0.01 to create the image of this in 'y-space' and and 0.01 to go back again to the reciprocal image of the image in 'x-space'. The evaluated images of the initial subpaving after it has been minced up very finely (precision 0.001) are also shown. The reciprocal image of the image is a much better comparison to the initial subpaving as the errors accumulated are smaller, but the additional parts due to are again apparent - they are caused by the process, not by the precision to which we carry it out.</p>
<div class="image">
<img src="NEWexample3_4Fine.png" alt="NEWexample3_4Fine.png"/>
<div class="caption">
Results for Example 3.4 using precision 0.001 for initial paving, then 0.01</div></div>
 <hr/>
<h2><a class="anchor" id="newsec_extension"></a>
Extending the SPnode class</h2>
<p>We can create new classes derived from this base class, each class a form of SPnode specialised for a particular kind of statistical set processing.</p>
<p>See:</p>
<ul>
<li><a class="el" href="StatsSubPavings.shtml">Subpavings for processing statistical sample data</a> </li>
</ul>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:23 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
