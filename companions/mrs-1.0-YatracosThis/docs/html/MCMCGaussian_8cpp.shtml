<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: MCMCGaussian.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('MCMCGaussian_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MCMCGaussian.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Testing StatsSubPavings (aka SPSnodes) with MCMC new style (May 2012) and multivariate (independent dimensions) gaussian data.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="histall_8hpp_source.shtml">histall.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="piecewise__constant__function_8hpp_source.shtml">piecewise_constant_function.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="MCMC__Trunk_2dataprep_8hpp_source.shtml">dataprep.hpp</a>&quot;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
</div>
<p><a href="MCMCGaussian_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MCMCGaussian_8cpp.shtml#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Testing StatsSubPavings (aka SPSnodes) with MCMC new style (May 2012) and multivariate (independent dimensions) gaussian data. </p>

<p>Definition in file <a class="el" href="MCMCGaussian_8cpp_source.shtml">MCMCGaussian.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="MCMCGaussian.cpp::main" ref="a0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ImageSetDiff_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MCMCGaussian_8cpp_source.shtml#l00044">44</a> of file <a class="el" href="MCMCGaussian_8cpp_source.shtml">MCMCGaussian.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">subpavings::AdaptiveHistogram::getRootLeaves()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">subpavings::AdaptiveHistogram::insertFromRVec()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">subpavings::PiecewiseConstantFunction::outputToTxtTabs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">subpavings::AdaptiveHistogram::outputToTxtTabs()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01150">subpavings::AdaptiveHistogram::prioritySplit()</a>, and <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01781">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// sort out user-defined parameters------------------//</span>
  <span class="keywordflow">if</span> ( argc &lt; 14) {
    cerr &lt;&lt; <span class="stringliteral">&quot;Syntax: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; d n loops seed burnin thinout hist1crit hist2crit hist3crit hist1critleaf hist2critleaf hist3critleaf numstateschosen log_full&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Syntax: &quot;</span> + std::string(argv[0]) + <span class="stringliteral">&quot; d n loops seed burnin thinout hist1crit hist2crit hist3crit hist1critleaf hist2critleaf hist3critleaf numstateschosen [log_full]&quot;</span>);
  }

  <span class="keywordtype">int</span> d = atoi(argv[1]);  <span class="comment">// dimensions</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = atoi(argv[2]);  <span class="comment">// number of points to generate</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loops = atoi(argv[3]); <span class="comment">// number of states to loop through</span>

  <span class="keywordtype">int</span> dataSeed = atoi(argv[4]); <span class="comment">// seed for data generation</span>

  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> burnin = atoi(argv[5]); 
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> thinout = atoi(argv[6]);

  <span class="comment">//this is really a bad naming scheme: this is for CritLeaves_GTE</span>
  <span class="keywordtype">size_t</span> hist1Crit = atoi(argv[7]);
  <span class="keywordtype">size_t</span> hist2Crit = atoi(argv[8]);
  <span class="keywordtype">size_t</span> hist3Crit = atoi(argv[9]); 

  <span class="comment">//this is for CritLargestCounts_GTE</span>
  <span class="keywordtype">size_t</span> hist1CritLeaf = atoi(argv[10]);
  <span class="keywordtype">size_t</span> hist2CritLeaf = atoi(argv[11]);
  <span class="keywordtype">size_t</span> hist3CritLeaf = atoi(argv[12]); <span class="comment">//this is actually not needed</span>

  <span class="keywordtype">size_t</span> minPQPoints1 = 1;
  <span class="keywordtype">size_t</span> minPQPoints2 = 1;
  <span class="keywordtype">size_t</span> minPQPoints3 = 1;

  <span class="keywordtype">bool</span> shiftCatalan = 0;
  
  <span class="keywordtype">size_t</span> NumStatesChosen = atoi(argv[13]);

  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logging = LOGSTATETRACE;

  cout &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; : process id is &quot;</span> &lt;&lt; getpid() &lt;&lt; std::endl;

  <span class="comment">// ------- prepare to generate some data for the tests -----------</span>

  <span class="comment">// set up a random number generator and use mt19937 for generator</span>
  gsl_rng * r = gsl_rng_alloc (gsl_rng_mt19937); <span class="comment">// set up with default seed</span>
  <span class="comment">//long unsigned int seed = 1234;</span>
  gsl_rng_set (r, dataSeed); <span class="comment">// change the seed</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Data seed is &quot;</span> &lt;&lt; dataSeed &lt;&lt; endl;
    
  <span class="keywordtype">string</span> samplesFileName; <span class="comment">// for samples</span>
  <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>
  ofstream oss;         <span class="comment">// ofstream object</span>
  oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
  oss.precision(5);

  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>* theDataPtr = <span class="keyword">new</span> <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>;   <span class="comment">// a container for all the points generated</span>

  <span class="comment">//gat41</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; i++) {
    rvector thisrv(d);
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt;= d; j++) {
      <span class="comment">//double z = gsl_rng_uniform(r);</span>
      <span class="keywordtype">double</span> z = gsl_ran_gaussian(r, 1.0); <span class="comment">// generate a normal r.v.</span>
      
      thisrv[j] = (z);
    }
    <span class="comment">// put points generated into container</span>
    theDataPtr-&gt;push_back(thisrv);
  }

  <span class="comment">// free the random number generator</span>
  <span class="keywordflow">try</span> {
    gsl_rng_free (r);
    r = NULL;
  }
  <span class="keywordflow">catch</span>(...) {}<span class="comment">// catch and swallow</span>

  <span class="comment">/* these parameters are set up here just to get an idea of what</span>
<span class="comment">   * is happening in each state - I don&#39;t care about the actual </span>
<span class="comment">   * sampling. variable loops came from user-supplied parameters.*/</span>
  <span class="comment">//unsigned int burnin = 10; // don&#39;t care about this</span>
  <span class="comment">//unsigned int thinout = loops/10; // don&#39;t care here either.</span>
  <span class="keywordtype">size_t</span> minPoints = 1;

  <span class="comment">// set up proposal distribution object</span>
  <a class="code" href="classsubpavings_1_1UniformProposal.shtml">UniformProposal</a> proposal;
  <span class="comment">// set up prior distribution object</span>
  <a class="code" href="classsubpavings_1_1LogCatalanPrior.shtml" title="A class for a log prior based on a Catalan number prior.">LogCatalanPrior</a> logPrior;
  cout &lt;&lt; <span class="stringliteral">&quot;=============================================&quot;</span>;
  cout &lt;&lt; <span class="stringliteral">&quot;\nStart example: n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; and d = &quot;</span> &lt;&lt; d &lt;&lt; endl;
  
<span class="comment">//==============MCMC with different starting states========================//</span>
  <span class="keywordtype">int</span> numFunc = 1;

  <span class="comment">// parameters needed to start the PQ</span>
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logPQ = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; <span class="comment">// logging level  </span>
  <a class="code" href="classsubpavings_1_1CompVol.shtml" title="Class comparing on volume of box of node.">CompVol</a> comp2; 
  CompVolMassMinus comp1;
  <a class="code" href="classsubpavings_1_1CompCount.shtml" title="Class comparing on count of data points associated with a node.">CompCount</a> compCount;
  vector&lt;real&gt; IAEContainer; <span class="comment">//for MCMC </span>

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> func = 0; func &lt; numFunc; func++) {
    cout &lt;&lt; <span class="stringliteral">&quot;\n========Function : &quot;</span> &lt;&lt; func &lt;&lt; <span class="stringliteral">&quot;========&quot;</span> &lt;&lt; endl; 
    ostringstream stm;
    stm &lt;&lt; func; <span class="comment">// for output purposes</span>
    vector&lt;size_t&gt; LeafContainer; <span class="comment">// to store the number of leaf nodes from which the optimal posterior support is at</span>
    
    <span class="comment">/*</span>
<span class="comment">    // make the paving box</span>
<span class="comment">    ivector pavingBox(d);</span>
<span class="comment">    for(int k=1; k &lt;= d; k++) pavingBox[k] = pavingInterval;</span>
<span class="comment">    */</span>
    
    <span class="comment">// make an Adaptive Histogram with the given pavingBox and, by default,</span>
    <span class="comment">// holdAllStats = false so that the underlying rootPaving managed by the</span>
    <span class="comment">// myHistFirst will not maintain all available stats, only counts</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myHistFirst; <span class="comment">// still let the data decide the box</span>

    <span class="comment">// put in the data in a &#39;pulse&#39; with no splitting, ie into root box</span>
    <span class="keywordtype">bool</span> successfulInsertion = myHistFirst.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*theDataPtr);

    <span class="keywordflow">if</span> (successfulInsertion) {

      vector&lt;real&gt; ChosenStateMaxPosterior;
      vector&lt;AdaptiveHistogram&gt; ChosenStateSubset;

      <span class="comment">/*</span>
<span class="comment">      //----------------------------------------------------------//</span>
<span class="comment">      //Option 1: make a histogram using the estimate</span>
<span class="comment">      //--- make the histogram have the same shape as the estimate------//</span>
<span class="comment">      // except if minPoints will not allow this</span>
<span class="comment">      myHistFirst.reshapeToUnion(estimate, minPoints);</span>
<span class="comment">      cout &lt;&lt; &quot;After reshaping to shape of function, histogram has &quot; &lt;&lt; myHistFirst.getRootLeaves() &lt;&lt; &quot; leaves&quot; &lt;&lt; endl;</span>
<span class="comment">      //get the number of leaf nodes in this state</span>
<span class="comment">      histLeaf1 = myHistFirst.getRootLeaves();</span>
<span class="comment">      //----------------------------------------------------------//</span>
<span class="comment">      */</span>

      <span class="comment">//----------------------------------------------------------//</span>
      <span class="comment">//Option 2: get the optimal estimate by computing the posterior from SEB-PQ</span>
      <span class="keywordtype">size_t</span> histCrit;
      <span class="keywordflow">if</span> (func == 0) { histCrit = hist1Crit; }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func==1) { histCrit = hist2Crit; }
      <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critStop(histCrit);
      cout &lt;&lt; <span class="stringliteral">&quot;PQ to &quot;</span>  &lt;&lt; histCrit &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;

      <span class="comment">//containers to store needed outputs</span>
      vector&lt;real&gt; Posterior;
      vector&lt;real&gt; PosteriorSupport;
      vector&lt;double&gt; EmptyBox;
      <span class="keywordtype">int</span> Txt = func;
      vector&lt;real&gt; IAEPQContainer;

      <span class="keywordtype">bool</span> successfulHist = <span class="keyword">false</span>;
      <span class="comment">// start the first stage of PQ here</span>
      <span class="keywordflow">if</span> (func == 0) {
        successfulHist = myHistFirst.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(comp1, critStop, 
        logPQ, minPQPoints1, Posterior, logPrior, EmptyBox, 
        PosteriorSupport, IAEPQContainer, shiftCatalan);
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
        successfulHist = myHistFirst.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(comp2, critStop, 
        logPQ, minPQPoints2, Posterior, logPrior, EmptyBox,
        PosteriorSupport, IAEPQContainer,  shiftCatalan);
      }

      <span class="keywordflow">if</span> (successfulHist) {
        <span class="comment">// output log-posterior</span>
        <span class="keywordtype">string</span> PostFileName;
        PostFileName = <span class="stringliteral">&quot;Posterior&quot;</span>;
        PostFileName += stm.str();
        PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(PostFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; Posterior.size(); i++) {
          oss &lt;&lt; Posterior[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();

        <span class="comment">// output support log-posterior </span>
        PostFileName = <span class="stringliteral">&quot;PosteriorSupport&quot;</span>;
        PostFileName += stm.str();
        PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(PostFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorSupport.size(); i++) {
          oss &lt;&lt; PosteriorSupport[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        
        <span class="comment">// output the cumulative ratio of empty boxes</span>
        <span class="keywordtype">string</span> EmptyFileName;
        EmptyFileName = <span class="stringliteral">&quot;Empty&quot;</span>;
        EmptyFileName += stm.str();
        EmptyFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(EmptyFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; EmptyBox.size(); i++) {
          oss &lt;&lt; EmptyBox[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        
        <span class="comment">// get K number of states with a local highest posterior</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Choosing &quot;</span> &lt;&lt; NumStatesChosen &lt;&lt; <span class="stringliteral">&quot; states&quot;</span> &lt;&lt; endl;
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; NumStatesChosen; j++) {
          ostringstream stmj;
          stmj &lt;&lt; j;
          <span class="keywordtype">int</span> step = int(1.0*PosteriorSupport.size()/(1.0*NumStatesChosen));
          <span class="comment">//find where the posterior/log-posterior/emptyVol is the highest</span>
          <span class="keywordtype">size_t</span> maxPosition = 0;
          real maxPosterior = -1*(numeric_limits&lt;double&gt;::infinity());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; step; i++) {
            <span class="keywordtype">size_t</span> thisPosition = j*step + i;
            <span class="keywordflow">if</span> (PosteriorSupport[thisPosition] &gt; maxPosterior) {
              maxPosterior = PosteriorSupport[thisPosition];
              maxPosition = thisPosition;
            }
          }
          cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------&quot;</span> &lt;&lt; endl;
          cout &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;-th subset: &quot;</span>&lt;&lt; endl;
          cout &lt;&lt; <span class="stringliteral">&quot;log posterior highest at split &quot;</span> &lt;&lt; maxPosition;
          <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critValMax(maxPosition+1);
          LeafContainer.push_back(maxPosition+1);

          <span class="comment">// now get the posterior-optimal histogram</span>
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHist;
          myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*theDataPtr);
          
          <span class="comment">// get the corresponding histogram</span>
          <span class="keywordflow">if</span> (func == 0) {
            myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(comp1, critValMax, logPQ, minPQPoints1);
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
            myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(comp2, critValMax, logPQ, minPQPoints2);
          }
          <span class="keywordtype">size_t</span> chosenHistLeaves = myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>();
          cout &lt;&lt; <span class="stringliteral">&quot; and has &quot;</span> &lt;&lt; myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
          
          <span class="comment">//optional hist output</span>
          myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a49a8ff01e1398420cd45642d5b1d3106" title="Output the subpaving managed by this to a txt file.">outputToTxtTabs</a>(<span class="stringliteral">&quot;SelectedCarvedHistogram.txt&quot;</span>);
          
          <span class="comment">// start SEB from chosen histogram</span>
          <span class="comment">// initialize containers</span>
          vector&lt;real&gt; PosteriorChosen;
          vector&lt;double&gt; EmptyBoxChosen;
          vector&lt;real&gt; PosteriorSupportChosen;
          vector&lt;real&gt; IAEContainerChosen;

          <span class="keywordflow">if</span> (func == 0) { histCrit = hist1CritLeaf; }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func==1) { histCrit = hist2CritLeaf; }
          <a class="code" href="classsubpavings_1_1CritLargestCount__LTE.shtml" title="Class for testing the count of the node with the largest count in histogram&#39;s subpaving.">CritLargestCount_LTE</a> critLeaf(histCrit);
          cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ to at most &quot;</span>  &lt;&lt; (histCrit) &lt;&lt; <span class="stringliteral">&quot; points in each node&quot;</span> &lt;&lt; endl;
          Txt = 900 + func*10 + j;

          <span class="keywordflow">if</span> (func == 0) {
            successfulHist = myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compCount, critLeaf, 
            logPQ, minPQPoints1, PosteriorChosen, logPrior,  EmptyBoxChosen, 
            PosteriorSupportChosen, IAEContainerChosen, shiftCatalan);
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
            successfulHist = myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compCount, critLeaf, 
            logPQ, minPQPoints2, PosteriorChosen, logPrior, EmptyBoxChosen, 
            PosteriorSupportChosen, IAEContainerChosen,  shiftCatalan);
          }

          <span class="comment">// optional</span>
          <span class="comment">// output log-posterior</span>
          PostFileName = <span class="stringliteral">&quot;PosteriorChosen&quot;</span>;
          PostFileName += stm.str(); <span class="comment">//for func</span>
          PostFileName += stmj.str(); <span class="comment">//for j</span>
          PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
          oss.open(PostFileName.c_str());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
            oss &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;
          }
          oss &lt;&lt; flush;
          oss.close();

          <span class="comment">// output support log-posterior </span>
          PostFileName = <span class="stringliteral">&quot;PosteriorSupportChosen&quot;</span>;
          PostFileName += stm.str();
          PostFileName += stmj.str();
          PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
          oss.open(PostFileName.c_str());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorSupportChosen.size(); i++) {
            oss &lt;&lt; PosteriorSupportChosen[i] &lt;&lt; endl;
          }
          oss &lt;&lt; flush;
          oss.close();
  
          <span class="comment">// output the cumulative ratio of empty boxes</span>
          EmptyFileName = <span class="stringliteral">&quot;EmptyChosen&quot;</span>;
          EmptyFileName += stm.str();
          EmptyFileName += stmj.str();
          EmptyFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
          oss.open(EmptyFileName.c_str());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; EmptyBoxChosen.size(); i++) {
            oss &lt;&lt; EmptyBoxChosen[i] &lt;&lt; endl;
          }
          oss &lt;&lt; flush;
          oss.close();

          <span class="comment">// get the max position for this sub-set</span>
          maxPosition = 0;
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
            <span class="keywordflow">if</span> (PosteriorChosen[i] &gt; maxPosterior) {
              maxPosterior = PosteriorChosen[i];
              maxPosition = i;
            }
          }
          cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ using carved support has log-posterior highest at index &quot;</span> &lt;&lt; maxPosition &lt;&lt; endl;;
          ChosenStateMaxPosterior.push_back(PosteriorChosen[maxPosition]);
          
          <span class="comment">// now get the posterior-optimal histogram for this subset using PQ-SEB</span>
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHistSubset;
          myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*theDataPtr);
          <span class="comment">// be careful here</span>
          <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critValMaxSubset(chosenHistLeaves + maxPosition);
          
          <span class="keywordflow">if</span> (func == 0) {
            myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compCount, critValMaxSubset, 
            logPQ, minPQPoints1);
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
            myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compCount, critValMaxSubset, 
            logPQ, minPQPoints2);
          }
          cout &lt;&lt; <span class="stringliteral">&quot; Chosen state has &quot;</span> &lt;&lt; myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
          <span class="comment">//keep this histogram in a container</span>
          ChosenStateSubset.push_back(myChosenHistSubset);
        } <span class="comment">// end of going through NumStatesChosen</span>
        cout &lt;&lt; <span class="stringliteral">&quot;-----------------------------------------------&quot;</span> &lt;&lt; endl;

        <span class="comment">// start the SEB-PQ from the root node as a sanity check</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Starting the SEB-PQ from the root node:&quot;</span> &lt;&lt; endl;
        <span class="comment">// initialize containers</span>
        vector&lt;real&gt; PosteriorChosen;
        vector&lt;double&gt; EmptyBoxChosen;
        vector&lt;real&gt; PosteriorSupportChosen;
        vector&lt;real&gt; IAEContainerChosen;

        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHist;
        myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*theDataPtr);

        <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critStop(hist3Crit);
        cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ to &quot;</span>  &lt;&lt; (hist3Crit) &lt;&lt; <span class="stringliteral">&quot; leaf nodes&quot;</span> &lt;&lt; endl;
        Txt = 9000 + func*100 + NumStatesChosen;
        <span class="keywordflow">if</span> (func == 0) {
          successfulHist = myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compCount, critStop, 
          logPQ, minPQPoints1, PosteriorChosen, logPrior, EmptyBoxChosen, 
          PosteriorSupportChosen, IAEContainerChosen, shiftCatalan);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
          successfulHist = myChosenHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#afa5a767156398a6d29db12fcbf0a46c7">prioritySplitMCMC</a>(compCount, critStop, 
          logPQ, minPQPoints2, PosteriorChosen, logPrior, EmptyBoxChosen, 
          PosteriorSupportChosen, IAEContainerChosen, shiftCatalan);
        }

        <span class="comment">// optional</span>
        <span class="comment">// output log-posterior</span>
        PostFileName = <span class="stringliteral">&quot;PosteriorChosen&quot;</span>;
        PostFileName += stm.str(); <span class="comment">//for func</span>
        ostringstream stm1;
        stm1 &lt;&lt; NumStatesChosen;
        PostFileName += stm1.str(); 
        PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(PostFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
            oss &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;
          }
          oss &lt;&lt; flush;
          oss.close();

        <span class="comment">// output support log-posterior </span>
        PostFileName = <span class="stringliteral">&quot;PosteriorSupportChosen&quot;</span>;
        PostFileName += stm.str();
        PostFileName += stm1.str();
        PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(PostFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorSupportChosen.size(); i++) {
          oss &lt;&lt; PosteriorSupportChosen[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
  
        <span class="comment">// output the cumulative ratio of empty boxes</span>
        EmptyFileName = <span class="stringliteral">&quot;EmptyChosen&quot;</span>;
        EmptyFileName += stm.str();
        EmptyFileName += stm1.str();
        EmptyFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(EmptyFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; EmptyBoxChosen.size(); i++) {
          oss &lt;&lt; EmptyBoxChosen[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();

        <span class="comment">// get the max position for this sub-set</span>
        <span class="keywordtype">size_t</span> maxPosition = 0;
        real maxPosterior = -1*(numeric_limits&lt;double&gt;::infinity());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
          <span class="keywordflow">if</span> (PosteriorChosen[i] &gt; maxPosterior) {
            maxPosterior = PosteriorChosen[i];
            maxPosition = i;
          }
        }
        cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ using carved support has log-posterior highest at index &quot;</span> &lt;&lt; maxPosition &lt;&lt; endl;
        ChosenStateMaxPosterior.push_back(PosteriorChosen[maxPosition]);
        
        <span class="comment">// now get the posterior-optimal histogram for this subset using PQ-SEB</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHistSubset;
        myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*theDataPtr);
        <span class="comment">// be careful here</span>
        <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critValMaxSubset(maxPosition+1);
        
        <span class="keywordflow">if</span> (func == 0) {
          myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compCount, critValMaxSubset, 
          logPQ, minPQPoints1);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
          myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2b60528af3d0f583b08284e11d4ff764">prioritySplit</a>(compCount, critValMaxSubset, 
          logPQ, minPQPoints2);
        }
        cout &lt;&lt; <span class="stringliteral">&quot; Chosen state has &quot;</span> &lt;&lt; myChosenHistSubset.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
        <span class="comment">//keep this histogram in a container</span>
        ChosenStateSubset.push_back(myChosenHistSubset);
        <span class="comment">//-------------end of getting from the root node------------------//</span>
        
        cout &lt;&lt; <span class="stringliteral">&quot;-----------------------------&quot;</span> &lt;&lt; endl;
        <span class="comment">// find which subset gives the maximum posterior</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Find the maximum over the maximum log-posteriors: &quot;</span> &lt;&lt; endl;
        maxPosition = 0;
        maxPosterior=-1*(numeric_limits&lt;double&gt;::infinity());
        <span class="keywordflow">if</span> ( ChosenStateMaxPosterior.size() != (1+NumStatesChosen) ) {
          cerr &lt;&lt; <span class="stringliteral">&quot;Number of states is incompatible.&quot;</span> &lt;&lt; endl;
          exit(0);
        }
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ChosenStateMaxPosterior.size(); i++) {
          cout &lt;&lt; <span class="stringliteral">&quot;Subset: &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; ChosenStateMaxPosterior[i] &lt;&lt; endl;
          <span class="keywordflow">if</span> (ChosenStateMaxPosterior[i] &gt; maxPosterior) {
            maxPosterior = ChosenStateMaxPosterior[i];
            maxPosition = i;
          }
        }
        cout &lt;&lt; <span class="stringliteral">&quot;Final optimal histogram is from subset &quot;</span> &lt;&lt; maxPosition;

        <span class="comment">// use this histogram as the starting state for MCMC</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myPosOptHist;
        myPosOptHist = ChosenStateSubset[maxPosition];
        cout &lt;&lt; <span class="stringliteral">&quot; and has &quot;</span> &lt;&lt; myPosOptHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span>  &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;
        <span class="comment">//optional hist output</span>
        myPosOptHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a49a8ff01e1398420cd45642d5b1d3106" title="Output the subpaving managed by this to a txt file.">outputToTxtTabs</a>(<span class="stringliteral">&quot;SelectedStartingHistogram.txt&quot;</span>);
          
        
        
        <span class="comment">//output the leaf container</span>
        <span class="keywordtype">string</span> LeafFileName = <span class="stringliteral">&quot;LeafChosen&quot;</span>;
        LeafFileName += stm.str();
        LeafFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(LeafFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; LeafContainer.size(); i++) {
          oss &lt;&lt; LeafContainer[i] &lt;&lt; endl;
        }
        oss &lt;&lt; 1 &lt;&lt; endl;
        oss &lt;&lt; flush;
        oss.close();
        
        <span class="comment">//----------End of getting an initial state---------------//</span>

        <span class="comment">//============start MCMC==============================//</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Starting MCMC PiecewiseConstantFunction samples with a state that has &quot;</span> &lt;&lt;  
        myPosOptHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &lt;&lt; <span class="stringliteral">&quot; leaf nodes:&quot;</span> &lt;&lt; endl;
        
        vector&lt;real&gt; LogLikAvg;
        vector&lt;real&gt; LogLikCurr;
        
        
        clock_t start, end;
        start = clock();

        <a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> mcmcAv = myPosOptHist.MCMCNEW(
                            loops, burnin, thinout,
                            proposal, logPrior,
                            minPoints, logging, stm.str(),
                            LogLikAvg, LogLikCurr);
        end = clock();

        cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span>
         &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;

        cout &lt;&lt; <span class="stringliteral">&quot;Finished MCMC sample averaging&quot;</span> &lt;&lt; endl;
        <span class="keywordtype">string</span> mcmcAvFilename = <span class="stringliteral">&quot;pcfAverage.txt&quot;</span>;
        mcmcAv.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">outputToTxtTabs</a>(mcmcAvFilename);

        <span class="comment">// output log-likelihood</span>
        <span class="keywordtype">string</span> IAEFileName;
        IAEFileName = <span class="stringliteral">&quot;LogLikCurrMCMC&quot;</span>;
        IAEFileName += stm.str();
        IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(IAEFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; LogLikCurr.size(); i++) {
          oss &lt;&lt; LogLikCurr[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        cout &lt;&lt; <span class="stringliteral">&quot;Log-lik output to &quot;</span> &lt;&lt; IAEFileName &lt;&lt; endl;
          
        <span class="comment">// output log-likelihood</span>
        IAEFileName = <span class="stringliteral">&quot;LogLikAvgMCMC&quot;</span>;
        IAEFileName += stm.str();
        IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(IAEFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; LogLikAvg.size(); i++) {
          oss &lt;&lt; LogLikAvg[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        cout &lt;&lt; <span class="stringliteral">&quot;Log-lik output to &quot;</span> &lt;&lt; IAEFileName &lt;&lt; endl;
      }
      <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">&quot;Failed to insert data&quot;</span> &lt;&lt; endl;

    } <span class="comment">// end of successfulHist condition</span>
  } <span class="comment">// end of loop</span>
  <span class="comment">//=======================End of Chains=================================//</span>



  <span class="keyword">delete</span> theDataPtr;

   <span class="keywordflow">return</span> 0;

} <span class="comment">// end of MCMC test program</span>
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="MCMCGaussian_8cpp.shtml">MCMCGaussian.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:22 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
