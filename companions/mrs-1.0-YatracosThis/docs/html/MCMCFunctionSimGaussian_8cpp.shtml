<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: MCMCFunctionSimGaussian.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('MCMCFunctionSimGaussian_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MCMCFunctionSimGaussian.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Get the Hellinger distance between actual Gaussian data and Gaussian data generated from a function estimate.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="histall_8hpp_source.shtml">histall.hpp</a>&quot;</code><br/>
<code>#include &quot;intervalmappedspnode_measurers.hpp&quot;</code><br/>
<code>#include &quot;functionestimator_interval.hpp&quot;</code><br/>
<code>#include &quot;<a class="el" href="piecewise__constant__function_8hpp_source.shtml">piecewise_constant_function.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="GaussianFobj_8hpp_source.shtml">GaussianFobj.hpp</a>&quot;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
<code>#include &quot;gsl/gsl_linalg.h&quot;</code><br/>
<code>#include &quot;gsl/gsl_matrix.h&quot;</code><br/>
<code>#include &quot;gsl/gsl_blas.h&quot;</code><br/>
<code>#include &quot;assert.h&quot;</code><br/>
</div>
<p><a href="MCMCFunctionSimGaussian_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MCMCFunctionSimGaussian_8cpp.shtml#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Get the Hellinger distance between actual Gaussian data and Gaussian data generated from a function estimate. </p>

<p>Definition in file <a class="el" href="MCMCFunctionSimGaussian_8cpp_source.shtml">MCMCFunctionSimGaussian.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="MCMCFunctionSimGaussian.cpp::main" ref="a0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ImageSetDiff_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MCMCFunctionSimGaussian_8cpp_source.shtml#l00056">56</a> of file <a class="el" href="MCMCFunctionSimGaussian_8cpp_source.shtml">MCMCFunctionSimGaussian.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">subpavings::AdaptiveHistogram::getRootBox()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01227">subpavings::AdaptiveHistogram::getRootPavingMean()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01235">subpavings::AdaptiveHistogram::getRootPavingVarCovar()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">subpavings::AdaptiveHistogram::getSubPaving()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375">subpavings::PiecewiseConstantFunction::getTotalIntegral()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">subpavings::AdaptiveHistogram::insertFromRVec()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">subpavings::PiecewiseConstantFunction::normalise()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">subpavings::PiecewiseConstantFunction::outputToTxtTabs()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854">subpavings::PiecewiseConstantFunction::simulateData()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// sort out user-defined parameters------------------//</span>
  <span class="keywordflow">if</span> ( argc &lt; 5 ) {
    cerr &lt;&lt; <span class="stringliteral">&quot;Syntax: &quot;</span> &lt;&lt; argv[0] &lt;&lt; 
    <span class="stringliteral">&quot;d maxLeavesEst n dataSeed&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Syntax: &quot;</span> + std::string(argv[0]) + <span class="stringliteral">&quot;d n states, symmetryIndicator&quot;</span>);
  }
  
  <span class="keywordtype">int</span> d = atoi(argv[1]);  <span class="comment">// ds</span>
  <span class="keywordtype">size_t</span> maxLeavesEst = atoi(argv[2]);  <span class="comment">// number of leaves in estimator</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = atoi(argv[3]);  <span class="comment">// number of points to generate</span>
  <span class="keywordtype">int</span> dataSeed = atoi(argv[4]); <span class="comment">// seed for data generation</span>

  <span class="keywordtype">size_t</span> minPoints = 1;
  <span class="keywordtype">size_t</span> minPQPoints1 = 1;
  <span class="keywordtype">size_t</span> minPQPoints2 = 1;
  <span class="keywordtype">size_t</span> minPQPoints3 = 1;

  cout &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; : process id is &quot;</span> &lt;&lt; getpid() &lt;&lt; std::endl;

  <span class="comment">// for output purposes</span>
  <span class="comment">// string formatting</span>
  ofstream oss;         <span class="comment">// ofstream object</span>
   oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
   oss.precision(10);

  <span class="comment">//=======generate actual data and get the root box==============//</span>
  <span class="comment">// set up a random number generator and use mt19937 for generator</span>
  gsl_rng * r = gsl_rng_alloc (gsl_rng_mt19937); <span class="comment">// set up with default seed</span>
  <span class="comment">//long unsigned int seed = 1234;</span>
  gsl_rng_set (r, dataSeed); <span class="comment">// change the seed</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Data seed is &quot;</span> &lt;&lt; dataSeed &lt;&lt; endl;

  cout &lt;&lt; <span class="stringliteral">&quot;\n Generate &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; data from actual density.&quot;</span> &lt;&lt; endl;

  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>* actualDataPtr = <span class="keyword">new</span> <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>;

  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; i++) {
    rvector thisrv(d);
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt;= d; j++) {
      <span class="comment">//double z = gsl_rng_uniform(r);</span>
      <span class="keywordtype">double</span> z = gsl_ran_gaussian(r, 1.0); <span class="comment">// generate a normal r.v.</span>
      thisrv[j] = (z);
    }
    <span class="comment">// put points generated into container</span>
    actualDataPtr-&gt;push_back(thisrv);
  }

  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>* actualHist = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>(<span class="keyword">true</span>); 
  actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*actualDataPtr);
  ivector pavingBoxEst = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a936a3426494278163afada104df26ecc" title="Get the box of the subpaving managed by this.">getRootBox</a>();

  <span class="comment">//=========end of getting a root box from the actual data=============</span>
  
  <span class="comment">//============== make estimate ============//</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nMake the function estimator to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
  
  <span class="comment">// specify function object (from /examples/MappedTargets</span>
  <a class="code" href="classsubpavings_1_1GaussianFobj.shtml">GaussianFobj</a> fobj;
  
  <span class="comment">/* function estimate is going to use same box as the histograms */</span>
  <span class="comment">//ivector pavingBoxEst(d);</span>
  <span class="comment">//for(int k=1; k &lt;= d; k++) pavingBoxEst[k] = pavingInterval;</span>
  
  <span class="comment">// Use fobj and pavingBox to get an estimator</span>
  FunctionEstimatorInterval estimator(pavingBoxEst, fobj);
  
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logEst = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; <span class="comment">// logging for making estimator</span>
  
<span class="preprocessor">  #if(1)</span>
<span class="preprocessor"></span>  <span class="keywordtype">size_t</span> maxLeavesEstDown = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(1.2*maxLeavesEst); <span class="comment">// go down to 1.2 x max</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span><span class="preprocessor">  #if(0)</span>
<span class="preprocessor"></span>    <span class="keywordtype">size_t</span> maxLeavesEstDown = maxLeavesEst;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;pq down to max leaves &quot;</span> &lt;&lt; maxLeavesEstDown &lt;&lt; endl;
  
  clock_t startEst = clock();
  
  <span class="comment">// priority split driven by splitting leaf with max reimann diff</span>
  ReimannDiffMeasurer measurer;
  estimator.prioritySplit(measurer, maxLeavesEstDown, logEst);
      
  <span class="comment">// stop recording time here</span>
  clock_t endEst = clock();
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves in estimate: &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;  
  cout &lt;&lt; <span class="stringliteral">&quot;After split, getTotalAreaOfIntervalBand() = &quot;</span>
    &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
  <span class="keywordtype">double</span> timingEst1 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for pq split in estimate: &quot;</span> &lt;&lt; timingEst1 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  startEst = clock();
  
<span class="preprocessor">  #if(1) </span>
<span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;Hull propagation&quot;</span> &lt;&lt; endl;
    estimator.hullPropagation();
    
    cout &lt;&lt; <span class="stringliteral">&quot;Priority merge to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
<span class="preprocessor">    #if(0)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by minimising increase the reimann diff</span>
    estimator.priorityMergeOnLoss(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span><span class="preprocessor">    #if(1)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by merging cherry with minimum reimann diff</span>
    estimator.priorityMerge(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>          
    <span class="comment">// stop recording time here</span>
    endEst = clock(); 
    <span class="keywordtype">double</span> timingEst2 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
    cout &lt;&lt; <span class="stringliteral">&quot;Computing time for hull propagate and merge up in estimate: &quot;</span> &lt;&lt; timingEst2 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
    
    cout &lt;&lt; <span class="stringliteral">&quot;After propagation and priority merge, getTotalAreaOfIntervalBand() = &quot;</span> 
          &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;number of leaves is = &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;Making estimate and normalising&quot;</span> &lt;&lt; endl;
  <span class="comment">// Make PiecewiseConstantFunction estimate from estimator</span>
  <a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> estimate = estimator.makePiecewiseConstantFunction();cout &lt;&lt; <span class="stringliteral">&quot;estimate has integral &quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; <span class="stringliteral">&quot; before normalizing&quot;</span> &lt;&lt; endl;
  real before = estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>();
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">normalise</a>();
  cout &lt;&lt; <span class="stringliteral">&quot;estimate has integral &quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; endl;
  
  <span class="comment">//optional</span>
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">outputToTxtTabs</a>(<span class="stringliteral">&quot;PCF.txt&quot;</span>);

  <span class="keywordtype">string</span> Integral = <span class="stringliteral">&quot;Integral.txt&quot;</span>;
  oss.open(Integral.c_str());
  oss &lt;&lt; before &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; endl;
  oss &lt;&lt; flush;
  oss.close();
  
  
  <span class="comment">//===========end of estimating function using PCF=========================//</span>

  <span class="comment">//===========generate data==============================================//</span>
  <span class="comment">// Use PiecewiseConstantFunction to generate data, supplying our own rng</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nGenerating data for simulation&quot;</span> &lt;&lt; endl;

  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>* theDataPtr = <span class="keyword">new</span> <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>;   <span class="comment">// a container for all the points generated</span>

  clock_t startData = clock();

  <span class="comment">// Gaussian data</span>
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854" title="Simulator taking a random number generator argument.">simulateData</a>(*theDataPtr, n, r);

  <span class="comment">// stop recording time here</span>
  clock_t endData = clock();  
  <span class="keywordtype">double</span> timingData = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endData - startData)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for simulating data: &quot;</span> &lt;&lt; timingData &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;

  cout &lt;&lt; (*theDataPtr).size() &lt;&lt; <span class="stringliteral">&quot; points generated&quot;</span> &lt;&lt; endl;
  
  <span class="keywordflow">try</span> {
    gsl_rng_free (r);
    r = NULL;
  }
  <span class="keywordflow">catch</span>(...) {}<span class="comment">// catch and swallow</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;\nStart example: n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; and d = &quot;</span> &lt;&lt; d &lt;&lt; endl;
  <span class="comment">//cout &lt;&lt; &quot;Paving interval is &quot; &lt;&lt; pavingInterval &lt;&lt; endl;</span>

  <span class="comment">//===========end of generating data=================================//</span>

  <span class="comment">//================get the hellinger distance for this set 0f data========//</span>
  real HDTrue = 0.0;   <span class="comment">//est vs true</span>
  real HDActual = 0.0;  <span class="comment">// est vs actual</span>
  real HDTrueActual = 0.0;  <span class="comment">// actual vs true</span>

  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>* estimateHist = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>(<span class="keyword">true</span>); 
  estimateHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*theDataPtr);

  <span class="comment">// get the mean and var-covar of the mapped data</span>
  rvector EstMean = (estimateHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>())-&gt;getMean(); <span class="comment">// get mean</span>
  <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> EstCovar = (estimateHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>())-&gt;getVarCovar(); <span class="comment">//get the covariance matrix/</span>

  <span class="comment">//compare against actual (0,1)</span>
  {
    <span class="comment">//get the mean</span>
    rvector ExactMean(d);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= d; i++) { ExactMean[i] = 0.0; }
    <span class="comment">//cout &lt;&lt; ExactMean &lt;&lt; endl;</span>

    <span class="comment">//get the differences of the mean vectors</span>
    rvector diffMean = ExactMean - EstMean;
    <span class="comment">//cout &lt;&lt; diffMean &lt;&lt; endl;</span>

    <span class="keywordflow">if</span> (d == 1) {
      interval covarI = interval(EstCovar[0]);
      interval actualCovarI = interval(1.0);
      interval sumVar = covarI + actualCovarI;
      <span class="comment">//cout &lt;&lt; sumVar &lt;&lt; &quot;\t&quot;;</span>
      interval insqrt = 2*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(covarI)*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(actualCovarI)/sumVar;
      <span class="comment">//cout &lt;&lt; insqrt &lt;&lt; &quot;\t&quot;;</span>
      interval H2 = interval(1,1) - <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(insqrt) *<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>((-0.25*diffMean[1]*diffMean[1])/sumVar);
      <span class="comment">//cout &lt;&lt; &quot;H2: &quot; &lt;&lt; H2 &lt;&lt; endl;</span>
      HDTrue = mid(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(H2));
    }

    <span class="keywordflow">else</span> {
    <span class="comment">// get the variance-covariances</span>
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> ExactCovar;
    ExactCovar.reserve(d*d);

    <span class="comment">// fill in the matrix where the off-diag are 0</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; d*d; i++) {
        ExactCovar.push_back(0.0); <span class="comment">//first fill up the container with 1</span>
    }
    <span class="comment">// then fill up the diags with 1</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; d; i++) {
      <span class="keywordtype">int</span> pos = i*d + i;
      ExactCovar[pos] = 1.0;
    }
    
      <span class="comment">//make a gsl matrix for the mean difference</span>
      gsl_matrix * diffMeanMat = gsl_matrix_alloc(d, 1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 1; j++) {
          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));
        }
      }
  
      <span class="comment">// initialize matrix objects</span>
      gsl_matrix * EstCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * ExactCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * PMat = gsl_matrix_alloc(d, d); <span class="comment">//make this same as CovarMat first</span>
    
      <span class="keywordtype">int</span> k = 0; <span class="comment">//counter for RealVec</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          gsl_matrix_set(EstCovarMat, i, j, _double(EstCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(PMat, i, j, _double(EstCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(ExactCovarMat, i, j, _double(ExactCovar[k])); <span class="comment">//cast to double</span>
          k++;
        }
      }
    
      <span class="comment">//add the two matrices</span>
      gsl_matrix_add(PMat, ExactCovarMat);
      gsl_matrix_scale(PMat, 0.5);
      <span class="comment">//cout &lt;&lt; &quot;add the two matrices: &quot; &lt;&lt; endl;</span>
    
      <span class="comment">// get the determinants </span>
      <span class="keywordtype">int</span> s;
      gsl_permutation * p = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(EstCovarMat, p, &amp;s);
      <span class="keywordtype">double</span> detCovarMat = gsl_linalg_LU_det(EstCovarMat, s);
      gsl_permutation_free(p);
    
      <span class="keywordtype">int</span> s1;
      gsl_permutation * p1 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(ExactCovarMat, p1, &amp;s1);
      <span class="keywordtype">double</span> detExactCovarMat = gsl_linalg_LU_det(ExactCovarMat, s1);
      gsl_permutation_free(p1);
    
      <span class="keywordtype">int</span> s2;
      gsl_permutation * p2 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(PMat, p2, &amp;s2);
      <span class="keywordtype">double</span> detPMat = gsl_linalg_LU_det(PMat, s2);
      
      <span class="comment">//cout &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detExactCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
    
      <span class="comment">//now get the inverse of P</span>
      gsl_matrix * Pinverse = gsl_matrix_alloc(d, d); 
      gsl_linalg_LU_invert(PMat, p2, Pinverse);
      gsl_permutation_free(p2);
    <span class="comment">/*</span>
<span class="comment">      cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    */</span>
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, d);
      gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);
    
      <span class="comment">// now convert all to rmatrix for easier computations</span>
      rmatrix diffMeanR(0, d-1, 0, 0);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 1; j++) {
          diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMat, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix diffMeanTransR(0, 0, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMatTranspose, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix PinvR(0, d-1, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); 
        }
      }
    
      <span class="comment">//free the gsl_matrices</span>
      gsl_matrix_free(EstCovarMat);
      gsl_matrix_free(ExactCovarMat);
      gsl_matrix_free(PMat);
    
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;
      <span class="comment">//cout &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
      real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(detCovarMat*detExactCovarMat));
      <span class="comment">//cout &lt;&lt; &quot;DB: &quot; &lt;&lt; DB &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> (DB &lt; 0) { HDTrue = 0.0; }
      <span class="keywordflow">else</span> {
        real BC = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-DB);
        assert(BC &gt;= 0);
        <span class="comment">//cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
        HDTrue = <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1-BC);
        <span class="comment">//cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HDTrue &lt;&lt; endl;</span>
        assert(HDTrue &gt;=0);
      }
    }
    cout &lt;&lt; <span class="stringliteral">&quot;Hellinger distance: &quot;</span> &lt;&lt; HDTrue &lt;&lt; endl;
  }

  <span class="comment">// compare against actual data</span>
  {
    <span class="comment">//get the mean</span>
    rvector ExactMean = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a95d9506c9ceea0359b99b0e36f1eff91" title="Gets the mean from the root box of the paving this manages.">getRootPavingMean</a>();
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> ExactCovar = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2bbfcf884ee91c2457eb2e9d2b81e31f" title="Gets variance covariance vector from root box of rootpaving.">getRootPavingVarCovar</a>();

    <span class="comment">//get the differences of the mean vectors</span>
    rvector diffMean = ExactMean - EstMean;
    <span class="comment">//cout &lt;&lt; diffMean &lt;&lt; endl;</span>

    <span class="keywordflow">if</span> (d == 1) {
      interval covarI = interval(EstCovar[0]);
      interval actualCovarI = interval(ExactCovar[0]);
      interval sumVar = covarI + actualCovarI;
      <span class="comment">//cout &lt;&lt; sumVar &lt;&lt; &quot;\t&quot;;</span>
      interval insqrt = 2*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(covarI)*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(actualCovarI)/sumVar;
      <span class="comment">//cout &lt;&lt; insqrt &lt;&lt; &quot;\t&quot;;</span>
      interval H2 = interval(1,1) - <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(insqrt) *<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>((-0.25*diffMean[1]*diffMean[1])/sumVar);
      <span class="comment">//cout &lt;&lt; &quot;H2: &quot; &lt;&lt; H2 &lt;&lt; endl;</span>
      HDActual = mid(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(H2));
    }

    <span class="keywordflow">else</span> {
      <span class="comment">//make a gsl matrix for the mean difference</span>
      gsl_matrix * diffMeanMat = gsl_matrix_alloc(d, 1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 1; j++) {
          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));
        }
      }
  
      <span class="comment">// initialize matrix objects</span>
      gsl_matrix * EstCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * ExactCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * PMat = gsl_matrix_alloc(d, d); <span class="comment">//make this same as CovarMat first</span>
    
      <span class="keywordtype">int</span> k = 0; <span class="comment">//counter for RealVec</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          gsl_matrix_set(EstCovarMat, i, j, _double(EstCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(PMat, i, j, _double(EstCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(ExactCovarMat, i, j, _double(ExactCovar[k])); <span class="comment">//cast to double</span>
          k++;
        }
      }
    
      <span class="comment">//add the two matrices</span>
      gsl_matrix_add(PMat, ExactCovarMat);
      gsl_matrix_scale(PMat, 0.5);
      <span class="comment">//cout &lt;&lt; &quot;add the two matrices: &quot; &lt;&lt; endl;</span>
    
      <span class="comment">// get the determinants </span>
      <span class="keywordtype">int</span> s;
      gsl_permutation * p = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(EstCovarMat, p, &amp;s);
      <span class="keywordtype">double</span> detCovarMat = gsl_linalg_LU_det(EstCovarMat, s);
      gsl_permutation_free(p);
    
      <span class="keywordtype">int</span> s1;
      gsl_permutation * p1 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(ExactCovarMat, p1, &amp;s1);
      <span class="keywordtype">double</span> detExactCovarMat = gsl_linalg_LU_det(ExactCovarMat, s1);
      gsl_permutation_free(p1);
    
      <span class="keywordtype">int</span> s2;
      gsl_permutation * p2 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(PMat, p2, &amp;s2);
      <span class="keywordtype">double</span> detPMat = gsl_linalg_LU_det(PMat, s2);
      
      <span class="comment">//cout &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detExactCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
    
      <span class="comment">//now get the inverse of P</span>
      gsl_matrix * Pinverse = gsl_matrix_alloc(d, d); 
      gsl_linalg_LU_invert(PMat, p2, Pinverse);
      gsl_permutation_free(p2);
    
    <span class="comment">/*</span>
<span class="comment">      cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    */</span>
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, d);
      gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);
    
      <span class="comment">// now convert all to rmatrix for easier computations</span>
      rmatrix diffMeanR(0, d-1, 0, 0);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 1; j++) {
          diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMat, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix diffMeanTransR(0, 0, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMatTranspose, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix PinvR(0, d-1, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); 
        }
      }
    
      <span class="comment">//free the gsl_matrices</span>
      gsl_matrix_free(EstCovarMat);
      gsl_matrix_free(ExactCovarMat);
      gsl_matrix_free(PMat);
    
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;
      <span class="comment">//cout &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
      real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(detCovarMat*detExactCovarMat));
      <span class="comment">//cout &lt;&lt; &quot;DB: &quot; &lt;&lt; DB &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> (DB &lt; 0) { HDTrue = 0.0; }
      <span class="keywordflow">else</span> {
        real BC = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-DB);
        assert(BC &gt;= 0);
        <span class="comment">//cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
        HDActual = <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1-BC);
        <span class="comment">//cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HDActual &lt;&lt; endl;</span>
        assert(HDActual &gt;=0);
      }
    }
    cout &lt;&lt; <span class="stringliteral">&quot;Hellinger distance: &quot;</span> &lt;&lt; HDActual &lt;&lt; endl;
  }


  <span class="comment">// actual vs true</span>
  {
    <span class="comment">//get the mean</span>
    rvector ActualMean = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a95d9506c9ceea0359b99b0e36f1eff91" title="Gets the mean from the root box of the paving this manages.">getRootPavingMean</a>();
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> ActualCovar = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2bbfcf884ee91c2457eb2e9d2b81e31f" title="Gets variance covariance vector from root box of rootpaving.">getRootPavingVarCovar</a>();

    <span class="comment">//get the mean</span>
    rvector TrueMean(d);
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= d; i++) { TrueMean[i] = 0.0; }

    <span class="comment">//get the differences of the mean vectors</span>
    rvector diffMean = ActualMean - TrueMean;

    <span class="keywordflow">if</span> (d == 1) {
      interval actualCovarI = interval(ActualCovar[0]);
      interval trueCovarI = interval(1.0);
      interval sumVar = trueCovarI + actualCovarI;
      interval insqrt = 2*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(trueCovarI)*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(actualCovarI)/sumVar;
      interval H2 = interval(1,1) - <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(insqrt) *<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>((-0.25*diffMean[1]*diffMean[1])/sumVar);
      HDTrueActual = mid(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(H2));
    }

    <span class="keywordflow">else</span> {
    <span class="comment">// get the variance-covariances</span>
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> TrueCovar;
    TrueCovar.reserve(d*d);

    <span class="comment">// fill in the matrix where the off-diag are 0</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; d*d; i++) {
        TrueCovar.push_back(0.0); <span class="comment">//first fill up the container with 1</span>
    }
    <span class="comment">// then fill up the diags with 1</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; d; i++) {
      <span class="keywordtype">int</span> pos = i*d + i;
      TrueCovar[pos] = 1.0;
    }
    
      <span class="comment">//make a gsl matrix for the mean difference</span>
      gsl_matrix * diffMeanMat = gsl_matrix_alloc(d, 1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 1; j++) {
          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));
        }
      }
  
      <span class="comment">// initialize matrix objects</span>
      gsl_matrix * TrueCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * ActualCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * PMat = gsl_matrix_alloc(d, d); <span class="comment">//make this same as CovarMat first</span>
    
      <span class="keywordtype">int</span> k = 0; <span class="comment">//counter for RealVec</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          gsl_matrix_set(ActualCovarMat, i, j, _double(ActualCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(PMat, i, j, _double(ActualCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(TrueCovarMat, i, j, _double(TrueCovar[k])); <span class="comment">//cast to double</span>
          k++;
        }
      }
    
      <span class="comment">//add the two matrices</span>
      gsl_matrix_add(PMat, TrueCovarMat);
      gsl_matrix_scale(PMat, 0.5);
      <span class="comment">//cout &lt;&lt; &quot;add the two matrices: &quot; &lt;&lt; endl;</span>
    
      <span class="comment">// get the determinants </span>
      <span class="keywordtype">int</span> s;
      gsl_permutation * p = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(ActualCovarMat, p, &amp;s);
      <span class="keywordtype">double</span> detCovarMat = gsl_linalg_LU_det(ActualCovarMat, s);
      gsl_permutation_free(p);
    
      <span class="keywordtype">int</span> s1;
      gsl_permutation * p1 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(TrueCovarMat, p1, &amp;s1);
      <span class="keywordtype">double</span> detExactCovarMat = gsl_linalg_LU_det(TrueCovarMat, s1);
      gsl_permutation_free(p1);
    
      <span class="keywordtype">int</span> s2;
      gsl_permutation * p2 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(PMat, p2, &amp;s2);
      <span class="keywordtype">double</span> detPMat = gsl_linalg_LU_det(PMat, s2);
      
      <span class="comment">//cout &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detExactCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
    
      <span class="comment">//now get the inverse of P</span>
      gsl_matrix * Pinverse = gsl_matrix_alloc(d, d); 
      gsl_linalg_LU_invert(PMat, p2, Pinverse);
      gsl_permutation_free(p2);
    <span class="comment">/*</span>
<span class="comment">      cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    */</span>
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, d);
      gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);
    
      <span class="comment">// now convert all to rmatrix for easier computations</span>
      rmatrix diffMeanR(0, d-1, 0, 0);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 1; j++) {
          diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMat, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix diffMeanTransR(0, 0, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMatTranspose, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix PinvR(0, d-1, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); 
        }
      }
    
      <span class="comment">//free the gsl_matrices</span>
      gsl_matrix_free(TrueCovarMat);
      gsl_matrix_free(ActualCovarMat);
      gsl_matrix_free(PMat);
    
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;
      <span class="comment">//cout &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
      real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(detCovarMat*detExactCovarMat));
      cout &lt;&lt; <span class="stringliteral">&quot;DB: &quot;</span> &lt;&lt; DB &lt;&lt; endl;
      <span class="keywordflow">if</span> (DB &lt; 0) { HDTrueActual = 0.0; }
      <span class="keywordflow">else</span> {
        real BC = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-DB);
        assert(BC &gt;= 0);
        <span class="comment">//cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
        HDTrueActual = <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1-BC);
        <span class="comment">//cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HDTrue &lt;&lt; endl;</span>
        assert(HDTrueActual &gt;=0);
      }
    }
    cout &lt;&lt; <span class="stringliteral">&quot;Hellinger distance: &quot;</span> &lt;&lt; HDTrueActual &lt;&lt; endl;
  }

  

  <span class="comment">//output Hellinger distances</span>
  <span class="keywordtype">string</span> filename;
  filename = <span class="stringliteral">&quot;HellingerDistance&quot;</span>;
  ostringstream stm;
  stm &lt;&lt; dataSeed;
  filename += stm.str();
  filename += <span class="stringliteral">&quot;.txt&quot;</span>;
  oss.open(filename.c_str());
  oss &lt;&lt; HDTrue &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; HDActual &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; HDTrueActual &lt;&lt; endl;
  oss &lt;&lt; flush;
  oss.close();
  

  <span class="comment">/*</span>
<span class="comment">  //optional </span>
<span class="comment">  string dataFileName = &quot;ActualData&quot;;</span>
<span class="comment">  dataFileName += stm.str(); </span>
<span class="comment">  dataFileName += &quot;.txt&quot;; </span>
<span class="comment">  oss.open(dataFileName.c_str());</span>
<span class="comment">  for (size_t i = 0; i &lt; n; i++) { </span>
<span class="comment">    for (size_t j = 1; j &lt;= d; j++) {</span>
<span class="comment">        oss &lt;&lt; (*actualDataPtr)[i][j] &lt;&lt; &quot;\t&quot;;</span>
<span class="comment">    }</span>
<span class="comment">    oss &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">    //cout &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">  }</span>
<span class="comment">  oss &lt;&lt; flush;</span>
<span class="comment">  oss.close();</span>
<span class="comment"></span>
<span class="comment">  cout &lt;&lt; &quot;Actual data written to  &quot; &lt;&lt; dataFileName &lt;&lt; endl;</span>
<span class="comment">  </span>
<span class="comment">  //optional </span>
<span class="comment">  dataFileName = &quot;MappedData&quot;;</span>
<span class="comment">  dataFileName += stm.str(); </span>
<span class="comment">  dataFileName += &quot;.txt&quot;; </span>
<span class="comment">  oss.open(dataFileName.c_str());</span>
<span class="comment">  for (size_t i = 0; i &lt; n; i++) { </span>
<span class="comment">    for (size_t j = 1; j &lt;= d; j++) {</span>
<span class="comment">        oss &lt;&lt; (*theDataPtr)[i][j] &lt;&lt; &quot;\t&quot;;</span>
<span class="comment">    }</span>
<span class="comment">    oss &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">    //cout &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">  }</span>
<span class="comment">  oss &lt;&lt; flush;</span>
<span class="comment">  oss.close();</span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;Estimated data written to  &quot; &lt;&lt; dataFileName &lt;&lt; endl;</span>
<span class="comment">  */</span>

  <span class="keyword">delete</span> estimateHist;
  <span class="keyword">delete</span> actualHist;
  <span class="keyword">delete</span> actualDataPtr;
  <span class="keyword">delete</span> theDataPtr;

  <span class="keywordflow">return</span> 0;
} <span class="comment">// end of MCMC test program</span>
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="MCMCFunctionSimGaussian_8cpp.shtml">MCMCFunctionSimGaussian.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:22 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
