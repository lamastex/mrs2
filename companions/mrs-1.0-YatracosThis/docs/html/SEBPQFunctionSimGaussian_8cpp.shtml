<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: SEBPQFunctionSimGaussian.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('SEBPQFunctionSimGaussian_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SEBPQFunctionSimGaussian.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Testing StatsSubPavings (aka SPSnodes) with SEB-PQ and Gaussian data generated from a function estimate.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="histall_8hpp_source.shtml">histall.hpp</a>&quot;</code><br/>
<code>#include &quot;intervalmappedspnode_measurers.hpp&quot;</code><br/>
<code>#include &quot;functionestimator_interval.hpp&quot;</code><br/>
<code>#include &quot;<a class="el" href="piecewise__constant__function_8hpp_source.shtml">piecewise_constant_function.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="GaussianFobj_8hpp_source.shtml">GaussianFobj.hpp</a>&quot;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
</div>
<p><a href="SEBPQFunctionSimGaussian_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SEBPQFunctionSimGaussian_8cpp.shtml#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Testing StatsSubPavings (aka SPSnodes) with SEB-PQ and Gaussian data generated from a function estimate. </p>

<p>Definition in file <a class="el" href="SEBPQFunctionSimGaussian_8cpp_source.shtml">SEBPQFunctionSimGaussian.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="SEBPQFunctionSimGaussian.cpp::main" ref="a0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ImageSetDiff_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="SEBPQFunctionSimGaussian_8cpp_source.shtml#l00046">46</a> of file <a class="el" href="SEBPQFunctionSimGaussian_8cpp_source.shtml">SEBPQFunctionSimGaussian.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">subpavings::AdaptiveHistogram::getRootBox()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375">subpavings::PiecewiseConstantFunction::getTotalIntegral()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">subpavings::AdaptiveHistogram::insertFromRVec()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">subpavings::PiecewiseConstantFunction::normalise()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01781">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854">subpavings::PiecewiseConstantFunction::simulateData()</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::TXT</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// sort out user-defined parameters------------------//</span>
  <span class="keywordflow">if</span> ( argc &lt; 17 ) {
    cerr &lt;&lt; <span class="stringliteral">&quot;Syntax: &quot;</span> &lt;&lt; argv[0] &lt;&lt; 
    <span class="stringliteral">&quot;d maxLeavesEst n states symmetryIndicator seed burnin thinout [log_full]&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Syntax: &quot;</span> + std::string(argv[0]) + <span class="stringliteral">&quot;d n states, symmetryIndicator&quot;</span>);
  }
  
  <span class="keywordtype">int</span> d = atoi(argv[1]);  <span class="comment">// dimensions</span>
  <span class="keywordtype">size_t</span> maxLeavesEst = atoi(argv[2]);  <span class="comment">// number of leaves in estimator</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = atoi(argv[3]);  <span class="comment">// number of points to generate</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loops = atoi(argv[4]); <span class="comment">// number of states to loop through</span>
  <span class="keywordtype">int</span> symmetryIndicator = atoi(argv[5]); <span class="comment">// 1 for symmetric, 0 otherwise</span>
  <span class="keywordtype">int</span> dataSeed = atoi(argv[6]); <span class="comment">// seed for data generation</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> burnin = atoi(argv[7]); 
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> thinout = atoi(argv[8]); 

  <span class="keywordtype">size_t</span> hist1Crit = atoi(argv[9]);
  <span class="keywordtype">size_t</span> hist2Crit = atoi(argv[10]);
  <span class="keywordtype">size_t</span> hist3Crit = atoi(argv[11]);
  
  <span class="keywordtype">size_t</span> hist1CritLeaf = atoi(argv[12]);
  <span class="keywordtype">size_t</span> hist2CritLeaf = atoi(argv[13]);
  
  <span class="keywordtype">size_t</span> NumStatesChosen = atoi(argv[14]);
  
  <span class="keywordtype">bool</span> computeIAE = atoi(argv[15]);
  
  <span class="keywordtype">bool</span> minVolControl = atoi(argv[16]);
  
  <span class="keywordtype">size_t</span> minPoints = 1;
  <span class="keywordtype">size_t</span> minPQPoints1 = 1;
  <span class="keywordtype">size_t</span> minPQPoints2 = 1;
  <span class="keywordtype">size_t</span> minPQPoints3 = 1;

  <span class="keywordtype">bool</span> shiftCatalan = 0;

  <span class="comment">/* for logging to output the logposterior for the sample average and current state */</span>
  <span class="comment">/* use LOGSTATETRACE only for current state */</span>
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logging = LOGSTATETRACE;
  <span class="keywordflow">if</span> ( argc &gt; 17 &amp;&amp; atoi( argv[17] ) ) logging = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a>;

  cout &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; : process id is &quot;</span> &lt;&lt; getpid() &lt;&lt; std::endl;

  <span class="comment">// set up proposal distribution object</span>
  <a class="code" href="classsubpavings_1_1UniformProposal.shtml">UniformProposal</a> proposal;
  <span class="comment">// set up prior distribution object</span>
  <a class="code" href="classsubpavings_1_1LogCatalanPrior.shtml" title="A class for a log prior based on a Catalan number prior.">LogCatalanPrior</a> logPrior;
    
  interval pavingIntervalSym(-6,6);
  interval pavingIntervalNonSym(-6.5,7);

  interval pavingInterval = pavingIntervalSym; <span class="comment">// if we are doing symmetric case</span>
  <span class="comment">// but if we&#39;ve asked for non-symmetric, change this</span>
  <span class="keywordflow">if</span> (!symmetryIndicator) pavingInterval = pavingIntervalNonSym;

  <span class="comment">// for output purposes</span>
  <span class="comment">// string formatting</span>
  ofstream oss;         <span class="comment">// ofstream object</span>
   oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
   oss.precision(10);

  <span class="comment">//=======get the root box from the actual data==============//</span>
  <span class="comment">// set up a random number generator and use mt19937 for generator</span>
  gsl_rng * r = gsl_rng_alloc (gsl_rng_mt19937); <span class="comment">// set up with default seed</span>
  <span class="comment">//long unsigned int seed = 1234;</span>
  gsl_rng_set (r, dataSeed); <span class="comment">// change the seed</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Data seed is &quot;</span> &lt;&lt; dataSeed &lt;&lt; endl;
  
  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>* tempDataPtr = <span class="keyword">new</span> <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>;

  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; i++) {
    rvector thisrv(d);
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt;= d; j++) {
      <span class="comment">//double z = gsl_rng_uniform(r);</span>
      <span class="keywordtype">double</span> z = gsl_ran_gaussian(r, 1.0); <span class="comment">// generate a normal r.v.</span>
      thisrv[j] = (z);
    }
    <span class="comment">// put points generated into container</span>
    tempDataPtr-&gt;push_back(thisrv);
  }

  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>* tempHist = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>; 
  tempHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*tempDataPtr);
  ivector pavingBoxEst = tempHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a936a3426494278163afada104df26ecc" title="Get the box of the subpaving managed by this.">getRootBox</a>();
  <span class="keyword">delete</span> tempHist;
  <span class="comment">//delete tempDataPtr;</span>
  <span class="comment">//=========end of getting a root box from the actual data=============</span>
  
  <span class="comment">//============== make estimate ============//</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nMake the function estimator to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
  
  <span class="comment">// specify function object (from /examples/MappedTargets</span>
  <a class="code" href="classsubpavings_1_1GaussianFobj.shtml">GaussianFobj</a> fobj;
  
  <span class="comment">/* function estimate is going to use same box as the histograms */</span>
  <span class="comment">//ivector pavingBoxEst(d);</span>
  <span class="comment">//for(int k=1; k &lt;= d; k++) pavingBoxEst[k] = pavingInterval;</span>
  
  <span class="comment">// Use fobj and pavingBox to get an estimator</span>
  FunctionEstimatorInterval estimator(pavingBoxEst, fobj);
  
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logEst = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; <span class="comment">// logging for making estimator</span>
  
<span class="preprocessor">  #if(1)</span>
<span class="preprocessor"></span>  <span class="keywordtype">size_t</span> maxLeavesEstDown = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(1.2*maxLeavesEst); <span class="comment">// go down to 1.2 x max</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span><span class="preprocessor">  #if(0)</span>
<span class="preprocessor"></span>    <span class="keywordtype">size_t</span> maxLeavesEstDown = maxLeavesEst;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;pq down to max leaves &quot;</span> &lt;&lt; maxLeavesEstDown &lt;&lt; endl;
  
  clock_t startEst = clock();
  
  <span class="comment">// priority split driven by splitting leaf with max reimann diff</span>
  ReimannDiffMeasurer measurer;
  estimator.prioritySplit(measurer, maxLeavesEstDown, logEst);
      
  <span class="comment">// stop recording time here</span>
  clock_t endEst = clock();
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves in estimate: &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;  
  cout &lt;&lt; <span class="stringliteral">&quot;After split, getTotalAreaOfIntervalBand() = &quot;</span>
    &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
  <span class="keywordtype">double</span> timingEst1 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for pq split in estimate: &quot;</span> &lt;&lt; timingEst1 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  startEst = clock();
  
<span class="preprocessor">  #if(1) </span>
<span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;Hull propagation&quot;</span> &lt;&lt; endl;
    estimator.hullPropagation();
    
    cout &lt;&lt; <span class="stringliteral">&quot;Priority merge to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
<span class="preprocessor">    #if(0)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by minimising increase the reimann diff</span>
    estimator.priorityMergeOnLoss(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span><span class="preprocessor">    #if(1)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by merging cherry with minimum reimann diff</span>
    estimator.priorityMerge(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>          
    <span class="comment">// stop recording time here</span>
    endEst = clock(); 
    <span class="keywordtype">double</span> timingEst2 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
    cout &lt;&lt; <span class="stringliteral">&quot;Computing time for hull propagate and merge up in estimate: &quot;</span> &lt;&lt; timingEst2 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
    
    cout &lt;&lt; <span class="stringliteral">&quot;After propagation and priority merge, getTotalAreaOfIntervalBand() = &quot;</span> 
          &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;number of leaves is = &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;Making estimate and normalising&quot;</span> &lt;&lt; endl;
  <span class="comment">// Make PiecewiseConstantFunction estimate from estimator</span>
  <a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> estimate = estimator.makePiecewiseConstantFunction();
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">normalise</a>();
  
  cout &lt;&lt; <span class="stringliteral">&quot;estimate has integral &quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; endl;

  <span class="comment">//===========end of estimating function using PCF=========================//</span>

  <span class="comment">//===========generate data==============================================//</span>
  <span class="comment">// Use PiecewiseConstantFunction to generate data, supplying our own rng</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nGenerating data for simulation&quot;</span> &lt;&lt; endl;

  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>* theDataPtr = <span class="keyword">new</span> <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>;   <span class="comment">// a container for all the points generated</span>

  clock_t startData = clock();

  <span class="comment">// Gaussian data</span>
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854" title="Simulator taking a random number generator argument.">simulateData</a>(*theDataPtr, n, r);

  <span class="comment">// stop recording time here</span>
  clock_t endData = clock();  
  <span class="keywordtype">double</span> timingData = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endData - startData)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for simulating data: &quot;</span> &lt;&lt; timingData &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;

  cout &lt;&lt; (*theDataPtr).size() &lt;&lt; <span class="stringliteral">&quot; points generated&quot;</span> &lt;&lt; endl;
  
  <span class="keywordflow">try</span> {
    gsl_rng_free (r);
    r = NULL;
  }
  <span class="keywordflow">catch</span>(...) {}<span class="comment">// catch and swallow</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;\nStart example: n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; and d = &quot;</span> &lt;&lt; d &lt;&lt; endl;
  <span class="comment">//cout &lt;&lt; &quot;Paving interval is &quot; &lt;&lt; pavingInterval &lt;&lt; endl;</span>

  <span class="comment">//===========end of generating data=================================//</span>

  <span class="keywordtype">int</span> numFunc = 1;
  
  ostringstream stmSeed;
  stmSeed &lt;&lt; dataSeed;

  <span class="comment">// parameters needed to start the PQ</span>
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logPQ = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; <span class="comment">// logging level  </span>
  <a class="code" href="classsubpavings_1_1CompVol.shtml" title="Class comparing on volume of box of node.">CompVol</a> comp2; 
  CompVolMassMinus comp1;
  <a class="code" href="classsubpavings_1_1CompCount.shtml" title="Class comparing on count of data points associated with a node.">CompCount</a> compCount;
  vector&lt;real&gt; IAEContainer; <span class="comment">//for MCMC </span>
  vector&lt;double&gt; Times; <span class="comment">// for MCMC times</span>

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> func = 0; func &lt; numFunc; func++) {
    
    <span class="keywordtype">double</span> minVolB = 0.0;
    
    cout &lt;&lt; <span class="stringliteral">&quot;\n========Function : &quot;</span> &lt;&lt; func &lt;&lt; <span class="stringliteral">&quot;========&quot;</span> &lt;&lt; endl; 
    ostringstream stm;
    stm &lt;&lt; func; <span class="comment">// for output purposes</span>
    vector&lt;size_t&gt; LeafContainer; <span class="comment">// to store the number of leaf nodes from which the optimal posterior support is at</span>
    
    <span class="comment">// make an Adaptive Histogram with the given pavingBox and, by default,</span>
    <span class="comment">// holdAllStats = false so that the underlying rootPaving managed by the</span>
    <span class="comment">// myHistFirst will not maintain all available stats, only counts</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myHistFirst(pavingBoxEst); <span class="comment">// still let the data decide the box</span>

    <span class="comment">// put in the data in a &#39;pulse&#39; with no splitting, ie into root box</span>
    <span class="keywordtype">bool</span> successfulInsertion = myHistFirst.insertFromRVec(*tempDataPtr);

    <span class="keywordflow">if</span> (successfulInsertion) {

      vector&lt;real&gt; ChosenStateMaxPosterior;
      vector&lt;AdaptiveHistogram&gt; ChosenStateSubset;

      <span class="comment">//===== start the SEB-PQ from the root node as a sanity check====//</span>
      {
      cout &lt;&lt; <span class="stringliteral">&quot;Starting the SEB-PQ from the root node:&quot;</span> &lt;&lt; endl;
      <span class="comment">// initialize containers</span>
      vector&lt;real&gt; PosteriorChosen;
      vector&lt;double&gt; EmptyBoxChosen;
      vector&lt;real&gt; PosteriorSupportChosen;
      vector&lt;real&gt; IAEContainerChosen;

      <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHist(pavingBoxEst);
      myChosenHist.insertFromRVec(*tempDataPtr);

      <span class="comment">//CritLargestCount_LTE critStop(hist3Crit);</span>
      <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critStop(hist3Crit);
      cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ to &quot;</span>  &lt;&lt; (hist3Crit) &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
      <span class="keywordtype">int</span> Txt = 9000 + func*100 + NumStatesChosen;
      <span class="keywordflow">if</span> (func == 0) {
        myChosenHist.prioritySplitMCMC(compCount, critStop, 
        logPQ, minPQPoints1, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, 
        PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, <span class="keyword">true</span>);
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
        myChosenHist.prioritySplitMCMC(compCount, critStop, 
        logPQ, minPQPoints2, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, 
        PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, <span class="keyword">true</span>);
      }

        cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ done!&quot;</span> &lt;&lt; endl;
    <span class="comment">//  myChosenHist.outputToTxtTabs(&quot;Hist1.txt&quot;);</span>
      }
      <span class="comment">/*</span>
<span class="comment">      //get the minimum volume</span>
<span class="comment">      if (minVolControl == true) {</span>
<span class="comment">        minVolB = myChosenHist.getBoxMinVol();</span>
<span class="comment">        cout &lt;&lt; &quot;Minimum volume: &quot; &lt;&lt; minVolB &lt;&lt; endl; </span>
<span class="comment">      }</span>
<span class="comment">      else { minVolB = 0.0; }</span>
<span class="comment">      </span>
<span class="comment">      </span>
<span class="comment">      ostringstream stm1;</span>
<span class="comment">      stm1 &lt;&lt; NumStatesChosen;</span>
<span class="comment">      */</span>
      
      
      <span class="comment">/*</span>
<span class="comment">      // optional</span>
<span class="comment">      // output log-posterior</span>
<span class="comment">      string PostFileName = &quot;PosteriorChosen&quot;;</span>
<span class="comment">      PostFileName += stm.str(); //for func</span>
<span class="comment">      PostFileName += stm1.str(); </span>
<span class="comment">      PostFileName += &quot;.txt&quot;;</span>
<span class="comment">      oss.open(PostFileName.c_str());</span>
<span class="comment">      for (size_t i = 0; i &lt; PosteriorChosen.size(); i++) {</span>
<span class="comment">        oss &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;</span>
<span class="comment">      }</span>
<span class="comment">      oss &lt;&lt; flush;</span>
<span class="comment">      oss.close();</span>
<span class="comment"></span>
<span class="comment">      // output support log-posterior </span>
<span class="comment">      PostFileName = &quot;PosteriorSupportChosen&quot;;</span>
<span class="comment">      PostFileName += stm.str();</span>
<span class="comment">      PostFileName += stm1.str();</span>
<span class="comment">      PostFileName += &quot;.txt&quot;;</span>
<span class="comment">      oss.open(PostFileName.c_str());</span>
<span class="comment">      for (size_t i = 0; i &lt; PosteriorSupportChosen.size(); i++) {</span>
<span class="comment">        oss &lt;&lt; PosteriorSupportChosen[i] &lt;&lt; endl;</span>
<span class="comment">      }</span>
<span class="comment">      oss &lt;&lt; flush;</span>
<span class="comment">      oss.close();</span>
<span class="comment">  </span>
<span class="comment">      // output the cumulative ratio of empty boxes</span>
<span class="comment">      EmptyFileName = &quot;EmptyChosen&quot;;</span>
<span class="comment">      EmptyFileName += stm.str();</span>
<span class="comment">      EmptyFileName += stm1.str();</span>
<span class="comment">      EmptyFileName += &quot;.txt&quot;;</span>
<span class="comment">      oss.open(EmptyFileName.c_str());</span>
<span class="comment">      for (size_t i = 0; i &lt; EmptyBoxChosen.size(); i++) {</span>
<span class="comment">        oss &lt;&lt; EmptyBoxChosen[i] &lt;&lt; endl;</span>
<span class="comment">      }</span>
<span class="comment">      oss &lt;&lt; flush;</span>
<span class="comment">      oss.close();</span>
<span class="comment">      */</span>

<span class="comment">/*</span>
<span class="comment">      //output IAE from second stage</span>
<span class="comment">      string IAEFileName = &quot;IAEPQChosen&quot;;</span>
<span class="comment">      IAEFileName += stmSeed.str();</span>
<span class="comment">      IAEFileName += stm1.str();</span>
<span class="comment">      IAEFileName += &quot;.txt&quot;;</span>
<span class="comment">      oss.open(IAEFileName.c_str());</span>
<span class="comment">      for (size_t i = 0; i &lt; IAEContainerChosen.size(); i++) {</span>
<span class="comment">        oss &lt;&lt; IAEContainerChosen[i] &lt;&lt; endl;</span>
<span class="comment">      }</span>
<span class="comment">      oss &lt;&lt; flush;</span>
<span class="comment">      oss.close();</span>
<span class="comment"></span>
<span class="comment">      // get the max position for this sub-set</span>
<span class="comment">      size_t maxPosition = 0;</span>
<span class="comment">      real maxPosterior = -1*(numeric_limits&lt;double&gt;::infinity());</span>
<span class="comment">      for (size_t i = 0; i &lt; PosteriorChosen.size(); i++) {</span>
<span class="comment">        //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;</span>
<span class="comment">        if (PosteriorChosen[i] &gt; maxPosterior) {</span>
<span class="comment">          maxPosterior = PosteriorChosen[i];</span>
<span class="comment">          maxPosition = i;</span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">      cout &lt;&lt; &quot;SEB-PQ from root node has log-posterior highest at index &quot; &lt;&lt; maxPosition;</span>
<span class="comment">      ChosenStateMaxPosterior.push_back(PosteriorChosen[maxPosition]);</span>
<span class="comment"></span>
<span class="comment">      // now get the posterior-optimal histogram for this subset using PQ-SEB</span>
<span class="comment">      AdaptiveHistogram myChosenHistSubset(pavingBoxEst);</span>
<span class="comment">      myChosenHistSubset.insertFromRVec(*theDataPtr);</span>
<span class="comment">      // be careful here</span>
<span class="comment">      CritLeaves_GTE critValMaxSubset(maxPosition+1);</span>
<span class="comment">      </span>
<span class="comment">      if (func == 0) {</span>
<span class="comment">        myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, </span>
<span class="comment">        logPQ, minPQPoints1);</span>
<span class="comment">      }</span>
<span class="comment">      else if (func == 1) {</span>
<span class="comment">        myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, </span>
<span class="comment">        logPQ, minPQPoints2);</span>
<span class="comment">      }</span>
<span class="comment">      cout &lt;&lt; &quot; and has &quot; &lt;&lt; myChosenHistSubset.getRootLeaves() &lt;&lt; &quot; leaf nodes.&quot; &lt;&lt; endl;</span>
<span class="comment">      //keep this histogram in a container</span>
<span class="comment">      ChosenStateSubset.push_back(myChosenHistSubset);</span>
<span class="comment">      cout &lt;&lt; &quot;-----------------------------&quot; &lt;&lt; endl;</span>
<span class="comment">      }</span>
<span class="comment">      //-------------end of getting from the root node------------------//</span>
<span class="comment"></span>
<span class="comment">      //===========A carved-in PQ======================//</span>
<span class="comment">      size_t histCrit;</span>
<span class="comment">      if (func == 0) { histCrit = hist1Crit; }</span>
<span class="comment">      else if (func==1) { histCrit = hist2Crit; }</span>
<span class="comment">      CritLeaves_GTE critStop(histCrit);</span>
<span class="comment">      cout &lt;&lt; &quot;Carving-in PQ to &quot;  &lt;&lt; histCrit &lt;&lt; &quot; leaves&quot; &lt;&lt; endl;</span>
<span class="comment"></span>
<span class="comment">      //containers to store needed outputs</span>
<span class="comment">      vector&lt;real&gt; Posterior;</span>
<span class="comment">      vector&lt;real&gt; PosteriorSupport;</span>
<span class="comment">      vector&lt;double&gt; EmptyBox;</span>
<span class="comment">      int Txt = func;</span>
<span class="comment">      vector&lt;real&gt; IAEPQContainer;</span>
<span class="comment"></span>
<span class="comment">      bool successfulHist = false;</span>
<span class="comment">      // start the carving PQ here</span>
<span class="comment">      if (func == 0) {</span>
<span class="comment">        successfulHist = myHistFirst.prioritySplitMCMC(comp1, critStop, </span>
<span class="comment">        logPQ, minPQPoints1, minVolB, Posterior, logPrior, Txt, EmptyBox, </span>
<span class="comment">        PosteriorSupport, IAEPQContainer, estimate, shiftCatalan, false);</span>
<span class="comment">      }</span>
<span class="comment">      else if (func == 1) {</span>
<span class="comment">        successfulHist = myHistFirst.prioritySplitMCMC(comp2, critStop, </span>
<span class="comment">        logPQ, minPQPoints2, minVolB, Posterior, logPrior, Txt, EmptyBox,</span>
<span class="comment">        PosteriorSupport, IAEPQContainer, estimate, shiftCatalan, false);</span>
<span class="comment">      }</span>
<span class="comment"></span>
<span class="comment">      if (successfulHist) {</span>
<span class="comment">        </span>
<span class="comment">        /*</span>
<span class="comment">        // output log-posterior</span>
<span class="comment">        string PostFileName;</span>
<span class="comment">        PostFileName = &quot;Posterior&quot;;</span>
<span class="comment">        PostFileName += stm.str();</span>
<span class="comment">        PostFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(PostFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; Posterior.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; Posterior[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        </span>
<span class="comment">        </span>
<span class="comment">        // output support log-posterior </span>
<span class="comment">        PostFileName = &quot;PosteriorSupport&quot;;</span>
<span class="comment">        PostFileName += stm.str();</span>
<span class="comment">        PostFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(PostFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; PosteriorSupport.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; PosteriorSupport[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        </span>
<span class="comment">        </span>
<span class="comment">        // output the cumulative ratio of empty boxes</span>
<span class="comment">        string EmptyFileName;</span>
<span class="comment">        EmptyFileName = &quot;Empty&quot;;</span>
<span class="comment">        EmptyFileName += stm.str();</span>
<span class="comment">        EmptyFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(EmptyFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; EmptyBox.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; EmptyBox[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        </span>
<span class="comment">        </span>
<span class="comment">        //output IAE from second stage</span>
<span class="comment">        string IAEFileName = &quot;IAEPQZoomIn&quot;;</span>
<span class="comment">        IAEFileName += stm.str();</span>
<span class="comment">        IAEFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(IAEFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; IAEPQContainer.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; IAEPQContainer[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        */</span>
        <span class="comment">//=============end of carving in====================//</span>
  <span class="comment">/*      </span>
<span class="comment">        //==== get K number of states with a local highest posterior ====//</span>
<span class="comment">        cout &lt;&lt; &quot;Choosing &quot; &lt;&lt; NumStatesChosen &lt;&lt; &quot; states&quot; &lt;&lt; endl;</span>
<span class="comment">        for (size_t j = 0; j &lt; NumStatesChosen; j++) {</span>
<span class="comment">          ostringstream stmj;</span>
<span class="comment">          stmj &lt;&lt; j;</span>
<span class="comment">          int step = int(1.0*PosteriorSupport.size()/(1.0*NumStatesChosen));</span>
<span class="comment">          //find where the posterior/log-posterior/emptyVol is the highest</span>
<span class="comment">          size_t maxPosition = 0;</span>
<span class="comment">          real maxPosterior = -1*(numeric_limits&lt;double&gt;::infinity());</span>
<span class="comment">          for (size_t i = 0; i &lt; step; i++) {</span>
<span class="comment">            size_t thisPosition = j*step + i;</span>
<span class="comment">            //cout &lt;&lt; thisPosition &lt;&lt; &quot;\t&quot; &lt;&lt; PosteriorSupport[thisPosition] &lt;&lt; endl;</span>
<span class="comment">            if (PosteriorSupport[thisPosition] &gt; maxPosterior) {</span>
<span class="comment">              maxPosterior = PosteriorSupport[thisPosition];</span>
<span class="comment">              maxPosition = thisPosition;</span>
<span class="comment">            }</span>
<span class="comment">          }</span>
<span class="comment">          cout &lt;&lt; &quot;----------------------------------&quot; &lt;&lt; endl;</span>
<span class="comment">          //cout &lt;&lt; j &lt;&lt; &quot;-th subset: &quot;&lt;&lt; endl;</span>
<span class="comment">          cout &lt;&lt; &quot;log posterior highest at split &quot; &lt;&lt; maxPosition;</span>
<span class="comment">          CritLeaves_GTE critValMax(maxPosition+1);</span>
<span class="comment">          LeafContainer.push_back(maxPosition+1);</span>
<span class="comment"></span>
<span class="comment">          // now get the posterior-optimal histogram</span>
<span class="comment">          AdaptiveHistogram myChosenHist(pavingBoxEst);</span>
<span class="comment">          myChosenHist.insertFromRVec(*theDataPtr);</span>
<span class="comment">          </span>
<span class="comment">          // get the corresponding histogram</span>
<span class="comment">          if (func == 0) {</span>
<span class="comment">            myChosenHist.prioritySplit(comp1, critValMax, logPQ, minPQPoints1);</span>
<span class="comment">          }</span>
<span class="comment">          else if (func == 1) {</span>
<span class="comment">            myChosenHist.prioritySplit(comp2, critValMax, logPQ, minPQPoints2);</span>
<span class="comment">          }</span>
<span class="comment">          size_t chosenHistLeaves = myChosenHist.getRootLeaves(); </span>
<span class="comment">          cout &lt;&lt; &quot; and has &quot; &lt;&lt; chosenHistLeaves &lt;&lt; &quot; leaf nodes.&quot; &lt;&lt; endl;</span>
<span class="comment">          //optional hist output</span>
<span class="comment">          //myChosenHist.outputToTxtTabs(&quot;SelectedCarvedHistogram.txt&quot;);</span>
<span class="comment">          </span>
<span class="comment">          //========SEB-PQ from chosen histograms======================//</span>
<span class="comment">          // initialize containers</span>
<span class="comment">          vector&lt;real&gt; PosteriorChosen;</span>
<span class="comment">          vector&lt;double&gt; EmptyBoxChosen;</span>
<span class="comment">          vector&lt;real&gt; PosteriorSupportChosen;</span>
<span class="comment">          vector&lt;real&gt; IAEContainerChosen;</span>
<span class="comment"></span>
<span class="comment">          if (func == 0) { histCrit = hist1CritLeaf; }</span>
<span class="comment">          else if (func==1) { histCrit = hist2CritLeaf; }</span>
<span class="comment">          CritLargestCount_LTE critLeaf(histCrit);</span>
<span class="comment">          cout &lt;&lt; &quot;SEB-PQ to at most &quot;  &lt;&lt; (histCrit) &lt;&lt; &quot; points in each node&quot; &lt;&lt; endl;</span>
<span class="comment">          Txt = 900 + func*10 + j;</span>
<span class="comment"></span>
<span class="comment">          if (func == 0) {</span>
<span class="comment">            successfulHist = myChosenHist.prioritySplitMCMC(compCount, critLeaf, </span>
<span class="comment">            logPQ, minPQPoints1, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, </span>
<span class="comment">            PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, false);</span>
<span class="comment">          }</span>
<span class="comment">          else if (func == 1) {</span>
<span class="comment">            successfulHist = myChosenHist.prioritySplitMCMC(compCount, critLeaf, </span>
<span class="comment">            logPQ, minPQPoints2, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, </span>
<span class="comment">            PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, false);</span>
<span class="comment">          }</span>
<span class="comment">          </span>
<span class="comment">          /*</span>
<span class="comment">          // optional</span>
<span class="comment">          // output log-posterior</span>
<span class="comment">          PostFileName = &quot;PosteriorChosen&quot;;</span>
<span class="comment">          PostFileName += stm.str(); //for func</span>
<span class="comment">          PostFileName += stmj.str(); //for j</span>
<span class="comment">          PostFileName += &quot;.txt&quot;;</span>
<span class="comment">          oss.open(PostFileName.c_str());</span>
<span class="comment">          for (size_t i = 0; i &lt; PosteriorChosen.size(); i++) {</span>
<span class="comment">            oss &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;</span>
<span class="comment">          }</span>
<span class="comment">          oss &lt;&lt; flush;</span>
<span class="comment">          oss.close();</span>
<span class="comment"></span>
<span class="comment">          // output support log-posterior </span>
<span class="comment">          PostFileName = &quot;PosteriorSupportChosen&quot;;</span>
<span class="comment">          PostFileName += stm.str();</span>
<span class="comment">          PostFileName += stmj.str();</span>
<span class="comment">          PostFileName += &quot;.txt&quot;;</span>
<span class="comment">          oss.open(PostFileName.c_str());</span>
<span class="comment">          for (size_t i = 0; i &lt; PosteriorSupportChosen.size(); i++) {</span>
<span class="comment">            oss &lt;&lt; PosteriorSupportChosen[i] &lt;&lt; endl;</span>
<span class="comment">          }</span>
<span class="comment">          oss &lt;&lt; flush;</span>
<span class="comment">          oss.close();</span>
<span class="comment">  </span>
<span class="comment">          // output the cumulative ratio of empty boxes</span>
<span class="comment">          EmptyFileName = &quot;EmptyChosen&quot;;</span>
<span class="comment">          EmptyFileName += stm.str();</span>
<span class="comment">          EmptyFileName += stmj.str();</span>
<span class="comment">          EmptyFileName += &quot;.txt&quot;;</span>
<span class="comment">          oss.open(EmptyFileName.c_str());</span>
<span class="comment">          for (size_t i = 0; i &lt; EmptyBoxChosen.size(); i++) {</span>
<span class="comment">            oss &lt;&lt; EmptyBoxChosen[i] &lt;&lt; endl;</span>
<span class="comment">          }</span>
<span class="comment">          oss &lt;&lt; flush;</span>
<span class="comment">          oss.close();</span>
<span class="comment">          */</span>
          <span class="comment">/*</span>
<span class="comment">          //output IAE from second stage</span>
<span class="comment">          string IAEFileName = &quot;IAEPQChosen&quot;;</span>
<span class="comment">          IAEFileName += stm.str();</span>
<span class="comment">          IAEFileName += stmj.str();</span>
<span class="comment">          IAEFileName += &quot;.txt&quot;;</span>
<span class="comment">          oss.open(IAEFileName.c_str());</span>
<span class="comment">          for (size_t i = 0; i &lt; IAEContainerChosen.size(); i++) {</span>
<span class="comment">            oss &lt;&lt; IAEContainerChosen[i] &lt;&lt; endl;</span>
<span class="comment">          }</span>
<span class="comment">          oss &lt;&lt; flush;</span>
<span class="comment">          oss.close();</span>
<span class="comment">          */</span>
          <span class="comment">// get the max position for this sub-set</span>
    <span class="comment">/*      maxPosition = 0;</span>
<span class="comment">          for (size_t i = 0; i &lt; PosteriorChosen.size(); i++) {</span>
<span class="comment">            //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; PosteriorChosen[i] &lt;&lt; endl; </span>
<span class="comment">            if (PosteriorChosen[i] &gt; maxPosterior) {</span>
<span class="comment">              maxPosterior = PosteriorChosen[i];</span>
<span class="comment">              maxPosition = i;</span>
<span class="comment">            }</span>
<span class="comment">          }</span>
<span class="comment">          cout &lt;&lt; &quot;SEB-PQ using carved support has log-posterior highest at index &quot; &lt;&lt; maxPosition;</span>
<span class="comment">          ChosenStateMaxPosterior.push_back(PosteriorChosen[maxPosition]);</span>
<span class="comment">          </span>
<span class="comment">          // now get the posterior-optimal histogram for this subset using PQ-SEB</span>
<span class="comment">          AdaptiveHistogram myChosenHistSubset(pavingBoxEst);</span>
<span class="comment">          myChosenHistSubset.insertFromRVec(*theDataPtr);</span>
<span class="comment">          // be careful here</span>
<span class="comment">          CritLeaves_GTE critValMaxSubset(chosenHistLeaves+maxPosition);</span>
<span class="comment">          </span>
<span class="comment">          if (func == 0) {</span>
<span class="comment">            myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, </span>
<span class="comment">            logPQ, minPQPoints1);</span>
<span class="comment">          }</span>
<span class="comment">          else if (func == 1) {</span>
<span class="comment">            myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, </span>
<span class="comment">            logPQ, minPQPoints2);</span>
<span class="comment">          }</span>
<span class="comment">          cout &lt;&lt; &quot; and has &quot; &lt;&lt; myChosenHistSubset.getRootLeaves() &lt;&lt; &quot; leaf nodes.&quot; &lt;&lt; endl;</span>
<span class="comment">          //keep this histogram in a container</span>
<span class="comment">          ChosenStateSubset.push_back(myChosenHistSubset);</span>
<span class="comment">        } // end of going through NumStatesChosen</span>
<span class="comment">        cout &lt;&lt; &quot;-----------------------------------------------&quot; &lt;&lt; endl;</span>
<span class="comment">        //========end of selecting K sub-sets===========================//</span>
<span class="comment"></span>
<span class="comment">        //=======find the maximum over the maximum======================//</span>
<span class="comment">        cout &lt;&lt; &quot;-----------------------------&quot; &lt;&lt; endl;</span>
<span class="comment">        // find which subset gives the maximum posterior</span>
<span class="comment">        cout &lt;&lt; &quot;Find the maximum over the maximum log-posteriors: &quot; &lt;&lt; endl;</span>
<span class="comment">        int maxPosition = 0;</span>
<span class="comment">        real maxPosterior=-1*(numeric_limits&lt;double&gt;::infinity());</span>
<span class="comment">        if ( ChosenStateMaxPosterior.size() != (1+NumStatesChosen) ) {</span>
<span class="comment">          cerr &lt;&lt; &quot;Number of states is incompatible.&quot; &lt;&lt; endl;</span>
<span class="comment">          exit(0);</span>
<span class="comment">        }</span>
<span class="comment">        for (size_t i = 0; i &lt; ChosenStateMaxPosterior.size(); i++) {</span>
<span class="comment">          cout &lt;&lt; &quot;Subset: &quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; ChosenStateMaxPosterior[i] &lt;&lt; endl;</span>
<span class="comment">          if (ChosenStateMaxPosterior[i] &gt; maxPosterior) {</span>
<span class="comment">            maxPosterior = ChosenStateMaxPosterior[i];</span>
<span class="comment">            maxPosition = i;</span>
<span class="comment">          }</span>
<span class="comment">        }</span>
<span class="comment">        cout &lt;&lt; &quot;Final optimal histogram is from subset &quot; &lt;&lt; maxPosition;</span>
<span class="comment"></span>
<span class="comment">        // use this histogram as the starting state for MCMC</span>
<span class="comment">        AdaptiveHistogram myPosOptHist;</span>
<span class="comment">        myPosOptHist = ChosenStateSubset[maxPosition];</span>
<span class="comment">        cout &lt;&lt; &quot; and has &quot; &lt;&lt; myPosOptHist.getRootLeaves() &lt;&lt; &quot; leaf nodes.&quot;  &lt;&lt; endl;</span>
<span class="comment">        cout &lt;&lt; &quot;---------------------------------------&quot; &lt;&lt; endl;</span>
<span class="comment">        </span>
<span class="comment">        cout &lt;&lt; &quot;Get the IAE of the chosen histogram: &quot; &lt;&lt; endl;</span>
<span class="comment">        PiecewiseConstantFunction tempPCF(myPosOptHist); </span>
<span class="comment">        real thisIAE = tempPCF.getIAE(estimate);</span>
<span class="comment">        cout &lt;&lt; &quot;IAE is &quot; &lt;&lt; thisIAE &lt;&lt; endl;</span>
<span class="comment">        IAEContainer.push_back(thisIAE);</span>
<span class="comment">        </span>
<span class="comment">        /*</span>
<span class="comment">        //output the leaf container</span>
<span class="comment">        string LeafFileName = &quot;LeafChosen&quot;;</span>
<span class="comment">        LeafFileName += stm.str();</span>
<span class="comment">        LeafFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(LeafFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; LeafContainer.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; LeafContainer[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; 1 &lt;&lt; endl;</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        */</span>

        <span class="comment">//----------End of getting an initial state---------------//</span>

      <span class="comment">//}</span>
      <span class="comment">//else cout &lt;&lt; &quot;Failed to insert data&quot; &lt;&lt; endl;</span>
      
    } <span class="comment">// end of successfulHist condition</span>
  } <span class="comment">// end of loop</span>
  <span class="comment">//=======================End of Chains=================================//</span>

<span class="comment">/*</span>
<span class="comment"></span>
<span class="comment">  // output IAE from MCMC</span>
<span class="comment">  string IAEFileName;</span>
<span class="comment">  IAEFileName = &quot;IAEInitial&quot;;</span>
<span class="comment">  IAEFileName += stmSeed.str();</span>
<span class="comment">  IAEFileName += &quot;.txt&quot;;</span>
<span class="comment">  oss.open(IAEFileName.c_str());</span>
<span class="comment">  for (size_t i = 0; i &lt; IAEContainer.size(); i++) {</span>
<span class="comment">    oss &lt;&lt; IAEContainer[i] &lt;&lt; endl;</span>
<span class="comment">  }</span>
<span class="comment">  oss &lt;&lt; flush;</span>
<span class="comment">  oss.close();</span>
<span class="comment">  cout &lt;&lt; &quot;IAE output to &quot; &lt;&lt; IAEFileName &lt;&lt; endl;</span>
<span class="comment">*/</span>
  <span class="comment">//delete theDataPtr;</span>

   <span class="keywordflow">return</span> 0;

} <span class="comment">// end of MCMC test program</span>
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="SEBPQFunctionSimGaussian_8cpp.shtml">SEBPQFunctionSimGaussian.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:23 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
