<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: Adaptive histograms</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('AdaptiveHistograms.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Adaptive histograms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_intro">Introduction</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_adhclass">The AdaptiveHistogram class</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_tree">Controlling the formation of the histogram partition</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_inputdata">Data input with AdaptiveHistogram objects</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_output">AdaptiveHistogram output</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_averaging">Averaging AdaptiveHistograms</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_examples">Examples using adaptive histograms</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsec_furtherdev">Further development</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="adhsec_intro"></a>
Introduction</h2>
<p>An adaptive histogram is a histogram where bin widths and bin centres of the partition of the data space adapt in some way to the data to be represented in the histogram. The basic ideas here are from classical statistical principles.</p>
<hr/>
<h2><a class="anchor" id="adhsec_adhclass"></a>
The AdaptiveHistogram class</h2>
<p>The AdaptiveHistogram class organises statistical sample data for the purpose of creating adaptive histograms. The class holds the container of sample data and uses a tree of <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnodes </a> (<a class="el" href="namespacesubpavings.shtml#ace6b16f0adf0db13eeb38e124d5328c6">StatsSubPaving </a>) to represent a regular non-minimal subpaving or partition of the dataspace which can develop adaptively according to the data.</p>
<p>The AdaptiveHistogram object manages the tree through the tree's root node. This represents the box being <em>covered</em> by the subpaving, which is the data sample space to be partitioned into histogram bins. The boxes of the statistical subpaving can be considered as histogram bins and are represented by the leaf nodes of the tree. Data is associated with boxes in the subpaving: the count of data associated with a leaf node of the tree is the number of data points falling into the box (bin) represented by that node.</p>
<p><a class="anchor" id="ADHholdallstats"></a>The AdaptiveHistogram data member <a class="el" href="">holdAllStats </a> controls whether the tree of SPSnodes managed by the histogram object will maintain <a class="el" href="StatsSubPavings.shtml#SPScountsonly">all summary statistics for the data in each node, or just count data</a>. If a value for holdAllStats is not specified in the AdaptiveHistogram constructor, holdAllStats will be set to false so that, by default, only count data is maintained.</p>
<p>The image belows shows a partition of a [0, 1]x[0, 1] data space into a subpaving and the data points in each box of the subpaving, together with the tree representation with the counts of data in the boxes represented by each node of the tree. In the image, the nodes of the tree are identified with their <a class="el" href="newsubpavings.shtml#SPnodename">nodeNames</a>.</p>
<div class="image">
<img src="ADHExampleSimpleSPandTree.png" alt="ADHExampleSimpleSPandTree.png"/>
<div class="caption">
A simple 2-dimensional histogram partition with data as subpaving and tree</div></div>
 <p>The equivalent normalised histogram is shown below. The height <img class="formulaInl" alt="$ h_j $" src="form_7.png"/> associated with bin <img class="formulaInl" alt="$ j $" src="form_8.png"/> is <img class="formulaInl" alt="$ \frac{n_j}{Nvol_j} $" src="form_9.png"/> where <img class="formulaInl" alt="$ n_j $" src="form_10.png"/> is the number of data points associated with bin j, <img class="formulaInl" alt="$ vol_j $" src="form_11.png"/> is the volume of bin j, and <img class="formulaInl" alt="$ N $" src="form_12.png"/> is the total number of data points in the histogram, <img class="formulaInl" alt="$ N = \sum_{bins j} n_j $" src="form_13.png"/>. Thus</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ sum_{bins j} h_jvol_j = 1 \]" src="form_14.png"/>
</p>
<div class="image">
<img src="ADHExampleSimpleHist.png" alt="ADHExampleSimpleHist.png"/>
<div class="caption">
The equivalent histogram</div></div>
 <p>The AdaptiveHistogram class declarations and definitions can be found in <a class="el" href="adaptivehistogram_8hpp.shtml" title="AdaptiveHistogram declarations.">adaptivehistogram.hpp</a> and <a class="el" href="adaptivehistogram_8cpp.shtml" title="AdaptiveHistogram definitions.">adaptivehistogram.cpp</a>.</p>
<hr/>
<h2><a class="anchor" id="adhsec_tree"></a>
Controlling the formation of the histogram partition</h2>
<p>The purpose of the AdaptiveHistogram class is to allow the histogram bin widths and bin centres to adapt in some way to the data to be represented in the histogram.</p>
<p>There are three ways in which a partition can be formed:</p>
<ul>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsubsec_pq">Priority queue-based partitions</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsubsec_onebyone">Partition refinement during data insertion</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsubsec_mcmc">Partition changes in a Markov Chain using a Monte Carlo algorithm (MCMC)</a></li>
</ul>
<h3><a class="anchor" id="adhsubsec_pq"></a>
Priority queue-based partitions</h3>
<p>We can use a priority queue to form the partition starting from the point where all the data is initially associated with a single root box (the sample data space). The subpaving is refined by progressively bisecting boxes using a priority queue to determine which box, of all the boxes in the subpaving at that point, to bisect next. Using the tree representation the priority queue operates on leaf nodes, prioritising leaf nodes for splitting.</p>
<p>The priority queue operation must be able compare SPSnodes in order to prioritise which to act on first. Priority queue methods of the AdaptiveHistogram class use a function object for comparing SPSnodes. <a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj </a> is an abstract base class from which concrete classes for these function objects must be derived. Some examples of useful node comparison function objects can be found in the file <a class="el" href="nodecompobj_8hpp.shtml" title="Classes for comparing spsnodes.">nodecompobj.hpp</a>.</p>
<p>The priority queue operation must also have a 'stopping rule' to stop further changes in the subpaving/its tree representation. Typically this rule uses characteristics of the histogram as a whole (for example, the number of leaves in the tree). Priority queue methods of the AdaptiveHistogram class use a function object to provide the stopping rule. HistEvalObj is an abstract base class from which concrete classes for these function objects must be derived. Some examples of useful function objects to determine when adaptive changes in the data partition should cease can be found in the file <a class="el" href="histevalobj_8hpp.shtml" title="Declarations for classes for evaluating when to stop changing histograms.">histevalobj.hpp</a>.</p>
<p>The operation of the priority queue can be further controlled by specifiying a minimum number of data points which can be associated with any node in the tree which will be created by the method. Setting this parameter to be a value &gt; 0 will effectively remove from the queue any node which cannot be split because that would result in a child leaf with less than the required minimum number of data points associated with it. The priority queue operation will cease when there are no nodes in the queue if this occurs before the stopping rule is satisfied. Thus 'large' nodes (on the basis of the node comparison function) may not be split and the tree may not yet satisfy the stopping rule when the priority queue method has finished because of the effect of the value supplied for the minimum number of data points to be associated with a node.</p>
<p>The prioritySplit method also takes a parameter minVolB which controls the minimum volume of the boxes represented by the nodes in the tree which will be create by the method. If the total number of data points associated with the whole tree is N, then the minimum volume of the box represented by any node will be <img class="formulaInl" alt="$ \frac{1}{2} minVolB \frac{(logN)^2}{N} $" src="form_15.png"/>. Setting minVolB to 0.0 will mean that there is no minimm volume restriction on the boxes. The minimum volume parameter is useful when priority queue splitting to optimise some histogram fit scoring formula such as Akaike's Information Criteria (AIC).</p>
<p>Some care must be taken to specify a compatible pairing of node comparision and stopping rule, to ensure that the number of nodes in the queue will not just continue to increase without the stopping rule being satisfied.</p>
<p>For splitting using a priority queue method documentation see AdaptiveHistogram::prioritySplit().</p>
<p>Priority queues can also be used to coarsen a partition by reabsorbing pairs of sibling leaf nodes back into their parent node. This is known as 'merging' a subpaving. For merging using a priority queue method documentation see AdaptiveHistogram::priorityMerge().</p>
<p>For examples using priority queue approaches see <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_exambivg">An AdaptiveHistogram with Bivariate Gaussian data</a> and <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_examLevy">Example using data from a RSSample object</a></p>
<h3><a class="anchor" id="adhsubsec_onebyone"></a>
Partition refinement during data insertion</h3>
<p>The histogram partition can be progressively refined as each data point is inserted if the rules for forming the partition can be applied directly to each node in the tree representing the subpaving. For example, a statistically equivalent blocks (SEB) partition which has a maximum of some specified number of data points associated with each bin can be formed in this way. Each leaf node representing a box in the subpaving will be split when the number of data points associated with that node exceeds the maximum, irrespective of the attributes of other nodes or of tree as a whole.</p>
<p>Since each SPSnode in the tree can behave autonomously in this situation, the decision on whether to split is 'delegated' to the SPSnode objects. The SPSnode class provides a method for associating data with a node which takes as a parameter a function object which will direct whether the node should split after the data is added. <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj </a> is an abstract base class from which concrete classes for these function objects must be derived. Specific splitting rules can be encoded using these function objects and then used by the method for inserting data into an SPSnode. The total regular subpaving/its tree representation will develop accordingly. Some examples of useful function objects that can be used by nodes to determine when to split can be found in the file <a class="el" href="splitdecisionobj_8hpp.shtml" title="classes for determining whether to split an SPSnode.">splitdecisionobj.hpp</a>.</p>
<p>See <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_exambivg">An AdaptiveHistogram with Bivariate Gaussian data</a> for an example using this kind of process for partition formation.</p>
<h3><a class="anchor" id="adhsubsec_mcmc"></a>
Partition changes in a Markov Chain using a Monte Carlo algorithm (MCMC)</h3>
<p>The AdaptiveHistogram class can probabilistically change its partition to form different histogram states in a MCMC process. For more details see AdaptiveHistogram::MCMC() documentation.</p>
<hr/>
<h2><a class="anchor" id="adhsec_inputdata"></a>
Data input with AdaptiveHistogram objects</h2>
<p>The AdaptiveHistogram class is designed to deal with multi-dimensional data. Data associated with each AdaptiveHistogram object is stored as the cxsc::rvector type.</p>
<p>The AdaptiveHistogram class provides methods to take data from appropriately formatted txt files, from a container of rvectors, or from an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. If necessary, direct data insertion can also be coded in the user program. These methods are discussed in more detail below.</p>
<p>Data successfully passed to the AdaptiveHistogram object will be first put into the AdaptiveHistogram object's <a class="el" href="">data collection </a> and then an attempt will be made to associate it to the <a class="el" href="">StatsSubPaving </a> managed by the histogram. If the data does not fit in the root box of this StatsSubPaving, it cannot go into the StatsSubPaving but it will remain in the AdaptiveHistogram object's data collection.</p>
<h3><a class="anchor" id="adhsubsec_txtinput"></a>
Data input from a txt file</h3>
<h4><a class="anchor" id="adhsubsubsec_inputrvectors"></a>
Input multi-dimensional data from txt file</h4>
<p>This method reads in lines of data representing rvectors from a txt file. The dimensions of the rvector are deduced from the input format and all the data is then expected to be in the same dimensions. Any data read not matching the expected dimensions, based on assessing the first valid line found, will be rejected.</p>
<p>See <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_exambivg">An AdaptiveHistogram with Bivariate Gaussian data</a> for an example creating a txt file of data and then using this input method.</p>
<p>The method expects one line per rvector with the elements separated by white space (space or tabs), with no non-numeric characters ('e' is accepted as part of a floating point format).</p>
<p>The method can read one-dimensional data but insists on a decimal point in each number. If there is no decimal point the line will be rejected.</p>
<p>The method carries out some basic data checking. Input lines which do not pass (because they contain illegal characters, do not have decimal points in the data, or where the data is not of the expected dimension) are printed to standard output with an error message but the entire file will continue to be processed until the end of the file is reached.</p>
<p>For example </p>
<ul>
<li>
A line "12.04 1.00005e-10 -30.0006" will be read as a 3-dimensional rvector </li>
<li>
A line "12.04ab 1.00005e-10 -30.0006" will be rejected </li>
<li>
A line "12.04 1.00005e-10 -30 will be rejected
&lt;LI&gt; A line "-30.0006" will be read as a 1-dimensional rvector.
&lt;LI&gt; A line "30" will be rejected. </li>
</ul>
<p>For method documentation see AdaptiveHistogram::insertRvectorsFromTxt().</p>
<h4><a class="anchor" id="adhsubsubsec_inputdoubles"></a>
Input one-dimensional data formatted as doubles from a txt file</h4>
<p>This method reads in lines of data representing doubles from a txt file.</p>
<p>The method expects one line per number. Each number can only have dimension.</p>
<p>The method can accept and process data which does not contain a decimal point.</p>
<p>No data checking is carried out: lines containing characters not recognised as part of a valid number format may cause a runtime error.</p>
<p>For example </p>
<ul>
<li>
A line "-30.0006" will be read as a 1-dimensional rvector </li>
<li>
A line "30" will be read as a 1-dimensional rvector </li>
<li>
A line "30ab" will probably result in a runtime error </li>
</ul>
<p>For method documentation see AdaptiveHistogram::insertDoublesFromTxt().</p>
<h3><a class="anchor" id="adhsubsec_rvecinput"></a>
Data input from a container of rvectors</h3>
<p>Data as rvectors can be input directly from a container of type <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData </a>. For method documentation see AdaptiveHistogram::insertFromRVec().</p>
<p>For an example using this data input method see <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_examaveraging">Example of averaging histograms</a></p>
<p>A sub-sample of the data in a container of type RVecData can also be input to the histogram. See AdaptiveHistogram::insertSampleFromRVec(). This method may be useful when averaging over bootstrapped sub-samples from a data sample.</p>
<h3><a class="anchor" id="adhsubsec_rssampleinput"></a>
Data input from a RSSample object</h3>
<p>This method takes data from the samples held by an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. The <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object will have been created using rejection sampling (see <a class="el" href="moorerejsam.shtml">Moore Rejection Sampler</a> ).</p>
<p>For method documentation see AdaptiveHistogram::insertFromRSSample().</p>
<p>A sub-sample of the data in RSSample can also be input to the histogram. See AdaptiveHistogram::insertSampleFromRSSample(). This method may be useful when averaging over bootstrapped sub-samples from a data sample.</p>
<p>See <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_examLevy">Example using data from a RSSample object</a> for an example using averaging over bootstrapped samples from a RSSample.</p>
<h3><a class="anchor" id="adhsubsec_directinput"></a>
Direct data input in the user code</h3>
<p>The user can customise data input using the AdaptiveHistogram::insertOne() method. See <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_exambyhand">Example of insertion of data defined in the program</a> for an example.</p>
<hr/>
<h2><a class="anchor" id="adhsec_output"></a>
AdaptiveHistogram output</h2>
<p>A summary of a histogram can be output to a txt as either a tab-delimited file of numeric data or a space-delimited mixture of alphanumeric data.</p>
<h3><a class="anchor" id="adhsubsec_outputtabs"></a>
Tabbed numeric output to a txt file</h3>
<p>Data for the leaf nodes of the tree managed by the AdaptiveHistogram object is output to a .txt file using the methods AdaptiveHistogram::outputToTxtTabs() or AdaptiveHistogram::outputToTxtTabsWithEMPs(). The leaf nodes of the tree represent boxes (bins) in the subpaving (partition) of the data space.</p>
<p>AdaptiveHistogram::outputToTxtTabs() produces a tab-delimited file of numeric data starting with nodeName, then the node box volume, then the node counter, then the description of the node box as a tab-delimited list of interval upper and lower bounds, for each leaf node in the tree representing the subpaving managed by the AdaptiveHistogram object.</p>
<p>The <a class="el" href="newsubpavings.shtml#SPnodename">nodeName</a> is a name for the node which summarises its local place in the tree (i.e. its immediate parent and whether it is the left of right child of that parent).</p>
<p>The <a class="el" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5">counter </a> is a summary of the number of datapoints associated with the box represented by that node.</p>
<p>The description of the box represented by the node gives the upper and lower bound of each interval in the <a class="el" href="pavproc.shtml#intervalvectors">interval vector</a> describing that box.</p>
<p>The output format format when the node represents an n-dimensional box formed of intervals interval_1, interval_2, ... interval_n is</p>
<p>nodeName counter volume Inf(interval_1) Sup(interval_1) ... Inf(interval_n) Sup(interval_n)</p>
<p>The volume of the box is the product of the widths of the intervals comprising the interval vector defining the box.</p>
<p>Each line of the output file will contain data relating to one leaf node.</p>
<p>This format is designed for flexible subsequent processing, either for further manipulation or for graphical display.</p>
<p>For example, a section of .txt file output for 2-dimensional data is</p>
<div class="fragment"><pre class="fragment">
XLLLL   2.48672 3    -3.295435   -1.644448   -2.686375   -1.180173
XLLLRL  1.24336 2    -3.295435   -2.469941   -1.180173    0.326030
XLLLRR  1.24336 16   -2.469941   -1.644448   -1.180173    0.326030
XLLRLL  1.24336 13   -1.644448   -0.818954   -2.686375   -1.180173
XLLRLRL 0.62168 9    -0.818954    0.006540   -2.686375   -1.933274
</pre></div><p>For method documentation see AdaptiveHistogram::outputToTxtTabs()</p>
<p>Information about the contribution of each node to the empirical risk of the histogram as a non-parametric density estimate under scoring methods AIC and COPERR can also be output using AdaptiveHistogram::outputToTxtTabsWithEMPs()</p>
<h3><a class="anchor" id="adhsubsec_outputroot"></a>
Information on the whole sample to txt file</h3>
<p>Summary information about the whole <b> data sample </b> can be output to a txt file using the method outputRootToTxt(). This summarises all the data associated with the root box of the subpaving (the domain of all the bins in the histogram), its volume, the total number of datapoints associated with the histogram, the mean, and the sample variance-covariance matrix (the mean and variance-covariance matrix can only be output if the tree managed by the histogram is maintaining all statistics in its nodes, not just counts). The information is a mixture of alpha and numeric characters and is separated by spaces, not tabs.</p>
<p>For method documentation see AdaptiveHistogram::outputRootToTxt()</p>
<h3><a class="anchor" id="adhsubsec_outputroot"></a>
Information on the whole sample to txt file</h3>
<p>Information about the <b> whole histogram </b> can be printed to console output. This shows, for each node in the binary tree representing the subpaving whose leaves form the bins of the histogram, the subpaving box and its volume, the count, mean and variance-covariance matrix for the data associated with that node, and the - for leaf nodes only - the actual data. (The mean and variance-covariance matrix can only be output if the tree managed by the histogram is maintaining all statistics in its nodes, not just counts.) It is best to use this output method only for small histograms with small samples, since the amount of output is considerable.</p>
<p>For method documentation see <a class="el" href="adaptivehistogram_8cpp.shtml#a4b985816e4b7856ce15449885e012e09" title="Output the contents of an AdaptiveHistogram object.">operator&lt;&lt;(std::ostream &amp;os, const AdaptiveHistogram&amp; adh)</a></p>
<hr/>
<h2><a class="anchor" id="adhsec_averaging"></a>
Averaging AdaptiveHistograms</h2>
<p>Summary information from a number of different AdaptiveHistogram objects can be collated and averaged using the AdaptiveHistogramCollator class <b> provided that the statistical subpavings represented by <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode </a> trees managed by each AdaptiveHistogram collated all have identical root boxes</b>.</p>
<p>The AdaptiveHistogramCollator creates a subpaving which is the union of the subpavings of all the AdaptiveHistograms collated and keeps a record of the height of each collated histogram over each box in the new, unioned, subpaving. The subpaving is represented by a tree of <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnodes </a>.</p>
<p>Recall that for any individual histogram the height <img class="formulaInl" alt="$ h_j $" src="form_7.png"/> associated with bin j is <img class="formulaInl" alt="$ \frac{n_j}{Nvol_j} $" src="form_9.png"/> where <img class="formulaInl" alt="$ n_j $" src="form_10.png"/> is the number of data points associated with bin j, <img class="formulaInl" alt="$ vol_j $" src="form_11.png"/> is the volume of bin j, and <img class="formulaInl" alt="$ N $" src="form_12.png"/> is the total number of data points in the histogram, <img class="formulaInl" alt="$ N = \sum_{bins j} n_j $" src="form_13.png"/>.</p>
<p>The average histogram is formed by averaging the heights over all the the histograms collated for each box in the union of the subpavings of the histograms collated.</p>
<p>The image below shows two histograms, each on the data space [-5,5]x[-5,5].</p>
<div class="image">
<img src="DemoHists.png" alt="DemoHists.png"/>
<div class="caption">
Two histograms to demonstrate averaging</div></div>
 <p>We can look at the subpaving or parition of the data space for each histogram and the union of these two subpavings, which is also a regular subpaving.</p>
<div class="image">
<img src="DemoHistsPartitions.png" alt="DemoHistsPartitions.png"/>
<div class="caption">
The union of two subpavings</div></div>
 <p>For each original histogram, a histogram of exactly the same shape but formed over the union subpaving can be found. Some of the bins have been subdivided but the height over the subdivided bin is the same as the height over the original larger bin and so the shape is the same (and the area of the histogram still integrates to 1). The images below show the result of representing the histograms to get the same shape but over the union subpaving.</p>
<div class="image">
<img src="DemoHistsOverUnionPartition.png" alt="DemoHistsOverUnionPartition.png"/>
<div class="caption">
Maintaining histogram shape over the union partition</div></div>
 <p>The average histogram is found by averaging the heights of the two histograms for each bin that is part of the union partion.</p>
<div class="image">
<img src="DemoHistsAv.png" alt="DemoHistsAv.png"/>
<div class="caption">
The average histogram</div></div>
 <p>For examples using averaging and AdaptiveHistogramCollator objects, see <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_examaveraging">Example of averaging histograms</a> and <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_examLevy">Example using data from a RSSample object</a></p>
<hr/>
<h2><a class="anchor" id="adhsec_examples"></a>
Examples using adaptive histograms</h2>
<ul>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsubsec_exambivg">An AdaptiveHistogram with Bivariate Gaussian data</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsubsec_examaveraging">Example of averaging histograms</a></li>
<li><a class="el" href="AdaptiveHistograms.shtml#adhsubsec_exambyhand">Example of insertion of data defined in the program</a></li>
</ul>
<h3><a class="anchor" id="adhsubsec_exambivg"></a>
An AdaptiveHistogram with Bivariate Gaussian data</h3>
<p>In this example we show how an AdaptiveHistogram object can be used to process sample data from a Bivariate Gaussian distribution, ie two-dimensional data.</p>
<p>Our implementation of this example is in the file <a class="el" href="BiGTest_8cpp.shtml" title="Testing StatsSubPavings (aka SPSnodes) with Bivariate Gaussian data.">BiGTest.cpp</a>, which includes the header file dataprep.hpp.</p>
<p>Dataprep.hpp specifies libaries for generating simulated random samples from statistical distributions</p>
<p><a class="anchor" id="ADHexamdataprep"></a><p><div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef ___DATAPREP_HPP__</span>
<span class="preprocessor"></span><span class="preprocessor">#define ___DATAPREP_HPP__</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;gsl/gsl_statistics_double.h&gt;</span>
<span class="preprocessor">#include &lt;gsl/gsl_math.h&gt;</span>
<span class="preprocessor">#include &lt;gsl/gsl_sort.h&gt;</span>
<span class="preprocessor">#include &lt;gsl/gsl_statistics.h&gt;</span>
<span class="preprocessor">#include &lt;gsl/gsl_rng.h&gt;</span>
<span class="preprocessor">#include &lt;gsl/gsl_randist.h&gt;</span>

<span class="preprocessor">#endif</span>
</pre></div></p>
<p>In <a class="el" href="BiGTest_8cpp.shtml" title="Testing StatsSubPavings (aka SPSnodes) with Bivariate Gaussian data.">BiGTest.cpp</a> we include the other header files and libraries we want to be able to use. The file header <a class="el" href="histall_8hpp.shtml" title="all headers for using adaptive histograms.">histall.hpp</a> includes the headers usually needed for programming using AdaptiveHistograms. We also specify the namespaces we want to be able to use without qualification.</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;time.h&gt;</span>   <span class="comment">// clock and time classes</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>  <span class="comment">// input and output streams</span>

<span class="preprocessor">#include &quot;<a class="code" href="histall_8hpp.shtml" title="all headers for using adaptive histograms.">histall.hpp</a>&quot;</span>  <span class="comment">// headers for the histograms</span>
<span class="preprocessor">#include &quot;dataprep.hpp&quot;</span> <span class="comment">// headers for getting data</span>

<span class="keyword">using namespace </span>cxsc;
<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>subpavings;


<span class="keywordtype">int</span> <a class="code" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
{
</pre></div></p>
<p>The first part of the file is concerned with setting the up the objects to generate simulated random samples from a bivariate gaussian distribution.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// ------- prepare to generate some data for the tests -----------</span>

    <span class="comment">// set up a random number generator for bivariate gaussian rvs</span>
    <span class="keyword">const</span> gsl_rng_type * T;
    gsl_rng * r;

    <span class="keywordtype">int</span> i;
    <span class="keyword">const</span> <span class="keywordtype">int</span> n=10000;  <span class="comment">// number to generate</span>
    <span class="keywordtype">double</span> sigma_x=1;   <span class="comment">// distribution parameter</span>
    <span class="keywordtype">double</span> sigma_y=1;   <span class="comment">// distribution parameter</span>
    <span class="keywordtype">double</span> rho=0;       <span class="comment">// x and y uncorrelated</span>

    <span class="comment">//create a generator chosen by the environment variable GSL_RNG_TYPE</span>

    gsl_rng_env_setup();

    T = gsl_rng_default;
    r = gsl_rng_alloc (T);
</pre></div></p>
<p>In this example, we put the samples generated into a txt file which will then be used to input data into the histogram. Note that when we create an ofstream object for the file to send the samples to, we specify the formatting for this to be scientific with precision. This ensures that each value output will include a decimal point.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordtype">string</span> samplesFileName; <span class="comment">// for samples</span>
    <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>
    ofstream oss;         <span class="comment">// ofstream object</span>
    oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
    oss.precision(5);

    <span class="keywordtype">double</span> *x;
    <span class="keywordtype">double</span> *y;

    x= <span class="keyword">new</span> <span class="keywordtype">double</span>[n];   <span class="comment">// make x and y in dynamic memory</span>
    y= <span class="keyword">new</span> <span class="keywordtype">double</span>[n];   <span class="comment">// (so they must be freed later)</span>

    <span class="keywordtype">double</span>* itx;
    <span class="keywordtype">double</span>* ity;


    <span class="comment">// get n random variates chosen from the bivariate Gaussian</span>
    <span class="comment">// distribution with mean zero and given sigma_x, sigma_y.</span>
    <span class="keywordflow">for</span> (i = 0; i &lt; n; i++)
    {
        gsl_ran_bivariate_gaussian(r, sigma_x, sigma_y,
                                   rho, &amp;x[i], &amp;y[i]);

    }

    <span class="comment">// free the random number generator</span>
    gsl_rng_free (r);
</pre></div></p>
<p>These are then output into a txt file. Note the format used in the section where we output the data to a txt file: Each pair of numbers is on the same line, separated by whitespace (in this case, just space, but tabs would also work).</p>
<p><div class="fragment"><pre class="fragment">    itx = &amp;x[0];
    ity = &amp;y[0];

    <span class="comment">// create a name for the file to use</span>
    samplesFileName = <span class="stringliteral">&quot;bgSamples.txt&quot;</span>;
    <span class="comment">// output the sample data</span>
    oss.open(samplesFileName.c_str());         <span class="comment">// opens the file</span>

    <span class="keywordflow">for</span>(i=0; i&lt;n; i++) {
        oss &lt;&lt; (*itx) &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; (*ity);
        <span class="keywordflow">if</span> (i&lt;n-1) oss &lt;&lt; endl; <span class="comment">// new line if not final line</span>
        itx++;
        ity++;
    }
    oss &lt;&lt; flush;
    oss.close();

    cout &lt;&lt; <span class="stringliteral">&quot;Samples output to &quot;</span> &lt;&lt; samplesFileName &lt;&lt; endl &lt;&lt; endl;
</pre></div></p>
<p>We also set up a way to time the processes, and some boolean variables used later in the process</p>
<p><div class="fragment"><pre class="fragment">    clock_t start, end;     <span class="comment">// for timing</span>
    <span class="keywordtype">double</span> timeTaken;

    <span class="keywordtype">bool</span> successfulInsertion = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> successfulPQSplit = <span class="keyword">false</span>;
</pre></div></p>
<p>The first example in this file will show how to create a histogram with a rule to adjust the partition (split a node in the tree representing the subpaving partition) when the number of data points associated with the bin is greater than some number k. This is a simple implementation of an upper-bounded version of the statistically equivalent blocks (SEB) principle or test or rule.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// ------ example to create one histogram with splitting value ----</span>
    <span class="comment">// --------------------entered by user ----------------------------</span>
</pre></div></p>
<p>Pretending that we did not know how many data points were in the sample, we can find this out using the countLinesInTxt method and get an appropriate input value for k.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// get a count of the lines in the txt file</span>
    <span class="keywordtype">int</span> dataCount = <a class="code" href="namespacesubpavings.shtml#a5928e5a1c7fc26e6df9c5bf9eb4a37a2" title="Method to count lines in a txt file.">countLinesInTxt</a>(samplesFileName);
    <span class="keywordtype">int</span> myK = 0;

    <span class="comment">// tell user how many lines there are in the file</span>
    cout &lt;&lt; <span class="stringliteral">&quot;The file &quot;</span> &lt;&lt; samplesFileName &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; dataCount
            &lt;&lt; <span class="stringliteral">&quot; lines in it&quot;</span> &lt;&lt; endl &lt;&lt; endl;
    <span class="comment">// get a parameter for k</span>
    cout &lt;&lt; <span class="stringliteral">&quot;Enter a parameter for your splitting criteria here please:  &quot;</span>;
    cin &gt;&gt; myK;
    cout &lt;&lt; endl &lt;&lt; endl; <span class="comment">// myK has been input</span>
</pre></div></p>
<p>Now we make the AdaptiveHistogram object, in this case rather unimaginatively called myHistFirst.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// make an Adaptive Histogram object with no specified box and, by default,</span>
    <span class="comment">// holdAllStats = false so that the underlying rootPaving managed by the</span>
    <span class="comment">// histogram will not maintain all available stats, only counts</span>
    AdaptiveHistogram myHistFirst;
</pre></div></p>
<p>myHist is given no initial values. This means that we have not actually specified a root box for the subpaving represented by the tree of SPSnodes that myHistFirst manages. This will be dealt with later by myHistFirst which will create a box tailor-made to fit all the data.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is the safest approach when dealing with data if you are not sure of its magnitude since data which does not fit in the root box of the StatsSubPaving cannot be processed by that StatsSubPaving.</dd></dl>
<p>By default, the histogram data member <a class="el" href="AdaptiveHistograms.shtml#ADHholdallstats">holdAllStats</a> is false.</p>
<p>Then we start a clock, to time how long processing the data takes.</p>
<p><div class="fragment"><pre class="fragment">    start=clock();
    <span class="comment">// clock running</span>
</pre></div></p>
<p>Now we create the function object to direct whether or not a node is split after a data point is associated with it.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// make the function object to decide whether to split.</span>
    <span class="comment">// aim to get max myK data members in each box, default minimum</span>
    <span class="comment">// number of points allowed in each box is 0.</span>
    SplitOnK splitK(myK);
</pre></div></p>
<p>See the class documentation for <a class="el" href="classsubpavings_1_1SplitOnK.shtml">SplitOnK </a> for more information on this object. Note that the minimum number of points to be associated with a node defaults to 0 in this example. If a minimum number of points to be associated with a node is specified in the SplitOnK constructor this would effectively override the specfified maximum k where there was a conflict between the two requirements. All nodes would have a least the minimum number of points but might have more than k data points associated with them because splitting the node would violate the minimum.</p>
<p>Next we input the data from the txt file of samples to myHistFirst, using the insertRvectorsFromTxt method and supplying the function object splitK we have just created. We also specify that there will be no logging of the insertion process (see the enumeration <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL </a> for possible values for the logging parameter).</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// insert the data on by one, checking whether to split on each insertion</span>
    successfulInsertion = myHistFirst.insertRvectorsFromTxtOrd(samplesFileName,
            splitK, dim, headerlines, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>); <span class="comment">// no logging</span>
</pre></div></p>
<p>This method returns a boolean (true or false) value indicating whether or not some data has been successfully read in, put in the the <a class="el" href="">data collection </a>, and presented to the <a class="el" href="classsubpavings_1_1SPSnode.shtml">StatsSubPaving </a> managed by the histogram. In this case, because we did not initialise myHistFirst with a root box for the StatsSubPaving, a root box specifically tailored to the data will have been created as part of the data insertion process and so we will not have any data left out in the cold.</p>
<p>We now stop the clock and print out the processing time.</p>
<p><div class="fragment"><pre class="fragment">    end=clock();

    timeTaken = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end-start)/CLOCKS_PER_SEC;
    cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> &lt;&lt;timeTaken&lt;&lt; <span class="stringliteral">&quot; s.&quot;</span> &lt;&lt; endl;
</pre></div></p>
<p>If the data insertion process was successful, we can output the subpaving to a txt file. The name of the file to send the output to is given in the program.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// only do more if some data was fed in</span>
    <span class="keywordflow">if</span>(successfulInsertion) {

        <span class="comment">// create a name for the file to output</span>
        outputFileName = <span class="stringliteral">&quot;BivGaussianFirst.txt&quot;</span>;
        <span class="comment">// To realize a file output</span>
        myHistFirst.outputToTxtTabs(outputFileName);
</pre></div></p>
<p>Then we end the if statement checking if data insertion was successful and have finished the first example.</p>
<p><div class="fragment"><pre class="fragment">    }

    <span class="comment">// end of example for histogram with splitting value input by user</span>
</pre></div></p>
<p>The next part of the program demonstrates the priority queue method of forming the histogram: all the data is initially associated with the root box of the subpaving and a priority queue is then used to refine the bins in the partition.</p>
<p><div class="fragment"><pre class="fragment">    successfulInsertion = <span class="keyword">false</span>;
    successfulPQSplit = <span class="keyword">false</span>;

    <span class="comment">// example to create one histogram with pulse data and a priority</span>
    <span class="comment">// ---------- split to give a minimum number of bins -----------</span>
</pre></div></p>
<p>Again we make an AdaptiveHistogram object with no root box.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// make an Adaptive Histogram object with no specified box</span>
    <span class="comment">// or splitting value (and holdAllStats again defaults to false),</span>
    <span class="comment">// with the same data</span>
    AdaptiveHistogram myHistSecond;
</pre></div></p>
<p>We start the clock and insert the data, but this time we do not give any rule for splitting the subpaving as the data is inserted. The AdaptiveHistogram will simply make a root box big enough for all the data (because we have not pre-specified the root box) and will associate all the data with that box.</p>
<p><div class="fragment"><pre class="fragment">    start=clock();
    <span class="comment">// clock running</span>

    <span class="comment">// put in the data in a &#39;pulse&#39; with no splitting, ie one big box</span>
    successfulInsertion = myHistSecond.insertRvectorsFromTxt(samplesFileName);
</pre></div></p>
<p>Now, provided that insertion of the data was successful, we do the actual formation of the histogram by the splitting the boxes most in need of attention first (ie, a priority queue).</p>
<p>In this example we specify that nodes should be compared on the basis of the number of data points associated with them by using a node comparision function object of type <a class="el" href="classsubpavings_1_1CompCount.shtml">CompCount </a>. This means that the node most in need of attention in the priority queue is the one with the largest number of data points associated with it.</p>
<p>We specifiy a stopping rule with a histogram evaluation function object of type CritLeaves_GTE. This object will stop the priority queue when the number of leaves in the tree representing the subpaving managed by the histogram is greater than or equal to 50.</p>
<p>The example also specifies a minimum number of data points that can be associated with any node in the tree. This requirement will effectively remove from the priority queue all nodes whose children would have less than 1 data point associated with them if the node were split. See <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_pq">Priority queue-based partitions</a> and the AdaptiveHistogram::prioritySplit() method documentation for more information about the operation of this parameter.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> (successfulInsertion) {

        <span class="comment">// set up function objects for a priority split</span>

        <span class="comment">// function object to compare nodes on count</span>
        <span class="comment">// ie split node with largest count first</span>
        CompCount compCount;

        <span class="comment">// function object to split until number of leaves is &gt;= minLeaves</span>
        <span class="keywordtype">size_t</span> minLeaves = 50;
        CritLeaves_GTE critLeavesGTE(minLeaves);

        <span class="comment">/* minimum points to use when splitting.</span>
<span class="comment">        A node will not be splittable if either child would then have</span>
<span class="comment">        &lt; minPoints of data associated with it. */</span>
        <span class="keywordtype">size_t</span> minPoints = 1;

        <span class="comment">// do the priority split</span>
        successfulPQSplit = myHistSecond.prioritySplit(compCount,
                critLeavesGTE, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>, minPoints); <span class="comment">// no logging</span>
    }

    end=clock();
</pre></div></p>
<p>Then we show the time taken and output the histogram.</p>
<p><div class="fragment"><pre class="fragment">    timeTaken = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end-start)/CLOCKS_PER_SEC;
    cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> &lt;&lt;timeTaken&lt;&lt; <span class="stringliteral">&quot; s.&quot;</span> &lt;&lt; endl;


    <span class="keywordflow">if</span>(successfulPQSplit) { <span class="comment">// only do more if split was successful</span>

        <span class="comment">// create a name for the file to output</span>
        outputFileName = <span class="stringliteral">&quot;BivGaussianSecond.txt&quot;</span>;
        <span class="comment">// To realize a file output</span>
        myHistSecond.outputToTxtTabs(outputFileName);

    }
</pre></div></p>
<p>Free the memory allocated for the data points</p>
<p><div class="fragment"><pre class="fragment">    <span class="keyword">delete</span> x;   <span class="comment">// free dynamic memory used for x and y</span>
    <span class="keyword">delete</span> y;
</pre></div></p>
<p>And end the program</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordflow">return</span> 0;

} <span class="comment">// end of bivariate gaussian test program</span>
</pre></div></p>
<p>One of many possible displays of the result is shown below. This draws the histograms as 3-dimensional shapes, with the 'floor' being the boxes of the subpaving and the height of each histogram bar being the proportion of the total number of datapoints which were associated with that box divided by the floor area (volume of the box). The image shows both histograms, illustrating the smoothing effect achieved by priority queue splitting to a fixed number of leaves (bins in the partition).</p>
<div class="image">
<img src="bivgaussian.png" alt="bivgaussian.png"/>
<div class="caption">
Graphical representations of AdaptiveHistograms</div></div>
 <h3><a class="anchor" id="adhsubsec_examaveraging"></a>
Example of averaging histograms</h3>
<p>In this example we show how an AdaptiveHistogramCollator object can be used find the average histogram from ten different histograms (AdaptiveHistogram objects), each managing a sample of bivariate gaussian data.</p>
<p>Our implementation of this example is in the file <a class="el" href="Averaging_8cpp.shtml" title="Testing CollatorSPSnodes with Bivariate Gaussian data.">Averaging.cpp</a>, which includes the header file dataprep.hpp.</p>
<p><a class="el" href="AdaptiveHistograms.shtml#ADHexamdataprep">Dataprep.hpp</a> specifies libaries for generating simulated random samples from statistical distributions</p>
<p>In <a class="el" href="Averaging_8cpp.shtml" title="Testing CollatorSPSnodes with Bivariate Gaussian data.">Averaging.cpp</a> we also include the other header files and libraries we want to be able to use. The file header <a class="el" href="histall_8hpp.shtml" title="all headers for using adaptive histograms.">histall.hpp</a> includes the headers usually needed for programming using AdaptiveHistograms. We also specify the namespaces we want to be able to use without qualification.</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;time.h&gt;</span>   <span class="comment">// clock and time classes</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>  <span class="comment">// input and output streams</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>  <span class="comment">// to be able to manipulate strings as streams</span>

<span class="preprocessor">#include &quot;<a class="code" href="histall_8hpp.shtml" title="all headers for using adaptive histograms.">histall.hpp</a>&quot;</span>  <span class="comment">// headers for the histograms</span>
<span class="preprocessor">#include &quot;dataprep.hpp&quot;</span> <span class="comment">// headers for getting data</span>

<span class="keyword">using namespace </span>cxsc;
<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>subpavings;

<span class="keywordtype">int</span> <a class="code" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
{
</pre></div></p>
<p>The first part of the file is concerned with setting the file up to generate and store simulated random samples from a bivariate gaussian distribution.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// ------- prepare to generate some data for the tests -----------</span>

    <span class="comment">// set up a random number generator for bivariate gaussian rvs</span>
    <span class="keyword">const</span> gsl_rng_type * T;
    gsl_rng * r;

    <span class="keyword">const</span> <span class="keywordtype">int</span> n=10;  <span class="comment">// number to generate</span>
    <span class="keywordtype">double</span> sigma_x=1;   <span class="comment">// distribution parameter</span>
    <span class="keywordtype">double</span> sigma_y=1;   <span class="comment">// distribution parameter</span>
    <span class="keywordtype">double</span> rho=0;       <span class="comment">// x and y uncorrelated</span>

    <span class="comment">//create a generator chosen by the environment variable GSL_RNG_TYPE</span>

    gsl_rng_env_setup();

    T = gsl_rng_default;
    r = gsl_rng_alloc (T);
</pre></div></p>
<p>The example is described</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// ----------------   example to create and ------------------</span>
    <span class="comment">//---------------- collate multiple histograms -------------------</span>
</pre></div></p>
<p>It is vital that each AdaptiveHistogram to be collated has the same root box, so we make a large root box which will be used by all the histograms we subsequently make.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// make a box: the same box will be used by all histograms</span>
    <span class="comment">// so should be big enough for all of them</span>
    <span class="keywordtype">int</span> d = 2; <span class="comment">// dimensions</span>
    ivector pavingBox(d);
    interval dim1(-5,5);
    interval dim2(-5,5);
    pavingBox[1] = dim1;
    pavingBox[2] = dim2;
</pre></div></p>
<p>Then we make the AdaptiveHistogramCollator object</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// make a collation object, empty at present</span>
    AdaptiveHistogramCollator coll;
</pre></div></p>
<p>We have a loop for each histogram to be averaged, and within the loop we start by generating sample data for the histogram. Note that the sample data is stored in a <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData </a> container.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// the number of histograms to generate</span>
    <span class="keywordtype">int</span> numHist = 10000;

    <span class="comment">// for loop to generate histograms and add to collation</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=1; j&lt;=numHist; j++) {

        <span class="comment">//get n random variates chosen from the bivariate Gaussian</span>
        <span class="comment">// distribution with mean zero and given sigma_x, sigma_y.</span>

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> theData;   <span class="comment">// a container for all the points generated</span>

        <span class="comment">// make a sample</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {

            rvector thisrv(d);
            <span class="keywordtype">double</span> x = 0;
            <span class="keywordtype">double</span> y = 0;

            gsl_ran_bivariate_gaussian(r, sigma_x, sigma_y,
                                    rho, &amp;x, &amp;y);
            thisrv[1] = x;
            thisrv[2] = y;

            <span class="comment">// put points generated into container</span>
            theData.push_back(thisrv);

        }  <span class="comment">// data should be in theData</span>
</pre></div></p>
<p>We make an AdaptiveHistogram object to be used with this sample. Each histogram will use the a copy of the same root box for its subpaving.</p>
<p><div class="fragment"><pre class="fragment">        <span class="comment">// make an Adaptive Histogram object with a specified box.  By default,</span>
        <span class="comment">// holdAllStats = false so that the underlying rootPaving managed by the</span>
        <span class="comment">// myHistFirst will not maintain all available stats, only counts</span>
        AdaptiveHistogram myHist(pavingBox);
</pre></div></p>
<p>Each AdaptiveHistogram is to be formed under the rule where each bin should have a maximum number of data points k associated with it, but that maximum number of data points is a function of the total number of data points n and the histogram indexer j. This applies SEB heuristics for k to satisfy <img class="formulaInl" alt="$ \frac{k}{n} \rightarrow 0 $" src="form_16.png"/> as <img class="formulaInl" alt="$ n \rightarrow \infty $" src="form_17.png"/>. The resulting value for k is used in the constructor for an object of type SplitOnK. See the class documentation for <a class="el" href="classsubpavings_1_1SplitOnK.shtml">SplitOnK </a> for more information on this object. Note that the minimum number of points to be associated with a node defaults to 0.</p>
<p><div class="fragment"><pre class="fragment">        <span class="comment">// find k, the maximum number of data members</span>
        <span class="comment">// to be allowed in each box of the histogram</span>
        <span class="comment">// as a function of j and n</span>
        <span class="comment">// applying SEB heuristics for k to satisfy k/n -&gt; 0 as n -&gt; +oo</span>
        <span class="keywordtype">int</span> k_int = (int(log2(<span class="keywordtype">double</span>(n)))*2*j);

        cout &lt;&lt; <span class="stringliteral">&quot;Splitting with k = &quot;</span> &lt;&lt; k_int &lt;&lt; endl;

        <span class="keywordtype">bool</span> successfulInsertion = <span class="keyword">false</span>;

        <span class="comment">// make the function object to get max myK data members in each box</span>
        SplitOnK splitK(k_int);
</pre></div></p>
<p>Next we input the sample data from the container into the histogram, using the insertFromRVec method and supplying the function object splitK we have just created. We also specify that there will be no logging of the insertion process (see the enumeration <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL </a> for possible values for the logging parameter).</p>
<p>Note that we choose to split with each data insertion here. A priority queue with a stopping rule based on the maximum number of points associated with any any leaf node of the tree (CritLargestCount_LTE) could also be used.</p>
<p><div class="fragment"><pre class="fragment">        <span class="comment">// insert data into the histogram, splitting as we go, no logging</span>
        successfulInsertion = myHist.insertFromRVec(theData, splitK, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>);
</pre></div></p>
<p>Assuming that the data insertion has been successful, we output each histogram to a txt file and add it to the collation.</p>
<p>Adding the histogram to the collation does not change the AdaptiveHistogram object itself, it just adds information from that object to the collation.</p>
<p>A dot file of the tree representation of the histogram can also be created but works best for smaller histograms.</p>
<p><div class="fragment"><pre class="fragment">        <span class="comment">// only do more if some data was fed in</span>
        <span class="keywordflow">if</span>(successfulInsertion) {

            <span class="comment">// create a name for the file to output</span>
            <span class="keywordtype">string</span> fileName = <span class="stringliteral">&quot;BivGaussian&quot;</span>;
            <span class="comment">//convert j to a string</span>
            std::ostringstream stm2;
            stm2 &lt;&lt; j;
            <span class="comment">// add the stringed j to the filename</span>
            fileName += stm2.str();
            fileName += <span class="stringliteral">&quot;.txt&quot;</span>; <span class="comment">// and finish the filename</span>

            <span class="comment">// To realize a file output</span>
            myHist.outputToTxtTabs(fileName);

            <span class="comment">// add the histogram to the collection</span>
            coll.addToCollation(myHist);

            <span class="comment">// optional- create graph output</span>
            <span class="comment">// myHist.outputGraphDot();</span>
        }
</pre></div></p>
<p>This ends the loop for creating separate histogram objects. The random number generator can be freed.</p>
<p><div class="fragment"><pre class="fragment">    } <span class="comment">// end of for loop creating histograms</span>

    <span class="comment">// free the random number generator</span>
    gsl_rng_free (r);
</pre></div></p>
<p>And the collated information output to a txt file. A dot graph can also be created if desired.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordtype">string</span> collfileName = <span class="stringliteral">&quot;CollatorHistogram.txt&quot;</span>;
    coll.outputToTxtTabs(collfileName); <span class="comment">// output the collation to file</span>

    <span class="comment">// optional - create graph output - don&#39;t do for lots of leaves!</span>
    <span class="comment">//coll.outputGraphDot();</span>
</pre></div></p>
<p>Finally, the average is also output to a txt file.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The example ends.</p>
<p><div class="fragment"><pre class="fragment"></pre></div></p>
<p>The ten histograms constructed with different values of k based on the ten independent simulations of 10000 bivariate Gaussian samples are diplayed next along with the prabability density of the standard bivariate Gaussian.</p>
<div class="image">
<img src="BivGaussHists10.png" alt="BivGaussHists10.png"/>
<div class="caption">
Graphical representations of the 10 AdaptiveHistograms</div></div>
 <p>The average histogram or the sample mean histogram of the above 10 histograms are shown below with the probability density of the standard bivariate Gaussian.</p>
<div class="image">
<img src="BGAvgHist.png" alt="BGAvgHist.png"/>
<div class="caption">
Graphical representations of the average of the 10 AdaptiveHistograms</div></div>
 <h3><a class="anchor" id="adhsubsec_examLevy"></a>
Example using data from a RSSample object</h3>
<p>This example first generates data in an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object and then inputs samples from this to an AdaptiveHistogram, again averaging the resulting histograms.</p>
<p>The example must include the header files for the rejection sampling process</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;time.h&gt;</span>   <span class="comment">// clock and time classes</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>  <span class="comment">// input and output streams</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>  <span class="comment">// to be able to manipulate strings as streams</span>

<span class="preprocessor">#include &quot;<a class="code" href="histall_8hpp.shtml" title="all headers for using adaptive histograms.">histall.hpp</a>&quot;</span>  <span class="comment">// headers for the histograms</span>

<span class="preprocessor">#include &lt;gsl/gsl_qrng.h&gt;</span>       <span class="comment">// types needed by MRSampler.hpp</span>
<span class="preprocessor">#include &lt;gsl/gsl_randist.h&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="Fobj_8hpp.shtml" title="Fobj definition and declaration.">Fobj.hpp</a>&quot;</span>     <span class="comment">// to be able to use the Levy function objects</span>
<span class="preprocessor">#include &quot;<a class="code" href="FLevy2D_8hpp.shtml" title="Declarations for example function class FLevy2D (Levy function, 2 dimensions).">FLevy2D.hpp</a>&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="MRSampler_8hpp.shtml" title="Moore Rejection Sampler (MRSampler) declarations.">MRSampler.hpp</a>&quot;</span>    <span class="comment">// to be able to do MRS rejection sampling</span>


<span class="keyword">using namespace </span>cxsc;
<span class="keyword">using namespace </span>std;
<span class="keyword">using namespace </span>subpavings;

<span class="keywordtype">int</span> <a class="code" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{

    <span class="comment">// example to average 10 samples from a 2-d Levy shape</span>
</pre></div></p>
<p>We start by using the Moore Rejection Sampler to generate the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> of data. See <a class="el" href="moorerejsam.shtml">Moore Rejection Sampler</a> for more information.</p>
<p><div class="fragment"><pre class="fragment">    ios::sync_with_stdio (); <span class="comment">// so iostream works with stdio</span>
    cout &lt;&lt; SetPrecision (20, 15);  <span class="comment">// Number of mantissa digits in I/O</span>


    <span class="keywordtype">int</span> n_dimensions = 2;
    <span class="keywordtype">int</span> n_boxes = 1000;
    <span class="keywordtype">int</span> n_samples = 100000;
    <span class="keywordtype">double</span> Alb = 1.0;<span class="comment">// partition until lower bound on Acceptance Prob.&gt;Alb</span>
    <span class="keywordtype">unsigned</span> theSeed = 12345;


    <span class="keywordtype">bool</span> use_f_scale = <span class="keyword">true</span>;

    cout &lt;&lt; <span class="stringliteral">&quot;# n_dimensions: &quot;</span> &lt;&lt; n_dimensions &lt;&lt; <span class="stringliteral">&quot;  n_boxes: &quot;</span> &lt;&lt; n_boxes
        &lt;&lt; <span class="stringliteral">&quot;  n_samples: &quot;</span> &lt;&lt; n_samples &lt;&lt; <span class="stringliteral">&quot;  rng_seed = &quot;</span> &lt;&lt; theSeed
        &lt;&lt; endl; <span class="comment">//getchar();</span>

    <span class="comment">//Parameters specific to the Levy target</span>
    real <a class="code" href="LevyFobj2D_8cpp.shtml#ae3d1dc6c8ff5f4490d10dd105dfce9a7">Temperature</a> = 40.0;
    real <a class="code" href="LevyFobj2D_8cpp.shtml#abe2298578938894ea3823f8baea9361e">Center1</a> = 1.42513;
    real <a class="code" href="LevyFobj2D_8cpp.shtml#a896d9a31b2c3aeb2deecb90e98e18a14">Center2</a> = 0.80032;
    real <a class="code" href="LevyFobj2D_8cpp.shtml#a37e4011a5b0b8b87b1893520477568a2">GlobalMax</a> = 176.14;
    real <a class="code" href="LevyFobj2D_8cpp.shtml#ae28a2599911ae746bc33211d3ea52aaf">DomainLimit</a> = 10.0;    <span class="comment">//0.999999999999999;</span>
    <span class="keywordtype">bool</span> UseLogPi = <span class="keyword">false</span>; <span class="comment">// log scale won&#39;t work naively</span>

    <span class="comment">// make the function object</span>
    <a class="code" href="classFLevy2D.shtml" title="two-dimensional Levy density as a function object class">FLevy2D</a> F_Levy_Temp_2D(Temperature, GlobalMax,
                        Center1, Center2, DomainLimit, UseLogPi);

    <span class="comment">// create the sampler</span>
    <a class="code" href="classMRSampler.shtml" title="The Moore rejection sampler class for trans-dimensional targets over labeled metric spaces...">MRSampler</a> theSampler (F_Levy_Temp_2D, n_boxes, Alb, theSeed,
                        (use_f_scale == 1));

    <span class="comment">// produce the samples (n_sample samples should be produced)</span>
    <a class="code" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> rs_sample; <span class="comment">// object for the sample</span>

    theSampler.RejectionSampleMany (n_samples, rs_sample);
</pre></div></p>
<p>We make a root box which will be used by all the histograms to be averaged.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// make a box: the same box will be used by all histograms</span>
    <span class="comment">// so should be big enough for all of them, so use the function domain</span>
    <span class="comment">// set up the domain list</span>
    ivector pavingBox(2);
    interval dim1(-DomainLimit, DomainLimit);
    interval dim2(-DomainLimit, DomainLimit);
    pavingBox[1] = dim1;
    pavingBox[2] = dim2;
</pre></div></p>
<p>We specify how many data points are to go into each sample and how many histograms to average over, then make an AdaptiveHistogramCollator to collate the separate histograms together.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordtype">size_t</span> samplesize = 10000; <span class="comment">// number of samples to take from the RSSample</span>

    <span class="comment">// the number of histograms to generate</span>
    <span class="keywordtype">size_t</span> numSamples = 10;

    <span class="comment">// make a collation object, empty at present</span>
    AdaptiveHistogramCollator coll;
</pre></div></p>
<p>We will use a single method of the AdaptiveHistogramCollator object to both create each histogram using priority queue splitting and collate the histograms.</p>
<p>For this we need to set up function objects and other arguments to be used in the priority queue operations.</p>
<p>In this example we specify that nodes should be compared on the basis of the number of data points associated with them by using a node comparision function object of type <a class="el" href="classsubpavings_1_1CompCount.shtml">CompCount </a>. This means that the node most in need of attention in the priority queue is the one with the largest number of data points associated with it.</p>
<p>We specifiy a stopping rule with a histogram evaluation function object of type CritSmallestVol_LTE. This object is constructed to stop a priority queue when the volume of the smallest box in the subpaving (partition) is less than 0.05.</p>
<p>We could specify a minimum number of data points that can be associated with any node in a tree. In this example we set this to 0 which will have no effect on the priority queue operations. Similarly we use minVolB = 0.0 to specify no minimum volume for the boxes represented by nodes in the trees. See <a class="el" href="AdaptiveHistograms.shtml#adhsubsec_pq">Priority queue-based partitions</a> and the AdaptiveHistogram::prioritySplit() method documentation for more information about the operation of these arguements.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// set up objects for priority queue splitting</span>

    <span class="comment">// node comparison using count of data points associated with nodes</span>
    CompCount compCount;

    <span class="comment">// stopping on smallest volume criteria for splittable nodes</span>
    <span class="keywordtype">double</span> vol = 0.05;
    CritSmallestVol_LTE critSmallestVol(vol);

    <span class="comment">/* A node is not splittable if splitting that node would give at least</span>
<span class="comment">    one child with &lt; minPoints of data associated with it.*/</span>
    <span class="keywordtype">size_t</span> minPoints = 0;

    <span class="comment">/* minVolB is the multiplier for (log n)^2/n to determine the minumum</span>
<span class="comment">    volume for a splittable node where n is total points in subpaving.</span>
<span class="comment">    A node with volume &lt; minVolB(log n)^2/n will not be splittable. */</span>
    <span class="keywordtype">double</span> minVolB = 0.0;
</pre></div></p>
<p>The actual creation of the 'sample' histograms and their collation into the AdaptiveHistogramCollator is carried out using the AdaptiveHistogramCollator::collateFromRSSampleSplitPQ() method. If the method is successful, it will output a separate txt file for each 'sample' histogram.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordtype">bool</span> success = coll.collateFromRSSampleSplitPQ(samplesize, numSamples,
                    rs_sample, pavingBox, compCount,
                    critSmallestVol, minPoints, minVolB);
</pre></div></p>
<p>We can then output the collated results (CollatorHistogram.txt) and the average over the different histograms (AverageHistogram.txt).</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> (success) {
    <span class="keywordtype">string</span> fileName = <span class="stringliteral">&quot;CollatorHistogram.txt&quot;</span>;
    coll.outputToTxtTabs(fileName); <span class="comment">// output the collation to file</span>

    <span class="comment">//  Make an average histogram</span>
    AdaptiveHistogramCollator avColl = coll.makeAverage();
    fileName = <span class="stringliteral">&quot;AverageHistogram.txt&quot;</span>;     <span class="comment">// provide a filename</span>

    avColl.outputToTxtTabs(fileName);  <span class="comment">// output the average to file</span>
    }

    <span class="keywordflow">else</span>    cout &lt;&lt; <span class="stringliteral">&quot;Failed to create collation over histograms&quot;</span> &lt;&lt; endl;
</pre></div></p>
<p>The example program then ends.</p>
<p><div class="fragment"><pre class="fragment">    <span class="keywordflow">return</span> 0;

} <span class="comment">// end of Levy test program</span>
</pre></div></p>
<h3><a class="anchor" id="adhsubsec_exambyhand"></a>
Example of insertion of data defined in the program</h3>
<p>This is an example of a section of code which sets up an AdaptiveHistogram object by specifying the root box (the interval [-40.0 40.0]) as well as the splitting value (2) and then defines the data within the program code and feeds each value individually to the AdaptiveHistogram. It is unlikely that this method would be useful in most practical circumstances but the example is included to illustrate the use of the pre-specified root box and the insertOne() method.</p>
<div class="fragment"><pre class="fragment">  ivector x(1);
  x[1] = interval(-40.0, 40.0);

  AdaptiveHistogram myHist(x);

  <span class="keywordtype">size_t</span> k = 2;
  <span class="comment">// function object to split when &gt; 2 data points associated with a node</span>
  SplitOnK splitDecision(k);

  real newreal = -3.0;
  <span class="comment">// one dimensional rvector, only element is newreal</span>
  myHist.insertOne(newdata, splitDecision);

  newreal = 14.0;
  newdata = _rvector(newreal); <span class="comment">// another one</span>
  myHist.insertOne(newdata, splitDecision);

  newreal = 6.0;
  newdata = _rvector(newreal); <span class="comment">// another one</span>
  myHist.insertOne(newdata, splitDecision);

  newreal = -10.0;
  newdata = _rvector(newreal); <span class="comment">// another one</span>
  myHist.insertOne(newdata, splitDecision);

  newreal = -3.0;
  newdata = _rvector(newreal); <span class="comment">// another one</span>
  myHist.insertOne(newdata);
</pre></div><hr/>
<h2><a class="anchor" id="adhsec_furtherdev"></a>
Further development</h2>
<p>The AdaptiveHistogram class has not yet been fully developed. More methods and functionality can be usefully added.</p>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000002">Todo:</a></b></dt><dd><p class="startdd">More flexible user friendly input and output </p>
<p class="enddd">Generate graphical output for histograms</p>
</dd></dl>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:24 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
