<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::AdaptiveHistogramValidation Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1AdaptiveHistogramValidation.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::AdaptiveHistogramValidation Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::AdaptiveHistogramValidation" -->
<p>A wrapper or manager for an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> aka StatsSubPavingVal in conjunction with massive amounts of sample data.  
 <a href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::AdaptiveHistogramValidation:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1AdaptiveHistogramValidation__coll__graph.png" border="0" usemap="#subpavings_1_1AdaptiveHistogramValidation_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1AdaptiveHistogramValidation_coll__map" id="subpavings_1_1AdaptiveHistogramValidation_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1AdaptiveHistogramValidation-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae0f0cb633c516b90444862c87eef424c">AdaptiveHistogramValidation</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae0f0cb633c516b90444862c87eef424c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a07760421ee7a7bdf1d38cf29a1ebf5c8">AdaptiveHistogramValidation</a> (bool as)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a07760421ee7a7bdf1d38cf29a1ebf5c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a3ef9f2889ef3bde29457990c210094e9">AdaptiveHistogramValidation</a> (ivector &amp;v, bool as=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a3ef9f2889ef3bde29457990c210094e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a899983cbb878e24d4e3d7e54601b7dd2">AdaptiveHistogramValidation</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a899983cbb878e24d4e3d7e54601b7dd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aba8d900d6f696824de3e6cb5bb99e794">operator=</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#aba8d900d6f696824de3e6cb5bb99e794"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ad3d12ca5330306b377001a4064599430">operator+</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded addition operator.  <a href="#ad3d12ca5330306b377001a4064599430"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a26664847dd161cb938bddb579946b018">~AdaptiveHistogramValidation</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a26664847dd161cb938bddb579946b018"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59">getSubPaving</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> this manages.  <a href="#a6449b127c16423141cbed8f193cfcf59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a23a25c2169c94e019859f8efc2657c1b">getRootVcounter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets count in the rootpaving in the root paving.  <a href="#a23a25c2169c94e019859f8efc2657c1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abba9be0456a1228037dd40e7353d2169">getRootLeaves</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of leaf nodes in the root paving.  <a href="#abba9be0456a1228037dd40e7353d2169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a22ac33f1952cfb6b605193cddab42bae">getRootSumLeafCountOverVol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sum of leaf count over volume in root paving.  <a href="#a22ac33f1952cfb6b605193cddab42bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8d94391339b619f6f3aefb89ca761e99">getMinVol</a> (double minVolB) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of the minimum volume for a splittable node.  <a href="#a8d94391339b619f6f3aefb89ca761e99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abfd3760f709336024357625903d9f2e9">getHoldAllStats</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value of holdAllStats field.  <a href="#abfd3760f709336024357625903d9f2e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab9672c3fe9ee4ced96a1ad03ee12c1c9">getLeafLevels</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acba6350d62c4aa8c1d9de5589c039543">getLeafLevelsString</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a234fc6618948f692ea2458cedb4fed8f">getLeafCounts</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a75453f853b530cd3e2a7afccf25e39d0">outputLog</a> (const std::string &amp;s, const int i) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append current state of histogram to a txt log file.  <a href="#a75453f853b530cd3e2a7afccf25e39d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a30cd1199dfab7883a8191e501d372613">mergeUp</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a multileaf histogram up to just root box.  <a href="#a30cd1199dfab7883a8191e501d372613"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7498bdc1663c857052e5bc147bf086f7">splitToShape</a> (std::string instruction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a histogram to a specified shape.  <a href="#a7498bdc1663c857052e5bc147bf086f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a0286278b4e489ed8809dcb60d136dce7">outputGraphDot</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a .dot graph file from histogram structure.  <a href="#a0286278b4e489ed8809dcb60d136dce7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ac7ad1cd4a9403ae91083dc0ef2356a24">outputToTxtTabs</a> (const std::string &amp;s, bool confirm=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the subpaving managed by this to a txt file.  <a href="#ac7ad1cd4a9403ae91083dc0ef2356a24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a78d5c3ad5e31fc438e0c4cac65e73313">outputRootToTxt</a> (const std::string &amp;s, bool confirm=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output details of full sample (from root) to txt tile.  <a href="#a78d5c3ad5e31fc438e0c4cac65e73313"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert rvectors in a txt file into AdaptiveHistogram object.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>A group of overloaded functions which read in lines of data representing rvectors from a txt file. The dimensions of the rvector are deduced from the input format and all the data then expected to have the same dimension. Any data not matching the expected dimensions, based on assessing the first valid line found, will be rejected. Expects one line per rvector with the elements separated by white space (space or tabs), with no non-numeric characters. Carries out some basic data checking through <a class="el" href="namespacesubpavings.shtml#af62c725dd362922c15d45983e2d8f6cf" title="A quick check on a data string: expecting only numbers white space or decimal points.">checkString()</a>. Input lines which do not pass are printed to standard output with an error message but the entire file will continue to be processed and valid lines converted to rvectors which are stored in theData. Conversion to rvectors is via the cxsc::operator&lt;&lt; which allows an rvector to be constructed from a stream.</p>
<p>Can read 1-d rvector data from doubles or floats but insists on a decimal point in each number (otherwise the number is rejected).</p>
<p>For example, a string "12.04 1.00005e-10 -30.0006" will be read as a 3-dimensional rvector, a string "-30.0006" will be read as a 1-dimensional rvector and a string "30" will be rejected.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to read data from. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">headerlines</td><td>is number of headerlines to skip before reading data. Defaults to 0. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging) </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A file with filename s in the same directory as <a class="el" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> or with the filename incorporating directory location. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data inserted, false if txt file cannot be read, is empty, or contains no valid data, or if something failed after data is read and when it is being inserted. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a1c8f4b1ea86038de1e1d780f227f9b28">insertRvectorsFromTxt</a> (const std::string &amp;s, std::vector&lt; size_t &gt; &amp;numNodes, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ad8df8dae6a879dc00975edfe4a0cc3b6">insertRvectorsFromTxt</a> (const std::string &amp;s, std::vector&lt; size_t &gt; &amp;numNodes, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, const std::size_t headerlines=0, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert all rvectors from a container of rvectors.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa0d5d92e0474bfc0574340b34268dd39">insertFromRVec</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6817e38bd1c2749a711f702c70dd16b5">insertFromRVecForHoldOut</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, int holdOutCount, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging=<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ace1a6eca888d6251a7e3db5d1c59bf2b">insertFromRSSampleForHoldOut</a> (const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, int label, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, int holdOutCount, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data splitting method to obtain the "best" estimate.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Implementation of the data splitting method based on Devroye and Lugosi, 2001, p. 98.</p>
<p>This takes a histogram and progressively split using a priority queue to determine which node to split first. The current histogram is added into an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator </a> object. The Yatracos set as defined in Devroye and Lugosi, 2001 is obtained and stored in a list of pointers to sets of <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">subpavings::CollatorSPnode</a>. The corresponding delta value is obtained by taking the difference of the empirical measure of the training data and the empirical measure of the validation data.</p>
<p>Splitting continues until some criteria applying either to individual nodes or to the histogram as a whole is satisfied, or there are no more splittable nodes, or if some criteria in relation to the delta value is satisfied.</p>
<p>Nodes are not considered to be splittable if they satisfy two criteria: First, their volume is greater than the minimum volume specified for the histogram as a whole, minVolB. Second if both prospective children would have at least the parameter minChildPoints data points associated with them.</p>
<p>If more than one node is equally 'large', on the basis of the node comparison compTest used, then a random choice is made between all equally large nodes to find the node which will be split.</p>
<p>The random number generator used for random selection between equally 'large' nodes uses a default seed to ensure that results can be replicated. If you are looking at distributions of results across mulitple histograms, supply the random number generator to the priority queue to ensure that each histogram will make different random choices.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compTest</td><td>is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. </td></tr>
    <tr><td class="paramname">he</td><td>is an instance of a class which provides a function to determine when to stop splitting. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points any prospective child must have for a leaf node to be splittable. </td></tr>
    <tr><td class="paramname">minVolB</td><td>is a multiplier applied to (log n)^2/n to give the the minimum volume for a splittable node. A node with volume &lt; minVolB(log n)^2/n is not splittable. Important with AIC or COPERR. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a gls random number generator. </td></tr>
    <tr><td class="paramname">tol</td><td>is the tolerance for the stopping criteria. </td></tr>
    <tr><td class="paramname">distr</td><td>is an integer that indicates what distribution is being used to calculate the integrated absolute error (IAE) for simulation purposes. If 0, there will be no calculations for the IAE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>coll an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator </a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, int distr, int method, size_t hist, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ad076189eb2565d34b8f4998eb7330827">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, int distr, int method, size_t hist, size_t maxLeafNodes)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data splitting method to obtain the "best" estimate for uniform</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>mixtures.</p>
<p>The implementation is the same as above except that the IAE calculations are for uniform mixtures.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compTest</td><td>is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. </td></tr>
    <tr><td class="paramname">he</td><td>is an instance of a class which provides a function to determine when to stop splitting. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points any prospective child must have for a leaf node to be splittable. </td></tr>
    <tr><td class="paramname">minVolB</td><td>is a multiplier applied to (log n)^2/n to give the the minimum volume for a splittable node. A node with volume &lt; minVolB(log n)^2/n is not splittable. Important with AIC or COPERR. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a gls random number generator. </td></tr>
    <tr><td class="paramname">tol</td><td>is the tolerance for the stopping criteria. </td></tr>
    <tr><td class="paramname">myPart</td><td>is a reference to to StatsSubPaving that is split into a uniform mixture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>coll an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator </a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a63938649a46bb4a5ed5d432606b02427">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;optHist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae982e9b5ffc50d9893a557a09bfc89af">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;optHist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">prioritySplitAndEstimateWithSwitch</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;opthist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae2684877f0996eea6f6593f1be2ab38a">prioritySplitAndEstimateWithSwitch</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;opthist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae94f662a33afa791de400341ad98cff7">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;optHist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a831814eaa200ac0fb42b5b600ec785c3">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;optHist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae20e1507aad418b0d5aee31882b738ea">prioritySplitAndEstimateWithSwitch</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;optHist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ad3f8cf7cf11ce1214abd2559bea54393">prioritySplitAndEstimateWithSwitch</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;optHist)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data splitting method to obtain the "best" estimate for finite</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>mixtures.</p>
<p>The implementation is the same as above except that the IAE calculations are for finite mixtures.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compTest</td><td>is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. </td></tr>
    <tr><td class="paramname">he</td><td>is an instance of a class which provides a function to determine when to stop splitting. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points any prospective child must have for a leaf node to be splittable. </td></tr>
    <tr><td class="paramname">minVolB</td><td>is a multiplier applied to (log n)^2/n to give the the minimum volume for a splittable node. A node with volume &lt; minVolB(log n)^2/n is not splittable. Important with AIC or COPERR. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a gls random number generator. </td></tr>
    <tr><td class="paramname">tol</td><td>is the tolerance for the stopping criteria. </td></tr>
    <tr><td class="paramname">myPart</td><td>is a reference to to StatsSubPaving that is split into a uniform mixture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>coll an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator </a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a46ff8e128b5d734c3839871c465bcf46">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, <a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;opthist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a990028dc08bc4780df6a04f78b4ec644">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, <a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;opthist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8f39563ed08722fbe6be55474681abd5">prioritySplitAndEstimateWithSwitch</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, <a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;opthist)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6bd25ba3a874dee64a2fd93984542f39">prioritySplitAndEstimateWithSwitch</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, <a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;opthist)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data splitting method to obtain the "best" estimate. Samples</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>drawn from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> function estimations.</p>
<p>The implementation is the same as above except that the IAE calculations are for uniform mixtures.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compTest</td><td>is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. </td></tr>
    <tr><td class="paramname">he</td><td>is an instance of a class which provides a function to determine when to stop splitting. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points any prospective child must have for a leaf node to be splittable. </td></tr>
    <tr><td class="paramname">minVolB</td><td>is a multiplier applied to (log n)^2/n to give the the minimum volume for a splittable node. A node with volume &lt; minVolB(log n)^2/n is not splittable. Important with AIC or COPERR. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a gls random number generator. </td></tr>
    <tr><td class="paramname">stopCrit</td><td>is a bool to indicate if the splits are to stop when some criteria is met. </td></tr>
    <tr><td class="paramname">method,:</td><td>1. Yatracos; 2: Scheffe </td></tr>
    <tr><td class="paramname">hist</td><td>is the hist-th simulation </td></tr>
    <tr><td class="paramname">maxLeafNodes</td><td>is the maximum number of leaves allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>coll an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator </a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aeb61aa929e6edebe98d6d4fbb10a6adb">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, bool stopCrit, int method, size_t hist, size_t maxLeafNodes, <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;nodeEst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab38050780c66024e0c278789b37e25ed">prioritySplitAndEstimate</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, int method, size_t hist, size_t maxLeafNodes, <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;nodeEst)</td></tr>
<tr><td colspan="2"><div class="groupHeader">A heuristic data splitting method to obtain the "best" estimate</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>for uniform mixtures.</p>
<p>The implementation is similar same as above but instead of making pairwise comparisons at each split, we instead do a process of elimination and do pairwise comparisons.</p>
<p>Note: this method is used if wanting to calculat IAE for uniform mixtures.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compTest</td><td>is an instance of a class providing a function for comparing spsnodes, to order the nodes to prioitise splitting. </td></tr>
    <tr><td class="paramname">he</td><td>is an instance of a class which provides a function to determine when to stop splitting. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether histogram creation output is sent to a log file (defaults to no logging). </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points any prospective child must have for a leaf node to be splittable. </td></tr>
    <tr><td class="paramname">minVolB</td><td>is a multiplier applied to (log n)^2/n to give the the minimum volume for a splittable node. A node with volume &lt; minVolB(log n)^2/n is not splittable. Important with AIC or COPERR. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a gls random number generator. </td></tr>
    <tr><td class="paramname">tol</td><td>is the tolerance for the stopping criteria. </td></tr>
    <tr><td class="paramname">myPart</td><td>is a reference to to StatsSubPaving that is split into a uniform mixture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>coll an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator </a> object. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a86feeca7ad74bc1c9ebc35f2ef0dd5e6">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, long double tol, <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, size_t maxLeafNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a9a558b6a13ad7019acd893f0edbb107b">prioritySplit</a> (const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;compTest, const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;he, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, long double tol, <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, size_t maxLeafNodes)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get the IAE of a distribution</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Get the integrated absolute error of the specified distribution. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">distr</td><td>is an integer that indicates which distribution is used. 1: bivariate gaussian distribution (not implemented yet) 2: Levy 2D distribution (not implemented yet) 3: Rosenbrock 2D distribution (not implemented yet) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the integrated absolute error for this realization </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae599e0bbb226dc0610c4ec25845533d8">getIAE</a> (int distr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a034c61becd57f5d282435f5881950035">getFinMixIAE</a> (<a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a> (<a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, double tol, int deg, bool full)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab032205bb13623930c84ff142f565ac5">get2DIAE</a> (<a class="el" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a>(*testpnt)(<a class="el" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a>, interval))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a> (<a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, double weight, vector&lt; int &gt; holesLoc, bool full)</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7bebcc83720d315cbbb8c8ab85d7a945">AdaptiveHistogramValidation</a> (<a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *spn, bool as)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Private initialised constructor. Initialised with pointer to subpaving and value for holdAllStats.  <a href="#a7bebcc83720d315cbbb8c8ab85d7a945"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acf7246052d9032f41a4f237f1b5207d9">completeDataInsertionFromVec</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t holdOutCount, std::vector&lt; size_t &gt; &amp;numNodes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete insertion of training and validation data from a vector container.  <a href="#acf7246052d9032f41a4f237f1b5207d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7b6e78d7a069536dd096e81c6e3d8e1f">haveMadePaving</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const size_t dim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if we need to make root paving for the histogram object.  <a href="#a7b6e78d7a069536dd096e81c6e3d8e1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ac57fa83d1ec2fc1e9cf1565c9cc07f91">insertDataFromContainer</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> logging, size_t holdOutCount, std::vector&lt; size_t &gt; &amp;numNodes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert training and validation data from a container.  <a href="#ac57fa83d1ec2fc1e9cf1565c9cc07f91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a34f7487fd92886151634c00e8e75cca5">outputLogStart</a> (const std::string &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opening line of a txt log file.  <a href="#a34f7487fd92886151634c00e8e75cca5"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abaa0f3ffd23bccd07a2c4a4b9a60e579">makeBox</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const size_t dim)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a box to contain all the data.  <a href="#abaa0f3ffd23bccd07a2c4a4b9a60e579"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0">checkNodeCountForSplit</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const spn, bool volChecking, double minVol, size_t minChildPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to do checking for whether to split a node.  <a href="#ae63a7462ea0b3f0fc11ff45eff208cd0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c">rootVpaving</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root node of the subpaving tree.  <a href="#a811e21423987027452237cabf38c008c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c">rootBox</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The root box used to form the subpaving tree.  <a href="#aa8a961766f97013134d73f1735f3516c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">BigDataCollection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93">dataCollection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for all sample data passed to this.  <a href="#acae18e51a5026807492d2109702c3c93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd">holdAllStats</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls whether all available statistics are maintained in the rootPaving. If set to false (default) only counts are maintained.  <a href="#a4de24d08db784df2fdb619ba2c1f62fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2">creationString</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A string showing the order of creation of the rootPaving.  <a href="#a7d46cc6c04481f9579e9f5238ccea8b2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a0039bec0f033c35a5477375cb54eb8ea">padding</a> = 0.000005</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a constant for padding a box if it is tailor-made for data.  <a href="#a0039bec0f033c35a5477375cb54eb8ea"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A wrapper or manager for an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> aka StatsSubPavingVal in conjunction with massive amounts of sample data. </p>
<p>Here sample data is multi-dimensional point-valued data in a cxsc::rvector container. The <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml" title="A wrapper or manager for an SPSVnode aka StatsSubPavingVal in conjunction with massive amounts of sam...">AdaptiveHistogramValidation</a> class manages <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode </a> objects (<a class="el" href="namespacesubpavings.shtml#ace6b16f0adf0db13eeb38e124d5328c6">StatsSubPavings </a>) for the purpose of creating adaptive histograms from sample data and also manages the container for the sample data itself.</p>
<p>An <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> (a pointer to an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> is aliased as StatsSubPaving) is a binary tree representation of a regular subpaving which can be used for processing statistical sample data. SPSVnodes do not actually hold data, they only need to know where the data they are associated with is stored. The leaf nodes in the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree controlled by an <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml" title="A wrapper or manager for an SPSVnode aka StatsSubPavingVal in conjunction with massive amounts of sam...">AdaptiveHistogramValidation</a> object have a vector of iterators into the <a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">BigDataCollection</a>, a dataCollection managed by that <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml" title="A wrapper or manager for an SPSVnode aka StatsSubPavingVal in conjunction with massive amounts of sam...">AdaptiveHistogramValidation</a> object.</p>
<p>The <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml" title="A wrapper or manager for an SPSVnode aka StatsSubPavingVal in conjunction with massive amounts of sam...">AdaptiveHistogramValidation</a> class uses the C-XSC library class rvector for sample data points. rvectors can have 1 or many dimensions. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00082">82</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7bebcc83720d315cbbb8c8ab85d7a945"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation" ref="a7bebcc83720d315cbbb8c8ab85d7a945" args="(SPSVnode *spn, bool as)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7bebcc83720d315cbbb8c8ab85d7a945">AdaptiveHistogramValidation::AdaptiveHistogramValidation</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Private initialised constructor. Initialised with pointer to subpaving and value for holdAllStats. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00098">98</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">rootBox</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(as)
{
    <span class="keywordflow">if</span> (NULL == spn) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Cannot use null SPSVnode pointer in constructor&quot;</span>);
    }
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = spn;
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a> = spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();

    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae0f0cb633c516b90444862c87eef424c"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation" ref="ae0f0cb633c516b90444862c87eef424c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7bebcc83720d315cbbb8c8ab85d7a945">AdaptiveHistogramValidation::AdaptiveHistogramValidation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>By default, only counts are maintained in subpaving this manages, rather than all available stats. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00402">402</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">rootBox</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(<span class="keyword">false</span>), <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a>(<span class="stringliteral">&quot;&quot;</span>)
{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = NULL;
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a> = ivector();    <span class="comment">// ivector with length 1 and undefined elements</span>


    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a07760421ee7a7bdf1d38cf29a1ebf5c8"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation" ref="a07760421ee7a7bdf1d38cf29a1ebf5c8" args="(bool as)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7bebcc83720d315cbbb8c8ab85d7a945">AdaptiveHistogramValidation::AdaptiveHistogramValidation</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with parameter controlling whether all available statistics be maintained in the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml" title="A wrapper or manager for an SPSVnode aka StatsSubPavingVal in conjunction with massive amounts of sam...">AdaptiveHistogramValidation</a> (true for all stats, false for counts only). </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00414">414</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">rootBox</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(as), <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a>(<span class="stringliteral">&quot;&quot;</span>)
{
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = NULL;
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a> = ivector();    <span class="comment">// ivector with length 1 and undefined elements</span>


    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3ef9f2889ef3bde29457990c210094e9"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation" ref="a3ef9f2889ef3bde29457990c210094e9" args="(ivector &amp;v, bool as=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7bebcc83720d315cbbb8c8ab85d7a945">AdaptiveHistogramValidation::AdaptiveHistogramValidation</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>as</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with domain box. By default, only counts are maintained as stats in the in the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> tree managed by this <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml" title="A wrapper or manager for an SPSVnode aka StatsSubPavingVal in conjunction with massive amounts of sam...">AdaptiveHistogramValidation</a>.</p>
<p>Ideal constructor when the support domain of data is known a priori or has been transformed to a known domain but splitting criteria have not been determined a priori. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00427">427</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">rootBox</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(as)
{
    <span class="keywordflow">try</span> {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>(v, !as);
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();

        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a> = v;
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor:&quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor:&quot;</span> + msg);
    }

    <span class="comment">// nothing happens to dataCollection when object is constructed</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a899983cbb878e24d4e3d7e54601b7dd2"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::AdaptiveHistogramValidation" ref="a899983cbb878e24d4e3d7e54601b7dd2" args="(const AdaptiveHistogramValidation &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7bebcc83720d315cbbb8c8ab85d7a945">AdaptiveHistogramValidation::AdaptiveHistogramValidation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00458">458</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00110">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a>(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a>), <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>) 
{
    <span class="keywordflow">try</span> {
       <span class="comment">// cout &lt;&lt; &quot;calling copy constructor&quot; &lt;&lt; endl;</span>
      <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>(*(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>));
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

        <span class="comment">//copy dataCollection from other to this</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93" title="A container for all sample data passed to this.">dataCollection</a> = other.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93" title="A container for all sample data passed to this.">dataCollection</a>;

    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std:: endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;SPnodeException in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor: &quot;</span> + msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a26664847dd161cb938bddb579946b018"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::~AdaptiveHistogramValidation" ref="a26664847dd161cb938bddb579946b018" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a26664847dd161cb938bddb579946b018">AdaptiveHistogramValidation::~AdaptiveHistogramValidation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00536">536</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae63a7462ea0b3f0fc11ff45eff208cd0"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::checkNodeCountForSplit" ref="ae63a7462ea0b3f0fc11ff45eff208cd0" args="(const SPSVnode *const spn, bool volChecking, double minVol, size_t minChildPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0">AdaptiveHistogramValidation::checkNodeCountForSplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>volChecking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to do checking for whether to split a node. </p>
<p>Used in prioritySplit.</p>
<p>Decides whether to split node based on checking volume and number of points that would result in child nodes.</p>
<p>Node volume must be &gt;=minVol to split and If there is a minChildPoints&gt;0 specified, then either the node must have at least minChildPoints and all the points go to one of the children (the other getting none) or the smallest number of points which would go to the either of the prospective new children must be &gt;= minChildPoints</p>
<p>Thus in general the method will only return true if the given node satisfies both the minVol test and, if it were to be split, both children would have at least minChildPoints data points, but if all the data points would go to one child (none) to the other, this is considered to also satisfy the minChildPoints test.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>is a pointer to the target node. </td></tr>
    <tr><td class="paramname">volChecking</td><td>indicates whether volume is being checked </td></tr>
    <tr><td class="paramname">minVol</td><td>is the minimum volume allowed to be tested for. </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points that there would be in the children if the node were to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if has been a test conditions satisfied, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">378</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00970">subpavings::SPSVnode::getMinChildCountIfSplit()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> ((!volChecking || (volChecking &amp;&amp; (spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>() &gt;= minVol)))
        &amp;&amp; ((minChildPoints == 0)
            || (minChildPoints &gt; 0
                &amp;&amp;
                ((spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt;= minChildPoints) &amp;&amp;
                    ((spn-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a43024ae81075f8a822ccccad013b3ef7" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() == 0)
                    ||
                    (spn-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a43024ae81075f8a822ccccad013b3ef7" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>() &gt;= minChildPoints))
                ))
            )
        ) { retValue = <span class="keyword">true</span>; }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acf7246052d9032f41a4f237f1b5207d9"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::completeDataInsertionFromVec" ref="acf7246052d9032f41a4f237f1b5207d9" args="(const RVecData &amp;theData, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging, size_t holdOutCount, std::vector&lt; size_t &gt; &amp;numNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acf7246052d9032f41a4f237f1b5207d9">AdaptiveHistogramValidation::completeDataInsertionFromVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>holdOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>numNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Complete insertion of training and validation data from a vector container. </p>
<p>First checks if the box exists and makes it otherwise, then checks box dimensions against data dimensions if box already exists, and finally inserts the data. A boolean boolVal indicates if the data should be in the training or validation set.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether a log file is created for histogram creation process; set to TXT for logging to a txt file. </td></tr>
    <tr><td class="paramname">boolVal</td><td>a boolean to indicate if the data point should be in the validation set (true) or not (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData containing at least one rvector. </dd>
<dd>
this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object may have an initialised <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> pointed to by rootPaving, but rootPaving can also be NULL. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>If the rootPaving was NULL when the function was entered, then rootPaving is pointed to a new <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> object whose root node has a box tailored to contain all the data read in. </dd>
<dd>
The data in theData has been put into the <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>'s dataCollection and also associated with rootPaving's leaves via iterators to dataCollection. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if data successfully put into a dataCollection and associated with the rootPaving's leaves, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">116</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">haveMadePaving()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">insertDataFromContainer()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">rootBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00778">insertFromRSSampleForHoldOut()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00641">insertFromRVec()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00709">insertFromRVecForHoldOut()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00589">insertRvectorsFromTxt()</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="comment">//find the data dimensions from the first datapoint</span>
    <span class="keywordtype">int</span> dataDim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*theData.begin()) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*theData.begin()) + 1;

    <span class="comment">// ensure the paving exists</span>
    <span class="keywordtype">bool</span> hadToMakePaving = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7b6e78d7a069536dd096e81c6e3d8e1f" title="Checks if we need to make root paving for the histogram object.">haveMadePaving</a>(theData, dataDim);

    <span class="comment">// if we did not make the paving we have to check data dimensions</span>
    <span class="keywordflow">if</span> (!hadToMakePaving) {
        <span class="keywordflow">if</span>(dataDim != (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a>) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a>)) + 1) {

            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Dimensions of data do not match paving&quot;</span>);
        }
    }

    <span class="comment">// insert the data</span>
  <span class="comment">//  std::cout &lt;&lt; &quot;calling insertData...&quot; &lt;&lt; endl;</span>
    <span class="keywordtype">size_t</span> dataCountInserted
            = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ac57fa83d1ec2fc1e9cf1565c9cc07f91" title="Insert training and validation data from a container.">insertDataFromContainer</a>(theData, boolTest, logging, holdOutCount,
                                  numNodes);

    <span class="keywordflow">if</span> (dataCountInserted &gt; 0) {
        retValue = <span class="keyword">true</span>;
        <span class="comment">// switch on for more output during histogram creation &quot;</span>
        <span class="comment">/*</span>
<span class="comment">        std::cout &lt;&lt; &quot;End of inserting data: &quot; &lt;&lt; dataCountInserted</span>
<span class="comment">            &lt;&lt; &quot; data points inserted to dataCollection &quot;</span>
<span class="comment">            &lt;&lt; std:: endl;</span>
<span class="comment">        std::cout &lt;&lt; &quot;and associated with the tree if &quot;</span>
<span class="comment">            &lt;&lt; &quot;they fit into the root box&quot; &lt;&lt; std::endl;</span>
<span class="comment">        std::cout &lt;&lt; &quot;(check console output for possible records &quot;</span>
<span class="comment">            &lt;&lt; &quot;of datapoints which did not fit)&quot; &lt;&lt; std::endl;</span>
<span class="comment">        */</span>
        }

    <span class="keywordflow">if</span> (dataCountInserted == 0) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No data inserted&quot;</span>);

    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab032205bb13623930c84ff142f565ac5"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::get2DIAE" ref="ab032205bb13623930c84ff142f565ac5" args="(taylor::dim2taylor(*testpnt)(taylor::dim2taylor_vector, interval))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab032205bb13623930c84ff142f565ac5">AdaptiveHistogramValidation::get2DIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a>(*)(<a class="el" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a>, interval)&#160;</td>
          <td class="paramname"><em>testpnt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE of a bivariate gaussian/Levy 2D/Rosen 2D distribution.</p>
<p>Get the IAE for a finite mixture distribution </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03601">3601</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="Int_8h.shtml#a0de7ac342c4093f00c8fd6b899e54d87">integrateWithSplitting()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03408">getIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//number of points</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
   
  <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  (*this).getSubPaving()-&gt;getLeaves(leaves); <span class="comment">// fill the container</span>

  <span class="comment">// set up for taylor integration</span>
 <span class="comment">// taylor::dim2taylor (*testpnt)(taylor::dim2taylor_vector, interval);</span>
  real tol=1e-6;
  <span class="keywordtype">int</span> o=16;
 <span class="comment">// testpnt=BiGOP;</span>

  real result = 0; 
  <span class="keywordflow">for</span> (it=leaves.begin(); it &lt; leaves.end(); it++)
  { 
    <span class="comment">//get fhat  </span>
     interval fhat = interval(real((*it)-&gt;getCounter()/
                             (((*it)-&gt;nodeVolume())*1.0*n))); 
     
    <span class="comment">//get domain</span>
    ivector domain = (*it)-&gt;getBox();
     <span class="comment">// get the integrated absolute error at this box</span>
    interval resultInt = <a class="code" href="Int_8h.shtml#a0de7ac342c4093f00c8fd6b899e54d87">integrateWithSplitting</a>(testpnt, fhat, domain, o, tol);    
     <span class="comment">//add the errors    </span>
     result += Sup(resultInt);
   }
  <span class="comment">//accounting for boundaries - will have to think about this later perhaps</span>
  <span class="comment">//accumulate(dpIAE,gsl_cdf_ugaussian_P(xlow[0]),1.0);</span>
  <span class="comment">//accumulate(dpIAE,gsl_cdf_ugaussian_Q(xupp[nLeaves-1]),1.0);</span>
  <span class="keywordflow">return</span> result;  
}
</pre></div>
</div>
</div>
<a class="anchor" id="a034c61becd57f5d282435f5881950035"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getFinMixIAE" ref="a034c61becd57f5d282435f5881950035" args="(FinMix &amp;mixt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a034c61becd57f5d282435f5881950035">AdaptiveHistogramValidation::getFinMixIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a finite gaussian mixture distribution.</p>
<p>Get the IAE for a finite mixture distribution </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03530">3530</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAEBoun</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00223">FinMix::fhat</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00191">FinMixAbs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//---------fill in containers for names, volumes and heights of leaves</span>
  <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  (*this).getSubPaving()-&gt;getLeaves(leaves); <span class="comment">// fill the container</span>
  <span class="comment">//a container for the counts</span>
  <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> counts;  <span class="comment">// IntVec is a typedef for vector&lt;int&gt;</span>
  <span class="comment">//a container for the boxes</span>
  vector&lt;ivector&gt; boxes; vector&lt;ivector&gt;::iterator itBoxes;
  <span class="comment">//a container for the volumes</span>
  vector&lt;double&gt; volumes;
  <span class="comment">// a container for fhat</span>
  vector&lt;double&gt; fhat; vector&lt;double&gt;::iterator itFhat;
  <span class="comment">//number of points</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
            
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    <span class="comment">// remember that it points to a pointer, so *it is still a ptr</span>
    <span class="comment">// get the counts in all the leaves</span>
     counts.push_back((*it)-&gt;getCounter());
     <span class="comment">// get the boxes from all the leaves</span>
     boxes.push_back((*it)-&gt;getBox());
     <span class="comment">// get the volumes of all the leaves</span>
     volumes.push_back((*it)-&gt;nodeVolume());
     <span class="comment">// get fhat for all leaves</span>
     fhat.push_back(((*it)-&gt;getCounter())/((*it)-&gt;nodeVolume())/n);
  } <span class="comment">// end of iterating through leaves </span>
  
  <span class="comment">//----------------get the IAE-----------------------------------------------</span>
  dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>, <a class="code" href="HoldOutFinMix_8cpp.shtml#a97e24d3d1886f2162f0daa315bc812a7">dpIAEBoun</a>;
  dpIAE = 0.0;
  <span class="keywordtype">int</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>=counts.size();
  
  gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
  <span class="keywordtype">double</span> result = 0.0;
  <span class="keywordtype">double</span> error;
  gsl_function <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>;
  
  F.function = &amp;<a class="code" href="errorfunc_8cpp.shtml#a0350bc07337b5abac1dca82fb195940d" title="Get the absolute error of a finite mixture at x.">FinMixAbs</a>;
  F.params =  &amp;mixt;
  
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; j++){
    mixt.<a class="code" href="structFinMix.shtml#a7d058312162e6b9ccb408ddc688a274f">fhat</a> = fhat[j];
    rvector xuppVec = Sup(boxes[j]);
    <span class="keywordtype">double</span> xupp = _double(xuppVec[1]);
    rvector xlowVec = Inf(boxes[j]);
    <span class="keywordtype">double</span> xlow = _double(xlowVec[1]);
    gsl_integration_qags(&amp;F, xlow, xupp, 0, 1e-7, 1000, w, &amp;result, &amp;error);
    accumulate(dpIAE, result, 1.0);
  }
  
<span class="comment">/*  // Accounting for the boundaries</span>
<span class="comment">  rvector xuppVec1 = Sup(boxes[Nbin-1]);</span>
<span class="comment">  double xupp1 = _double(xuppVec1[1]);</span>
<span class="comment">  rvector xlowVec1 = Inf(boxes[0]);</span>
<span class="comment">  double xlow1 = _double(xlowVec1[1]);</span>
<span class="comment">  dpIAEBoun = dpFinMixIAEBoun(xlow1, xupp1, Weight, Mean, Sigma);</span>
<span class="comment">  dpIAE += dpIAEBoun;</span>
<span class="comment">*/</span>  
  <span class="comment">// cast dot precision to real</span>
  real FinMixIAE = rnd(dpIAE);
  
  <span class="comment">// free the workspace</span>
  gsl_integration_workspace_free (w);
  
  <span class="keywordflow">return</span> FinMixIAE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa8b89b93450dea8e464eac31d67c78d1"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getFinMixIntervalIAE" ref="aa8b89b93450dea8e464eac31d67c78d1" args="(FinMix &amp;mixt, double tol, int deg, bool full)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::interval <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">AdaptiveHistogramValidation::getFinMixIntervalIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a finite gaussian mixture distribution. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">3711</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01504">getL1error()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00894">subpavings::SPSVnode::getVcounter()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00221">FinMix::M</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01396">N()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00222">FinMix::S</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00220">FinMix::W</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02858">prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;get finmix interval IAE&quot; &lt;&lt; endl;</span>
  
  interval totalArea(0.0); <span class="comment">//initialize</span>
  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
  <span class="keywordtype">int</span> <a class="code" href="errorfunc_8cpp.shtml#abcd464084d71d1ca5caf89793fa1d050">N</a> = n + <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a7d7f4ecaaf020bcb614557eba4743f6a" title="Accessor for the node&#39;s validation data counter.">getVcounter</a>();
  
  <span class="comment">// need to iterate through the leaves</span>
  <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
  <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
  <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>
  
  <span class="comment">// container is filled by reading leaves off tree from left to right</span>
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    <span class="comment">//cout &lt;&lt; &quot;-----IAE for &quot; &lt;&lt; (*it)-&gt;getNodeName() &lt;&lt; endl;</span>
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;
    
    <span class="comment">//get the height in this leaf node</span>
    <span class="keywordtype">double</span> fhat;
    <span class="keywordflow">if</span> ( full == 0 ) { 
      fhat = (*it)-&gt;getCounter()/(*it)-&gt;nodeVolume()/n;
      <span class="comment">//cout &lt;&lt; (*it)-&gt;getCounter() &lt;&lt; &quot;\t&quot; &lt;&lt; (*it)-&gt;nodeVolume() &lt;&lt;&quot;\t&quot; &lt;&lt; fhat &lt;&lt; endl;</span>
    }
    <span class="keywordflow">else</span> {
      <span class="keywordtype">size_t</span> totalCount = (*it)-&gt;getCounter() + (*it)-&gt;getVcounter();
      fhat = totalCount/(*it)-&gt;nodeVolume()/<a class="code" href="errorfunc_8cpp.shtml#abcd464084d71d1ca5caf89793fa1d050">N</a>;
    }

    <span class="comment">//get the box of this leaf node</span>
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout &lt;&lt; (*it)-&gt;getBox() &lt;&lt; endl;</span>
    
    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    <span class="comment">// find the root</span>
    <span class="comment">//cout &lt;&lt; &quot;finding roots at this node &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
    <a class="code" href="errorfunc_8cpp.shtml#a4a991d5ab1bd0a117e02af6f83369bab">bisect</a>(thisIntW, tol, fhat, rootVec, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>); 

    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      <span class="comment">//cout &lt;&lt; &quot;no roots at &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        <span class="comment">//cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
        <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      <span class="comment">//cout &lt;&lt; &quot;==There are &quot; &lt;&lt; uniqueRootVec.size() &lt;&lt; &quot; unique root(s)==&quot; &lt;&lt; endl;</span>
      
      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        <span class="comment">//cout &lt;&lt; &quot;there is only one root..&quot; &lt;&lt; endl;</span>
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the left/right boundary:&quot; &lt;&lt; rootVec[0] &lt;&lt; endl;</span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          <span class="comment">//cout &lt;&lt; &quot;no root at the boundaries&quot; &lt;&lt; endl;</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;left interval: &quot; &lt;&lt; thisSubIntLeft &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLeft, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          <span class="comment">//cout &lt;&lt; &quot;right interval: &quot; &lt;&lt; thisSubIntRight &lt;&lt; endl; </span>
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntRight, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;let&#39;s have a look at all the roots:&quot; &lt;&lt; endl;</span>
        <span class="comment">//for (size_t i = 0; i &lt; uniqueRootVec.size(); i++) {</span>
          <span class="comment">//cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//}</span>

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>
  } <span class="comment">// end of iterating through the leaf nodes</span>
  
  <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; totalArea &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> totalArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abfd3760f709336024357625903d9f2e9"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getHoldAllStats" ref="abfd3760f709336024357625903d9f2e9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abfd3760f709336024357625903d9f2e9">AdaptiveHistogramValidation::getHoldAllStats</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the value of holdAllStats field. </p>
<p>This determines whether the histrogram's rootPaving will maintain all available stats (true) or just the counts (false). </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00573">573</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00115">holdAllStats</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae599e0bbb226dc0610c4ec25845533d8"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getIAE" ref="ae599e0bbb226dc0610c4ec25845533d8" args="(int distr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae599e0bbb226dc0610c4ec25845533d8">AdaptiveHistogramValidation::getIAE</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE of a distribution.</p>
<p>Get the IAE of the corresponding distribution based on function arguments. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03408">3408</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l00059">BiGOP()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03601">get2DIAE()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00088">LevyOP()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l00129">RosenOP()</a>.</p>
<div class="fragment"><pre class="fragment">{
      real IAE = 0;
    <a class="code" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a> (*testpnt)(<a class="code" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a>, interval);
    <span class="keywordflow">switch</span>(distr)
    { 
         
      <span class="keywordflow">case</span> 1: <span class="comment">//bivariate gaussian mixtures</span>
         testpnt = <a class="code" href="errorfunc_8cpp.shtml#abd72fe76528917561a4e1a7fdf7890d9" title="IAE for the bivariate gaussian.">BiGOP</a>;
      IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab032205bb13623930c84ff142f565ac5">get2DIAE</a>(testpnt);
      <span class="keywordflow">break</span>;
      
      <span class="keywordflow">case</span> 2: <span class="comment">// Levy 2D</span>
      testpnt = <a class="code" href="errorfunc_8cpp.shtml#a72f3aaf218533dc785d09b0dffacbad7" title="IAE for the Levy 2D.">LevyOP</a>;
      IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab032205bb13623930c84ff142f565ac5">get2DIAE</a>(testpnt);
      <span class="keywordflow">break</span>;
      
      <span class="keywordflow">case</span> 3: <span class="comment">//Rosenbrock 2D</span>
      testpnt = <a class="code" href="errorfunc_8cpp.shtml#a77af86554abcee2e013b9d8631ed4c5f" title="IAE for a Rosenbrock 2D.">RosenOP</a>;
      IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab032205bb13623930c84ff142f565ac5">get2DIAE</a>(testpnt);
      <span class="keywordflow">break</span>;
    }   
    <span class="keywordflow">return</span> IAE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a234fc6618948f692ea2458cedb4fed8f"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getLeafCounts" ref="a234fc6618948f692ea2458cedb4fed8f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a234fc6618948f692ea2458cedb4fed8f">AdaptiveHistogramValidation::getLeafCounts</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector of the leaf node counts.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of leaf counts, left to right order, </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03337">3337</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l01060">subpavings::SPSVnode::getLeafNodeCounts()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81" title="Define type Size_tVec as a container for size_t.">Size_tVec</a> counts; <span class="comment">// empty container</span>
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a0d6df4752e05170510e43b67d8eb3110">getLeafNodeCounts</a>(counts);
        <span class="comment">//levels has now been filled in</span>
    }
    <span class="keywordflow">return</span> counts;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab9672c3fe9ee4ced96a1ad03ee12c1c9"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getLeafLevels" ref="ab9672c3fe9ee4ced96a1ad03ee12c1c9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ab9672c3fe9ee4ced96a1ad03ee12c1c9">AdaptiveHistogramValidation::getLeafLevels</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a vector of the leaf node levels.</p>
<p>Root is level 0, next level down is 1, etc.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of leaf levels, left to right order, </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03323">3323</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00621">subpavings::SPnode::getLeafNodeLevels()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> levels; <span class="comment">// empty container</span>

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aa1df5c8572870d22d59c852b458c892b" title="Fill in a vector of leaf node levels.">getLeafNodeLevels</a>(0, levels);
        <span class="comment">//levels has now been filled in</span>
    }
    <span class="keywordflow">return</span> levels;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acba6350d62c4aa8c1d9de5589c039543"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getLeafLevelsString" ref="acba6350d62c4aa8c1d9de5589c039543" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acba6350d62c4aa8c1d9de5589c039543">AdaptiveHistogramValidation::getLeafLevelsString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a string of the leaf node levels.</p>
<p>Root is level 0, next level down is 1, etc. Example return string "3,3,2,1"</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a comma separated string of leaf levels, left to right order </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00579">579</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00692">subpavings::SPnode::getLeafNodeLevelsString()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">insertDataFromContainer()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">string</span> retValue = <span class="stringliteral">&quot;&quot;</span>;
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>)
        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a7ea8cd3649cbf13d5743d3cb23315d72" title="Get a string of leaf node levels.">getLeafNodeLevelsString</a>();

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8d94391339b619f6f3aefb89ca761e99"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getMinVol" ref="a8d94391339b619f6f3aefb89ca761e99" args="(double minVolB) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8d94391339b619f6f3aefb89ca761e99">AdaptiveHistogramValidation::getMinVol</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the value of the minimum volume for a splittable node. </p>
<p>Minimum volume = minVolB * (log n) ^2/n where n is points in histogram. Minimum volume is used in COPERR or AIC priority queue splitting to limit which nodes can be split. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minVolB</td><td>the multiplier applied to log n) ^2/n to find the minimum allowed node volume at which a node can be split (children will half the volume of the parent node). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">560</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">double</span> retValue = 0.0;

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {

        <span class="keywordtype">size_t</span> counter = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
        retValue =  minVolB * log(1.0*counter)*log(1.0*counter)/counter;
    }
    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abba9be0456a1228037dd40e7353d2169"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getRootLeaves" ref="abba9be0456a1228037dd40e7353d2169" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abba9be0456a1228037dd40e7353d2169">AdaptiveHistogramValidation::getRootLeaves</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets number of leaf nodes in the root paving. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">552</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02236">subpavings::spLeaves()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="namespacesubpavings.shtml#acd777346441d8790899ec09af3b11d61" title="Get the number of leaves of a tree (boxes in the subpaving)">spLeaves</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>); }
</pre></div>
</div>
</div>
<a class="anchor" id="a22ac33f1952cfb6b605193cddab42bae"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getRootSumLeafCountOverVol" ref="a22ac33f1952cfb6b605193cddab42bae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a22ac33f1952cfb6b605193cddab42bae">AdaptiveHistogramValidation::getRootSumLeafCountOverVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the sum of leaf count over volume in root paving. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00556">556</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l01147">subpavings::SPSVnode::getSumLeafCountOverVol()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#ac741a9772d992ba74911cf692e1ed772" title="Get the sum of the count over volume in the leaf nodes.">getSumLeafCountOverVol</a>(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a23a25c2169c94e019859f8efc2657c1b"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getRootVcounter" ref="a23a25c2169c94e019859f8efc2657c1b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a23a25c2169c94e019859f8efc2657c1b">AdaptiveHistogramValidation::getRootVcounter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets count in the rootpaving in the root paving. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00548">548</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spsvnode_8cpp_source.shtml#l00894">subpavings::SPSVnode::getVcounter()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>

<p>Referenced by <a class="el" href="UnifScheffe_8cpp_source.shtml#l00043">main()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a7d7f4ecaaf020bcb614557eba4743f6a" title="Accessor for the node&#39;s validation data counter.">getVcounter</a>(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a6449b127c16423141cbed8f193cfcf59"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getSubPaving" ref="a6449b127c16423141cbed8f193cfcf59" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59">AdaptiveHistogramValidation::getSubPaving</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> this manages. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">543</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00091">subpavings::AdaptiveHistogramVCollator::AdaptiveHistogramVCollator()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">getUnifIAE()</a>, <a class="el" href="AirTraffic_8cpp_source.shtml#l00043">main()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00068">subpavings::CritLeaves_GTEV::operator()()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00088">subpavings::CritLeaves_LTEV::operator()()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00108">subpavings::CritSmallestCount_LTEV::operator()()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00129">subpavings::CritLargestCount_LTEV::operator()()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00149">subpavings::CritSmallestVol_LTEV::operator()()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00169">subpavings::CritLargestVol_LTEV::operator()()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03970">operator&lt;&lt;()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03391">outputRootToTxt()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03367">outputToTxtTabs()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>;}
</pre></div>
</div>
</div>
<a class="anchor" id="aa54b166c50901dc9ec2976bb4a5df916"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::getUnifIAE" ref="aa54b166c50901dc9ec2976bb4a5df916" args="(AdaptiveHistogram &amp;myPart, double weight, vector&lt; int &gt; holesLoc, bool full)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">AdaptiveHistogramValidation::getUnifIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a uniform (mixture) distribution.</p>
<p>Get the IAE for the unform distribution </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">3435</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01238">subpavings::SPSVnode::getRootCounter()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00894">subpavings::SPSVnode::getVcounter()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02316">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="comment">// get the true height, f of the corresponding box in myPart</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> trueLeaves;
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> trueIt;
  <span class="comment">//AdaptiveHistogram * adhPtr;</span>
  <span class="comment">//adhPtr = &amp;myPart;</span>
  (myPart).<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(trueLeaves);

  <span class="comment">// setting up containers for the leaves</span>
  <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
  <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> it;
  <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves); <span class="comment">// fill the container</span>

  <span class="keywordtype">double</span> trueF; <span class="comment">//true density</span>
  ivector temp;
  
  dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>;    <span class="comment">// use type dotprecision for summation  </span>
  dpIAE=0.0;

  <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a346a5ff0d8177212b23342cada4b5c18" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
  <span class="keywordtype">int</span> allN = n + <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a7d7f4ecaaf020bcb614557eba4743f6a" title="Accessor for the node&#39;s validation data counter.">getVcounter</a>();
  <span class="comment">//go through all the leaves in this</span>
  <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout &lt;&lt; &quot;====checking &quot; &lt;&lt; (*it)-&gt;getBox() &lt;&lt; endl;</span>
      
    <span class="comment">// get the height of this leaf</span>
    <span class="keywordtype">double</span> fhat;
    <span class="keywordflow">if</span> ( full == 0 ) { 
      fhat = (*it)-&gt;getCounter()/(*it)-&gt;nodeVolume()/n;
      <span class="comment">//cout &lt;&lt; (*it)-&gt;getCounter() &lt;&lt; &quot;\t&quot; &lt;&lt; (*it)-&gt;nodeVolume() &lt;&lt;&quot;\t&quot; &lt;&lt; fhat &lt;&lt; endl;</span>
    }
    <span class="keywordflow">else</span> {
      <span class="keywordtype">size_t</span> totalCount = (*it)-&gt;getCounter() + (*it)-&gt;getVcounter();
      fhat = totalCount/(*it)-&gt;nodeVolume()/allN;
    }

    <span class="comment">//cout &lt;&lt; full &lt;&lt; &quot;\tfhat for box &quot; &lt;&lt; &quot;:&quot; &lt;&lt; fhat &lt;&lt; endl;</span>

    <span class="keywordtype">size_t</span> L = 0;
    <span class="keywordflow">for</span> (trueIt = trueLeaves.begin(); trueIt &lt; trueLeaves.end(); trueIt++) {
      <span class="comment">//cout &lt;&lt; &quot;----True leaf: &quot; &lt;&lt; (*trueIt)-&gt;getBox() &lt;&lt; &quot;\t&quot; &lt;&lt; endl;</span>
      ivector trueBox = (*trueIt)-&gt;getBox();

      <span class="keywordflow">if</span> (  holesLoc[L] == 0 ) { trueF = 0; }
      <span class="keywordflow">else</span> { trueF = weight/((*trueIt)-&gt;nodeVolume()); }
      <span class="comment">//cout &lt;&lt; &quot;pdf: &quot; &lt;&lt; trueF  &lt;&lt; endl;</span>
      
      <span class="comment">// if this is contained in trueBox</span>
      <span class="keywordflow">if</span> ( (*it)-&gt;getBox() &lt;= (*trueIt)-&gt;getBox() || (*it)-&gt;getBox() == (*trueIt)-&gt;getBox() ) {
        <span class="comment">//use the volume of this</span>
        real r = ((*it)-&gt;nodeVolume())*(fhat - trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
        <span class="comment">//can move on to next leaf rather than iterating thru all trueBoxes</span>
        <span class="comment">//think about this later</span>
      } <span class="comment">//end of if this box is in trueBox</span>
      
      <span class="comment">// if this contains trueBox</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*trueIt)-&gt;getBox() &lt;= (*it)-&gt;getBox()) {
        <span class="comment">//use the volume of trueBox</span>
        real r = ((*trueIt)-&gt;nodeVolume())*(fhat - trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
      } <span class="comment">//end of if trueBox is in this box</span>
      
      <span class="comment">// if this is partially contained in trueBox </span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>   (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(temp, thisBox, trueBox)) {
        <span class="keywordflow">if</span> (Inf(temp) != Sup(temp)){
          <span class="keywordtype">double</span> volume = <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(temp);
          real r = volume*(fhat - trueF);
          <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
          accumulate(dpIAE, abs(r), 1.0);
        }
      }
      L++;
    } <span class="comment">// end of going through trueBoxes</span>
  } <span class="comment">// end of going through thisBoxes</span>
  
   <span class="comment">//cast dotprecision to real</span>
   real unifIAE = rnd(dpIAE);
   <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; unifIAE &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> unifIAE;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a7b6e78d7a069536dd096e81c6e3d8e1f"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::haveMadePaving" ref="a7b6e78d7a069536dd096e81c6e3d8e1f" args="(const RVecData &amp;theData, const size_t dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7b6e78d7a069536dd096e81c6e3d8e1f">AdaptiveHistogramValidation::haveMadePaving</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if we need to make root paving for the histogram object. </p>
<p>Points rootPAving to a new <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> if rootPaving is NULL, with the box of the root node matching the dimensions of the data as given in function argument and tailored to fit the data in theData.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data. </td></tr>
    <tr><td class="paramname">dim</td><td>the dimensions of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>if return value is true, rootPaving points to a new <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> and a new ivector has been assigned to rootBox, and the rootBox ivector is the box of the root node of the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> to which rootPaving points. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if function needed to make a new <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>, false if rootPaving already pointed to an SPS node. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">170</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00115">holdAllStats</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">subpavings::isEmpty()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00209">makeBox()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">rootBox</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">completeDataInsertionFromVec()</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {

        <span class="comment">// check if we need to make the paving on the basis of the data</span>
        <span class="keywordflow">if</span> (<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>)) {

            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abaa0f3ffd23bccd07a2c4a4b9a60e579" title="Make a box to contain all the data.">makeBox</a>(theData, dim);

            <span class="comment">// point rootVpaving to a new SPSVnode with box myBox</span>
            <span class="comment">// and also pass in the not value of holdAllStats which controls</span>
            <span class="comment">// whether all available statistics are maintained in the</span>
            <span class="comment">// rootVpaving (true) or just counts (false)</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a>, !<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>);
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();

            retValue = <span class="keyword">true</span>;
        }
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; e)
    {
        <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = e.what();
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in &quot;</span>
            &lt;&lt; <span class="stringliteral">&quot;AdaptiveHistogramValidation::haveMadePaving()&quot;</span>
            &lt;&lt; std::endl;
        <span class="keywordflow">throw</span>;
    }

    <span class="keywordflow">return</span> retValue;
    <span class="comment">// end of making the subpaving if there was not one</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac57fa83d1ec2fc1e9cf1565c9cc07f91"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::insertDataFromContainer" ref="ac57fa83d1ec2fc1e9cf1565c9cc07f91" args="(const RVecData &amp;theData, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging, size_t holdOutCount, std::vector&lt; size_t &gt; &amp;numNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ac57fa83d1ec2fc1e9cf1565c9cc07f91">AdaptiveHistogramValidation::insertDataFromContainer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>holdOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>numNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert training and validation data from a container. </p>
<p>Attempts to insert data from a container theData into this <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object's dataCollection and to associate the data with the leaves of the subpaving tree pointed to by this's rootPaving. Data in theData which falls outside the boundaries of the rootBox will not be inserted and a message will be printed to standard output. A boolean is used to indicate if the data point should be in the training or validation set.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data. </td></tr>
    <tr><td class="paramname">logging</td><td>an enum controlling whether a log file is created for histogram creation process; set to TXT for logging to a txt file. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function </td></tr>
    <tr><td class="paramname">boolVal</td><td>a boolean to indicate if the data point should be in the validation set (true) or not (false). operator determining whether to split a node when a data point arrives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData containing at least one rvector. </dd>
<dd>
this <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml" title="A wrapper or manager for an SPSVnode aka StatsSubPavingVal in conjunction with massive amounts of sam...">AdaptiveHistogramValidation</a> object must have a rootPaving pointing to an initialised <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>; this <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> may already have data associated with it. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The data in theData which is within the boundaries of the rootBox has been put into the <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>'s dataCollection and also associated with rootPaving's leaves via iterators to dataCollection. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of datapoints for which insertion has been attempted. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">269</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00110">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00579">getLeafLevelsString()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">subpavings::SPSVnode::insertOneFind()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02257">subpavings::spTotalNodes()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">completeDataInsertionFromVec()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">size_t</span> counter = 0;    <span class="comment">// to count the input</span>
    <span class="keywordtype">bool</span> boolVal; <span class="comment">// to  indicate if this data is a training or validation point</span>
    <span class="comment">// for logging output to keep track of splits if necessary</span>
    <span class="keywordtype">int</span> i = 0;
    std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
    std::string s = <span class="stringliteral">&quot;&quot;</span>;
    <span class="comment">// if we are splitting as we go and logging, set up a log file</span>
    <span class="keywordflow">if</span> ((logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) &amp;&amp; (boolTest() == <span class="keyword">true</span>)) {
        baseFileName = <span class="stringliteral">&quot;splitOutput&quot;</span>;
        s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
       <span class="comment">// outputLogStart(s);</span>
        <span class="comment">// log the current state of the histogram</span>
      <span class="comment">//  outputLog(s, i);</span>
        i++;
    }
   
   <span class="comment">//int hist = 0;</span>
   <a class="code" href="namespacesubpavings.shtml#a0e6592215c5f3504143e6c5ac38dcfec" title="Define type RVecDataCItr as const_iterator over RVecData.">RVecDataCItr</a> cit;
    <span class="comment">// feed the data to myHist</span>
    <span class="keywordflow">for</span>(cit = theData.begin(); cit &lt; theData.end(); cit++) {
        <span class="comment">// put it into dataCollection</span>
        <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> it = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93" title="A container for all sample data passed to this.">dataCollection</a>.end();
        it = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93" title="A container for all sample data passed to this.">dataCollection</a>.insert(it, *cit);
        <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* insertedInto = NULL;
        <span class="keywordflow">if</span> (counter &lt; holdOutCount) {
          <span class="comment">// try inserting </span>
          boolVal = <span class="keyword">true</span>;
          insertedInto =
                <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(it,<a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, boolTest, boolVal);
        }
        <span class="keywordflow">else</span> {
         boolVal = <span class="keyword">false</span>;
      <span class="comment">// try inserting</span>
         insertedInto =
                <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a58deac20a0a5b69bb06cdc04fc059135" title="Inserts data into this node.">insertOneFind</a>(it,<a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, boolTest, boolVal);
           numNodes.push_back(<a class="code" href="namespacesubpavings.shtml#aa737c3b183c306abbef9b3d515f632fb" title="Get the number of leaves of a tree (boxes in the subpaving)">spTotalNodes</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>));
           
           <span class="comment">/* </span>
<span class="comment">           string histFileName;</span>
<span class="comment">           std::ostringstream stm1;</span>
<span class="comment">           stm1 &lt;&lt; hist;</span>
<span class="comment">           histFileName = &quot;Hist&quot;;</span>
<span class="comment">           histFileName += stm1.str();</span>
<span class="comment">           histFileName += &quot;.txt&quot;;</span>
<span class="comment">           cout &lt;&lt; &quot;get histogram:&quot; &lt;&lt; histFileName &lt;&lt; endl;</span>
<span class="comment">           outputToTxtTabs(histFileName);     </span>
<span class="comment">           hist++;    </span>
<span class="comment">           */</span>     
      }

        <span class="comment">//insertOneFind returns either NULL if no insert possible</span>
        <span class="comment">// or a pointer to the node the data goes to before that node</span>
        <span class="comment">// is split (it could be split more than once)</span>
        <span class="keywordflow">if</span> (NULL == insertedInto) { <span class="comment">// failed to insert</span>
            std::cout &lt;&lt; <span class="stringliteral">&quot;Failed to insert point &quot;</span>
                &lt;&lt; *cit &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="stringliteral">&quot;Root node of subpaving has box &quot;</span>
                &lt;&lt; <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> &lt;&lt; std::endl;
        }
        <span class="comment">// successful insertion, and we are splitting as we go</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (boolTest() == <span class="keyword">true</span> &amp;&amp; boolVal == <span class="keyword">false</span> ) {
            std::string newNames = insertedInto-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();
     
            <span class="keywordflow">if</span>(newNames.length() &gt; 0) { <span class="comment">// there are new nodes</span>
                <span class="comment">//add the new child names if any</span>
                <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += newNames;

                <span class="keywordflow">if</span> (logging) { <span class="comment">// log the current state of the histogram</span>
<span class="comment">//                    outputLog(s, i);</span>
                    i++;
                }        
           
            }
       }
        counter++;
    }
    <span class="keywordflow">if</span> (counter &gt; 0) { <span class="comment">// data inserted</span>
         <span class="keywordflow">if</span> ((logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) &amp;&amp; (boolTest() == <span class="keyword">true</span>))  {
            <span class="comment">// add leaf node levels string to log</span>
            <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(s, <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acba6350d62c4aa8c1d9de5589c039543">getLeafLevelsString</a>());
        }
    }
    <span class="keywordflow">return</span> counter;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ace1a6eca888d6251a7e3db5d1c59bf2b"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::insertFromRSSampleForHoldOut" ref="ace1a6eca888d6251a7e3db5d1c59bf2b" args="(const RSSample &amp;rss, int label, const SplitDecisionObj &amp;boolTest, int holdOutCount, LOGGING_LEVEL logging)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ace1a6eca888d6251a7e3db5d1c59bf2b">AdaptiveHistogramValidation::insertFromRSSampleForHoldOut</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>holdOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> are associated with the root paving for hold out estimation, no splitting. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00778">778</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">completeDataInsertionFromVec()</a>, <a class="el" href="sptools_8cpp_source.shtml#l01021">subpavings::getRvectorsFromRSSample()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

  <span class="comment">//  bool boolVal=true;</span>
    
    <span class="keywordflow">try</span> {

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

            <span class="comment">// get data from the container and check how many data points found</span>
            <span class="keywordtype">size_t</span> numberFound = <a class="code" href="namespacesubpavings.shtml#ad435f1951db3078702d178b718018651" title="Get all rvectors from an RSSample object.">getRvectorsFromRSSample</a>(myDataRvectors, rss, label);


            <span class="keywordflow">if</span> (numberFound &gt; 0) {
                <span class="comment">/*</span>
<span class="comment">                // confirm the amount of data taken from the container</span>
<span class="comment">                std::cout &lt;&lt; &quot;End of taking data from container of rvectors: &quot;</span>
<span class="comment">                    &lt;&lt; numberFound &lt;&lt; &quot; data points found&quot; &lt;&lt; std::endl;</span>
<span class="comment">                */</span>
                <span class="comment">// complete the data insertion</span>

               <span class="comment">// cout &lt;&lt; &quot;calling complateDataInsertion...&quot; &lt;&lt; endl;</span>
          vector&lt;size_t&gt; temp;
                retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acf7246052d9032f41a4f237f1b5207d9" title="Complete insertion of training and validation data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                     boolTest, logging, holdOutCount, temp);
            }
      }
    
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
         <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
} <span class="comment">// end of insertFromRSSampleForHoldOut</span>
</pre></div>
</div>
</div>
<a class="anchor" id="aa0d5d92e0474bfc0574340b34268dd39"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::insertFromRVec" ref="aa0d5d92e0474bfc0574340b34268dd39" args="(const RVecData &amp;rvec, const SplitDecisionObj &amp;boolTest, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa0d5d92e0474bfc0574340b34268dd39">AdaptiveHistogramValidation::insertFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00641">641</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">completeDataInsertionFromVec()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00930">subpavings::getRvectorsFromRVec()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="UnifScheffe_8cpp_source.shtml#l00043">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="keywordtype">size_t</span> numberFound = 0;

        <span class="keywordflow">if</span> (rvec.empty()) { <span class="comment">// no data points to get</span>
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No data to insert&quot;</span>);
        }

        <span class="keywordflow">else</span> { <span class="comment">// there is data to get</span>

            <span class="comment">// get data from the container and check how many data points found</span>
            <span class="keywordtype">size_t</span> numberFound = <a class="code" href="namespacesubpavings.shtml#a211cb10f439ff2bdb92ce92906159792" title="Get all rvectors from a container of rvectors.">getRvectorsFromRVec</a>(myDataRvectors, rvec);


            <span class="keywordflow">if</span> (numberFound &gt; 0) {
                <span class="comment">/*</span>
<span class="comment">                // confirm the amount of data taken from the container</span>
<span class="comment">                std::cout &lt;&lt; &quot;End of taking data from container of rvectors: &quot;</span>
<span class="comment">                    &lt;&lt; numberFound &lt;&lt; &quot; data points found&quot; &lt;&lt; std::endl;</span>
<span class="comment">                */</span>
                <span class="comment">// complete the data insertion</span>
           vector&lt;size_t&gt; temp;
                retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acf7246052d9032f41a4f237f1b5207d9" title="Complete insertion of training and validation data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                        boolTest, logging, 0,
                                      temp);
            }
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
         <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a6817e38bd1c2749a711f702c70dd16b5"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::insertFromRVecForHoldOut" ref="a6817e38bd1c2749a711f702c70dd16b5" args="(const RVecData &amp;rvec, const SplitDecisionObj &amp;boolTest, int holdOutCount, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6817e38bd1c2749a711f702c70dd16b5">AdaptiveHistogramValidation::insertFromRVecForHoldOut</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>holdOutCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving for hold out estimation, no splitting. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00709">709</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">completeDataInsertionFromVec()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00930">subpavings::getRvectorsFromRVec()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="FiniteMixtureStats_8cpp_source.shtml#l00041">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

  <span class="comment">//  bool boolVal=true;</span>
    
    <span class="keywordflow">try</span> {

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

<span class="comment">//        size_t numberFound = 0;</span>

        <span class="keywordflow">if</span> (rvec.empty()) { <span class="comment">// no data points to get</span>
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No data to insert&quot;</span>);
        }

        <span class="keywordflow">else</span> { <span class="comment">// there is data to get</span>

            <span class="comment">// get data from the container and check how many data points found</span>
            <span class="keywordtype">size_t</span> numberFound = <a class="code" href="namespacesubpavings.shtml#a211cb10f439ff2bdb92ce92906159792" title="Get all rvectors from a container of rvectors.">getRvectorsFromRVec</a>(myDataRvectors, rvec);


            <span class="keywordflow">if</span> (numberFound &gt; 0) {
                <span class="comment">/*</span>
<span class="comment">                // confirm the amount of data taken from the container</span>
<span class="comment">                std::cout &lt;&lt; &quot;End of taking data from container of rvectors: &quot;</span>
<span class="comment">                    &lt;&lt; numberFound &lt;&lt; &quot; data points found&quot; &lt;&lt; std::endl;</span>
<span class="comment">                */</span>
                <span class="comment">// complete the data insertion</span>

               <span class="comment">// cout &lt;&lt; &quot;calling complateDataInsertion...&quot; &lt;&lt; endl;</span>
          vector&lt;size_t&gt; temp;
                retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acf7246052d9032f41a4f237f1b5207d9" title="Complete insertion of training and validation data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                     boolTest, logging, holdOutCount, temp);
            }
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
         <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
} <span class="comment">// end of insertRVecForHoldOut </span>
</pre></div>
</div>
</div>
<a class="anchor" id="a1c8f4b1ea86038de1e1d780f227f9b28"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::insertRvectorsFromTxt" ref="a1c8f4b1ea86038de1e1d780f227f9b28" args="(const std::string &amp;s, std::vector&lt; size_t &gt; &amp;numNodes, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a1c8f4b1ea86038de1e1d780f227f9b28">subpavings::AdaptiveHistogramValidation::insertRvectorsFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>All rvectors are associated with the root paving, no spliting. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00409">409</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>

<p>Referenced by <a class="el" href="AirTraffic_8cpp_source.shtml#l00043">main()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// a dummy split decision object</span>
        <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a1c8f4b1ea86038de1e1d780f227f9b28">insertRvectorsFromTxt</a>(s, numNodes, sn, headerlines, logging);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad8df8dae6a879dc00975edfe4a0cc3b6"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::insertRvectorsFromTxt" ref="ad8df8dae6a879dc00975edfe4a0cc3b6" args="(const std::string &amp;s, std::vector&lt; size_t &gt; &amp;numNodes, const SplitDecisionObj &amp;boolTest, const std::size_t headerlines=0, LOGGING_LEVEL logging=NOLOG)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a1c8f4b1ea86038de1e1d780f227f9b28">AdaptiveHistogramValidation::insertRvectorsFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em> = <code><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adaptive splitting with each data point inserted. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00589">589</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">completeDataInsertionFromVec()</a>, <a class="el" href="namespacesubpavings.shtml#a7918dddb1a8e32f72835e1e7b4442ca6">subpavings::readRvectorsFromTxt()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;

    <span class="keywordflow">try</span> {
        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> myDataRvectors; <span class="comment">// container for the rvectors we take in</span>

        <span class="comment">// try to read in the file</span>
        retValue = <a class="code" href="namespacesubpavings.shtml#a7918dddb1a8e32f72835e1e7b4442ca6" title="Read in rvectors from a txt file.">readRvectorsFromTxt</a>(myDataRvectors, s, headerlines);

        <span class="keywordflow">if</span> (retValue) {
            retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acf7246052d9032f41a4f237f1b5207d9" title="Complete insertion of training and validation data from a vector container.">completeDataInsertionFromVec</a>(myDataRvectors,
                                                    boolTest, logging, 0,
                                   numNodes);
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory inserting data.  Orginal error: &quot;</span>
                                            + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error inserting data.  Orginal error: &quot;</span>
                                    + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException inserting data.  Orginal error: &quot;</span> + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error inserting data.  Orginal error: &quot;</span> + oldmsg;
        cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abaa0f3ffd23bccd07a2c4a4b9a60e579"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::makeBox" ref="abaa0f3ffd23bccd07a2c4a4b9a60e579" args="(const RVecData &amp;theData, const size_t dim)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abaa0f3ffd23bccd07a2c4a4b9a60e579">AdaptiveHistogramValidation::makeBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a box to contain all the data. </p>
<p>Used if a box has not already been provided. Makes a box tailored to contain all of the data. So all the data has to be available for input.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>a reference to a container of rvector data </td></tr>
    <tr><td class="paramname">dim</td><td>the dimensions of the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an ivector same dimensions as the data and to fit all the data including an allowance for padding. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00209">209</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00090">padding</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">haveMadePaving()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// set up a vector of maxes</span>
    vector&lt;real&gt; maxs;

    <span class="comment">// give maxs starting values from the first element in the rvectors</span>
    rvector first = *theData.begin();

    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;=dim; i++) {
        maxs.push_back(first[i]);
    }

    <span class="comment">// make mins the same as maxes to start with</span>
    vector&lt;real&gt; mins = maxs;

    <a class="code" href="namespacesubpavings.shtml#a0e6592215c5f3504143e6c5ac38dcfec" title="Define type RVecDataCItr as const_iterator over RVecData.">RVecDataCItr</a> cit;

    <span class="comment">// go over the rest of the container</span>
    <span class="keywordflow">for</span>(cit = theData.begin()+1; cit &lt; theData.end(); cit++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;= dim; i++) {
            real r = (*cit)[i];
            <span class="comment">// vectors indexed 0 - n-1, rvectors ndexed 1 - n</span>
            <span class="keywordflow">if</span>(r &lt; mins[i-1]) {
                mins[i-1] = r;
            }
            <span class="keywordflow">if</span>(r &gt; maxs[i-1]) {
                maxs[i-1] = r;
            }
        } <span class="comment">// end going through rvector elements</span>
    } <span class="comment">// end going through rvectors</span>

    ivector retVal(dim);    <span class="comment">// set up an ivector to become the return value</span>

    <span class="comment">// and make each interval the (min, max) of the corresponding elements</span>
    <span class="comment">// of the rvectors -/+ some padding</span>

    std::cout &lt;&lt; <span class="stringliteral">&quot;A box is being made for the data.  &quot;</span>
        &lt;&lt; <span class="stringliteral">&quot;The box is &quot;</span> &lt;&lt; std::endl;  <span class="comment">// standard output message</span>

    <span class="comment">// make intervals and make them elements of the ivector</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;=dim; i++) {
        interval myInterval(mins[i-1]-<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a0039bec0f033c35a5477375cb54eb8ea" title="a constant for padding a box if it is tailor-made for data.">padding</a>, maxs[i-1]+<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a0039bec0f033c35a5477375cb54eb8ea" title="a constant for padding a box if it is tailor-made for data.">padding</a>);
        std::cout &lt;&lt; myInterval &lt;&lt; <span class="stringliteral">&quot;  &quot;</span>;    <span class="comment">// output</span>
        retVal[i]=myInterval;
    }
    std::cout &lt;&lt; std::endl;

    <span class="keywordflow">return</span> retVal;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a30cd1199dfab7883a8191e501d372613"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::mergeUp" ref="a30cd1199dfab7883a8191e501d372613" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a30cd1199dfab7883a8191e501d372613">subpavings::AdaptiveHistogramValidation::mergeUp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merge a multileaf histogram up to just root box. </p>
<p>No prioritistion, just brute force </p>

</div>
</div>
<a class="anchor" id="ad3d12ca5330306b377001a4064599430"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::operator+" ref="ad3d12ca5330306b377001a4064599430" args="(const AdaptiveHistogramValidation &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> subpavings::AdaptiveHistogramValidation::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overloaded addition operator. </p>
<p>Makes a new histogram by adding this and rhs together. The subpaving will be the union of the subpavings of this and rhs. Data is reinserted into the new histogram so that the counts in each box of the subpaving are exactly right for that subpaving. This is in contrast to the way that the AdaptiveHistogramValidationCollator works (divides a count evenly in two when apportioning it between bisected boxes). holdAllStats will be set to the logical and of the values for this and rhs. </p>

</div>
</div>
<a class="anchor" id="aba8d900d6f696824de3e6cb5bb99e794"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::operator=" ref="aba8d900d6f696824de3e6cb5bb99e794" args="(const AdaptiveHistogramValidation &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp; AdaptiveHistogramValidation::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">495</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00110">dataCollection</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00115">holdAllStats</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">rootBox</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {
        <span class="comment">//cout &lt;&lt; &quot;copy assignment operator&quot; &lt;&lt; endl;</span>
        <span class="comment">// we have to make sure we delete the current paving</span>
        <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = NULL;
        }

        <span class="keywordflow">if</span> (NULL != rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>(*(rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>));
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">//copy dataCollection from other to this</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93" title="A container for all sample data passed to this.">dataCollection</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93" title="A container for all sample data passed to this.">dataCollection</a>;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd" title="Controls whether all available statistics are maintained in the rootPaving. If set to false (default)...">holdAllStats</a>;
        }
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a> = rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c" title="The root box used to form the subpaving tree.">rootBox</a>;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor&quot;</span>);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor&quot;</span>);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cerr &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor&quot;</span>);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0286278b4e489ed8809dcb60d136dce7"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::outputGraphDot" ref="a0286278b4e489ed8809dcb60d136dce7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a0286278b4e489ed8809dcb60d136dce7">AdaptiveHistogramValidation::outputGraphDot</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a .dot graph file from histogram structure. </p>
<p>Makes a simple .dot graph from the histogram using node names and the .png image for this graph.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>a constructed histogram </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>a .dot file and a .png in the same directory as the program creating it was run in. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03349">3349</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01005">subpavings::SPnode::outputGraphDot()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
        success = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aaaf0891a67e056e19f8e086c0139fd96" title="Make a .dot graph file from an SPnode tree structure.">outputGraphDot</a>();

    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Sorry, you can&#39;t make a graph without a root paving&quot;</span>
                &lt;&lt; std::endl;
    }
    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a75453f853b530cd3e2a7afccf25e39d0"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::outputLog" ref="a75453f853b530cd3e2a7afccf25e39d0" args="(const std::string &amp;s, const int i) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a75453f853b530cd3e2a7afccf25e39d0">subpavings::AdaptiveHistogramValidation::outputLog</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append current state of histogram to a txt log file. </p>
<p>Format is a tab-delimited file of numeric data. Output includes node contributions to unscaled EMP under COPERR and AIC and the changes in EMP that would result from splitting the node.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">i</td><td>the number of pass (ie, 0, 1, 2, 3 etc) in process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34f7487fd92886151634c00e8e75cca5"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::outputLogStart" ref="a34f7487fd92886151634c00e8e75cca5" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a34f7487fd92886151634c00e8e75cca5">AdaptiveHistogramValidation::outputLogStart</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opening line of a txt log file. </p>
<p>Starts the log file with file name and date and time </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00360">360</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Make a string with filename and timestamp to start log file</span>
    time_t rawtime;
    <span class="keyword">struct </span>tm * timeinfo;
    time ( &amp;rawtime );
    timeinfo = localtime ( &amp;rawtime );
    ofstream os(s.c_str());         <span class="comment">// replace data</span>
    <span class="keywordflow">if</span> (os.is_open()) {
        os &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; s &lt;&lt; <span class="stringliteral">&quot; created &quot;</span> &lt;&lt;  asctime (timeinfo) &lt;&lt; std::endl;
        os.close();
    }
    <span class="keywordflow">else</span> {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
            &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a78d5c3ad5e31fc438e0c4cac65e73313"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::outputRootToTxt" ref="a78d5c3ad5e31fc438e0c4cac65e73313" args="(const std::string &amp;s, bool confirm=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a78d5c3ad5e31fc438e0c4cac65e73313">AdaptiveHistogramValidation::outputRootToTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>confirm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output details of full sample (from root) to txt tile. </p>
<p>Format is a mixture of alpha and numeric data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">confirm</td><td>is a boolean controlling whether confirmation goes to console output (defaults to false). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03391">3391</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01765">subpavings::SPSVnode::nodePrint()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {

        <span class="comment">// To generate a file output of root node of the AdaptiveHistogramValidation</span>
        ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a51715ef7b6e370006e914fee15061cfc" title="Output details of a specific node.">nodePrint</a>(os); <span class="comment">// the output</span>
        <span class="keywordflow">if</span> (confirm)
            std::cout &lt;&lt; <span class="stringliteral">&quot;Details of the root paving of the AdaptiveHistogramValidation &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;has been written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="ac7ad1cd4a9403ae91083dc0ef2356a24"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::outputToTxtTabs" ref="ac7ad1cd4a9403ae91083dc0ef2356a24" args="(const std::string &amp;s, bool confirm=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ac7ad1cd4a9403ae91083dc0ef2356a24">AdaptiveHistogramValidation::outputToTxtTabs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>confirm</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the subpaving managed by this to a txt file. </p>
<p>Format is a tab-delimited file of numeric data starting with nodeName, then the node box volume, then the node counter, then the description of the node box as a tab-delimited list of interval upper and lower bounds.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">confirm</td><td>is a boolean controlling whether confirmation goes to console output (defaults to false). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03367">3367</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01795">subpavings::SPSVnode::leavesOutputTabs()</a>, and <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>.</p>

<p>Referenced by <a class="el" href="AirTraffic_8cpp_source.shtml#l00043">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {

        <span class="comment">// To generate a file output of the AdaptiveHistogramValidation object</span>
        ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>
        <span class="keywordflow">if</span> (os.is_open()) {

            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#abcac815b9e5e60a3d18fa3534a12c518" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os); <span class="comment">// the output</span>
            <span class="keywordflow">if</span> (confirm)
                std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the AdaptiveHistogramValidation &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;has been written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
        }
        <span class="keywordflow">else</span> {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
                &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a86feeca7ad74bc1c9ebc35f2ef0dd5e6"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplit" ref="a86feeca7ad74bc1c9ebc35f2ef0dd5e6" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, long double tol, AdaptiveHistogram &amp;myPart, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a86feeca7ad74bc1c9ebc35f2ef0dd5e6">subpavings::AdaptiveHistogramValidation::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

</div>
</div>
<a class="anchor" id="a9a558b6a13ad7019acd893f0edbb107b"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplit" ref="a9a558b6a13ad7019acd893f0edbb107b" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, long double tol, AdaptiveHistogram &amp;myPart, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a86feeca7ad74bc1c9ebc35f2ef0dd5e6">subpavings::AdaptiveHistogramValidation::prioritySplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

</div>
</div>
<a class="anchor" id="a261b3220218fe58d08713381aa7b0b44"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="a261b3220218fe58d08713381aa7b0b44" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, int distr, int method, size_t hist, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>2D shapes: minVolB and minChildPoints supplied but no random number generator. </p>

<p>Referenced by <a class="el" href="FiniteMixtureStats_8cpp_source.shtml#l00041">main()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00850">prioritySplitAndEstimate()</a>.</p>

</div>
</div>
<a class="anchor" id="ad076189eb2565d34b8f4998eb7330827"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="ad076189eb2565d34b8f4998eb7330827" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, int distr, int method, size_t hist, size_t maxLeafNodes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>2D shapes: With random number generator. All other parameters supplied. </p>

</div>
</div>
<a class="anchor" id="a63938649a46bb4a5ed5d432606b02427"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="a63938649a46bb4a5ed5d432606b02427" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, AdaptiveHistogram &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;optHist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>optHist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00850">850</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">prioritySplitAndEstimate()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    gsl_rng * rgsl = NULL;
    <span class="keywordtype">bool</span> cancontinue;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        <span class="comment">// call the function with a random number generator</span>
        cancontinue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">prioritySplitAndEstimate</a>(compTest, he, logging, minChildPoints, 
                        minVolB, rgsl, stopCrit, myPart, weight, holesLoc,
                        method, hist,
                        maxLeafNodes, maxCheck, optHist);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority stage split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
   
   <span class="keywordflow">return</span> cancontinue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae982e9b5ffc50d9893a557a09bfc89af"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="ae982e9b5ffc50d9893a557a09bfc89af" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, AdaptiveHistogram &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;optHist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>optHist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">922</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00335">subpavings::ExpandWithValid()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00990">subpavings::AdaptiveHistogramVCollator::getMinDelta()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">getMinVol()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00341">subpavings::AdaptiveHistogramVCollator::getNumberCollated()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">getRootLeaves()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00511">subpavings::AdaptiveHistogramVCollator::getSplitNodePtr()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04264">getUnifTrueDelta()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00680">subpavings::AdaptiveHistogramVCollator::getYatracosDelta()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00360">outputLogStart()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//cout &lt;&lt; &quot;calling prioritySplitAndEstimate:&quot; &lt;&lt; endl;</span>
   <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
   <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
   
    <span class="comment">//boolean for validation data</span>
    <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>;
    
    <span class="comment">// for stopping criteria</span>
    <span class="keywordtype">size_t</span> flagStop = 0;
    <span class="keywordtype">int</span> currentSmallest = 0;
    
    <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    
    <span class="comment">//set up collator to keep the histograms as splits happen</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> coll;
    
   <span class="comment">//=======initializing containers======================================</span>
  <span class="comment">//set up a list for the Yatracos set </span>
  list&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; listYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (row)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecRowYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (col)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecColYatSet;    
  <span class="comment">//set up a vector for maximum Delta_theta vectors</span>
  vector&lt; vector&lt;double&gt; &gt; vecMaxDeltaVec;
  <span class="comment">//initializing the vector - to allow the delta vector to be in </span>
  <span class="comment">// right order  since the first histogram does not have a </span>
  <span class="comment">// Yatracos set</span>
  <span class="comment">//the first element in this vector will not be plotted since </span>
  <span class="comment">// the first histogram is an empty set</span>
  vector&lt;double&gt; theta0;
  theta0.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); 
  <span class="comment">//the supremum of an empty set is -Infimum </span>
  vecMaxDeltaVec.push_back(theta0);
  <span class="comment">//set up a vector of the corresponding theta with the minimum </span>
  <span class="comment">// distance estimates</span>
  vector&lt; vector&lt;int&gt; &gt; vecMinDistTheta;
  <span class="comment">// set up a vector for the infimum </span>
  vector&lt;double&gt; vecInfDelta;
  <span class="comment">// set up a vector for the integrated absolute error for each histogram</span>
   vector&lt;real&gt; vecIAE; 
   vector&lt;real&gt; vecIAEFull;
   real minIAE = 1000.00;
   
   vector&lt;real&gt; TrueDelta;
   TrueDelta.push_back(-1); 
   
   real trueDeltaCurrent = 0;
   
   <span class="comment">// to keep the histograms</span>
   vector&lt;AdaptiveHistogramValidation&gt; tempHist;
   <span class="comment">//==============end of initializing containers=============================//   </span>
   <span class="comment">// check if the root box is empty</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }
    <span class="keywordflow">try</span> {       
        <span class="comment">// add the histogram before any split happens into the collator</span>
        <span class="keywordtype">size_t</span> agg = 0;
      coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
      tempHist.push_back(*<span class="keyword">this</span>);
      <span class="comment">// calculate the IAE </span>
      real IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 0);
      <span class="comment">// push back into vecIAE </span>
      vecIAE.push_back(IAE);
      minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
      
      <span class="comment">//get the IAE for the full data set</span>
      real IAEF = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 1);
      <span class="comment">// push back into vecIAE </span>
      vecIAEFull.push_back(IAEF);

    <span class="comment">//============checks  for splittable nodes=============================//</span>
        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="comment">//logging</span>
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }
        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8d94391339b619f6f3aefb89ca761e99" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
            volChecking = <span class="keyword">true</span>;
        }
      <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
      multiset&lt;SPSVnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));
      <span class="keywordtype">int</span> i=0;
      <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a34f7487fd92886151634c00e8e75cca5" title="Opening line of a txt log file.">outputLogStart</a>(s);    
            i++;
      }
      <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
      <span class="comment">// there are enough points in the whole node</span>
      <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
      <span class="comment">// or the minChildCountIfSplit test passed</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootVpaving pointer into the set</span>
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> sit;            
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }        
        <span class="comment">//==================end of checks=====================================//</span>
  
      <span class="keywordtype">size_t</span> ch = 0;
      
        <span class="comment">//=========start priority queue====================================//</span>
        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out   </span>
      <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {          
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* chosenLargest;
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSVnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSVnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator&gt; equalLargest;
            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {
                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }
            <span class="keywordflow">else</span> {
                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }
            <span class="comment">// split the biggest one and divide up its training and validation </span>
            <span class="comment">// data</span>
            
            cout &lt;&lt; <span class="stringliteral">&quot;--------------Split &quot;</span> &lt;&lt; coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>() &lt;&lt; endl;
            <a class="code" href="namespacesubpavings.shtml#a6a89808457c34dbca09c2c75ef57c169" title="Expand a leaf node to have two child nodes.">ExpandWithValid</a>(chosenLargest, boolVal);
                          
            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new left child into the multiset</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>());
            }
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new right child into the multiset</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>());
            }
            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file                   </span>
                i++;
            }

          <span class="comment">//==========get IAE for this histogram======================//</span>
        <span class="comment">//cout &lt;&lt; &quot;get IAE for histogram &quot; &lt;&lt; coll.getNumberCollated() &lt;&lt; endl;</span>
        real IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 0);
        minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF =<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 1);
        vecIAEFull.push_back(IAEF); 
        
        
        <span class="comment">// keep this histogram in a container </span>
        tempHist.push_back(*<span class="keyword">this</span>);
        
        <span class="comment">/*</span>
<span class="comment">        string fileName = &quot;QueueHist&quot;;</span>
<span class="comment">        ostringstream stm;</span>
<span class="comment">        stm &lt;&lt; ch;</span>
<span class="comment">        fileName += stm.str();</span>
<span class="comment">        fileName += &quot;.txt&quot;;</span>
<span class="comment">        outputToTxtTabs(fileName);</span>
<span class="comment">        </span>
<span class="comment">        ch++;</span>
<span class="comment">        */</span>
        <span class="comment">//cout &lt;&lt; &quot;add into collator&quot; &lt;&lt; endl;</span>
        <span class="comment">// add current histogram to collation</span>
        <span class="keywordtype">size_t</span> agg = 0;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
          
        <span class="comment">//cout &lt;&lt; &quot;get the split node&quot; &lt;&lt; endl;</span>
        <span class="comment">// first we need a pointer to the corresponding CollatorSPVnode </span>
        <span class="comment">// of the SPSVnode* chosenLargest     </span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * splitCollNode;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab38cfd38290579694a35950af5c80c36" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtr</a>(splitCollNode, chosenLargest);
        <span class="comment">//cout &lt;&lt; chosenLargest-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; splitCollNode-&gt;getNodeName() &lt;&lt; endl;</span>
        
        <span class="comment">//cout &lt;&lt; &quot;get the yat class&quot; &lt;&lt; endl;</span>
        <span class="comment">// get the Yatracos class for this collation</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad94f1c5c6943e7bb35e74030af5113fd" title="Get the Yatracos set.">getYatracosClassAll</a>(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        <span class="comment">//cout &lt;&lt; &quot;get delta theta&quot; &lt;&lt; endl;</span>
        <span class="comment">// get delta_theta for each theta</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a741a4e9b7dac5673c641b3a991b4a419" title="Get the maximum delta values for all thetas for the Yatracos Class.">getYatracosDelta</a>(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        <span class="comment">// get the true delta</span>
        real trueDelta = 0;
        vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator listIt;   
        <span class="comment">//cout &lt;&lt; &quot;Current Yatracos set has &quot; &lt;&lt; (*tempList).size() &lt;&lt; &quot; nodes.&quot; &lt;&lt; endl;</span>
        <span class="keywordflow">for</span> (listIt = (vecRowYatSet).begin(); listIt &lt; vecRowYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
            real trueDeltaR = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a9a9e088604995104a0313e525d4771e7">getUnifTrueDelta</a>(myPart, weight, holesLoc, (*listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        <span class="keywordflow">for</span> (listIt = (vecColYatSet).begin(); listIt &lt; vecColYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
            real trueDeltaR = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a9a9e088604995104a0313e525d4771e7">getUnifTrueDelta</a>(myPart, weight, holesLoc, (*listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        <span class="keywordflow">if</span> ( vecRowYatSet.empty() &amp;&amp; vecColYatSet.empty() ) { trueDelta = -1; TrueDelta.push_back(trueDelta); } 

        <span class="comment">//check theorem 10.1</span>
        <span class="comment">//cout &lt;&lt; &quot;check theorem: &quot; &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; IAE &lt;&lt; &quot;\t&quot; &lt;&lt; minIAE &lt;&lt; &quot;\t&quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
        <span class="comment">//if (trueDelta &gt;= 0) { assert(IAE &lt;= (3*minIAE + 4*trueDelta)); }</span>

        <span class="comment">//stopping criteria</span>
        <span class="keywordflow">if</span> (stopCrit == <span class="keyword">true</span>) {
          <span class="comment">//cout &lt;&lt; &quot;checking stopping criteria: &quot; &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> toStop = coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#adc9f2cb78559081ca925defe641bd583">getMinDelta</a>(maxCheck, vecMaxDeltaVec);
          <span class="keywordflow">if</span> (toStop == <span class="keyword">true</span>) {
            cout &lt;&lt; <span class="stringliteral">&quot;Stopping criteria met.&quot;</span> &lt;&lt; endl;
            <span class="keywordflow">break</span>;
          } 
        }

        <span class="comment">//==========checks to see if need to split again=========//</span>
            <span class="comment">//checking if there are any more &#39;largest&#39; nodes in the priority queue</span>
            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough){    
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
            }
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abba9be0456a1228037dd40e7353d2169" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      } <span class="comment">// end of while loop</span>
      <span class="comment">//cout &lt;&lt; &quot;===========End of splitting=============&quot; &lt;&lt; endl;</span>
        
      <span class="comment">//do the merging here based on vecMinDistTheta</span>
         
      <span class="comment">//================Outputs to .txt files=================== </span>
      ofstream os;         <span class="comment">// ofstream object</span>
      os &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
      os.precision(5);

       <span class="comment">// get the minimum delta to get the MDE histogram</span>
      vector&lt; vector&lt;double&gt; &gt;::iterator it1; 
      vector&lt;double&gt;::iterator it2;
      <span class="keywordtype">int</span> Theta=0;
      <span class="comment">//cout &lt;&lt; &quot;MaxDelta&quot; &lt;&lt; endl;</span>
      <span class="keywordtype">size_t</span> <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a> = vecMaxDeltaVec.size(); 
      <span class="keywordtype">double</span> minDelta = 1000;
      <span class="keywordtype">int</span> minTheta = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>; i++){
        <span class="comment">//cout &lt;&lt; &quot;Theta: &quot; &lt;&lt; Theta &lt;&lt; &quot;\t&quot; &lt;&lt; vecMaxDeltaVec[F-1][i] &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( vecMaxDeltaVec[F-1][i] &lt; minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout &lt;&lt; <span class="stringliteral">&quot;MDE at &quot;</span> &lt;&lt; minTheta &lt;&lt; <span class="stringliteral">&quot; with IAE &quot;</span> &lt;&lt; vecIAE[minTheta] &lt;&lt; endl; 
         optHist = tempHist[minTheta];

      <span class="comment">// output vecDeltaMaxVec into .txt </span>
      ostringstream stm1, stm2;
      stm1 &lt;&lt; hist;
      stm2 &lt;&lt; method;
      <span class="keywordtype">string</span> fileNameDelta = <span class="stringliteral">&quot;UnifMethod&quot;</span>;
      fileNameDelta += stm2.str();
      fileNameDelta += <span class="stringliteral">&quot;DeltaMax&quot;</span>;
      fileNameDelta += stm1.str();
      fileNameDelta += <span class="stringliteral">&quot;.txt&quot;</span>;  
      os.open(fileNameDelta.c_str());
      <span class="keywordflow">for</span> (it1 = vecMaxDeltaVec.begin(); it1 &lt; vecMaxDeltaVec.end(); it1++){ 
        <span class="keywordflow">for</span> (it2 = (*it1).begin(); it2 &lt; (*it1).end(); it2++){
          os &lt;&lt; (*it2) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
        }
        os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      }          
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;DeltaMax for each theta output to &quot;</span> &lt;&lt; fileNameDelta &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
      <span class="comment">//----------------end of output for vecDeltaMaxVec-------------</span>
 
         <span class="comment">//output vecIAE to .txt file</span>
      <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>
      outputFileName = <span class="stringliteral">&quot;UnifMethod&quot;</span>;
      outputFileName += stm2.str();
      outputFileName += <span class="stringliteral">&quot;IAEandTrueDelta&quot;</span>;
      outputFileName += stm1.str();
      outputFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      os.open(outputFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vecIAE.size(); i++){
        os &lt;&lt; vecIAE[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vecIAEFull[i] &lt;&lt; TrueDelta[i] &lt;&lt; endl;
      }
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;IAE output to &quot;</span> &lt;&lt; outputFileName &lt;&lt; endl;
      <span class="comment">//=================end of output for vecIAE---------------------------      </span>
   } <span class="comment">// end of try</span>
    
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority stage split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    
   <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a46ff8e128b5d734c3839871c465bcf46"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="a46ff8e128b5d734c3839871c465bcf46" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, FinMix &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, AdaptiveHistogramValidation &amp;opthist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>opthist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02788">2788</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">prioritySplitAndEstimate()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    gsl_rng * rgsl = NULL;
    <span class="keywordtype">bool</span> cancontinue;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        <span class="comment">// call the function with a random number generator</span>
        cancontinue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">prioritySplitAndEstimate</a>(compTest, he, logging, minChildPoints, 
                        minVolB, rgsl, stopCrit, mixt, method, hist,
                        maxLeafNodes, maxCheck, tol, deg, optHist);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority stage split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
   
   <span class="keywordflow">return</span> cancontinue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a990028dc08bc4780df6a04f78b4ec644"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="a990028dc08bc4780df6a04f78b4ec644" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, FinMix &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, AdaptiveHistogramValidation &amp;opthist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>opthist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02858">2858</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00335">subpavings::ExpandWithValid()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04065">getFinMixIntervalTrueDelta()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00990">subpavings::AdaptiveHistogramVCollator::getMinDelta()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">getMinVol()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00341">subpavings::AdaptiveHistogramVCollator::getNumberCollated()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">getRootLeaves()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00511">subpavings::AdaptiveHistogramVCollator::getSplitNodePtr()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00680">subpavings::AdaptiveHistogramVCollator::getYatracosDelta()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00360">outputLogStart()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//cout &lt;&lt; &quot;calling prioritySplitAndEstimate:&quot; &lt;&lt; endl;</span>
   <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
   <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
   
    <span class="comment">//boolean for validation data</span>
    <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>;
    
    <span class="comment">// for stopping criteria</span>
    <span class="keywordtype">size_t</span> flagStop = 0;
    <span class="keywordtype">int</span> currentSmallest = 0;
    
    <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    
    <span class="comment">//set up collator to keep the histograms as splits happen</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> coll;
    
   <span class="comment">//=======initializing containers======================================</span>
  <span class="comment">//set up a list for the Yatracos set </span>
  list&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; listYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (row)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecRowYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (col)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecColYatSet;    
  <span class="comment">//set up a vector for maximum Delta_theta vectors</span>
  vector&lt; vector&lt;double&gt; &gt; vecMaxDeltaVec;
  <span class="comment">//initializing the vector - to allow the delta vector to be in </span>
  <span class="comment">// right order  since the first histogram does not have a </span>
  <span class="comment">// Yatracos set</span>
  <span class="comment">//the first element in this vector will not be plotted since </span>
  <span class="comment">// the first histogram is an empty set</span>
  vector&lt;double&gt; theta0;
  theta0.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); 
  <span class="comment">//the supremum of an empty set is -Infimum </span>
  vecMaxDeltaVec.push_back(theta0);
  <span class="comment">//set up a vector of the corresponding theta with the minimum </span>
  <span class="comment">// distance estimates</span>
  vector&lt; vector&lt;int&gt; &gt; vecMinDistTheta;
  <span class="comment">// set up a vector for the infimum </span>
  vector&lt;double&gt; vecInfDelta;
  <span class="comment">// set up a vector for the integrated absolute error for each histogram</span>
   vector&lt;real&gt; vecIAE; 
   vector&lt;real&gt; vecIAEFull;
   real minIAE = 1000.00;
   
   vector&lt;real&gt; TrueDelta;
   TrueDelta.push_back(-1); 
   
   real trueDeltaCurrent = 0;
   
   <span class="comment">// to keep the histograms</span>
   vector&lt;AdaptiveHistogramValidation&gt; tempHist;
   <span class="comment">//==============end of initializing containers=============================//   </span>
   <span class="comment">// check if the root box is empty</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }
    <span class="keywordflow">try</span> {       
        <span class="comment">// add the histogram before any split happens into the collator</span>
        <span class="keywordtype">size_t</span> agg = 0;
      coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
      tempHist.push_back(*<span class="keyword">this</span>);
      <span class="comment">// calculate the IAE </span>
      real IAE = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 0));
      <span class="comment">// push back into vecIAE </span>
      vecIAE.push_back(IAE);
      minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
      
      <span class="comment">//get the IAE for the full data set</span>
      real IAEF = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 1));
      <span class="comment">// push back into vecIAE </span>
      vecIAEFull.push_back(IAEF);

    <span class="comment">//============checks  for splittable nodes=============================//</span>
        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="comment">//logging</span>
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }
        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8d94391339b619f6f3aefb89ca761e99" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
            volChecking = <span class="keyword">true</span>;
        }
      <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
      multiset&lt;SPSVnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));
      <span class="keywordtype">int</span> i=0;
      <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a34f7487fd92886151634c00e8e75cca5" title="Opening line of a txt log file.">outputLogStart</a>(s);    
            i++;
      }
      <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
      <span class="comment">// there are enough points in the whole node</span>
      <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
      <span class="comment">// or the minChildCountIfSplit test passed</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootVpaving pointer into the set</span>
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> sit;            
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }        
        <span class="comment">//==================end of checks=====================================//</span>
  
      <span class="keywordtype">size_t</span> ch = 0;
      
        <span class="comment">//=========start priority queue====================================//</span>
        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out   </span>
      <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {          
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* chosenLargest;
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSVnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSVnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator&gt; equalLargest;
            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {
                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }
            <span class="keywordflow">else</span> {
                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }
            <span class="comment">// split the biggest one and divide up its training and validation </span>
            <span class="comment">// data</span>
            
            cout &lt;&lt; <span class="stringliteral">&quot;--------------Split &quot;</span> &lt;&lt; coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>()-1 &lt;&lt; endl;
            <a class="code" href="namespacesubpavings.shtml#a6a89808457c34dbca09c2c75ef57c169" title="Expand a leaf node to have two child nodes.">ExpandWithValid</a>(chosenLargest, boolVal);
                          
            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

            <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new left child into the multiset</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>());
            }
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) {
                <span class="comment">// insert the new right child into the multiset</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>());
            }
            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file                   </span>
                i++;
            }

          <span class="comment">//==========get IAE for this histogram======================//</span>
        <span class="comment">//cout &lt;&lt; &quot;get IAE for histogram &quot; &lt;&lt; coll.getNumberCollated() &lt;&lt; endl;</span>
        real IAE = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 0));
        minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 1));
        vecIAEFull.push_back(IAEF); 
        
        
        <span class="comment">// keep this histogram in a container </span>
        tempHist.push_back(*<span class="keyword">this</span>);
        
        <span class="comment">/*</span>
<span class="comment">        string fileName = &quot;QueueHist&quot;;</span>
<span class="comment">        ostringstream stm;</span>
<span class="comment">        stm &lt;&lt; ch;</span>
<span class="comment">        fileName += stm.str();</span>
<span class="comment">        fileName += &quot;.txt&quot;;</span>
<span class="comment">        outputToTxtTabs(fileName);</span>
<span class="comment">        </span>
<span class="comment">        ch++;</span>
<span class="comment">        */</span>
        <span class="comment">//cout &lt;&lt; &quot;add into collator&quot; &lt;&lt; endl;</span>
        <span class="comment">// add current histogram to collation</span>
        <span class="keywordtype">size_t</span> agg = 0;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
          
        <span class="comment">//cout &lt;&lt; &quot;get the split node&quot; &lt;&lt; endl;</span>
        <span class="comment">// first we need a pointer to the corresponding CollatorSPVnode </span>
        <span class="comment">// of the SPSVnode* chosenLargest     </span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * splitCollNode;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab38cfd38290579694a35950af5c80c36" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtr</a>(splitCollNode, chosenLargest);
        <span class="comment">//cout &lt;&lt; chosenLargest-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; splitCollNode-&gt;getNodeName() &lt;&lt; endl;</span>
        
        <span class="comment">//cout &lt;&lt; &quot;get the yat class&quot; &lt;&lt; endl;</span>
        <span class="comment">// get the Yatracos class for this collation</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad94f1c5c6943e7bb35e74030af5113fd" title="Get the Yatracos set.">getYatracosClassAll</a>(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        <span class="comment">//cout &lt;&lt; &quot;get delta theta&quot; &lt;&lt; endl;</span>
        <span class="comment">// get delta_theta for each theta</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a741a4e9b7dac5673c641b3a991b4a419" title="Get the maximum delta values for all thetas for the Yatracos Class.">getYatracosDelta</a>(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        <span class="comment">// get the true delta</span>
        real trueDelta = 0.0;
        vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator listIt;   
        <span class="comment">//cout &lt;&lt; &quot;Current Yatracos set has &quot; &lt;&lt; (*tempList).size() &lt;&lt; &quot; nodes.&quot; &lt;&lt; endl;</span>
        <span class="keywordflow">for</span> (listIt = (vecRowYatSet).begin(); listIt &lt; vecRowYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
              interval TrueDeltaI = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a34c69f3d97096d5aaf88958a1449963b">getFinMixIntervalTrueDelta</a>(mixt, tol, deg, (*listIt));
              real trueDeltaR = mid(TrueDeltaI);
              trueDeltaR = abs(trueDeltaR);
              trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
              <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
              trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
              <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
              trueDeltaCurrent = trueDelta;
              TrueDelta.push_back(trueDelta);
            }
          }

          <span class="keywordflow">for</span> (listIt = (vecColYatSet).begin(); listIt &lt; vecColYatSet.end(); listIt++) {
            <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
              interval TrueDeltaI = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a34c69f3d97096d5aaf88958a1449963b">getFinMixIntervalTrueDelta</a>(mixt, tol, deg, (*listIt));
              real trueDeltaR = mid(TrueDeltaI);
              trueDeltaR = abs(trueDeltaR);
              trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
              <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
              trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
              <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
              trueDeltaCurrent = trueDelta;
              TrueDelta.push_back(trueDelta);
            }
          }

        <span class="keywordflow">if</span> ( vecRowYatSet.empty() &amp;&amp; vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
        <span class="comment">//check theorem 10.1</span>
        <span class="comment">//cout &lt;&lt; &quot;check theorem: &quot; &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; IAE &lt;&lt; &quot;\t&quot; &lt;&lt; minIAE &lt;&lt; &quot;\t&quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( trueDelta &gt;= 0) {  assert(IAE &lt;= (3*minIAE + 4*trueDelta)); }

        <span class="comment">//stopping criteria</span>
        <span class="keywordflow">if</span> (stopCrit == <span class="keyword">true</span>) {
          <span class="comment">//cout &lt;&lt; &quot;checking stopping criteria: &quot; &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> toStop = coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#adc9f2cb78559081ca925defe641bd583">getMinDelta</a>(maxCheck, vecMaxDeltaVec);
          <span class="keywordflow">if</span> (toStop == <span class="keyword">true</span>) {
            cout &lt;&lt; <span class="stringliteral">&quot;Stopping criteria met.&quot;</span> &lt;&lt; endl;
            <span class="keywordflow">break</span>;
          } 
        }
        <span class="comment">//==========checks to see if need to split again=========//</span>
            <span class="comment">//checking if there are any more &#39;largest&#39; nodes in the priority queue</span>
            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough){    
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
            }
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abba9be0456a1228037dd40e7353d2169" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      } <span class="comment">// end of while loop</span>
      <span class="comment">//cout &lt;&lt; &quot;===========End of splitting=============&quot; &lt;&lt; endl;</span>
        
      <span class="comment">//do the merging here based on vecMinDistTheta</span>
         
      <span class="comment">//================Outputs to .txt files=================== </span>
      ofstream os;         <span class="comment">// ofstream object</span>
      os &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
      os.precision(5);

       <span class="comment">// get the minimum delta to get the MDE histogram</span>
      vector&lt; vector&lt;double&gt; &gt;::iterator it1; 
      vector&lt;double&gt;::iterator it2;
      <span class="keywordtype">int</span> Theta=0;
      <span class="comment">//cout &lt;&lt; &quot;MaxDelta&quot; &lt;&lt; endl;</span>
      <span class="keywordtype">size_t</span> <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a> = vecMaxDeltaVec.size(); 
      <span class="keywordtype">double</span> minDelta = 1000;
      <span class="keywordtype">int</span> minTheta = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>; i++){
        <span class="comment">//cout &lt;&lt; &quot;Theta: &quot; &lt;&lt; Theta &lt;&lt; &quot;\t&quot; &lt;&lt; vecMaxDeltaVec[F-1][i] &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( vecMaxDeltaVec[F-1][i] &lt; minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout &lt;&lt; <span class="stringliteral">&quot;MDE at &quot;</span> &lt;&lt; minTheta &lt;&lt; <span class="stringliteral">&quot; with IAE &quot;</span> &lt;&lt; vecIAE[minTheta] &lt;&lt; endl; 
         optHist = tempHist[minTheta];

      <span class="comment">// output vecDeltaMaxVec into .txt </span>
      ostringstream stm1, stm2;
      stm1 &lt;&lt; hist;
      stm2 &lt;&lt; method;
      <span class="keywordtype">string</span> fileNameDelta = <span class="stringliteral">&quot;FinMixMethod&quot;</span>;
      fileNameDelta += stm2.str();
      fileNameDelta += <span class="stringliteral">&quot;DeltaMax&quot;</span>;
      fileNameDelta += stm1.str();
      fileNameDelta += <span class="stringliteral">&quot;.txt&quot;</span>;  
      os.open(fileNameDelta.c_str());
      <span class="keywordflow">for</span> (it1 = vecMaxDeltaVec.begin(); it1 &lt; vecMaxDeltaVec.end(); it1++){ 
        <span class="keywordflow">for</span> (it2 = (*it1).begin(); it2 &lt; (*it1).end(); it2++){
          os &lt;&lt; (*it2) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
        }
        os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      }          
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;DeltaMax for each theta output to &quot;</span> &lt;&lt; fileNameDelta &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
      <span class="comment">//----------------end of output for vecDeltaMaxVec-------------</span>
 
         <span class="comment">//output vecIAE to .txt file</span>
      <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>
      outputFileName = <span class="stringliteral">&quot;FinMixMethod&quot;</span>;
      outputFileName += stm2.str();
      outputFileName += <span class="stringliteral">&quot;IAEandTrueDelta&quot;</span>;
      outputFileName += stm1.str();
      outputFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      os.open(outputFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vecIAE.size(); i++){
        os &lt;&lt; vecIAE[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vecIAEFull[i] &lt;&lt; TrueDelta[i] &lt;&lt; endl;
      }
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;IAE output to &quot;</span> &lt;&lt; outputFileName &lt;&lt; endl;
      <span class="comment">//=================end of output for vecIAE---------------------------      </span>
   } <span class="comment">// end of try</span>
    
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority stage split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    
   <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae94f662a33afa791de400341ad98cff7"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="ae94f662a33afa791de400341ad98cff7" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, RealMappedSPnode &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;optHist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeEst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>optHist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

</div>
</div>
<a class="anchor" id="a831814eaa200ac0fb42b5b600ec785c3"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="a831814eaa200ac0fb42b5b600ec785c3" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, RealMappedSPnode &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;optHist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeEst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>optHist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

</div>
</div>
<a class="anchor" id="aeb61aa929e6edebe98d6d4fbb10a6adb"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="aeb61aa929e6edebe98d6d4fbb10a6adb" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, int method, size_t hist, size_t maxLeafNodes, RealMappedSPnode &amp;nodeEst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeEst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>minVolB and minChildPoints supplied but no random number generator. </p>

</div>
</div>
<a class="anchor" id="ab38050780c66024e0c278789b37e25ed"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate" ref="ab38050780c66024e0c278789b37e25ed" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, int method, size_t hist, size_t maxLeafNodes, RealMappedSPnode &amp;nodeEst)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a261b3220218fe58d08713381aa7b0b44">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeEst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

</div>
</div>
<a class="anchor" id="aabc3d1996ec2e9e1e227f6012c0c8f06"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch" ref="aabc3d1996ec2e9e1e227f6012c0c8f06" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, AdaptiveHistogram &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;opthist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>opthist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02244">2244</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="FinMixScheffe_8cpp_source.shtml#l00044">main()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01317">prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
    gsl_rng * rgsl = NULL;
    <span class="keywordtype">bool</span> cancontinue;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        <span class="comment">// call the function with a random number generator</span>
        cancontinue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">prioritySplitAndEstimateWithSwitch</a>(compTest, he, logging, minChildPoints, 
                        minVolB, rgsl, stopCrit, myPart, weight, holesLoc,
                        method, hist,
                        maxLeafNodes, maxCheck, optHist);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority stage split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
   
   <span class="keywordflow">return</span> cancontinue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae2684877f0996eea6f6593f1be2ab38a"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch" ref="ae2684877f0996eea6f6593f1be2ab38a" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, AdaptiveHistogram &amp;myPart, double weight, std::vector&lt; int &gt; holesLoc, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;opthist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>opthist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02316">2316</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00335">subpavings::ExpandWithValid()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00990">subpavings::AdaptiveHistogramVCollator::getMinDelta()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">getMinVol()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00341">subpavings::AdaptiveHistogramVCollator::getNumberCollated()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">getRootLeaves()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00511">subpavings::AdaptiveHistogramVCollator::getSplitNodePtr()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04264">getUnifTrueDelta()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00680">subpavings::AdaptiveHistogramVCollator::getYatracosDelta()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00360">outputLogStart()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//cout &lt;&lt; &quot;calling prioritySplitAndEstimate:&quot; &lt;&lt; endl;</span>
   <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
   <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
   
    <span class="comment">//boolean for validation data</span>
    <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>;
    
    <span class="comment">// for stopping criteria</span>
    <span class="keywordtype">size_t</span> flagStop = 0;
    <span class="keywordtype">int</span> currentSmallest = 0;
    
    <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    
    <span class="comment">//set up collator to keep the histograms as splits happen</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> coll;
    
   <span class="comment">//=======initializing containers======================================</span>
  <span class="comment">//set up a list for the Yatracos set </span>
  list&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; listYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (row)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecRowYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (col)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecColYatSet;    
  <span class="comment">//set up a vector for maximum Delta_theta vectors</span>
  vector&lt; vector&lt;double&gt; &gt; vecMaxDeltaVec;
  <span class="comment">//initializing the vector - to allow the delta vector to be in </span>
  <span class="comment">// right order  since the first histogram does not have a </span>
  <span class="comment">// Yatracos set</span>
  <span class="comment">//the first element in this vector will not be plotted since </span>
  <span class="comment">// the first histogram is an empty set</span>
  vector&lt;double&gt; theta0;
  theta0.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); 
  <span class="comment">//the supremum of an empty set is -Infimum </span>
  vecMaxDeltaVec.push_back(theta0);
  <span class="comment">//set up a vector of the corresponding theta with the minimum </span>
  <span class="comment">// distance estimates</span>
  vector&lt; vector&lt;int&gt; &gt; vecMinDistTheta;
  <span class="comment">// set up a vector for the infimum </span>
  vector&lt;double&gt; vecInfDelta;
  <span class="comment">// set up a vector for the integrated absolute error for each histogram</span>
   vector&lt;real&gt; vecIAE; 
   vector&lt;real&gt; vecIAEFull;
   real minIAE = 1000.00;
   
   vector&lt;real&gt; TrueDelta;
   TrueDelta.push_back(-1); 

  real trueDeltaCurrent = 0;
  
   <span class="comment">// to keep the histograms</span>
   vector&lt;AdaptiveHistogramValidation&gt; tempHist;
   <span class="comment">//==============end of initializing containers=============================//   </span>
   <span class="comment">// check if the root box is empty</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }
    <span class="keywordflow">try</span> {       
        <span class="comment">// add the histogram before any split happens into the collator</span>
        <span class="keywordtype">size_t</span> agg = 0;
      coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
      tempHist.push_back(*<span class="keyword">this</span>);
      <span class="comment">// calculate the IAE </span>
      real IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 0);
      <span class="comment">// push back into vecIAE </span>
      vecIAE.push_back(IAE);
      minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
      
      <span class="comment">//get the IAE for the full data set</span>
      real IAEF = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 1);
      <span class="comment">// push back into vecIAE </span>
      vecIAEFull.push_back(IAEF);

    <span class="comment">//============checks  for splittable nodes=============================//</span>
        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="comment">//logging</span>
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }
        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8d94391339b619f6f3aefb89ca761e99" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
            volChecking = <span class="keyword">true</span>;
        }
      <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
      multiset&lt;SPSVnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));
      <span class="keywordtype">int</span> i=0;
      <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a34f7487fd92886151634c00e8e75cca5" title="Opening line of a txt log file.">outputLogStart</a>(s);    
            i++;
      }
      <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
      <span class="comment">// there are enough points in the whole node</span>
      <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
      <span class="comment">// or the minChildCountIfSplit test passed</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootVpaving pointer into the set</span>
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> sit;            
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }        
        <span class="comment">//==================end of checks=====================================//</span>
  
        <span class="comment">//=========start priority queue====================================//</span>
        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out   </span>
      <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {          
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* chosenLargest;
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSVnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSVnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator&gt; equalLargest;
            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {
                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }
            <span class="keywordflow">else</span> {
                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }
            <span class="comment">// split the biggest one and divide up its training and validation </span>
            <span class="comment">// data</span>
            <a class="code" href="namespacesubpavings.shtml#a6a89808457c34dbca09c2c75ef57c169" title="Expand a leaf node to have two child nodes.">ExpandWithValid</a>(chosenLargest, boolVal);
           
            cout &lt;&lt; <span class="stringliteral">&quot;---------split &quot;</span> &lt;&lt; coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>()-1 &lt;&lt; endl;
                           
            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

        <span class="comment">// remove empty boxes AND</span>
        <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>
            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;getCounter() &gt; 0) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new left child into the multiset</span>
                <span class="comment">//cout &lt;&lt; (chosenLargest-&gt;getLeftChild())-&gt;getCounter()  &lt;&lt; endl;</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;getCounter() &gt; 0) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new right child into the multiset</span>
               <span class="comment">//cout &lt;&lt; (chosenLargest-&gt;getRightChild())-&gt;getCounter()  &lt;&lt; endl;</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file                   </span>
                i++;
            }

          <span class="comment">//==========get IAE for this histogram======================//</span>
         
        <span class="comment">//cout &lt;&lt; &quot;get IAE for histogram &quot; &lt;&lt; coll.getNumberCollated() &lt;&lt; endl;</span>
        real IAE = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 0);
        minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa54b166c50901dc9ec2976bb4a5df916">getUnifIAE</a>(myPart, weight, holesLoc, 1);
        vecIAEFull.push_back(IAEF); 

        <span class="comment">// keep this histogram in a container </span>
        tempHist.push_back(*<span class="keyword">this</span>);
        
        <span class="comment">//cout &lt;&lt; &quot;add into collator&quot; &lt;&lt; endl;</span>
        <span class="comment">// add current histogram to collation</span>
        <span class="keywordtype">size_t</span> agg = 0;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
          
        <span class="comment">//cout &lt;&lt; &quot;get the split node&quot; &lt;&lt; endl;</span>
        <span class="comment">// first we need a pointer to the corresponding CollatorSPVnode </span>
        <span class="comment">// of the SPSVnode* chosenLargest     </span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * splitCollNode;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab38cfd38290579694a35950af5c80c36" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtr</a>(splitCollNode, chosenLargest);
        <span class="comment">//cout &lt;&lt; chosenLargest-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; splitCollNode-&gt;getNodeName() &lt;&lt; endl;</span>
        
        <span class="comment">//cout &lt;&lt; &quot;get the yat class&quot; &lt;&lt; endl;</span>
        <span class="comment">// get the Yatracos class for this collation</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad94f1c5c6943e7bb35e74030af5113fd" title="Get the Yatracos set.">getYatracosClassAll</a>(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        <span class="comment">//cout &lt;&lt; &quot;get delta theta&quot; &lt;&lt; endl;</span>
        <span class="comment">// get delta_theta for each theta</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a741a4e9b7dac5673c641b3a991b4a419" title="Get the maximum delta values for all thetas for the Yatracos Class.">getYatracosDelta</a>(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        <span class="comment">// get the true delta</span>
        real trueDelta = 0.0;
        vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator listIt;   
        <span class="comment">//cout &lt;&lt; &quot;Current Yatracos set has &quot; &lt;&lt; (*tempList).size() &lt;&lt; &quot; nodes.&quot; &lt;&lt; endl;</span>
        <span class="keywordflow">for</span> (listIt = (vecRowYatSet).begin(); listIt &lt; vecRowYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
            real trueDeltaR = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a9a9e088604995104a0313e525d4771e7">getUnifTrueDelta</a>(myPart, weight, holesLoc, (*listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        <span class="keywordflow">for</span> (listIt = (vecColYatSet).begin(); listIt &lt; vecColYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
            real trueDeltaR = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a9a9e088604995104a0313e525d4771e7">getUnifTrueDelta</a>(myPart, weight, holesLoc, (*listIt));
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        
        <span class="keywordflow">if</span> ( vecRowYatSet.empty() &amp;&amp; vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
        <span class="comment">//check theorem 10.1</span>
        <span class="comment">//if ( trueDelta &gt;= 0 ) { assert(IAE &lt;= (3*minIAE + 4*trueDelta)); }</span>

        <span class="comment">//stopping criteria</span>
        <span class="keywordflow">if</span> (stopCrit == <span class="keyword">true</span>) {
          <span class="comment">//cout &lt;&lt; &quot;checking stopping criteria: &quot; &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> toStop = coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#adc9f2cb78559081ca925defe641bd583">getMinDelta</a>(maxCheck, vecMaxDeltaVec);
          <span class="keywordflow">if</span> (toStop == <span class="keyword">true</span>) {
            cout &lt;&lt; <span class="stringliteral">&quot;Stopping criteria met.&quot;</span> &lt;&lt; endl;
            <span class="keywordflow">break</span>;
          } 
        }
        


        <span class="comment">//==========checks to see if need to split again=========//</span>
            <span class="comment">//checking if there are any more &#39;largest&#39; nodes in the priority queue</span>
            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough){    
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
            }
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abba9be0456a1228037dd40e7353d2169" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      } <span class="comment">// end of while loop</span>
      <span class="comment">//cout &lt;&lt; &quot;===========End of splitting=============&quot; &lt;&lt; endl;</span>
        
      <span class="comment">//do the merging here based on vecMinDistTheta</span>
         
      <span class="comment">//================Outputs to .txt files=================== </span>
      ofstream os;         <span class="comment">// ofstream object</span>
      os &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
      os.precision(5);

       <span class="comment">// get the minimum delta to get the MDE histogram</span>
      vector&lt; vector&lt;double&gt; &gt;::iterator it1; 
      vector&lt;double&gt;::iterator it2;
      <span class="keywordtype">int</span> Theta=0;
      <span class="comment">//cout &lt;&lt; &quot;MaxDelta&quot; &lt;&lt; endl;</span>
      <span class="keywordtype">size_t</span> <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a> = vecMaxDeltaVec.size(); 
      <span class="keywordtype">double</span> minDelta = 1000;
      <span class="keywordtype">int</span> minTheta = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>; i++){
        <span class="comment">//cout &lt;&lt; &quot;Theta: &quot; &lt;&lt; Theta &lt;&lt; &quot;\t&quot; &lt;&lt; vecMaxDeltaVec[F-1][i] &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( vecMaxDeltaVec[F-1][i] &lt; minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout &lt;&lt; <span class="stringliteral">&quot;MDE at &quot;</span> &lt;&lt; minTheta &lt;&lt; <span class="stringliteral">&quot; with IAE &quot;</span> &lt;&lt; vecIAE[minTheta] &lt;&lt; endl; 
         optHist = tempHist[minTheta];

      <span class="comment">// output vecDeltaMaxVec into .txt </span>
      ostringstream stm1, stm2;
      stm1 &lt;&lt; hist;
      stm2 &lt;&lt; method;
      <span class="keywordtype">string</span> fileNameDelta = <span class="stringliteral">&quot;UnifMethod&quot;</span>;
      fileNameDelta += stm2.str();
      fileNameDelta += <span class="stringliteral">&quot;DeltaMax&quot;</span>;
      fileNameDelta += stm1.str();
      fileNameDelta += <span class="stringliteral">&quot;.txt&quot;</span>;  
      os.open(fileNameDelta.c_str());
      <span class="keywordflow">for</span> (it1 = vecMaxDeltaVec.begin(); it1 &lt; vecMaxDeltaVec.end(); it1++){ 
        <span class="keywordflow">for</span> (it2 = (*it1).begin(); it2 &lt; (*it1).end(); it2++){
          os &lt;&lt; (*it2) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
        }
        os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      }          
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;DeltaMax for each theta output to &quot;</span> &lt;&lt; fileNameDelta &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
      <span class="comment">//----------------end of output for vecDeltaMaxVec-------------</span>
 
         <span class="comment">//output vecIAE to .txt file</span>
      <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>
      outputFileName = <span class="stringliteral">&quot;UnifMethod&quot;</span>;
      outputFileName += stm2.str();
      outputFileName += <span class="stringliteral">&quot;IAEandTrueDelta&quot;</span>;
      outputFileName += stm1.str();
      outputFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      os.open(outputFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vecIAE.size(); i++){
        os &lt;&lt; vecIAE[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vecIAEFull[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; TrueDelta[i] &lt;&lt; endl;
      }
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;IAE output to &quot;</span> &lt;&lt; outputFileName &lt;&lt; endl;
      <span class="comment">//=================end of output for vecIAE---------------------------      </span>
   } <span class="comment">// end of try</span>
    
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority stage split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    
   <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f39563ed08722fbe6be55474681abd5"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch" ref="a8f39563ed08722fbe6be55474681abd5" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, FinMix &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, AdaptiveHistogramValidation &amp;opthist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>opthist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01317">1317</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02244">prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    gsl_rng * rgsl = NULL;
    <span class="keywordtype">bool</span> cancontinue;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        <span class="comment">// call the function with a random number generator</span>
        cancontinue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">prioritySplitAndEstimateWithSwitch</a>(compTest, he, logging, minChildPoints, 
                        minVolB, rgsl, stopCrit, mixt, method, hist,
                        maxLeafNodes, maxCheck, tol, deg, optHist);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority stage split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
   
   <span class="keywordflow">return</span> cancontinue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6bd25ba3a874dee64a2fd93984542f39"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch" ref="a6bd25ba3a874dee64a2fd93984542f39" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, FinMix &amp;mixt, int method, size_t hist, size_t maxLeafNodes, int maxCheck, double tol, int deg, AdaptiveHistogramValidation &amp;opthist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>opthist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">1387</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00335">subpavings::ExpandWithValid()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04065">getFinMixIntervalTrueDelta()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00990">subpavings::AdaptiveHistogramVCollator::getMinDelta()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">getMinVol()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00341">subpavings::AdaptiveHistogramVCollator::getNumberCollated()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">getRootLeaves()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00511">subpavings::AdaptiveHistogramVCollator::getSplitNodePtr()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00680">subpavings::AdaptiveHistogramVCollator::getYatracosDelta()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00360">outputLogStart()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//cout &lt;&lt; &quot;calling prioritySplitAndEstimate:&quot; &lt;&lt; endl;</span>
   <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
   <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
   
    <span class="comment">//boolean for validation data</span>
    <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>;
    
    <span class="comment">// for stopping criteria</span>
    <span class="keywordtype">size_t</span> flagStop = 0;
    <span class="keywordtype">int</span> currentSmallest = 0;
    
    <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    
    <span class="comment">//set up collator to keep the histograms as splits happen</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> coll;
    
   <span class="comment">//=======initializing containers======================================</span>
  <span class="comment">//set up a list for the Yatracos set </span>
  list&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; listYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (row)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecRowYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (col)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecColYatSet;    
  <span class="comment">//set up a vector for maximum Delta_theta vectors</span>
  vector&lt; vector&lt;double&gt; &gt; vecMaxDeltaVec;
  <span class="comment">//initializing the vector - to allow the delta vector to be in </span>
  <span class="comment">// right order  since the first histogram does not have a </span>
  <span class="comment">// Yatracos set</span>
  <span class="comment">//the first element in this vector will not be plotted since </span>
  <span class="comment">// the first histogram is an empty set</span>
  vector&lt;double&gt; theta0;
  theta0.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); 
  <span class="comment">//the supremum of an empty set is -Infimum </span>
  vecMaxDeltaVec.push_back(theta0);
  <span class="comment">//set up a vector of the corresponding theta with the minimum </span>
  <span class="comment">// distance estimates</span>
  vector&lt; vector&lt;int&gt; &gt; vecMinDistTheta;
  <span class="comment">// set up a vector for the infimum </span>
  vector&lt;double&gt; vecInfDelta;
  <span class="comment">// set up a vector for the integrated absolute error for each histogram</span>
   vector&lt;real&gt; vecIAE; 
   vector&lt;real&gt; vecIAEFull;
   real minIAE = 1000.00;
   
   vector&lt;real&gt; TrueDelta;
   TrueDelta.push_back(-1); 

  real trueDeltaCurrent = 0;
  
   <span class="comment">// to keep the histograms</span>
   vector&lt;AdaptiveHistogramValidation&gt; tempHist;
   <span class="comment">//==============end of initializing containers=============================//   </span>
   <span class="comment">// check if the root box is empty</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }
    <span class="keywordflow">try</span> {       
        <span class="comment">// add the histogram before any split happens into the collator</span>
        <span class="keywordtype">size_t</span> agg = 0;
      coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
      tempHist.push_back(*<span class="keyword">this</span>);
      <span class="comment">// calculate the IAE </span>
      real IAE = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 0));
      <span class="comment">// push back into vecIAE </span>
      vecIAE.push_back(IAE);
      minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
      
      <span class="comment">//get the IAE for the full data set</span>
      real IAEF = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 1));
      <span class="comment">// push back into vecIAE </span>
      vecIAEFull.push_back(IAEF);

    <span class="comment">//============checks  for splittable nodes=============================//</span>
        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="comment">//logging</span>
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }
        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8d94391339b619f6f3aefb89ca761e99" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
            volChecking = <span class="keyword">true</span>;
        }
      <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
      multiset&lt;SPSVnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));
      <span class="keywordtype">int</span> i=0;
      <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a34f7487fd92886151634c00e8e75cca5" title="Opening line of a txt log file.">outputLogStart</a>(s);    
            i++;
      }
      <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
      <span class="comment">// there are enough points in the whole node</span>
      <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
      <span class="comment">// or the minChildCountIfSplit test passed</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootVpaving pointer into the set</span>
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> sit;            
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }        
        <span class="comment">//==================end of checks=====================================//</span>
  
        <span class="comment">//=========start priority queue====================================//</span>
        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out   </span>
      <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {          
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* chosenLargest;
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSVnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSVnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator&gt; equalLargest;
            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {
                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }
            <span class="keywordflow">else</span> {
                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }
            <span class="comment">// split the biggest one and divide up its training and validation </span>
            <span class="comment">// data</span>
            <a class="code" href="namespacesubpavings.shtml#a6a89808457c34dbca09c2c75ef57c169" title="Expand a leaf node to have two child nodes.">ExpandWithValid</a>(chosenLargest, boolVal);
           
            cout &lt;&lt; <span class="stringliteral">&quot;---------split &quot;</span> &lt;&lt; coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>()-1 &lt;&lt; endl;
                           
            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

        <span class="comment">// remove empty boxes AND</span>
        <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>
            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;getCounter() &gt; 0) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new left child into the multiset</span>
                <span class="comment">//cout &lt;&lt; (chosenLargest-&gt;getLeftChild())-&gt;getCounter()  &lt;&lt; endl;</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;getCounter() &gt; 0) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new right child into the multiset</span>
               <span class="comment">//cout &lt;&lt; (chosenLargest-&gt;getRightChild())-&gt;getCounter()  &lt;&lt; endl;</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file                   </span>
                i++;
            }

          <span class="comment">//==========get IAE for this histogram======================//</span>
         
        <span class="comment">//cout &lt;&lt; &quot;get IAE for histogram &quot; &lt;&lt; coll.getNumberCollated() &lt;&lt; endl;</span>
        real IAE = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 0));
        minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        
        real IAEF = mid(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8b89b93450dea8e464eac31d67c78d1">getFinMixIntervalIAE</a>(mixt, tol, deg, 1));
        vecIAEFull.push_back(IAEF); 

        <span class="comment">// keep this histogram in a container </span>
        tempHist.push_back(*<span class="keyword">this</span>);
        
        <span class="comment">//cout &lt;&lt; &quot;add into collator&quot; &lt;&lt; endl;</span>
        <span class="comment">// add current histogram to collation</span>
        <span class="keywordtype">size_t</span> agg = 0;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
          
        <span class="comment">//cout &lt;&lt; &quot;get the split node&quot; &lt;&lt; endl;</span>
        <span class="comment">// first we need a pointer to the corresponding CollatorSPVnode </span>
        <span class="comment">// of the SPSVnode* chosenLargest     </span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * splitCollNode;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab38cfd38290579694a35950af5c80c36" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtr</a>(splitCollNode, chosenLargest);
        <span class="comment">//cout &lt;&lt; chosenLargest-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; splitCollNode-&gt;getNodeName() &lt;&lt; endl;</span>
        
        <span class="comment">//cout &lt;&lt; &quot;get the yat class&quot; &lt;&lt; endl;</span>
        <span class="comment">// get the Yatracos class for this collation</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad94f1c5c6943e7bb35e74030af5113fd" title="Get the Yatracos set.">getYatracosClassAll</a>(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        <span class="comment">//cout &lt;&lt; &quot;get delta theta&quot; &lt;&lt; endl;</span>
        <span class="comment">// get delta_theta for each theta</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a741a4e9b7dac5673c641b3a991b4a419" title="Get the maximum delta values for all thetas for the Yatracos Class.">getYatracosDelta</a>(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        <span class="comment">// get the true delta</span>
        real trueDelta = 0.0;
        vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator listIt;   
        <span class="comment">//cout &lt;&lt; &quot;Current Yatracos set has &quot; &lt;&lt; (*tempList).size() &lt;&lt; &quot; nodes.&quot; &lt;&lt; endl;</span>
        <span class="keywordflow">for</span> (listIt = (vecRowYatSet).begin(); listIt &lt; vecRowYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !((*listIt).empty()) ) {
            interval trueDeltaI = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a34c69f3d97096d5aaf88958a1449963b">getFinMixIntervalTrueDelta</a>(mixt, tol, deg, (*listIt));
            real trueDeltaR = mid(trueDeltaI);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        
        <span class="keywordflow">for</span> (listIt = (vecColYatSet).begin(); listIt &lt; vecColYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !((*listIt).empty()) ) {
            interval trueDeltaI = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a34c69f3d97096d5aaf88958a1449963b">getFinMixIntervalTrueDelta</a>(mixt, tol, deg, (*listIt));
            real trueDeltaR = mid(trueDeltaI);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        
        
        <span class="keywordflow">if</span> ( vecRowYatSet.empty() &amp;&amp; vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
      <span class="comment">//check theorem 10.1</span>
      <span class="keywordflow">if</span> ( trueDelta &gt;= 0) {  assert(IAE &lt;= (3*minIAE + 4*trueDelta)); }

        <span class="comment">//stopping criteria</span>
        <span class="keywordflow">if</span> (stopCrit == <span class="keyword">true</span>) {
          <span class="comment">//cout &lt;&lt; &quot;checking stopping criteria: &quot; &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> toStop = coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#adc9f2cb78559081ca925defe641bd583">getMinDelta</a>(maxCheck, vecMaxDeltaVec);
          <span class="keywordflow">if</span> (toStop == <span class="keyword">true</span>) {
            cout &lt;&lt; <span class="stringliteral">&quot;Stopping criteria met.&quot;</span> &lt;&lt; endl;
            <span class="keywordflow">break</span>;
          } 
        }

        <span class="comment">//==========checks to see if need to split again=========//</span>
            <span class="comment">//checking if there are any more &#39;largest&#39; nodes in the priority queue</span>
            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough){    
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
            }
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abba9be0456a1228037dd40e7353d2169" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      } <span class="comment">// end of while loop</span>
      <span class="comment">//cout &lt;&lt; &quot;===========End of splitting=============&quot; &lt;&lt; endl;</span>
        
      <span class="comment">//do the merging here based on vecMinDistTheta</span>
         
      <span class="comment">//================Outputs to .txt files=================== </span>
      ofstream os;         <span class="comment">// ofstream object</span>
      os &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
      os.precision(5);

       <span class="comment">// get the minimum delta to get the MDE histogram</span>
      vector&lt; vector&lt;double&gt; &gt;::iterator it1; 
      vector&lt;double&gt;::iterator it2;
      <span class="keywordtype">int</span> Theta=0;
      <span class="comment">//cout &lt;&lt; &quot;MaxDelta&quot; &lt;&lt; endl;</span>
      <span class="keywordtype">size_t</span> <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a> = vecMaxDeltaVec.size(); 
      <span class="keywordtype">double</span> minDelta = 1000;
      <span class="keywordtype">int</span> minTheta = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>; i++){
        <span class="comment">//cout &lt;&lt; &quot;Theta: &quot; &lt;&lt; Theta &lt;&lt; &quot;\t&quot; &lt;&lt; vecMaxDeltaVec[F-1][i] &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( vecMaxDeltaVec[F-1][i] &lt; minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout &lt;&lt; <span class="stringliteral">&quot;MDE at &quot;</span> &lt;&lt; minTheta &lt;&lt; <span class="stringliteral">&quot; with IAE &quot;</span> &lt;&lt; vecIAE[minTheta] &lt;&lt; endl; 
         optHist = tempHist[minTheta];

      <span class="comment">// output vecDeltaMaxVec into .txt </span>
      ostringstream stm1, stm2;
      stm1 &lt;&lt; hist;
      stm2 &lt;&lt; method;
      <span class="keywordtype">string</span> fileNameDelta = <span class="stringliteral">&quot;FinMixMethod&quot;</span>;
      fileNameDelta += stm2.str();
      fileNameDelta += <span class="stringliteral">&quot;DeltaMax&quot;</span>;
      fileNameDelta += stm1.str();
      fileNameDelta += <span class="stringliteral">&quot;.txt&quot;</span>;  
      os.open(fileNameDelta.c_str());
      <span class="keywordflow">for</span> (it1 = vecMaxDeltaVec.begin(); it1 &lt; vecMaxDeltaVec.end(); it1++){ 
        <span class="keywordflow">for</span> (it2 = (*it1).begin(); it2 &lt; (*it1).end(); it2++){
          os &lt;&lt; (*it2) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
        }
        os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      }          
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;DeltaMax for each theta output to &quot;</span> &lt;&lt; fileNameDelta &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
      <span class="comment">//----------------end of output for vecDeltaMaxVec-------------</span>
 
         <span class="comment">//output vecIAE to .txt file</span>
      <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>
      outputFileName = <span class="stringliteral">&quot;FinMixMethod&quot;</span>;
      outputFileName += stm2.str();
      outputFileName += <span class="stringliteral">&quot;IAEandTrueDelta&quot;</span>;
      outputFileName += stm1.str();
      outputFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      os.open(outputFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vecIAE.size(); i++){
        os &lt;&lt; vecIAE[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vecIAEFull[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; TrueDelta[i] &lt;&lt; endl;
      }
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;IAE output to &quot;</span> &lt;&lt; outputFileName &lt;&lt; endl;
      <span class="comment">//=================end of output for vecIAE---------------------------      </span>
   } <span class="comment">// end of try</span>
    
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority stage split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    
   <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae20e1507aad418b0d5aee31882b738ea"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch" ref="ae20e1507aad418b0d5aee31882b738ea" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, bool stopCrit, RealMappedSPnode &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;optHist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeEst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>optHist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01777">1777</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02244">prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    gsl_rng * rgsl = NULL;
    <span class="keywordtype">bool</span> cancontinue;

    <span class="keywordflow">try</span> {
        <span class="comment">// set up a random number generator for uniform rvs</span>
        <span class="keyword">const</span> gsl_rng_type * tgsl;
        <span class="comment">// set the library variables *gsl_rng_default and</span>
        <span class="comment">// gsl_rng_default_seed to default environmental vars</span>
        gsl_rng_env_setup();
        tgsl = gsl_rng_default; <span class="comment">// make tgsl the default type</span>
        rgsl = gsl_rng_alloc (tgsl); <span class="comment">// set up with default seed</span>

        <span class="comment">// call the function with a random number generator</span>
        cancontinue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">prioritySplitAndEstimateWithSwitch</a>(compTest, he, logging, minChildPoints, 
                        minVolB, rgsl, stopCrit, nodeEst, method, hist,
                        maxLeafNodes, maxCheck, optHist);
        gsl_rng_free (rgsl);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in priority stage split.  Orginal error: &quot;</span>
                                     + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordflow">if</span> (NULL != rgsl) gsl_rng_free(rgsl); <span class="comment">// free the random number generator</span>
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
   
   <span class="keywordflow">return</span> cancontinue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad3f8cf7cf11ce1214abd2559bea54393"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch" ref="ad3f8cf7cf11ce1214abd2559bea54393" args="(const NodeCompObjVal &amp;compTest, const HistEvalObjVal &amp;he, LOGGING_LEVEL logging, size_t minChildPoints, double minVolB, gsl_rng *rgsl, bool stopCrit, RealMappedSPnode &amp;nodeEst, int method, size_t hist, size_t maxLeafNodes, int maxCheck, AdaptiveHistogramValidation &amp;optHist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aabc3d1996ec2e9e1e227f6012c0c8f06">AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>compTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a> &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a>&#160;</td>
          <td class="paramname"><em>logging</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVolB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stopCrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeEst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>optHist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>With random number generator. All other parameters supplied. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01847">1847</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00335">subpavings::ExpandWithValid()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01080">subpavings::SPSVnode::getLeaves()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04344">getMappedFunctionTrueDelta()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00990">subpavings::AdaptiveHistogramVCollator::getMinDelta()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">getMinVol()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00341">subpavings::AdaptiveHistogramVCollator::getNumberCollated()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">getRootLeaves()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00511">subpavings::AdaptiveHistogramVCollator::getSplitNodePtr()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00680">subpavings::AdaptiveHistogramVCollator::getYatracosDelta()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00360">outputLogStart()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00345">subpavings::AdaptiveHistogramVCollator::outputToTxtTabs()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">//cout &lt;&lt; &quot;calling prioritySplitAndEstimate:&quot; &lt;&lt; endl;</span>
   <span class="keywordtype">bool</span> cancontinue = <span class="keyword">false</span>;
   <span class="keywordtype">bool</span> TooManyLeaves = <span class="keyword">false</span>;
   
    <span class="comment">//boolean for validation data</span>
    <span class="keywordtype">bool</span> boolVal = <span class="keyword">true</span>;
    
    <span class="comment">// for stopping criteria</span>
    <span class="keywordtype">size_t</span> flagStop = 0;
    <span class="keywordtype">int</span> currentSmallest = 0;
    
    <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    
    <span class="comment">//set up collator to keep the histograms as splits happen</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> coll;
    
   <span class="comment">//=======initializing containers======================================</span>
  <span class="comment">//set up a list for the Yatracos set </span>
  list&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; listYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (row)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecRowYatSet;
  <span class="comment">//set up a vector for sets of pointers to CollatorSPVnode (col)</span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecColYatSet;    
  <span class="comment">//set up a vector for maximum Delta_theta vectors</span>
  vector&lt; vector&lt;double&gt; &gt; vecMaxDeltaVec;
  <span class="comment">//initializing the vector - to allow the delta vector to be in </span>
  <span class="comment">// right order  since the first histogram does not have a </span>
  <span class="comment">// Yatracos set</span>
  <span class="comment">//the first element in this vector will not be plotted since </span>
  <span class="comment">// the first histogram is an empty set</span>
  vector&lt;double&gt; theta0;
  theta0.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); 
  <span class="comment">//the supremum of an empty set is -Infimum </span>
  vecMaxDeltaVec.push_back(theta0);
  <span class="comment">//set up a vector of the corresponding theta with the minimum </span>
  <span class="comment">// distance estimates</span>
  vector&lt; vector&lt;int&gt; &gt; vecMinDistTheta;
  <span class="comment">// set up a vector for the infimum </span>
  vector&lt;double&gt; vecInfDelta;
  <span class="comment">// set up a vector for the integrated absolute error for each histogram</span>
   vector&lt;real&gt; vecIAE; 
   vector&lt;real&gt; vecIAEFull;
   real minIAE = 1000.00;
   
   vector&lt;real&gt; TrueDelta;
   TrueDelta.push_back(-1); 

  real trueDeltaCurrent = 0;
  
   <span class="comment">// to keep the histograms</span>
   vector&lt;AdaptiveHistogramValidation&gt; tempHist;
   <span class="comment">//==============end of initializing containers=============================//   </span>
   <span class="comment">// check if the root box is empty</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for prioritySplit&quot;</span>);
    }
    <span class="keywordflow">try</span> {       
        <span class="comment">// add the histogram before any split happens into the collator</span>
        <span class="keywordtype">size_t</span> agg = 0;
      coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
      tempHist.push_back(*<span class="keyword">this</span>);
      <span class="comment">// calculate the IAE </span>
      real IAE = 0.0;
      <span class="comment">//real IAE = getMappedFunctionIAE(nodeEst, 0);</span>
      <span class="comment">// push back into vecIAE </span>
      vecIAE.push_back(IAE);
      minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
      
      <span class="comment">//get the IAE for the full data set</span>
      <span class="comment">//real IAEF =getMappedFunctionIAE(nodeEst, 0);</span>
      <span class="comment">// push back into vecIAE </span>
      real IAEF = 0.0;
      vecIAEFull.push_back(IAEF);

    <span class="comment">//============checks  for splittable nodes=============================//</span>
        <span class="keywordtype">bool</span> volChecking = <span class="keyword">false</span>; <span class="comment">// record if we need to check volume before split</span>
        <span class="keywordtype">double</span> minVol = -1.0; <span class="comment">// minimum volume (used only if checking)</span>
        <span class="comment">//logging</span>
        std::string baseFileName = <span class="stringliteral">&quot;&quot;</span>;
        std::string s = <span class="stringliteral">&quot;&quot;</span>;
        <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
            <span class="comment">// pass to log output to keep track of splits</span>
            baseFileName = <span class="stringliteral">&quot;pqOutput&quot;</span>;
            s = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseFileName);
        }
        <span class="comment">// make volChecking true if minVolB is &gt; 0.0</span>
        <span class="keywordflow">if</span> (minVolB &gt; 0.0) {
            <span class="comment">// minimum volume of a splittable node is minVolB(log n)^2/n</span>
            minVol = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a8d94391339b619f6f3aefb89ca761e99" title="get the value of the minimum volume for a splittable node.">getMinVol</a>(minVolB);
            volChecking = <span class="keyword">true</span>;
        }
      <span class="comment">// a multiset for the queue (key values are not necessarily unique)</span>
      multiset&lt;SPSVnode*, MyCompare&gt; pq((<a class="code" href="classMyCompare.shtml">MyCompare</a>(compTest)));
      <span class="keywordtype">int</span> i=0;
      <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
             <span class="comment">// Start log file with filename and timestamp</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a34f7487fd92886151634c00e8e75cca5" title="Opening line of a txt log file.">outputLogStart</a>(s);    
            i++;
      }
      <span class="comment">// put nodes into the starting set IF they meet minVol test AND IF either</span>
      <span class="comment">// there are enough points in the whole node</span>
      <span class="comment">// and minChildCountIfSplit is 0 (ie all points go to one child)</span>
      <span class="comment">// or the minChildCountIfSplit test passed</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="comment">// check to insert a copy of the rootVpaving pointer into the set</span>
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>, volChecking, minVol,
                minChildPoints)) {
                    pq.insert(<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// root is not a leaf</span>
            <a class="code" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9" title="Define type SPSVnodePtrs as container of pointers to SPSVnodes.">SPSVnodePtrs</a> leaves;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
            <span class="comment">// check to insert each of the leaves into the set</span>
            <a class="code" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0" title="Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.">SPSVnodePtrsItr</a> sit;            
            <span class="keywordflow">for</span> (sit = leaves.begin(); sit &lt; leaves.end(); sit++) {
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>((*sit), volChecking, minVol,
                minChildPoints)) {
               pq.insert(*sit);
                }
            }
        }
        cancontinue = (!pq.empty());
        <span class="keywordtype">bool</span> bigEnough = cancontinue;
        <span class="keywordflow">if</span>(!cancontinue) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;No splittable leaves to split - aborting&quot;</span> &lt;&lt; std::endl;
        }        
        <span class="comment">//==================end of checks=====================================//</span>
  
        <span class="comment">//=========start priority queue====================================//</span>
        <span class="comment">// split until the HistEvalObj he () operator returns true</span>
        <span class="comment">// we only put splittable nodes into the set, so we don&#39;t have to check</span>
        <span class="comment">// that they are splittable when we take them out   </span>
      <span class="keywordflow">while</span> (bigEnough &amp;&amp; !he(<span class="keyword">this</span>) &amp;&amp; !TooManyLeaves) {          
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* largest = *(pq.rbegin ()); <span class="comment">// the last largest in the set</span>
            <a class="code" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>* chosenLargest;
            <span class="comment">// find if there are any more equal to largest around</span>
            multiset&lt;SPSVnode*, MyCompare&gt;::iterator mit;
            pair&lt;multiset&lt;SPSVnode*, MyCompare&gt;::iterator,
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator&gt; equalLargest;
            equalLargest = pq.equal_range(largest); <span class="comment">// everything that = largest</span>
            <span class="keywordtype">size_t</span> numberLargest = pq.count(largest); <span class="comment">// number of =largest</span>

            <span class="keywordflow">if</span> (numberLargest &gt; 1) {
                <span class="comment">// draw a random number in [0,1)</span>
                <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
                real sum = 0.0;
                <span class="comment">// random selection of the =largest node to chose</span>
                <span class="keywordflow">for</span> (mit=equalLargest.first; mit!=equalLargest.second; ++mit) {
                    sum += 1.0/(1.0*numberLargest);
                    <span class="keywordflow">if</span> (rand &lt; sum) {
                        <span class="keywordflow">break</span>;
                    }
                }
                chosenLargest = *(mit); <span class="comment">// the chosen largest in the set</span>
                pq.erase(mit);<span class="comment">// take the iterator to chosen largest out of the set</span>
            }
            <span class="keywordflow">else</span> {
                chosenLargest = *(pq.rbegin ()); <span class="comment">// the only largest</span>
                multiset&lt;SPSVnode*, MyCompare&gt;::iterator it = pq.end();
                it--;
                pq.erase(it);<span class="comment">// take this largest out of the set</span>
            }
            <span class="comment">// split the biggest one and divide up its training and validation </span>
            <span class="comment">// data</span>
            <a class="code" href="namespacesubpavings.shtml#a6a89808457c34dbca09c2c75ef57c169" title="Expand a leaf node to have two child nodes.">ExpandWithValid</a>(chosenLargest, boolVal);
           
            cout &lt;&lt; <span class="stringliteral">&quot;---------split &quot;</span> &lt;&lt; coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>()-1 &lt;&lt; endl;
                           
            <span class="comment">// add the new child names to the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> += chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();

        <span class="comment">// remove empty boxes AND</span>
        <span class="comment">// but only put the children into the container if they can be</span>
            <span class="comment">// split, which means IF the child meets the min vol test AND IF</span>
            <span class="comment">// either there are enough points in the whole child and</span>
                <span class="comment">// the child&#39;s minChildCountIfSplit is 0 (ie all points go to</span>
                <span class="comment">// one child of the child)</span>
            <span class="comment">// or the child&#39;s minChildCountIfSplit test is passed</span>
            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;getCounter() &gt; 0) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new left child into the multiset</span>
                <span class="comment">//cout &lt;&lt; (chosenLargest-&gt;getLeftChild())-&gt;getCounter()  &lt;&lt; endl;</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2" title="Accessor for the left child of a node.">getLeftChild</a>());
            }

            <span class="keywordflow">if</span> ( ((chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;getCounter() &gt; 0) 
            &amp;&amp; (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#ae63a7462ea0b3f0fc11ff45eff208cd0" title="Method to do checking for whether to split a node.">checkNodeCountForSplit</a>(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>(),
                    volChecking, minVol, minChildPoints)) ) {
                <span class="comment">// insert the new right child into the multiset</span>
               <span class="comment">//cout &lt;&lt; (chosenLargest-&gt;getRightChild())-&gt;getCounter()  &lt;&lt; endl;</span>
                pq.insert(chosenLargest-&gt;<a class="code" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42" title="Accessor for the right child of a node.">getRightChild</a>());
            }

            <span class="keywordflow">if</span> (logging != <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>) {
                <span class="comment">// To add current state of histogram to log file                   </span>
                i++;
            }

          <span class="comment">//==========get IAE for this histogram======================//</span>
         
        <span class="comment">//cout &lt;&lt; &quot;get IAE for histogram: \t&quot;;</span>
        real IAE = 0.0;
        <span class="comment">//real IAE = getMappedFunctionIAE(nodeEst, 0);</span>
        minIAE = (IAE &lt; minIAE) ? IAE : minIAE;
        vecIAE.push_back(IAE); 
        <span class="comment">//cout &lt;&lt; IAE &lt;&lt; endl;</span>
        
        real IAEF = 0.0;
        <span class="comment">//real IAEF = getMappedFunctionIAE(nodeEst, 1);</span>
        vecIAEFull.push_back(IAEF); 

        <span class="comment">// keep this histogram in a container </span>
        tempHist.push_back(*<span class="keyword">this</span>);
        
        <span class="comment">//cout &lt;&lt; &quot;add into collator&quot; &lt;&lt; endl;</span>
        <span class="comment">// add current histogram to collation</span>
        <span class="keywordtype">size_t</span> agg = 0;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02" title="Add an AdaptiveHistogramVal object to the collation.">addToCollationWithVal</a>(*<span class="keyword">this</span>, 1, agg);
          
        <span class="comment">//cout &lt;&lt; &quot;get the split node&quot; &lt;&lt; endl;</span>
        <span class="comment">// first we need a pointer to the corresponding CollatorSPVnode </span>
        <span class="comment">// of the SPSVnode* chosenLargest     </span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * splitCollNode;
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab38cfd38290579694a35950af5c80c36" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtr</a>(splitCollNode, chosenLargest);
        <span class="comment">//cout &lt;&lt; chosenLargest-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; splitCollNode-&gt;getNodeName() &lt;&lt; endl;</span>
        
        <span class="comment">//cout &lt;&lt; &quot;get the yat class&quot; &lt;&lt; endl;</span>
        <span class="comment">// get the Yatracos class for this collation</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad94f1c5c6943e7bb35e74030af5113fd" title="Get the Yatracos set.">getYatracosClassAll</a>(splitCollNode, vecRowYatSet,
                            vecColYatSet, listYatSet);

        <span class="comment">//cout &lt;&lt; &quot;get delta theta&quot; &lt;&lt; endl;</span>
        <span class="comment">// get delta_theta for each theta</span>
        coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a741a4e9b7dac5673c641b3a991b4a419" title="Get the maximum delta values for all thetas for the Yatracos Class.">getYatracosDelta</a>(listYatSet, vecRowYatSet, vecColYatSet, 
                        vecMaxDeltaVec);

        <span class="comment">// get the true delta</span>
        real trueDelta = 0.0;
        vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator listIt;   
        <span class="comment">//cout &lt;&lt; &quot;Current Yatracos set has &quot; &lt;&lt; (*tempList).size() &lt;&lt; &quot; nodes.&quot; &lt;&lt; endl;</span>
        <span class="keywordflow">for</span> (listIt = (vecRowYatSet).begin(); listIt &lt; vecRowYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
            real trueDeltaR = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a49d507fa0b75a7ad720204f0f581af6d">getMappedFunctionTrueDelta</a>(nodeEst, *listIt);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }
        <span class="keywordflow">for</span> (listIt = (vecColYatSet).begin(); listIt &lt; vecColYatSet.end(); listIt++) {
          <span class="keywordflow">if</span> ( !(*listIt).empty() ) {
            real trueDeltaR = <a class="code" href="adaptivehistogramvalidation_8cpp.shtml#a49d507fa0b75a7ad720204f0f581af6d">getMappedFunctionTrueDelta</a>(nodeEst, *listIt);
            trueDeltaR = abs(trueDeltaR);
            trueDelta = (trueDeltaR &gt; trueDelta) ? trueDeltaR : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;previous: &quot; &lt;&lt; trueDeltaCurrent &lt;&lt; &quot;\t current: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDelta = (trueDeltaCurrent &gt; trueDelta) ? trueDeltaCurrent : trueDelta;
            <span class="comment">//cout &lt;&lt; &quot;delta after comparison: &quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
            trueDeltaCurrent = trueDelta;
            TrueDelta.push_back(trueDelta);
          }
        }

        <span class="keywordflow">if</span> ( vecRowYatSet.empty() &amp;&amp; vecColYatSet.empty() ) 
        { trueDelta = -1; TrueDelta.push_back(trueDelta); } 
        
        <span class="comment">//check theorem 10.1</span>
        <span class="comment">//cout &lt;&lt; &quot;checking theorem 10.1&quot; &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; IAE &lt;&lt; &quot;\t&quot; &lt;&lt; minIAE &lt;&lt; &quot;\t&quot; &lt;&lt; trueDelta &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( trueDelta &gt;= 0 ) { assert(IAE &lt;= (3*minIAE + 4*trueDelta)); }

        <span class="comment">//stopping criteria</span>
        <span class="keywordflow">if</span> (stopCrit == <span class="keyword">true</span>) {
          <span class="comment">//cout &lt;&lt; &quot;checking stopping criteria: &quot; &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> toStop = coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#adc9f2cb78559081ca925defe641bd583">getMinDelta</a>(maxCheck, vecMaxDeltaVec);
          <span class="keywordflow">if</span> (toStop == <span class="keyword">true</span>) {
            cout &lt;&lt; <span class="stringliteral">&quot;Stopping criteria met.&quot;</span> &lt;&lt; endl;
            <span class="keywordflow">break</span>;
          } 
        }

        <span class="comment">//==========checks to see if need to split again=========//</span>
            <span class="comment">//checking if there are any more &#39;largest&#39; nodes in the priority queue</span>
            bigEnough = (!pq.empty());
            <span class="keywordflow">if</span> (!bigEnough){    
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: no splittable nodes left&quot;</span>
                    &lt;&lt; std::endl;
            }
        <span class="comment">// check if number of leaf nodes in subpaving &gt; maxLeafNodes</span>
        <span class="comment">// maximum number of leaf nodes allowed</span>
        <span class="comment">//n^B, A+B &gt; 1, 0  &lt; A &lt; 1, 0 &lt; B &lt; 1 - refer Prop. 1 in PQ paper</span>
        TooManyLeaves = (<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#abba9be0456a1228037dd40e7353d2169" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &gt; maxLeafNodes);
        <span class="keywordflow">if</span> ( TooManyLeaves) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;Terminated splitting: maximum number of leaf nodes = &quot;</span>&lt;&lt; maxLeafNodes &lt;&lt; <span class="stringliteral">&quot; reached&quot;</span>
                          &lt;&lt; std::endl;
        }
      } <span class="comment">// end of while loop</span>
      <span class="comment">//cout &lt;&lt; &quot;===========End of splitting=============&quot; &lt;&lt; endl;</span>
        
      <span class="comment">//do the merging here based on vecMinDistTheta</span>
         
      <span class="comment">//================Outputs to .txt files=================== </span>
      
      coll.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad2a470a3974ad963de7debb7fe870efe" title="Output the collated information to a txt file.">outputToTxtTabs</a>(<span class="stringliteral">&quot;CollFromMDEPQ.txt&quot;</span>);
      
      ofstream os;         <span class="comment">// ofstream object</span>
      os &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
      os.precision(5);

       <span class="comment">// get the minimum delta to get the MDE histogram</span>
      vector&lt; vector&lt;double&gt; &gt;::iterator it1; 
      vector&lt;double&gt;::iterator it2;
      <span class="keywordtype">int</span> Theta=0;
      <span class="comment">//cout &lt;&lt; &quot;MaxDelta&quot; &lt;&lt; endl;</span>
      <span class="keywordtype">size_t</span> <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a> = vecMaxDeltaVec.size(); 
      <span class="keywordtype">double</span> minDelta = 1000;
      <span class="keywordtype">int</span> minTheta = 0;
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>; i++){
        <span class="comment">//cout &lt;&lt; &quot;Theta: &quot; &lt;&lt; Theta &lt;&lt; &quot;\t&quot; &lt;&lt; vecMaxDeltaVec[F-1][i] &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( vecMaxDeltaVec[F-1][i] &lt; minDelta ) { 
          minDelta = vecMaxDeltaVec[F-1][i]; 
          minTheta = Theta; 
        } 
        Theta++;
      }

      cout &lt;&lt; <span class="stringliteral">&quot;MDE at &quot;</span> &lt;&lt; minTheta &lt;&lt; <span class="stringliteral">&quot; with IAE &quot;</span> &lt;&lt; vecIAE[minTheta] &lt;&lt; endl; 
         optHist = tempHist[minTheta];

      <span class="comment">// output vecDeltaMaxVec into .txt </span>
      ostringstream stm1, stm2;
      stm1 &lt;&lt; hist;
      stm2 &lt;&lt; method;
      <span class="keywordtype">string</span> fileNameDelta = <span class="stringliteral">&quot;MappedFunctionMethod&quot;</span>;
      fileNameDelta += stm2.str();
      fileNameDelta += <span class="stringliteral">&quot;DeltaMax&quot;</span>;
      fileNameDelta += stm1.str();
      fileNameDelta += <span class="stringliteral">&quot;.txt&quot;</span>;  
      os.open(fileNameDelta.c_str());
      <span class="keywordflow">for</span> (it1 = vecMaxDeltaVec.begin(); it1 &lt; vecMaxDeltaVec.end(); it1++){ 
        <span class="keywordflow">for</span> (it2 = (*it1).begin(); it2 &lt; (*it1).end(); it2++){
          os &lt;&lt; (*it2) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
        }
        os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
      }          
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;DeltaMax for each theta output to &quot;</span> &lt;&lt; fileNameDelta &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
      <span class="comment">//----------------end of output for vecDeltaMaxVec-------------</span>
 
         <span class="comment">//output vecIAE to .txt file</span>
      <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>
      outputFileName = <span class="stringliteral">&quot;MappedFunctionMethod&quot;</span>;
      outputFileName += stm2.str();
      outputFileName += <span class="stringliteral">&quot;IAEandTrueDelta&quot;</span>;
      outputFileName += stm1.str();
      outputFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      os.open(outputFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vecIAE.size(); i++){
        os &lt;&lt; vecIAE[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vecIAEFull[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; TrueDelta[i] &lt;&lt; endl;
      }
      os &lt;&lt; flush;
      os.close();
      std::cout &lt;&lt; <span class="stringliteral">&quot;IAE output to &quot;</span> &lt;&lt; outputFileName &lt;&lt; endl;
      <span class="comment">//=================end of output for vecIAE---------------------------      </span>
   } <span class="comment">// end of try</span>
    
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in priority stage split.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in priority stage split.  Orginal error: &quot;</span> + oldmsg;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    
   <span class="keywordflow">return</span> (cancontinue);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7498bdc1663c857052e5bc147bf086f7"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::splitToShape" ref="a7498bdc1663c857052e5bc147bf086f7" args="(std::string instruction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7498bdc1663c857052e5bc147bf086f7">AdaptiveHistogramValidation::splitToShape</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>instruction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a histogram to a specified shape. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instruction</td><td>specifies the required shape, eg "3, 3. 2, 1" </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03255">3255</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">creationString</a>, <a class="el" href="spnode_8cpp_source.shtml#l01496">subpavings::SPnode::getChildNodeNames()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">rootVpaving</a>, <a class="el" href="spnode_8cpp_source.shtml#l01551">subpavings::SPnode::splitRootToShape()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;

    <span class="comment">// checks:  is there a root paving, is the string properly formed?</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for splitToShape&quot;</span>);
    }

    <span class="keywordflow">if</span> (instruction.length() == 0) {
      <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No instruction&quot;</span>);
    }

    std::string legal(<span class="stringliteral">&quot;, 0123456789&quot;</span>);
    <span class="keywordflow">if</span> (instruction.find_first_not_of(legal) != std::string::npos) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Illegal character in instruction&quot;</span>);
    }

    <span class="keywordflow">try</span> { <span class="comment">// all seems to be okay, we can start spliting the root paving</span>
        <span class="comment">// specify what to look for as numbers or decimal point or + or -</span>

       success = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a62e9df1a7c96af8f0796a6ea211b38ea" title="Split a root paving to a specified shape.">splitRootToShape</a>(instruction);

        <span class="keywordflow">if</span> (success) {
            <span class="comment">// update the creation string</span>
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2" title="A string showing the order of creation of the rootPaving.">creationString</a> = <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>()
                + <a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c" title="Pointer to the root node of the subpaving tree.">rootVpaving</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a0e7556ec8e2ba5174777c0f6b32573d5" title="Gets a string of child nodes names.">getChildNodeNames</a>();
        }
        <span class="keywordflow">else</span> {
            std::cerr &lt;&lt; std::endl;
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Your instruction does not describe a proper tree.&quot;</span>;
            std::cerr &lt;&lt; <span class="stringliteral">&quot;  Please check your instruction and try again.&quot;</span>
            &lt;&lt; std::endl;
       }
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory in splitToShape.  Orginal error: &quot;</span>
                                            + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error in splitToShape.  Orginal error: &quot;</span>
                                    + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException in splitToShape.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error in splitToShape.  Orginal error: &quot;</span> + oldmsg;
        std::cerr &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a7d46cc6c04481f9579e9f5238ccea8b2"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::creationString" ref="a7d46cc6c04481f9579e9f5238ccea8b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a7d46cc6c04481f9579e9f5238ccea8b2">subpavings::AdaptiveHistogramValidation::creationString</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A string showing the order of creation of the rootPaving. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00119">119</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00098">AdaptiveHistogramValidation()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">haveMadePaving()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">operator=()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03255">splitToShape()</a>.</p>

</div>
</div>
<a class="anchor" id="acae18e51a5026807492d2109702c3c93"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::dataCollection" ref="acae18e51a5026807492d2109702c3c93" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">BigDataCollection</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#acae18e51a5026807492d2109702c3c93">subpavings::AdaptiveHistogramValidation::dataCollection</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container for all sample data passed to this. </p>
<p>The sample that has come in thus far. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00110">110</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00458">AdaptiveHistogramValidation()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">insertDataFromContainer()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a4de24d08db784df2fdb619ba2c1f62fd"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::holdAllStats" ref="a4de24d08db784df2fdb619ba2c1f62fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a4de24d08db784df2fdb619ba2c1f62fd">subpavings::AdaptiveHistogramValidation::holdAllStats</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Controls whether all available statistics are maintained in the rootPaving. If set to false (default) only counts are maintained. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00115">115</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00573">getHoldAllStats()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">haveMadePaving()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a0039bec0f033c35a5477375cb54eb8ea"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::padding" ref="a0039bec0f033c35a5477375cb54eb8ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const real <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a0039bec0f033c35a5477375cb54eb8ea">AdaptiveHistogramValidation::padding</a> = 0.000005<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>a constant for padding a box if it is tailor-made for data. </p>
<p>The padding if the size of the root box is obtained from the min and max of the data that is fully fed in. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00090">90</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00209">makeBox()</a>.</p>

</div>
</div>
<a class="anchor" id="aa8a961766f97013134d73f1735f3516c"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::rootBox" ref="aa8a961766f97013134d73f1735f3516c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#aa8a961766f97013134d73f1735f3516c">subpavings::AdaptiveHistogramValidation::rootBox</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The root box used to form the subpaving tree. </p>
<p>We may not need this, at present it gets passed to the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> constructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00104">104</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00098">AdaptiveHistogramValidation()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00116">completeDataInsertionFromVec()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">haveMadePaving()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a811e21423987027452237cabf38c008c"></a><!-- doxytag: member="subpavings::AdaptiveHistogramValidation::rootVpaving" ref="a811e21423987027452237cabf38c008c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a>* <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a811e21423987027452237cabf38c008c">subpavings::AdaptiveHistogramValidation::rootVpaving</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to the root node of the subpaving tree. </p>
<p>An <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> is a binary tree representation of a subpaving, designed for processing statistical data. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml#l00097">97</a> of file <a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00098">AdaptiveHistogramValidation()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03601">get2DIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03530">getFinMixIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03337">getLeafCounts()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03323">getLeafLevels()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00579">getLeafLevelsString()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">getMinVol()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">getRootLeaves()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00556">getRootSumLeafCountOverVol()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00548">getRootVcounter()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">getSubPaving()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">haveMadePaving()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">insertDataFromContainer()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00495">operator=()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03349">outputGraphDot()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03391">outputRootToTxt()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03367">outputToTxtTabs()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03255">splitToShape()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00536">~AdaptiveHistogramValidation()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a></li>
<li><a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:32 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
