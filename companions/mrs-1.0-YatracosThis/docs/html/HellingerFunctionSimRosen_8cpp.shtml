<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: HellingerFunctionSimRosen.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('HellingerFunctionSimRosen_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HellingerFunctionSimRosen.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Get the Hellinger distance between actual Gaussian data and Gaussian data generated from a function estimate.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="histall_8hpp_source.shtml">histall.hpp</a>&quot;</code><br/>
<code>#include &quot;intervalmappedspnode_measurers.hpp&quot;</code><br/>
<code>#include &quot;functionestimator_interval.hpp&quot;</code><br/>
<code>#include &quot;<a class="el" href="piecewise__constant__function_8hpp_source.shtml">piecewise_constant_function.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="RosenDensityFobj_8hpp_source.shtml">RosenDensityFobj.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="SmallClasses_8hpp_source.shtml">SmallClasses.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Fobj_8hpp_source.shtml">Fobj.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="FRosenbrock_8hpp_source.shtml">FRosenbrock.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="MRSampler_8hpp_source.shtml">MRSampler.hpp</a>&quot;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
<code>#include &quot;gsl/gsl_linalg.h&quot;</code><br/>
<code>#include &quot;gsl/gsl_matrix.h&quot;</code><br/>
<code>#include &quot;gsl/gsl_blas.h&quot;</code><br/>
<code>#include &quot;assert.h&quot;</code><br/>
</div>
<p><a href="HellingerFunctionSimRosen_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HellingerFunctionSimRosen_8cpp.shtml#a0c0402be9ebd7abad750822814d38f99">ProduceMRSamples</a> (<a class="el" href="classFobj.shtml">Fobj</a> &amp;<a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, int n_boxes, int n_samples, double Alb, unsigned seed, bool use_f_scale, <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rs_sample)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="HellingerFunctionSimRosen_8cpp.shtml#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Get the Hellinger distance between actual Gaussian data and Gaussian data generated from a function estimate. </p>

<p>Definition in file <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml">HellingerFunctionSimRosen.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="HellingerFunctionSimRosen.cpp::main" ref="a0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ImageSetDiff_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml#l00116">116</a> of file <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml">HellingerFunctionSimRosen.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">subpavings::AdaptiveHistogram::getRootBox()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01227">subpavings::AdaptiveHistogram::getRootPavingMean()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01235">subpavings::AdaptiveHistogram::getRootPavingVarCovar()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">subpavings::AdaptiveHistogram::getSubPaving()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375">subpavings::PiecewiseConstantFunction::getTotalIntegral()</a>, <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00018">Height</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01023">subpavings::AdaptiveHistogram::insertFromRSSample()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">subpavings::AdaptiveHistogram::insertFromRVec()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">subpavings::PiecewiseConstantFunction::normalise()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">subpavings::PiecewiseConstantFunction::outputToTxtTabs()</a>, <a class="el" href="MooreImpSam_2CFN3_2CFN3_8cpp_source.shtml#l00058">ProduceMRSamples()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854">subpavings::PiecewiseConstantFunction::simulateData()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>, and <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00017">Tinverse</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// sort out user-defined parameters------------------//</span>
  <span class="keywordflow">if</span> ( argc &lt; 6 ) {
    cerr &lt;&lt; <span class="stringliteral">&quot;Syntax: &quot;</span> &lt;&lt; argv[0] &lt;&lt; 
    <span class="stringliteral">&quot;d maxLeavesEst n dataSeed&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Syntax: &quot;</span> + std::string(argv[0]) + <span class="stringliteral">&quot;d n states, symmetryIndicator&quot;</span>);
  }
  
  <span class="keywordtype">int</span> d = atoi(argv[1]);  <span class="comment">// ds</span>
  <span class="keywordtype">size_t</span> maxLeavesEst = atoi(argv[2]);  <span class="comment">// number of leaves in estimator</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = atoi(argv[3]);  <span class="comment">// number of points to generate</span>
  <span class="keywordtype">int</span> dataSeed = atoi(argv[4]); <span class="comment">// seed for data generation</span>

  <span class="keywordtype">size_t</span> minPoints = 1;
  <span class="keywordtype">size_t</span> minPQPoints1 = 1;
  <span class="keywordtype">size_t</span> minPQPoints2 = 1;
  <span class="keywordtype">size_t</span> minPQPoints3 = 1;

  <span class="keywordtype">int</span> n_boxes = atoi(argv[5]); <span class="comment">// for mrs</span>

  cout &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; : process id is &quot;</span> &lt;&lt; getpid() &lt;&lt; std::endl;

  <span class="comment">// for output purposes</span>
  <span class="comment">// string formatting</span>
  ofstream oss;         <span class="comment">// ofstream object</span>
   oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
   oss.precision(10);

  <span class="comment">//=======generate actual data and get the root box==============//</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\n Generate &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; data from actual density.&quot;</span> &lt;&lt; endl;

  ios::sync_with_stdio ();  <span class="comment">// call this function so iostream works with stdio</span>
  cout &lt;&lt; SetPrecision (20, 15);  <span class="comment">// Number of mantissa digits in I/O</span>
  
  
  <span class="comment">// set up a random number generator and use mt19937 for generator</span>
  gsl_rng * r = gsl_rng_alloc (gsl_rng_mt19937); <span class="comment">// set up with default seed</span>
  <span class="comment">//long unsigned int seed = 1234;</span>
  gsl_rng_set (r, dataSeed); <span class="comment">// change the seed</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Data seed is &quot;</span> &lt;&lt; dataSeed &lt;&lt; endl;
  
  <span class="comment">// set default values</span>
  <span class="keywordtype">int</span> n_dimensions = d; 
  <span class="keywordtype">int</span> n_samples = n;
  <span class="keywordtype">double</span> Alb = 1.0;<span class="comment">// partition until lower bound on Acceptance Prob. is &gt; Alb</span>
  <span class="keywordtype">unsigned</span> theSeed = dataSeed;
  
  <span class="comment">//Parameters specific to the Rosenbrock target</span>
  real <a class="code" href="RosenFobj2D_8cpp.shtml#aec5c4d9798cfa73539577e4a2206ab1a">Tinverse</a> = 1.0;
  real <a class="code" href="RosenFobj2D_8cpp.shtml#ab0eb64c1a8d085bcf238d947f3fa839f">Height</a> = 100.0;
  real RosenDomainLimit = 10.0;
  
  cout &lt;&lt; <span class="stringliteral">&quot;# n_dimensions: &quot;</span> &lt;&lt; n_dimensions &lt;&lt; <span class="stringliteral">&quot;  n_boxes: &quot;</span> &lt;&lt; n_boxes 
       &lt;&lt; <span class="stringliteral">&quot;  n_samples: &quot;</span> &lt;&lt; n_samples &lt;&lt; <span class="stringliteral">&quot;  rng_seed = &quot;</span> &lt;&lt; theSeed  
       &lt;&lt; endl; <span class="comment">//getchar();</span>
  
  <span class="keywordtype">bool</span> UseLogPi = <span class="keyword">false</span>; <span class="comment">// log scale won&#39;t work naively</span>
  <span class="keywordtype">bool</span> use_f_scale = <span class="keyword">false</span>;
  
  <span class="comment">// make the function object</span>
  <a class="code" href="classFRosenbrock.shtml" title="n-dimensional Rosenbrock density as a function object class">FRosenbrock</a> FRosen (n_dimensions, 
                      Tinverse, Height, RosenDomainLimit, UseLogPi);
  
  <span class="comment">// produce the samples</span>
  <a class="code" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a>* actualDataPtr = <span class="keyword">new</span> <a class="code" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a>; 
  <a class="code" href="MooreImpSam_2CFN3_2CFN3_8cpp.shtml#a631ece91d072eb67cffd058e11c49468">ProduceMRSamples</a>(FRosen, n_boxes, n_samples, 
                   Alb, theSeed, use_f_scale, *actualDataPtr);

  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>* actualHist = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>(<span class="keyword">true</span>); 
  actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">insertFromRSSample</a>(*actualDataPtr, 0, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>);
  ivector pavingBoxEst = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a936a3426494278163afada104df26ecc" title="Get the box of the subpaving managed by this.">getRootBox</a>();

  <span class="comment">//=========end of getting a root box from the actual data=============</span>
  
  <span class="comment">//============== make estimate ============//</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nMake the function estimator to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
  
  <span class="comment">// specify function object (from /examples/MappedTargets</span>
  <a class="code" href="classRosenDensityFobj.shtml">RosenDensityFobj</a> fobj;
  
  <span class="comment">/* function estimate is going to use same box as the histograms */</span>
  <span class="comment">//ivector pavingBoxEst(d);</span>
  <span class="comment">//for(int k=1; k &lt;= d; k++) pavingBoxEst[k] = pavingInterval;</span>
  
  <span class="comment">// Use fobj and pavingBox to get an estimator</span>
  FunctionEstimatorInterval estimator(pavingBoxEst, fobj);
  
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logEst = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; <span class="comment">// logging for making estimator</span>
  
<span class="preprocessor">  #if(1)</span>
<span class="preprocessor"></span>  <span class="keywordtype">size_t</span> maxLeavesEstDown = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(1.2*maxLeavesEst); <span class="comment">// go down to 1.2 x max</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span><span class="preprocessor">  #if(0)</span>
<span class="preprocessor"></span>    <span class="keywordtype">size_t</span> maxLeavesEstDown = maxLeavesEst;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;pq down to max leaves &quot;</span> &lt;&lt; maxLeavesEstDown &lt;&lt; endl;
  
  clock_t startEst = clock();
  
  <span class="comment">// priority split driven by splitting leaf with max reimann diff</span>
  ReimannDiffMeasurer measurer;
  estimator.prioritySplit(measurer, maxLeavesEstDown, logEst);
      
  <span class="comment">// stop recording time here</span>
  clock_t endEst = clock();
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves in estimate: &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;  
  cout &lt;&lt; <span class="stringliteral">&quot;After split, getTotalAreaOfIntervalBand() = &quot;</span>
    &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
  <span class="keywordtype">double</span> timingEst1 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for pq split in estimate: &quot;</span> &lt;&lt; timingEst1 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  startEst = clock();
  
<span class="preprocessor">  #if(1) </span>
<span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;Hull propagation&quot;</span> &lt;&lt; endl;
    estimator.hullPropagation();
    
    cout &lt;&lt; <span class="stringliteral">&quot;Priority merge to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
<span class="preprocessor">    #if(0)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by minimising increase the reimann diff</span>
    estimator.priorityMergeOnLoss(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span><span class="preprocessor">    #if(1)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by merging cherry with minimum reimann diff</span>
    estimator.priorityMerge(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>          
    <span class="comment">// stop recording time here</span>
    endEst = clock(); 
    <span class="keywordtype">double</span> timingEst2 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
    cout &lt;&lt; <span class="stringliteral">&quot;Computing time for hull propagate and merge up in estimate: &quot;</span> &lt;&lt; timingEst2 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
    
    cout &lt;&lt; <span class="stringliteral">&quot;After propagation and priority merge, getTotalAreaOfIntervalBand() = &quot;</span> 
          &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;number of leaves is = &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;Making estimate and normalising&quot;</span> &lt;&lt; endl;
  <span class="comment">// Make PiecewiseConstantFunction estimate from estimator</span>
  <a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> estimate = estimator.makePiecewiseConstantFunction();
  
  cout &lt;&lt; <span class="stringliteral">&quot;estimate has integral &quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; <span class="stringliteral">&quot; before normalizing&quot;</span> &lt;&lt; endl;
  real before = estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>();
  
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">normalise</a>();
  
  cout &lt;&lt; <span class="stringliteral">&quot;estimate has integral &quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; endl;
  
  <span class="comment">//optional</span>
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">outputToTxtTabs</a>(<span class="stringliteral">&quot;PCF.txt&quot;</span>);
  
  
  <span class="keywordtype">string</span> Integral = <span class="stringliteral">&quot;Integral.txt&quot;</span>;
  oss.open(Integral.c_str());
  oss &lt;&lt; before &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; endl;
  oss &lt;&lt; flush;
  oss.close();
  
  
  
  
  <span class="comment">//===========end of estimating function using PCF=========================//</span>

  <span class="comment">//===========generate data==============================================//</span>
  <span class="comment">// Use PiecewiseConstantFunction to generate data, supplying our own rng</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nGenerating data for simulation&quot;</span> &lt;&lt; endl;

  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>* theDataPtr = <span class="keyword">new</span> <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>;   <span class="comment">// a container for all the points generated</span>

  clock_t startData = clock();

  <span class="comment">// Gaussian data</span>
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854" title="Simulator taking a random number generator argument.">simulateData</a>(*theDataPtr, n, r);

  <span class="comment">// stop recording time here</span>
  clock_t endData = clock();  
  <span class="keywordtype">double</span> timingData = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endData - startData)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for simulating data: &quot;</span> &lt;&lt; timingData &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;

  cout &lt;&lt; (*theDataPtr).size() &lt;&lt; <span class="stringliteral">&quot; points generated&quot;</span> &lt;&lt; endl;
  
  <span class="keywordflow">try</span> {
    gsl_rng_free (r);
    r = NULL;
  }
  <span class="keywordflow">catch</span>(...) {}<span class="comment">// catch and swallow</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;\nStart example: n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; and d = &quot;</span> &lt;&lt; d &lt;&lt; endl;
  <span class="comment">//cout &lt;&lt; &quot;Paving interval is &quot; &lt;&lt; pavingInterval &lt;&lt; endl;</span>

  <span class="comment">//===========end of generating data=================================//</span>

  <span class="comment">//================get the hellinger distance for this set 0f data========//</span>
  real HDEstActual = 0.0;  <span class="comment">// est vs actual</span>
  
  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>* estimateHist = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>(<span class="keyword">true</span>); 
  estimateHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae19b382cf2c8f7f9b1d20883a7faf5c8">insertFromRVec</a>(*theDataPtr);

  <span class="comment">// get the mean and var-covar of the mapped data</span>
  rvector EstMean = (estimateHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>())-&gt;getMean(); <span class="comment">// get mean</span>
  <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> EstCovar = (estimateHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>())-&gt;getVarCovar(); <span class="comment">//get the covariance matrix/</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;Estimated mean: &quot;</span> &lt;&lt; EstMean &lt;&lt; endl;

  <span class="comment">/*</span>
<span class="comment">  //compare against actual (0,1)</span>
<span class="comment">  {</span>
<span class="comment">    //get the mean</span>
<span class="comment">    rvector ExactMean(d);</span>
<span class="comment">    for (int i = 1; i &lt;= d; i++) { ExactMean[i] = 0.0; }</span>
<span class="comment">    //cout &lt;&lt; ExactMean &lt;&lt; endl;</span>
<span class="comment"></span>
<span class="comment">    //get the differences of the mean vectors</span>
<span class="comment">    rvector diffMean = ExactMean - EstMean;</span>
<span class="comment">    //cout &lt;&lt; diffMean &lt;&lt; endl;</span>
<span class="comment"></span>
<span class="comment">    if (d == 1) {</span>
<span class="comment">      interval covarI = interval(EstCovar[0]);</span>
<span class="comment">      interval actualCovarI = interval(1.0);</span>
<span class="comment">      interval sumVar = covarI + actualCovarI;</span>
<span class="comment">      //cout &lt;&lt; sumVar &lt;&lt; &quot;\t&quot;;</span>
<span class="comment">      interval insqrt = 2*sqrt(covarI)*sqrt(actualCovarI)/sumVar;</span>
<span class="comment">      //cout &lt;&lt; insqrt &lt;&lt; &quot;\t&quot;;</span>
<span class="comment">      interval H2 = interval(1,1) - sqrt(insqrt) *exp((-0.25*diffMean[1]*diffMean[1])/sumVar);</span>
<span class="comment">      //cout &lt;&lt; &quot;H2: &quot; &lt;&lt; H2 &lt;&lt; endl;</span>
<span class="comment">      HDTrue = mid(sqrt(H2));</span>
<span class="comment">    }</span>
<span class="comment"></span>
<span class="comment">    else {</span>
<span class="comment">    // get the variance-covariances</span>
<span class="comment">    RealVec ExactCovar;</span>
<span class="comment">    ExactCovar.reserve(d*d);</span>
<span class="comment"></span>
<span class="comment">    // fill in the matrix where the off-diag are 0</span>
<span class="comment">    for (size_t i = 0; i &lt; d*d; i++) {</span>
<span class="comment">        ExactCovar.push_back(0.0); //first fill up the container with 1</span>
<span class="comment">    }</span>
<span class="comment">    // then fill up the diags with 1</span>
<span class="comment">    for (size_t i = 0; i &lt; d; i++) {</span>
<span class="comment">      int pos = i*d + i;</span>
<span class="comment">      ExactCovar[pos] = 1.0;</span>
<span class="comment">    }</span>
<span class="comment">    </span>
<span class="comment">      //make a gsl matrix for the mean difference</span>
<span class="comment">      gsl_matrix * diffMeanMat = gsl_matrix_alloc(d, 1);</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j = 0; j &lt; 1; j++) {</span>
<span class="comment">          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));</span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">  </span>
<span class="comment">      // initialize matrix objects</span>
<span class="comment">      gsl_matrix * EstCovarMat = gsl_matrix_alloc(d, d);</span>
<span class="comment">      gsl_matrix * ExactCovarMat = gsl_matrix_alloc(d, d);</span>
<span class="comment">      gsl_matrix * PMat = gsl_matrix_alloc(d, d); //make this same as CovarMat first</span>
<span class="comment">    </span>
<span class="comment">      int k = 0; //counter for RealVec</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          gsl_matrix_set(EstCovarMat, i, j, _double(EstCovar[k])); //cast to double</span>
<span class="comment">          gsl_matrix_set(PMat, i, j, _double(EstCovar[k])); //cast to double</span>
<span class="comment">          gsl_matrix_set(ExactCovarMat, i, j, _double(ExactCovar[k])); //cast to double</span>
<span class="comment">          k++;</span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      //add the two matrices</span>
<span class="comment">      gsl_matrix_add(PMat, ExactCovarMat);</span>
<span class="comment">      gsl_matrix_scale(PMat, 0.5);</span>
<span class="comment">      //cout &lt;&lt; &quot;add the two matrices: &quot; &lt;&lt; endl;</span>
<span class="comment">    </span>
<span class="comment">      // get the determinants </span>
<span class="comment">      int s;</span>
<span class="comment">      gsl_permutation * p = gsl_permutation_alloc(d);</span>
<span class="comment">      gsl_linalg_LU_decomp(EstCovarMat, p, &amp;s);</span>
<span class="comment">      double detCovarMat = gsl_linalg_LU_det(EstCovarMat, s);</span>
<span class="comment">      gsl_permutation_free(p);</span>
<span class="comment">    </span>
<span class="comment">      int s1;</span>
<span class="comment">      gsl_permutation * p1 = gsl_permutation_alloc(d);</span>
<span class="comment">      gsl_linalg_LU_decomp(ExactCovarMat, p1, &amp;s1);</span>
<span class="comment">      double detExactCovarMat = gsl_linalg_LU_det(ExactCovarMat, s1);</span>
<span class="comment">      gsl_permutation_free(p1);</span>
<span class="comment">    </span>
<span class="comment">      int s2;</span>
<span class="comment">      gsl_permutation * p2 = gsl_permutation_alloc(d);</span>
<span class="comment">      gsl_linalg_LU_decomp(PMat, p2, &amp;s2);</span>
<span class="comment">      double detPMat = gsl_linalg_LU_det(PMat, s2);</span>
<span class="comment">      </span>
<span class="comment">      //cout &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detExactCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
<span class="comment">    </span>
<span class="comment">      //now get the inverse of P</span>
<span class="comment">      gsl_matrix * Pinverse = gsl_matrix_alloc(d, d); </span>
<span class="comment">      gsl_linalg_LU_invert(PMat, p2, Pinverse);</span>
<span class="comment">      gsl_permutation_free(p2);</span>
<span class="comment">    /*</span>
<span class="comment">      cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    */</span>
    <span class="comment">/*</span>
<span class="comment">      //now get the Bhattacharya coefficient</span>
<span class="comment">      //DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
<span class="comment">      gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, d);</span>
<span class="comment">      gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);</span>
<span class="comment">    </span>
<span class="comment">      // now convert all to rmatrix for easier computations</span>
<span class="comment">      rmatrix diffMeanR(0, d-1, 0, 0);</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; 1; j++) {</span>
<span class="comment">          diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); </span>
<span class="comment">          //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMat, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      rmatrix diffMeanTransR(0, 0, 0, d-1);</span>
<span class="comment">      for (int i = 0; i &lt; 1; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); </span>
<span class="comment">          //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMatTranspose, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      rmatrix PinvR(0, d-1, 0, d-1);</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      //free the gsl_matrices</span>
<span class="comment">      gsl_matrix_free(EstCovarMat);</span>
<span class="comment">      gsl_matrix_free(ExactCovarMat);</span>
<span class="comment">      gsl_matrix_free(PMat);</span>
<span class="comment">    </span>
<span class="comment">      //now get the Bhattacharya coefficient</span>
<span class="comment">      //DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
<span class="comment">      rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;</span>
<span class="comment">      //cout &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
<span class="comment">      real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/sqrt(detCovarMat*detExactCovarMat));</span>
<span class="comment">      //cout &lt;&lt; &quot;DB: &quot; &lt;&lt; DB &lt;&lt; endl;</span>
<span class="comment">      if (DB &lt; 0) { HDTrue = 0.0; }</span>
<span class="comment">      else {</span>
<span class="comment">        real BC = exp(-DB);</span>
<span class="comment">        assert(BC &gt;= 0);</span>
<span class="comment">        //cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
<span class="comment">        HDTrue = sqrt(1-BC);</span>
<span class="comment">        //cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HDTrue &lt;&lt; endl;</span>
<span class="comment">        assert(HDTrue &gt;=0);</span>
<span class="comment">      }</span>
<span class="comment">    }</span>
<span class="comment">    cout &lt;&lt; &quot;Hellinger distance: &quot; &lt;&lt; HDTrue &lt;&lt; endl;</span>
<span class="comment">  }</span>
<span class="comment">  */</span>

  <span class="comment">// compare against actual data</span>
  {
    <span class="comment">//get the mean</span>
    rvector ExactMean = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a95d9506c9ceea0359b99b0e36f1eff91" title="Gets the mean from the root box of the paving this manages.">getRootPavingMean</a>();
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> ExactCovar = actualHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a2bbfcf884ee91c2457eb2e9d2b81e31f" title="Gets variance covariance vector from root box of rootpaving.">getRootPavingVarCovar</a>();

    <span class="comment">//get the differences of the mean vectors</span>
    rvector diffMean = ExactMean - EstMean;
    cout &lt;&lt; <span class="stringliteral">&quot;Exact mean: &quot;</span> &lt;&lt; ExactMean &lt;&lt; endl;

    <span class="keywordflow">if</span> (d == 1) {
      interval covarI = interval(EstCovar[0]);
      interval actualCovarI = interval(ExactCovar[0]);
      interval sumVar = covarI + actualCovarI;
      <span class="comment">//cout &lt;&lt; sumVar &lt;&lt; &quot;\t&quot;;</span>
      interval insqrt = 2*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(covarI)*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(actualCovarI)/sumVar;
      <span class="comment">//cout &lt;&lt; insqrt &lt;&lt; &quot;\t&quot;;</span>
      interval H2 = interval(1,1) - <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(insqrt) *<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>((-0.25*diffMean[1]*diffMean[1])/sumVar);
      <span class="comment">//cout &lt;&lt; &quot;H2: &quot; &lt;&lt; H2 &lt;&lt; endl;</span>
      HDEstActual = mid(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(H2));
    }

    <span class="keywordflow">else</span> {
      <span class="comment">//make a gsl matrix for the mean difference</span>
      gsl_matrix * diffMeanMat = gsl_matrix_alloc(d, 1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 1; j++) {
          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));
        }
      }
  
      <span class="comment">// initialize matrix objects</span>
      gsl_matrix * EstCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * ExactCovarMat = gsl_matrix_alloc(d, d);
      gsl_matrix * PMat = gsl_matrix_alloc(d, d); <span class="comment">//make this same as CovarMat first</span>
    
      <span class="keywordtype">int</span> k = 0; <span class="comment">//counter for RealVec</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          gsl_matrix_set(EstCovarMat, i, j, _double(EstCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(PMat, i, j, _double(EstCovar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(ExactCovarMat, i, j, _double(ExactCovar[k])); <span class="comment">//cast to double</span>
          k++;
        }
      }
    
      <span class="comment">//add the two matrices</span>
      gsl_matrix_add(PMat, ExactCovarMat);
      gsl_matrix_scale(PMat, 0.5);
      <span class="comment">//cout &lt;&lt; &quot;add the two matrices: &quot; &lt;&lt; endl;</span>
    
      <span class="comment">// get the determinants </span>
      <span class="keywordtype">int</span> s;
      gsl_permutation * p = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(EstCovarMat, p, &amp;s);
      <span class="keywordtype">double</span> detCovarMat = gsl_linalg_LU_det(EstCovarMat, s);
      gsl_permutation_free(p);
    
      <span class="keywordtype">int</span> s1;
      gsl_permutation * p1 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(ExactCovarMat, p1, &amp;s1);
      <span class="keywordtype">double</span> detExactCovarMat = gsl_linalg_LU_det(ExactCovarMat, s1);
      gsl_permutation_free(p1);
    
      <span class="keywordtype">int</span> s2;
      gsl_permutation * p2 = gsl_permutation_alloc(d);
      gsl_linalg_LU_decomp(PMat, p2, &amp;s2);
      <span class="keywordtype">double</span> detPMat = gsl_linalg_LU_det(PMat, s2);
      
      <span class="comment">//cout &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detExactCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
    
      <span class="comment">//now get the inverse of P</span>
      gsl_matrix * Pinverse = gsl_matrix_alloc(d, d); 
      gsl_linalg_LU_invert(PMat, p2, Pinverse);
      gsl_permutation_free(p2);
    
    <span class="comment">/*</span>
<span class="comment">      cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    */</span>
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, d);
      gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);
    
      <span class="comment">// now convert all to rmatrix for easier computations</span>
      rmatrix diffMeanR(0, d-1, 0, 0);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 1; j++) {
          diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMat, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix diffMeanTransR(0, 0, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); 
          <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMatTranspose, i, j) &lt;&lt; endl; </span>
        }
      }
    
      rmatrix PinvR(0, d-1, 0, d-1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; d; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; d; j++) {
          PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); 
        }
      }
    
      <span class="comment">//free the gsl_matrices</span>
      gsl_matrix_free(EstCovarMat);
      gsl_matrix_free(ExactCovarMat);
      gsl_matrix_free(PMat);
    
      <span class="comment">//now get the Bhattacharya coefficient</span>
      <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
      rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;
      <span class="comment">//cout &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
      real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(detCovarMat*detExactCovarMat));
      <span class="comment">//cout &lt;&lt; &quot;DB: &quot; &lt;&lt; DB &lt;&lt; endl;</span>
      real BC = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-DB);
      assert(BC &gt;= 0);
      <span class="comment">//cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
      HDEstActual = <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1-BC);
      <span class="comment">//cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HDActual &lt;&lt; endl;</span>
      assert(HDEstActual &gt;=0);
    }
    cout &lt;&lt; <span class="stringliteral">&quot;Hellinger distance: &quot;</span> &lt;&lt; HDEstActual &lt;&lt; endl;
  }

  <span class="comment">/*</span>
<span class="comment">  // actual vs true</span>
<span class="comment">  {</span>
<span class="comment">    //get the mean</span>
<span class="comment">    rvector ActualMean = actualHist-&gt;getRootPavingMean();</span>
<span class="comment">    RealVec ActualCovar = actualHist-&gt;getRootPavingVarCovar();</span>
<span class="comment"></span>
<span class="comment">    //get the mean</span>
<span class="comment">    rvector TrueMean(d);</span>
<span class="comment">    for (int i = 1; i &lt;= d; i++) { TrueMean[i] = 0.0; }</span>
<span class="comment"></span>
<span class="comment">    //get the differences of the mean vectors</span>
<span class="comment">    rvector diffMean = ActualMean - TrueMean;</span>
<span class="comment"></span>
<span class="comment">    if (d == 1) {</span>
<span class="comment">      interval actualCovarI = interval(ActualCovar[0]);</span>
<span class="comment">      interval trueCovarI = interval(1.0);</span>
<span class="comment">      interval sumVar = trueCovarI + actualCovarI;</span>
<span class="comment">      interval insqrt = 2*sqrt(trueCovarI)*sqrt(actualCovarI)/sumVar;</span>
<span class="comment">      interval H2 = interval(1,1) - sqrt(insqrt) *exp((-0.25*diffMean[1]*diffMean[1])/sumVar);</span>
<span class="comment">      HDTrueActual = mid(sqrt(H2));</span>
<span class="comment">    }</span>
<span class="comment"></span>
<span class="comment">    else {</span>
<span class="comment">    // get the variance-covariances</span>
<span class="comment">    RealVec TrueCovar;</span>
<span class="comment">    TrueCovar.reserve(d*d);</span>
<span class="comment"></span>
<span class="comment">    // fill in the matrix where the off-diag are 0</span>
<span class="comment">    for (size_t i = 0; i &lt; d*d; i++) {</span>
<span class="comment">        TrueCovar.push_back(0.0); //first fill up the container with 1</span>
<span class="comment">    }</span>
<span class="comment">    // then fill up the diags with 1</span>
<span class="comment">    for (size_t i = 0; i &lt; d; i++) {</span>
<span class="comment">      int pos = i*d + i;</span>
<span class="comment">      TrueCovar[pos] = 1.0;</span>
<span class="comment">    }</span>
<span class="comment">    </span>
<span class="comment">      //make a gsl matrix for the mean difference</span>
<span class="comment">      gsl_matrix * diffMeanMat = gsl_matrix_alloc(d, 1);</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j = 0; j &lt; 1; j++) {</span>
<span class="comment">          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));</span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">  </span>
<span class="comment">      // initialize matrix objects</span>
<span class="comment">      gsl_matrix * TrueCovarMat = gsl_matrix_alloc(d, d);</span>
<span class="comment">      gsl_matrix * ActualCovarMat = gsl_matrix_alloc(d, d);</span>
<span class="comment">      gsl_matrix * PMat = gsl_matrix_alloc(d, d); //make this same as CovarMat first</span>
<span class="comment">    </span>
<span class="comment">      int k = 0; //counter for RealVec</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          gsl_matrix_set(ActualCovarMat, i, j, _double(ActualCovar[k])); //cast to double</span>
<span class="comment">          gsl_matrix_set(PMat, i, j, _double(ActualCovar[k])); //cast to double</span>
<span class="comment">          gsl_matrix_set(TrueCovarMat, i, j, _double(TrueCovar[k])); //cast to double</span>
<span class="comment">          k++;</span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      //add the two matrices</span>
<span class="comment">      gsl_matrix_add(PMat, TrueCovarMat);</span>
<span class="comment">      gsl_matrix_scale(PMat, 0.5);</span>
<span class="comment">      //cout &lt;&lt; &quot;add the two matrices: &quot; &lt;&lt; endl;</span>
<span class="comment">    </span>
<span class="comment">      // get the determinants </span>
<span class="comment">      int s;</span>
<span class="comment">      gsl_permutation * p = gsl_permutation_alloc(d);</span>
<span class="comment">      gsl_linalg_LU_decomp(ActualCovarMat, p, &amp;s);</span>
<span class="comment">      double detCovarMat = gsl_linalg_LU_det(ActualCovarMat, s);</span>
<span class="comment">      gsl_permutation_free(p);</span>
<span class="comment">    </span>
<span class="comment">      int s1;</span>
<span class="comment">      gsl_permutation * p1 = gsl_permutation_alloc(d);</span>
<span class="comment">      gsl_linalg_LU_decomp(TrueCovarMat, p1, &amp;s1);</span>
<span class="comment">      double detExactCovarMat = gsl_linalg_LU_det(TrueCovarMat, s1);</span>
<span class="comment">      gsl_permutation_free(p1);</span>
<span class="comment">    </span>
<span class="comment">      int s2;</span>
<span class="comment">      gsl_permutation * p2 = gsl_permutation_alloc(d);</span>
<span class="comment">      gsl_linalg_LU_decomp(PMat, p2, &amp;s2);</span>
<span class="comment">      double detPMat = gsl_linalg_LU_det(PMat, s2);</span>
<span class="comment">      </span>
<span class="comment">      //cout &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detExactCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
<span class="comment">    </span>
<span class="comment">      //now get the inverse of P</span>
<span class="comment">      gsl_matrix * Pinverse = gsl_matrix_alloc(d, d); </span>
<span class="comment">      gsl_linalg_LU_invert(PMat, p2, Pinverse);</span>
<span class="comment">      gsl_permutation_free(p2);</span>
<span class="comment">    /*</span>
<span class="comment">      cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    */</span><span class="comment">/*</span>
<span class="comment">      //now get the Bhattacharya coefficient</span>
<span class="comment">      //DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
<span class="comment">      gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, d);</span>
<span class="comment">      gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);</span>
<span class="comment">    </span>
<span class="comment">      // now convert all to rmatrix for easier computations</span>
<span class="comment">      rmatrix diffMeanR(0, d-1, 0, 0);</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; 1; j++) {</span>
<span class="comment">          diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); </span>
<span class="comment">          //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMat, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      rmatrix diffMeanTransR(0, 0, 0, d-1);</span>
<span class="comment">      for (int i = 0; i &lt; 1; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); </span>
<span class="comment">          //cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(diffMeanMatTranspose, i, j) &lt;&lt; endl; </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      rmatrix PinvR(0, d-1, 0, d-1);</span>
<span class="comment">      for (int i = 0; i &lt; d; i++) {</span>
<span class="comment">        for (int j=0; j &lt; d; j++) {</span>
<span class="comment">          PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); </span>
<span class="comment">        }</span>
<span class="comment">      }</span>
<span class="comment">    </span>
<span class="comment">      //free the gsl_matrices</span>
<span class="comment">      gsl_matrix_free(TrueCovarMat);</span>
<span class="comment">      gsl_matrix_free(ActualCovarMat);</span>
<span class="comment">      gsl_matrix_free(PMat);</span>
<span class="comment">    </span>
<span class="comment">      //now get the Bhattacharya coefficient</span>
<span class="comment">      //DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
<span class="comment">      rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;</span>
<span class="comment">      //cout &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
<span class="comment">      real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/sqrt(detCovarMat*detExactCovarMat));</span>
<span class="comment">      cout &lt;&lt; &quot;DB: &quot; &lt;&lt; DB &lt;&lt; endl;</span>
<span class="comment">      if (DB &lt; 0) { HDTrueActual = 0.0; }</span>
<span class="comment">      else {</span>
<span class="comment">        real BC = exp(-DB);</span>
<span class="comment">        assert(BC &gt;= 0);</span>
<span class="comment">        //cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
<span class="comment">        HDTrueActual = sqrt(1-BC);</span>
<span class="comment">        //cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HDTrue &lt;&lt; endl;</span>
<span class="comment">        assert(HDTrueActual &gt;=0);</span>
<span class="comment">      }</span>
<span class="comment">    }</span>
<span class="comment">    cout &lt;&lt; &quot;Hellinger distance: &quot; &lt;&lt; HDTrueActual &lt;&lt; endl;</span>
<span class="comment">  }*/</span>

  

  <span class="comment">//output Hellinger distances</span>
  <span class="keywordtype">string</span> filename;
  filename = <span class="stringliteral">&quot;HellingerDistance&quot;</span>;
  ostringstream stm;
  stm &lt;&lt; dataSeed;
  filename += stm.str();
  filename += <span class="stringliteral">&quot;.txt&quot;</span>;
  oss.open(filename.c_str());
  oss &lt;&lt; HDEstActual &lt;&lt; endl;
  <span class="comment">//oss &lt;&lt; HDTrue &lt;&lt; &quot;\t&quot; &lt;&lt; HDActual &lt;&lt; &quot;\t&quot; &lt;&lt; HDTrueActual &lt;&lt; endl;</span>
  oss &lt;&lt; flush;
  oss.close();
  

  <span class="comment">/*</span>
<span class="comment">  //optional </span>
<span class="comment">  string dataFileName = &quot;ActualData&quot;;</span>
<span class="comment">  dataFileName += stm.str(); </span>
<span class="comment">  dataFileName += &quot;.txt&quot;; </span>
<span class="comment">  oss.open(dataFileName.c_str());</span>
<span class="comment">  for (size_t i = 0; i &lt; n; i++) { </span>
<span class="comment">    for (size_t j = 1; j &lt;= d; j++) {</span>
<span class="comment">        oss &lt;&lt; (*actualDataPtr)[i][j] &lt;&lt; &quot;\t&quot;;</span>
<span class="comment">    }</span>
<span class="comment">    oss &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">    //cout &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">  }</span>
<span class="comment">  oss &lt;&lt; flush;</span>
<span class="comment">  oss.close();</span>
<span class="comment"></span>
<span class="comment">  cout &lt;&lt; &quot;Actual data written to  &quot; &lt;&lt; dataFileName &lt;&lt; endl;</span>
<span class="comment">  </span>
<span class="comment">  //optional </span>
<span class="comment">  dataFileName = &quot;MappedData&quot;;</span>
<span class="comment">  dataFileName += stm.str(); </span>
<span class="comment">  dataFileName += &quot;.txt&quot;; </span>
<span class="comment">  oss.open(dataFileName.c_str());</span>
<span class="comment">  for (size_t i = 0; i &lt; n; i++) { </span>
<span class="comment">    for (size_t j = 1; j &lt;= d; j++) {</span>
<span class="comment">        oss &lt;&lt; (*theDataPtr)[i][j] &lt;&lt; &quot;\t&quot;;</span>
<span class="comment">    }</span>
<span class="comment">    oss &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">    //cout &lt;&lt; &quot;\n&quot;;</span>
<span class="comment">  }</span>
<span class="comment">  oss &lt;&lt; flush;</span>
<span class="comment">  oss.close();</span>
<span class="comment">  </span>
<span class="comment">  cout &lt;&lt; &quot;Estimated data written to  &quot; &lt;&lt; dataFileName &lt;&lt; endl;</span>
<span class="comment">  */</span>

  <span class="keyword">delete</span> estimateHist;
  <span class="keyword">delete</span> actualHist;
  <span class="keyword">delete</span> actualDataPtr;
  <span class="keyword">delete</span> theDataPtr;

  <span class="keywordflow">return</span> 0;
} <span class="comment">// end of MCMC test program</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a0c0402be9ebd7abad750822814d38f99"></a><!-- doxytag: member="HellingerFunctionSimRosen.cpp::ProduceMRSamples" ref="a0c0402be9ebd7abad750822814d38f99" args="(Fobj &amp;f, int n_boxes, int n_samples, double Alb, unsigned seed, bool use_f_scale, RSSample &amp;rs_sample)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="SEBPQFunctionSimRosen_8cpp.shtml#a0c0402be9ebd7abad750822814d38f99">ProduceMRSamples</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFobj.shtml">Fobj</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_f_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml#l00062">62</a> of file <a class="el" href="HellingerFunctionSimRosen_8cpp_source.shtml">HellingerFunctionSimRosen.cpp</a>.</p>

<p>References <a class="el" href="SmallClasses_8hpp_source.shtml#l00238">RSSample::EnvelopeIntegral</a>, <a class="el" href="classFobj.shtml#a541c0edbb08855d1e3cdbb45b0aa26af">Fobj::get_interval_calls()</a>, <a class="el" href="classFobj.shtml#a63df2521571faeb43663613a9a4611e7">Fobj::get_real_calls()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00245">RSSample::IntegralEstimate()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00260">RSSample::Mean()</a>, <a class="el" href="MRSampler_8cpp_source.shtml#l00354">MRSampler::RejectionSampleMany()</a>, and <a class="el" href="SmallClasses_8hpp_source.shtml#l00241">RSSample::Samples</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//ofstream out (&quot;MRS_Rosenbrock.samples&quot;);//file to store the i.i.d samples</span>
  clock_t T1 = clock (), T2, T3;
  <span class="comment">// Construct theSampler with the chosen target shape object FTG</span>
  <a class="code" href="classMRSampler.shtml" title="The Moore rejection sampler class for trans-dimensional targets over labeled metric spaces...">MRSampler</a> theSampler (f, n_boxes, Alb, seed, (use_f_scale == 1));
  
        <span class="comment">//--comment this printing block if not needed</span>
        <span class="comment">// To print out the partition of the domain</span>
        <span class="comment">//cout &lt;&lt; &quot;Domain Partition: \n&quot; ;</span>
        <span class="comment">//ofstream Partout (&quot;MRS_RosenbrockDomain.txt&quot;); //Filename</span>
        <span class="comment">//theSampler.Print_Domain_Partition(Partout);</span>
        <span class="comment">//cout &lt;&lt; &quot;The output has been written to MRS_IsIt1or2CoinsDomain.txt&quot; </span>
        <span class="comment">//     &lt;&lt; endl &lt;&lt; endl;</span>
 
        <span class="comment">// To realize a file output of the RangeDomainSet</span>
   <span class="comment">//     ofstream os(&quot;MRS_RosenbrockRangeDomainSet.txt&quot;);         // Filename</span>
   <span class="comment">//     os &lt;&lt; theSampler &lt;&lt; endl;                   </span>
   <span class="comment">//     cout &lt;&lt; &quot;output has been written to MRS_IsIt1or2CoinsRangeDomainSet.txt&quot; </span>
   <span class="comment">//          &lt;&lt; endl &lt;&lt; endl;</span>
        <span class="comment">//--end of printing block</span>
<span class="comment"></span>  <span class="comment">// To print out the partition of the domain</span>
  
  T2 = clock ();
  <span class="keywordtype">double</span> Ptime = (double) (T2 - T1) / CLOCKS_PER_SEC;
  
  <span class="comment">//RSSample rs_sample;</span>
  cout &lt;&lt; <span class="stringliteral">&quot;before Rej..SampleMany \n&quot;</span>;
  cout &lt;&lt; <span class="stringliteral">&quot;n_samples: &quot;</span> &lt;&lt; n_samples &lt;&lt; endl;
  theSampler.RejectionSampleMany (n_samples, rs_sample);
  cout &lt;&lt; <span class="stringliteral">&quot;after Rej..SampleMany \n&quot;</span>;
  <span class="keywordtype">double</span> IntegralEstimate = _double (rs_sample.<a class="code" href="classRSSample.shtml#a9537562ed9b4bc945e4c92b2237732a8" title="A real estimate of the integral of the function over the domain.">IntegralEstimate</a> ());
  cout &lt;&lt; <span class="stringliteral">&quot;rs_sample IU, N, Nrs: &quot;</span> &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#aa3f52ce941256fc7d6cf71347fdfa67c" title="The envelope integral as a cxsc::real.">EnvelopeIntegral</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> 
       &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.size() &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;RSSampleMany, integral est: &quot;</span> &lt;&lt; IntegralEstimate &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;RSSampleMany mean: \n&quot;</span>; rs_sample.<a class="code" href="classRSSample.shtml#a6e553a95e36dbecd6f0491bf71c6a761" title="Arithmetic mean of the sampled labeled points in a label-specific way.">Mean</a> ();
  <span class="comment">//rs_sample.Print(out);</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;n interval function calls: &quot;</span> &lt;&lt; f.<a class="code" href="classFobj.shtml#a541c0edbb08855d1e3cdbb45b0aa26af" title="Get number of interval function calls.">get_interval_calls</a> () &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;n real function calls: &quot;</span> &lt;&lt; f.<a class="code" href="classFobj.shtml#a63df2521571faeb43663613a9a4611e7" title="Get number of real function calls.">get_real_calls</a> () &lt;&lt; endl;
  
  <span class="comment">//----------------------------------------------------------------------------</span>
  T3 = clock ();
  <span class="keywordtype">double</span> Stime = (double) (T3 - T2) / CLOCKS_PER_SEC;
  cout &lt;&lt; <span class="stringliteral">&quot;# CPU Time (seconds). Partitioning: &quot;</span> &lt;&lt; Ptime &lt;&lt; <span class="stringliteral">&quot;  Sampling: &quot;</span> 
       &lt;&lt; Stime &lt;&lt; <span class="stringliteral">&quot;  Total: &quot;</span> &lt;&lt; (Ptime + Stime) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;# CPU time (secods) per estimate: &quot;</span> 
       &lt;&lt; (Ptime + Stime) / (<span class="keywordtype">double</span>) (n_samples) &lt;&lt; endl;
}
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="HellingerFunctionSimRosen_8cpp.shtml">HellingerFunctionSimRosen.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:20 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
