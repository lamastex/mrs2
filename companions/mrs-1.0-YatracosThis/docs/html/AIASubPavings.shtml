<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: Implementation of Applied Interval Analysis procedures under C-XSC</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('AIASubPavings.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Implementation of Applied Interval Analysis procedures under C-XSC </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="AIASubPavings.shtml#AIAsec_setcomputation">Regular subpavings and set computation</a></li>
<li><a class="el" href="AIASubPavings.shtml#AIAsec_SIVIA">Set inversion using interval analysis</a></li>
<li><a class="el" href="AIASubPavings.shtml#AIAsec_imageSp">Image evaluation</a></li>
<li><a class="el" href="AIASubPavings.shtml#AIAsec_examples">Examples from Applied Interval Analysis using AIASPnodes</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="AIAsec_setcomputation"></a>
Regular subpavings and set computation</h2>
<p>[AIA2001] show how subpavings can approximate compact sets in a guaranteed way and how computation on subpavings allows approximate computation on these compact sets. For any full compact set X we can find a subpaving 'lower bound' of X (which can be thought of an an 'inner paving' of X) and a subpaving 'upper bound' of X (or <a class="anchor" id="outerpaving"></a>'outer paving' of X) as 'close' to X as we desire (distance and ordering of sets and hence what is meant by 'close' has to be defined of course). X is enclosed by the inner and outer paving. [AIA2001, pp. 48-49]</p>
<p>To get 'close' to the set we want to enclose, we can take a large box (the root node of the binary tree representing the subpaving) which we know encloses the set and then progressively subdivide the box and the subboxes, etc, checking to see if we can discard any subbox (prune that branch) to get a subpaving/tree representation of the subpaving which meets our criteria for 'closeness' to our target compact set.</p>
<hr/>
<h2><a class="anchor" id="AIAsec_SIVIA"></a>
Set inversion using interval analysis</h2>
<p>Set inversion is the computation of a reciprocal image X = <b>f</b><sup>-1</sup>(Y) where Y is regular subpaving of R<sup>m</sup>. [AIA2001] develop an algorithm SIVIA (Set Inverter Via Interval Analysis) for finding an outer subpaving of X to a specified level of precision. Starting with a large search box [<b>x</b>](0) to which the outer subpaving of X is guaranteed to belong and given a inclusion function [<b>f</b>]([<b>x</b>]) for <b>f</b>, we form a subpaving by progressively bisecting and then testing the resulting subboxes to see if they should be included in our solution subpaving.</p>
<p>The test for any box [<b>x</b>] is a comparison of [<b>f</b>]([<b>x</b>]) to Y. This test has three possible outcomes</p>
<ol>
<li>
If [<b>f</b>]([<b>x</b>]) has an empty intersection with Y then [<b>x</b>] does not belong to X and can be cut off from the solution tree </li>
<li>
If [<b>f</b>]([<b>x</b>]) is entirely in Y then [<b>x</b>] belongs to the solution and is kept as part of the solution tree </li>
<li>
If [<b>f</b>]([<b>x</b>]) has a non-empty intersection with Y but is not entirely in Y then [<b>x</b>] is undetermined. If [<b>x</b>] has width greater than the specified precision parameter it is bisected and each subbox (child in the tree structure) is then tested. If [<b>x</b>] has width less than or equal to the specified precision parameter it included in the solution, ie the suppaving outer bound of the set X [AIA2001, pp. 55-56]. </li>
</ol>
<p>Thus the solution, the outer subpaving of the set X, includes the 'uncertainty' layer of boxes that cross the boundaries of the set but whose width is small enough to satisfy our precision criteria. We can make the uncertainty layer thinner by having a smaller precision and subdividing and testing the boxes in that layer further [AIA2001, p. 56].</p>
<p>An implementation of SIVIA using C++ is described in [AIA2001, pp. 339-342]. This includes an extension of the usual booleans TRUE and FALSE to a set of <em>interval booleans</em> which includes notion of <em>indeterminate</em>.</p>
<p>SIVIA can also be used to evaluate an outer subpaving of the image of set by a function provided that the function is invertible in the usual sense. This involves specifying the inclusion function [<b>f</b><sup>-1</sup>] for <b>f</b><sup>-1</sup> the inverse of <b>f</b> and taking as an initial search box some box guaranteed to contain the image of the set.</p>
<hr/>
<h2><a class="anchor" id="AIAsec_imageSp"></a>
Image evaluation</h2>
<p>Computation of the direct image of a subpaving Y = <b>f</b>(X) where X is a regular subpaving of R<sup>n</sup> (image evaluation) is more complex in the case where the function is not invertible in the usual sense. AIA2001 develop an algorithm ImageSP for finding an outer subpaving of Y to a specified level of precision.</p>
<p>Given a subpaving X for which we seek an outer approximation of the image and an inclusion function [<b>f</b>]([<b>x</b>]) for <b>f</b>, ImageSP proceeds as follows:</p>
<ol>
<li>
Mince X (recursively bisect each box) until each box in X has width less than the specified level of precision. (X will no longer be a minimal subpaving.) </li>
<li>
For each [<b>x</b>] in the minced X, add [<b>f</b>]([<b>x</b>]) to a list of image boxes U and compute the interval hull of the union of all these image boxes. </li>
<li>
If [<b>f</b>]([<b>x</b>]) Merge these boxes into a single, minimal, subpaving the root of which corresponds to the hull and which only contains boxes with width lower than the specified level of precision. </li>
</ol>
<p>An implementation of ImageSP using C++ is described in [AIA2001, pp. 342-347].</p>
<p>We have reimplemented the algorithms for set inversion and image evaluation using the C-XSC interval library with as little change to the structure and code used in [Applied Interval Analysis, Springer, 2001] as possible, other than that necessitated by the use of C-XSC. Our class is called <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> (a pointer to an <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> is aliased as AIASubPaving)</p>
<hr/>
<h2><a class="anchor" id="AIAsec_examples"></a>
Examples from Applied Interval Analysis using AIASPnodes</h2>
<p>AIA2001 show how computation on subpavings allows approximate computation on compact sets. Their SUBPAVINGS class and various supporting procedures are used to implement their two main algorithms:</p>
<ul>
<li>
SIVIA (Set Inversion Via Interval Analysis). Set inversion is the computation of a reciprocal image X = <b>f</b><sup>-1</sup>(Y) where Y is regular subpaving of R<sup>m</sup> </li>
<li>
ImageSp (Image evaluation). Computation of the direct image of a subpaving Y = <b>f</b>(X) where X is a regular subpaving of R<sup>n</sup> </li>
</ul>
<p>The following examples show how we have replicated the SUBPAVING class and the implementations of SIVIA and ImageSp created by AIA2001 and available on their website <a href="http://www.lss.supelec.fr/books/intervals/">http://www.lss.supelec.fr/books/intervals/</a>)</p>
<ul>
<li><a class="el" href="AIASubPavings.shtml#AIAexamsec_11_33">Exercise 11.33</a></li>
<li><a class="el" href="AIASubPavings.shtml#AIAexamsec_11_35">Exercise 11.35</a></li>
<li><a class="el" href="AIASubPavings.shtml#AIAexamsec_3_3">Example 3.3</a></li>
<li><a class="el" href="AIASubPavings.shtml#AIAexamsec_3_4">Example 3.4</a></li>
</ul>
<p>Our implementation uses the C-XSC library but otherwise makes as little alteration to the structure and code used in Applied Interval Analysis as possible, other than that necessitated by the use of C-XSC. Our class is called <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> (a pointer to an <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> is aliased as AIASubPaving).</p>
<p>The <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class declarations and inline definitions are in the header file <a class="el" href="AIAsubpaving_8hpp.shtml" title="AIASPnode (AISSubPaving) declarations.">AIAsubpaving.hpp</a>. Other definitions are in the file <a class="el" href="AIAsubpaving_8cpp.shtml" title="AIASPnode (AISSubPaving) definitions.">AIAsubpaving.cpp</a></p>
<h3><a class="anchor" id="AIAexamsec_11_33"></a>
Exercise 11.33</h3>
<p>See AIA2001, p. 342.</p>
<p>Exercise 11.33 explores the use of SIVIA and the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class for set inversion. In particular, this example demonstrates that it is possible to use to evaluate the direct image of a set by a function, <em>provided that the function is invertible in the usual sense</em>.</p>
<p>Our implementation of this example is in the file <a class="el" href="Exr__11__33_8cpp.shtml" title="Exercise 11.33 from Jaulin et al, Springer, 2001, p. 342.">Exr_11_33.cpp</a>, which has header file <a class="el" href="Exr__11__33_8hpp.shtml">Exr_11_33.hpp</a></p>
<p><a class="el" href="Exr__11__33_8hpp.shtml">Exr_11_33.hpp</a> shows the includes for this example</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="AIAsubpaving_8hpp.shtml" title="AIASPnode (AISSubPaving) declarations.">AIAsubpaving.hpp</a>&quot;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
</pre></div></p>
<p>The file <a class="el" href="AIAsubpaving_8hpp.shtml" title="AIASPnode (AISSubPaving) declarations.">AIAsubpaving.hpp</a> is included in order to be able to use the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class it declares. &lt;time.h&gt; is included in order to use the clock method and get information on the time take to run the example. &lt;fstream&gt; is included in order to be able to output data to a file.</p>
<p>Turning now to Exm_11_33.cpp,</p>
<p>First we include the header file</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="Exr__11__33_8hpp.shtml">Exr_11_33.hpp</a>&quot;</span>
</pre></div></p>
<p>Then we declare some AIASubPavings as global (AIASubPaving is declared as an alias for a pointer to an <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> in the AIAsubpavings.hpp header file). Declaring them as global means that they are available to all the functions in the file (they have file scope) and so they do not need to be passed as parameters to the functions that use them.</p>
<p><div class="fragment"><pre class="fragment"><span class="comment">// These AIASubPavings are declared as global</span>
<a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> <a class="code" href="Exm__3__3_8cpp.shtml#a61a4b8518251e3f73c3e1951e3c733ec">Sc</a>, <a class="code" href="Exr__11__33_8cpp.shtml#a6f925a28990597524155ac8e7381d5fa">Sc1</a>, <a class="code" href="Exr__11__33_8cpp.shtml#a16765ea8c433ea86ad0e3ae0e36685c7">Sc2</a>;
</pre></div></p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Use of globals is normally discouraged in good programming,</dd></dl>
<p>Then we specify the interval boolean tests we are going to use in the example. The interval boolean test is the key to set inversion with interval analysis. Recall that set inversion is the computation of a reciprocal image X = <b>f</b><sup>-1</sup>(Y) where Y is regular subpaving of R<sup>m</sup> (see <a class="el" href="AIASubPavings.shtml#AIAsec_SIVIA">Set inversion using interval analysis</a>). Y is the subpaving we want to invert. The interval boolean test takes a box in 'x-space' and tests whether the image of the box in 'y-space' ie the image under the inclusion function [<b>f</b>], is in the subpaving Y. The interval boolean test can return one of the special interval boolean types BI_TRUE (the image of the box is inside Y), BI_FALSE (the image of the box is outside Y), or BI_INDET (indeterminate: the image of the box [<b>f</b>]([<b>x</b>] is partly in and partly out of the subpaving Y, ie overlaps the boundary of Y).</p>
<p>The first test <a class="anchor" id="IBTAnnular"></a>IBTAnnular tests a 2-d box in IR<sup>2</sup> for inclusion in the set corresponding to the area between circles centred at the origin and with radii 1 and 2. The test is performed on the interval image [<b>f</b>]([<b>x</b>]) of the box [<b>x</b>] supplied as the function argument. The test itself specifies the inclusion function f [<b>f</b>] (x[1]<sup>2</sup> + x[2]<sup>2</sup>). In this case the test also specifies the subpaving to invert - in this case this is a very simple subpaving being just a single interval [1 2]. The test can return BI_TRUE, BI_FALSE, or BI_INDET.</p>
<p><div class="fragment"><pre class="fragment"><span class="comment">// specifications of example interval boolean tests</span>
<span class="comment">// The boolean interval test can return BI_TRUE, BI_FALSE, or BI_INDET</span>

<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> <a class="code" href="Exm__3__3_8cpp.shtml#ad4bce9ed969316e3fb7c990094be55a7">IBTAnnular</a>(<span class="keyword">const</span> ivector&amp; x)
{
  <span class="comment">// here we test a 2-d box for inclusion in the area between circles centred </span>
  <span class="comment">// on the origin with radii 1 and 2</span>
  interval ToInvert(1.0,2.0),Temp;
  interval Img = <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[1]) + <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[2]);

  <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Temp,Img,ToInvert)) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
  <span class="keywordflow">if</span> ( Img&lt;=ToInvert ) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>;

  <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;
}
</pre></div></p>
<p>The second test <a class="anchor" id="IBTFdirect"></a>IBTFdirect is also an interval boolean test but on first sight looks rather different to IBTAnnular. Taking it apart, we can how it does the same thing. The test takes a ivector argument and calculates the interval image of this using an inclusion function. The inclusion function is again specified within the test. In this case it is in fact the inverse of an invertible function: this test will be used to run SIVIA 'backwards'. Note that the subpaving we are inverting is one of the <a class="anchor" id="AIAglobal"></a>global AIASubPaving variables, Sc. Because the subpaving is not a simple interval as in the previous test, the test uses the <a class="el" href="classAIASPnode.shtml#a0869804e6aaefcc26aebe081061df6ad" title="Check for containment of interval vector or box in the AIASubPaving.">AIASPnode::operator&lt;=(const ivector&amp;, AIASubPaving)</a>, which returns an AIA_BOOL_INTERVAL type just like the test above.</p>
<p><div class="fragment"><pre class="fragment"><a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> <a class="code" href="Exr__11__33_8cpp.shtml#a20b13850dd9692440454d010da913e98">IBTFdirect</a>(<span class="keyword">const</span> ivector&amp; x)
{
  <span class="comment">// A boolean interval test to illustrate SIVIA being used to evaluate the </span>
  <span class="comment">// direct image of a set by a function provided the function is invertible</span>
  <span class="comment">// ie SIVIA will invert inverse_f</span>

  interval Temp;
  ivector Img(2);

  <span class="comment">// taking the function f : (x1,x2) -&gt; (2x1-x2,-x1+2x2)</span>
  <span class="comment">// f is invertible and the inverse is </span>
  <span class="comment">// inverse_f : (x1,x2) -&gt; (2x1 + x2,x1+2x2)/3</span>
  <span class="comment">// this is an inclusion function for inverse_f</span>

  Img[1] = (2.0*x[1]+x[2]) / 3.0;
  Img[2] = (x[1]+2.0*x[2]) / 3.0;

  <span class="keywordflow">return</span> (Img&lt;=Sc); <span class="comment">// Sc is an AIASubPaving set up by the first example</span>
}
</pre></div></p>
<p>The third test <a class="anchor" id="IBTFinverse"></a>IBTFinverse is similar again. The function f is the same function as that for which we used the inverse in the test <a class="el" href="AIASubPavings.shtml#IBTFdirect">IBTFdirect</a> above. The subpaving we test for inclusion in is another of the globals, Sc1, and again we use the <a class="el" href="classAIASPnode.shtml#a0869804e6aaefcc26aebe081061df6ad" title="Check for containment of interval vector or box in the AIASubPaving.">AIASPnode::operator&lt;=(const ivector&amp;, AIASubPaving)</a> to returns an AIA_BOOL_INTERVAL.</p>
<p><div class="fragment"><pre class="fragment"><a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> <a class="code" href="Exr__11__33_8cpp.shtml#ad999a60ef78af33c65610c301d3c57dc">IBTFinverse</a>(<span class="keyword">const</span> ivector&amp; x)
{
  interval Temp;
  ivector Img(2);

  <span class="comment">// the function f is f : (x1,x2) -&gt; (2x1-x2,-x1+2x2)</span>

  Img[1] = 2.0*x[1]-x[2];
  Img[2] = -x[1]+2.0*x[2];

  <span class="keywordflow">return</span> (Img&lt;=Sc1);
}

<span class="comment">// end specification of example boolean interval tests</span>
</pre></div></p>
<p>Now we say that we are using the std and cxsc namespaces to avoid having to type cxsc::ivector or std::cout etc.</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>cxsc;
<span class="keyword">using namespace </span>std;
</pre></div></p>
<p>In the main process we start by declare some of the variables we will be using</p>
<p><div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> <a class="code" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
{
  <span class="keywordtype">double</span> prec;
  clock_t start, end;

  ivector x(2);
  x[1] = interval(-5.0,5.0);
  x[2] = interval(-5.0,5.0);

  <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> A;
  A = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(x);
</pre></div></p>
<p>A 2-dimensional interval vector x is set up which is the 2-d box [-5 5]<sup>2</sup>. This is used to initialise a newed <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> in dynamic memory, with A as an AIASubPaving or pointer to an <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>. Creating the node object in dynamic memory allows us to use pointers to it outside the scope of the function which created the object</p>
<p>Now we use the SIVIA algorithm (see <a class="el" href="AIASubPavings.shtml#AIAsec_SIVIA">Set inversion using interval analysis</a>) to find a 'subpaving characterisation' Sc containing the area between circles centred on the origin with radii 1 and 2 in 2 dimensional space. We say 'subpaving characterisation' because the subpaving is an <a class="el" href="AIASubPavings.shtml#outerpaving">outer subpaving</a> of the actual area between circles centred on the origin with radii 1 and 2.</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// Using SIVIA for set inversion</span>
  <span class="comment">//find an AIASubPaving characterisation Sc containing the area between </span>
  <span class="comment">// circles centred on the origin</span>
  <span class="comment">// with radii 1 and 2 (in 2 dimensional space)</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc={(x1,x2) | 1 &lt;= x1^2+x2^2 &lt;= 2 }&quot;</span> 
       &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.001): &quot;</span>;
</pre></div></p>
<p>A description of what we are doing is sent to standard output, The program asks the user to input a precision between 1 and 0.001.</p>
<p>The clock is started and <a class="el" href="AIAsubpaving_8cpp.shtml#a9bc7ba1f54979fabaf0f0ffeab245234">Sivia(AIA_PIBT BoolTest, AIASubPaving A, double eps)</a> is called. The AIA_PIBT (pointer to an interval boolean test) is <a class="el" href="AIASubPavings.shtml#IBTAnnular">IBTAnnular</a>, as described above. A is provided as an initial search box, and prec is given as the argument for the eps parameter. The clock is stopped when Sivia has returned a value for Sc.</p>
<p><div class="fragment"><pre class="fragment">  start = clock();

  <span class="comment">// when we start we give A a box big enough to guarantee to contain </span>
  <span class="comment">// the characterisation of Sc</span>

  Sc = <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(<a class="code" href="Exm__3__3_8cpp.shtml#ad4bce9ed969316e3fb7c990094be55a7">IBTAnnular</a>,A,prec);
  end = clock();
</pre></div></p>
<p>Sc now points to the root node of a tree representing the subpaving constructed with Sivia.</p>
<p>The SIVIA algorithm works by taking an initial search box, testing it, rejecting those returning BI_FALSE, including those returning BI_TRUE in the subpaving it is building, and bisecting again if the interval boolean test returns BI_INDET, and recursively sending each subbox to SIVIA to be tested similarly. Each subbox continues to be bisected until either the test returns a clear BI_TRUE or BI_FALSE or the test is BI_INDET but the width of the box is the value given for eps, which means that it is thin enough to be included in the subpaving to be returned. The eps parameter provides a 'stopping rule' prevents SIVIA recursing endlessly. A larger value for eps will mean a thicker uncertainty layer in the outer subpaving of the area we seek to characterise.</p>
<p>We stop the clock after calling Sivia and report the computing time and the volume and number of leaf boxes of the subpaving.</p>
<p><div class="fragment"><pre class="fragment">  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
       &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Volume: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc) &lt;&lt; endl;
</pre></div></p>
<p>Then we create an output file of giving the subpaving as a list of interval vectors. The file name is specified in the example as AIAannular.txt and the first three lines of the file give, respectively, the dimensions we are working in, the initial search box, and the precision used. The subpaving itself is then output. The format used for outputting the subpaving is specified in <a class="el" href="AIAsubpaving_8cpp.shtml#a545707f4bc32ad5dac67608be229b51d">operator&lt;&lt;(std::ostream &amp;, AIASubPaving)</a></p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// To realize a file output of the AIASubPaving Sc</span>
                    <span class="comment">// Filename</span>
  ofstream os(<span class="stringliteral">&quot;AIAannular.txt&quot;</span>);
  os &lt;&lt; 2 &lt;&lt; endl;  <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Root box</span>
  os &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
  os &lt;&lt; Sc &lt;&lt; endl; <span class="comment">// AIASubPaving itself</span>
  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIAannular.txt&quot;</span> 
       &lt;&lt; endl &lt;&lt; endl;

  <span class="comment">// end of testing to find reciprocal image</span>

  <span class="comment">// the AIASubPaving Sc that we have created is the regular AIASubPaving </span>
  <span class="comment">// that covers the set</span>
  <span class="comment">// X = {(x1,x2) in R2 | sqr(x1) + sqr(x2) is in [1,2]} </span>
  <span class="comment">// (remember that it contains this area rather than being this area, </span>
  <span class="comment">// and that eps has determined how small we go in the AIASubPaving </span>
</pre></div></p>
<p>This example now moves on to use this subpaving in further demonstrations of the SIVIA algorithm. First, we delete the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> that A currently points to and replace it with a new one, again providing an initial search box [-5.0 5.0]<sup>2</sup></p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// make a new AIASubPaving to provide an initial source box for the test next</span>
</pre></div></p>
<p>Now we prepare to use SIVIA to find the direct image of an invertible function, which can be thought of as using SIVIA in reverse: normally SIVIA characterises the reciprocal image X = <b>f</b><sup>-1</sup>(Y) where Y, the subpaving we want to invert, is regular subpaving of R<sup>m</sup>. However, if we have X but want to find Y (or a characterisation for Y) and f is invertible so that we can specify an inclusion function [<b>f</b><sup>-1</sup>] for <b>f</b><sup>-1</sup> then we can use this inclusion function to characterise Y. SIVIA can only be used to find a direct image under <b>f</b> when <b>f</b> is invertible in the normal sense because we need to be able to specify [<b>f</b><sup>-1</sup>] in our interval boolean test.</p>
<p>A description of what we are doing is printed to standard output and the user again asked to enter a precision, and the clock is started</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// testing using SIVIA to find the direct image of an invertible function</span>
  <span class="comment">// remember that we are only finding some upper enclosure of the direct </span>
  <span class="comment">// image really</span>
  <span class="comment">// Note that this example will use the AIASubPaving Sc we created </span>
  <span class="comment">// above - see IBTFdirect</span>

  <span class="comment">// ie create an AIASubPaving Sc1 containing f(Sc), where Sc was found above</span>

  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc1=f(Sc)&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;with f1(x) = 2*x1-x2,&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;      f2(x) = -x1+2*x2,&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;by realizing the inversion of f-1 by Sivia&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.01): &quot;</span>;
</pre></div></p>
<p>Now we run Sivia as above, but the argument supplied for the interval boolean test parameter is <a class="el" href="AIASubPavings.shtml#IBTFdirect">IBTFdirect</a> as given at the top of the file. This specifies [<b>f</b><sup>-1</sup>] for f<sub>1</sub>(x) = 2x<sub>1</sub> - x<sub>2</sub>, f<sub>2</sub>(x) = -x<sub>1</sub> + 2x<sub>2</sub>. Recall that <a class="el" href="AIASubPavings.shtml#IBTFdirect">IBTFdirect</a> specifies that the subpaving to invert is Sc, ie the subpaving we found using Sivia above.</p>
<p><div class="fragment"><pre class="fragment">  start = clock();
                    <span class="comment">// Sc1 will be used by the following example</span>
  Sc1 = <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(<a class="code" href="Exr__11__33_8cpp.shtml#a20b13850dd9692440454d010da913e98">IBTFdirect</a>,A,prec);
  end = clock();
</pre></div></p>
<p>Sc1 now points to the root node of a tree representing the subpaving constructed with Sivia.</p>
<p>The computing time, volume and number of leaves are reported and an output file produced.</p>
<p><div class="fragment"><pre class="fragment">  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
       &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Volume: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc1) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(Sc1) &lt;&lt; endl;

  <span class="comment">// To realize a file output of the AIASubPaving Sc1</span>
                    <span class="comment">// Filename</span>
  ofstream os1(<span class="stringliteral">&quot;AIAdirect.txt&quot;</span>);
  os1 &lt;&lt; 2 &lt;&lt; endl; <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Root box</span>
  os1 &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os1 &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
                    <span class="comment">// AIASubPaving itself</span>
  os1 &lt;&lt; Sc1 &lt;&lt; endl;

  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIAdirect.txt&quot;</span> 
       &lt;&lt; endl &lt;&lt; endl;

  <span class="comment">// end of example for finding direct image</span>
</pre></div></p>
<p>We have now found a subpaving Sc in 'x-space' and used Sivia on an function inverse to get a characterisation Sc1 of the image of Sc in 'y-space'. The final step is to use Sivia again to go back to 'x-space' and find the reciprocal image Sc2 of Sc1!</p>
<p>Start by resetting A again, describe what we are doing, and get the precision</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// get a new AIASubPaving A to provide initial source box for next example</span>
  <span class="keyword">delete</span> A;

  x[1] = interval(-5.0,5.0);
  x[2] = interval(-5.0,5.0);

  A = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(x);

  <span class="comment">// Image evaluation using set inversion</span>
  <span class="comment">// this uses the AIASubPaving Sc1 created by the above example</span>
  <span class="comment">// create an AIASubPaving Sc2 which contains inverse_f(Sc1)</span>

  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc2=f-1(Sc1)&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;with f^-1_1(x) = (2*x1+x2)/3,&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;     f^-1_2(x) = (x1+2*x2)/3,&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;by realizing the inversion of f by Sivia&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.01): &quot;</span>;
</pre></div></p>
<p>Now the argument supplied for the interval boolean test parameter is <a class="el" href="AIASubPavings.shtml#IBTFinverse">IBTFinverse</a> from the top of the file. This specifies [<b>f</b>] for f<sub>1</sub>(x) = 2x<sub>1</sub> - x<sub>2</sub>,f<sub>2</sub>(x) = -x<sub>1</sub> + 2x<sub>2</sub>. <a class="el" href="AIASubPavings.shtml#IBTFinverse">IBTFinverse</a> also specifies that the subpaving to invert is Sc1, ie the subpaving in 'y-space' we have just found using Sivia above.</p>
<p><div class="fragment"><pre class="fragment">  start = clock();
  Sc2 = <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(<a class="code" href="Exr__11__33_8cpp.shtml#ad999a60ef78af33c65610c301d3c57dc">IBTFinverse</a>,A,prec);
  end = clock();
</pre></div></p>
<p>Sc2 now points to the root node of a tree representing the subpaving constructed with Sivia.</p>
<p>The computing time, volume and number of leaves are reported and an output file produced.</p>
<p><div class="fragment"><pre class="fragment">  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
       &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Volume: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc2) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(Sc2) &lt;&lt; endl;

  <span class="comment">// To realize a file output of the AIASubPaving Sc</span>
                    <span class="comment">// Filename</span>
  ofstream os2(<span class="stringliteral">&quot;AIAinverse.txt&quot;</span>);
  os2 &lt;&lt; 2 &lt;&lt; endl; <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Root box</span>
  os2 &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os2 &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
                    <span class="comment">// AIASubPaving itself</span>
  os2 &lt;&lt; Sc2 &lt;&lt; endl;

  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIAinverse.txt&quot;</span> 
       &lt;&lt; endl &lt;&lt; endl;

  <span class="comment">// end of testing SIVIA for set inversion</span>
  <span class="comment">// we should compare Sc2 to Sc in terms of volume and look at the effects of </span>
  <span class="comment">// the precision variable</span>
</pre></div></p>
<p>Finally we need to delete all the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> trees we created in dynamic memory, then the program can return.</p>
<p><div class="fragment"><pre class="fragment">  <span class="keyword">delete</span> A;         <span class="comment">// delete subpavings newed in dyamic memory</span>
  <span class="keyword">delete</span> <a class="code" href="Exm__3__3_8cpp.shtml#a61a4b8518251e3f73c3e1951e3c733ec">Sc</a>;
  <span class="keyword">delete</span> <a class="code" href="Exr__11__33_8cpp.shtml#a6f925a28990597524155ac8e7381d5fa">Sc1</a>;
  <span class="keyword">delete</span> <a class="code" href="Exr__11__33_8cpp.shtml#a16765ea8c433ea86ad0e3ae0e36685c7">Sc2</a>;

  <span class="keywordflow">return</span> 0;
}
</pre></div></p>
<p>The example can be run with different values supplied for the precision in each case, to examine the effect that this has on the volume and number of leaves of the subpavings.</p>
<p>One of the interesting points about this example is that we can see the effect of pessimism in inclusion functions (AIA2001, pp. 15-17, p. 342). We start by making a subpaving Sc in 'x-space' and then find Sc1, a subpaving characterisation for the image of Sc under a function <b>f</b> (ie, a subpaving in 'y-space'), and then go back to 'x-space' again and with Sc2 as a subpaving characterisation for the reciprocal image of Sc1 under <b>f</b>.</p>
<p>Under the output format currently specified, the the first part of the output file AIAdirect.txt looks like this:</p>
<div class="fragment"><pre class="fragment">
2
[ -5.000000,  5.000000] [ -5.000000,  5.000000]
Precision is 0.05
[  -1.953125 ,  -1.875000 ] , [  -0.078125 ,   0.000000 ]
[  -1.289062 ,  -1.250000 ] , [  -0.820312 ,  -0.781250 ]
[  -1.406250 ,  -1.328125 ] , [  -0.703125 ,  -0.625000 ]
[  -1.328125 ,  -1.289062 ] , [  -0.742188 ,  -0.703125 ]
</pre></div><p>All the output from this example rendered graphically looks like this.</p>
<div class="image">
<img src="AIAexample11_33.png" alt="AIAexample11_33.png"/>
<div class="caption">
Results for Exercise 11.33 using precision 0.05</div></div>
 <h3><a class="anchor" id="AIAexamsec_11_35"></a>
Exercise 11.35</h3>
<p>See examples/AIA/Exr_11_35</p>
<h3><a class="anchor" id="AIAexamsec_3_3"></a>
Example 3.3</h3>
<p>See AIA2001, p. 61.</p>
<p>Example 3.3 explores the use of ImageSp and the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> class for image evaluation. In <a class="el" href="AIASubPavings.shtml#AIAexamsec_3_3">Example 3.3</a> used Sivia to find the image of a subpaving under a function <b>f</b>, but this is only possible when <b>f</b> is invertible in the usual sense.</p>
<p>Computation of the direct image of a subpaving Y = <b>f</b>(X) where X is a regular subpaving of R<sup>n</sup> (image evaluation) is more complex in the case where the function is not invertible in the usual sense.</p>
<p>Our implementation of this example is in the file <a class="el" href="Exm__3__3_8cpp.shtml" title="Example 3.3 from Jaulin et al, Springer, 2001, p. 61.">Exm_3_3.cpp</a>, which has header file <a class="el" href="Exm__3__3_8hpp.shtml">Exm_3_3.hpp</a>.</p>
<p><a class="el" href="Exm__3__3_8hpp.shtml">Exm_3_3.hpp</a> shows is similar to the header for Example 11.33 so we will move straight on the describing the file <a class="el" href="Exm__3__3_8cpp.shtml" title="Example 3.3 from Jaulin et al, Springer, 2001, p. 61.">Exm_3_3.cpp</a>.</p>
<p>First we include the header file and declare more global subpavings.</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="Exm__3__3_8hpp.shtml">Exm_3_3.hpp</a>&quot;</span>

<span class="comment">// These AIASubPavings are declared as global</span>
<a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> <a class="code" href="Exm__3__3_8cpp.shtml#a61a4b8518251e3f73c3e1951e3c733ec">Sc</a>, <a class="code" href="Exm__3__3_8cpp.shtml#a58bc430cfad550646042603ef50cd6b7">Sc4</a>;
</pre></div></p>
<p>Now we look at the functions used in our main program.</p>
<p>The first is a boolean interval test <a class="el" href="AIASubPavings.shtml#IBTAnnular">IBTAnnular</a> is exactly the same as that used for Exercise 11.33.</p>
<p><div class="fragment"><pre class="fragment"><span class="comment">// specifications of example interval boolean tests</span>
<span class="comment">// The boolean interval test can return BI_TRUE, BI_FALSE, or BI_INDET</span>

<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> <a class="code" href="Exm__3__3_8cpp.shtml#ad4bce9ed969316e3fb7c990094be55a7">IBTAnnular</a>(<span class="keyword">const</span> ivector&amp; x)
{
  <span class="comment">// here we test a 2-d box for inclusion in the area between circles centred </span>
  <span class="comment">// on the origin with radii 1 and 2</span>
  interval ToInvert(1.0,2.0),Temp;
  interval Img = <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[1]) + <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[2]);

  <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Temp,Img,ToInvert)) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
  <span class="keywordflow">if</span> ( Img&lt;=ToInvert ) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>;

  <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;
}

<span class="comment">// end specification of example boolean interval tests</span>
</pre></div></p>
<p>The next function is an interval vector function, <a class="anchor" id="IVFex3_3"></a>IVFex3_3. An interval vector function returns the interval vector image of an interval vector x under <b>f</b> for <b>f</b> as specified in the function and x supplied as the function argument.</p>
<p>In this case <b>f</b>: R<sup>2</sup> -&gt; R<sup>2</sup>, <b>f</b><sub>1</sub>(x<sub>1</sub>, x<sub>2</sub>) = x<sub>1</sub>x<sub>2</sub>, <b>f</b><sub>2</sub>(x<sub>1</sub>, x<sub>2</sub>) = x<sub>1</sub> + x<sub>2</sub></p>
<p><div class="fragment"><pre class="fragment"><span class="comment">// specification of example interval vector function,</span>
<span class="comment">// ie, vector inclusion function</span>
<span class="comment">// as in Example 3.3 of AIA</span>
ivector <a class="code" href="Exm__3__3_8cpp.shtml#a08a7ccec803f0858fe9d44dbeb8e9a29">IVF_ex3_3</a>(<span class="keyword">const</span> ivector&amp; x)
{
  <span class="comment">// example in 2-d space R2</span>
  <span class="comment">// for f: R2 -&gt; R2</span>
  <span class="comment">//f1(x1, x2) = x1*x2</span>
  <span class="comment">//f2(x1, x2) = x1 + x2</span>

  ivector Img(2);

  Img[1] = x[1] * x[2];
  Img[2] = x[1] + x[2];

  <span class="keywordflow">return</span> (Img);
}

<span class="comment">// end specification of example interval vector funciions</span>
</pre></div></p>
<p>Then we say what namespaces we are using, start the main program, and set up an initial search box [-3.0 3.0]<sup>2</sup> and a pointer A to an <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> based on this search box.</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>cxsc;
<span class="keyword">using namespace </span>std;

<span class="keywordtype">int</span> <a class="code" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
{
  <span class="keywordtype">double</span> prec;
  clock_t start, end;

  ivector x(2);
  x[1] = interval(-3.0,3.0);
  x[2] = interval(-3.0,3.0);

  <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> A;
  A = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(x);
</pre></div></p>
<p>The first subpaving we create is again Sc, the subpaving covering the set in R<sup>2</sup> between circles centred at the origin and with radii 1 and 2.</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// Using SIVIA for set inversion</span>
  <span class="comment">// find an AIASubPaving characterisation Sc containing the area between </span>
  <span class="comment">// circles centred on the origin</span>
  <span class="comment">// with radii 1 and 2 (in 2 dimensional space)</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc={(x1,x2) | 1 &lt;= x1^2+x2^2 &lt;= 2 }&quot;</span> 
       &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.001): &quot;</span>;
  cin &gt;&gt; prec;

  start = clock();

  <span class="comment">// when we start we give A a box big enough to guarantee to contain the </span>
  <span class="comment">// characterisation of Sc</span>

  Sc = <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(<a class="code" href="Exm__3__3_8cpp.shtml#ad4bce9ed969316e3fb7c990094be55a7">IBTAnnular</a>,A,prec);
  end = clock();

  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
       &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Volume: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(Sc) &lt;&lt; endl;

  <span class="comment">// To realize a file output of the AIASubPaving Sc</span>
                    <span class="comment">// Filename</span>
  ofstream os(<span class="stringliteral">&quot;AIA3_3a.txt&quot;</span>);
  os &lt;&lt; 2 &lt;&lt; endl;  <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Root box</span>
  os &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
  os &lt;&lt; Sc &lt;&lt; endl; <span class="comment">// AIASubPaving itself</span>
  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIA3_3a.txt&quot;</span> 
       &lt;&lt; endl &lt;&lt; endl;

  <span class="comment">// the AIASubPaving Sc that we have created is the regular </span>
  <span class="comment">// AIASubPaving that covers the set</span>
  <span class="comment">// X = {(x1,x2) in R2 | sqr(x1) + sqr(x2) is in [1,2]} </span>
  <span class="comment">// (remember that it contains this area rather than being this area, </span>
  <span class="comment">// and that eps has determined how small we go in the AIASubPaving </span>
</pre></div></p>
<p>Now we move on to using ImageSp. We are going to find Sc4, a characterisation of the set f(Sc) using f as defined in <a class="el" href="Exm__3__3_8cpp.shtml#a08a7ccec803f0858fe9d44dbeb8e9a29">IVF_ex3_3</a>.</p>
<p>First we say what we are doing and ask for a precision.</p>
<p><div class="fragment"><pre class="fragment">  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc4=f(Sc)&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot; with Sc from our first example and &quot;</span>&lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;with f1(x) = x1*x2,&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;     f2(x) = x1 + x2,&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;by realizing the image of f by ImageSp&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.01): &quot;</span>;
</pre></div></p>
<p>Then start the clock and run <a class="el" href="AIAsubpaving_8cpp.shtml#a6df9f8ffe0d5fbd9ec10bd6954b3b800">ImageSp(AIA_PIVF, AIASubPaving A, double eps)</a> giving as arguments our interval vector function, our subpaving node A, and our precision.</p>
<p>Sc4 now points to the root node of a tree representing the subpaving constructed with ImageSp.</p>
<p>The ImageSp algorithm works by taking an initial subpaving (in this case, the box of A), mincing it up into a fine subpaving where every box has width less than precision, and finding the image of each of these boxes with the specified interval vector test. It then forms a minimal regular subpaving which covers the union of all these image boxes, again with precision as specified.</p>
<p><div class="fragment"><pre class="fragment">  start = clock();

  <span class="comment">// use Image SP to find a characterisation of the image of Sc using the </span>
  <span class="comment">// function in IVF</span>
  Sc4 = <a class="code" href="classsubpavings_1_1SPnode.shtml#a5e79ff65a692b09c98ff53264ddfba9f" title="Creation of image subpaving with Interval Analysis.">ImageSp</a>(<a class="code" href="Exm__3__3_8cpp.shtml#a08a7ccec803f0858fe9d44dbeb8e9a29">IVF_ex3_3</a>, Sc, prec);

  end = clock();
</pre></div></p>
<p>We report the running time, volume and number of leaves in the image subpaving and send the output to a txt file</p>
<p><div class="fragment"><pre class="fragment">  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
       &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;The volume is &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc4) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;The number of leaves is &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(Sc4) &lt;&lt; endl;

  <span class="comment">// To realize a file output of the AIASubPaving Sc</span>
                    <span class="comment">// Filename</span>
  ofstream os4(<span class="stringliteral">&quot;AIA3_3d.txt&quot;</span>);
  os4 &lt;&lt; 2 &lt;&lt; endl; <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Domain AIASubPaving</span>
  os4 &lt;&lt; interval(-3.0,3.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-3.0,3.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os4 &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
                    <span class="comment">// Image AIASubPaving itself</span>
  os4 &lt;&lt; Sc4 &lt;&lt; endl;

  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIA3_3d.txt&quot;</span> 
</pre></div></p>
<p>Finally, we delete the subpavings and end the program.</p>
<p><div class="fragment"><pre class="fragment">  <span class="keyword">delete</span> A;         <span class="comment">// Delete all subpavings newed in dynamic memory</span>
  <span class="keyword">delete</span> <a class="code" href="Exm__3__3_8cpp.shtml#a61a4b8518251e3f73c3e1951e3c733ec">Sc</a>;
  <span class="keyword">delete</span> <a class="code" href="Exm__3__3_8cpp.shtml#a58bc430cfad550646042603ef50cd6b7">Sc4</a>;

  <span class="keywordflow">return</span> 0;
}
</pre></div></p>
<p>The subpavings produced by this program run using precision 0.05 for both subpavings is shown graphically below. As well as showing the initial subpaving (represented by Sc) and the image subpaving (represented by Sc4), we capture an intermediate step within ImageSp. This is the evaluation step, where we have a large set of (possibly overlapping) image boxes formed from all the minced up subboxes of the initial box ([-3.0 3.0]<sup>2</sup> chopped up so that each one is less than 0.05 wide). This set can be compared to the final regular minimal subpaving characterisation of the image which is formed by the function Regularize.</p>
<div class="image">
<img src="AIAexample3_3.png" alt="AIAexample3_3.png"/>
<div class="caption">
Results for Example 3.3 using precision 0.05</div></div>
 <h3><a class="anchor" id="AIAexamsec_3_4"></a>
Example 3.4</h3>
<p>See AIA2001, pp. 61-63.</p>
<p><a class="anchor" id="AIAexample3_4"></a>Finally we show another example using both Sivia and ImageSp. This example shows why we need ImageSp when to evaluate the images of functions that are only invertible in a set-theoretic sense, and also illustrates the interesting effects that can occur in these circumstances.</p>
<p>Our implementation of this example is in the file <a class="el" href="Exm__3__4_8cpp.shtml" title="Example 3.4 from Jaulin et al, Springer, 2001, pp. 61-63.">Exm_3_4.cpp</a>, which has header file <a class="el" href="Exm__3__4_8hpp.shtml">Exm_3_4.hpp</a>.</p>
<p><a class="el" href="Exm__3__4_8hpp.shtml">Exm_3_4.hpp</a> shows is similar to the other header files so we will move straight on the describing the file <a class="el" href="Exm__3__4_8cpp.shtml" title="Example 3.4 from Jaulin et al, Springer, 2001, pp. 61-63.">Exm_3_4.cpp</a>.</p>
<p>First we include the header file and declare more global subpavings.</p>
<p><div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;<a class="code" href="Exm__3__4_8hpp.shtml">Exm_3_4.hpp</a>&quot;</span>

<span class="comment">// These AIASubPavings are declared as global</span>
<a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> <a class="code" href="Exm__3__4_8cpp.shtml#a6121e44a51842f2e136bf41bacde57bc">Sc5</a>, <a class="code" href="Exm__3__4_8cpp.shtml#a45cd2800058123a38d9a98f9b30d27c3">Sc6</a>, <a class="code" href="Exm__3__4_8cpp.shtml#aabbd0f41c2d4d9a5efdb0185ff33289e">Sc7</a>;
</pre></div></p>
<p>Now we look at the functions used in our main program.</p>
<p>The first is a boolean interval test, <a class="anchor" id="IBT_ex3_4"></a>IBT_ex3_4. The first specifies a function <b>f</b>: R<sup>2</sup> -&gt; R such that <b>f</b>(x<sub>1</sub>, x<sub>2</sub>) = x<sub>1</sub><sup>4</sup> - x<sub>1</sub><sup>2</sup> + 4x<sub>2</sub><sup>2</sup> and tests the image of a box x under this function for inclusion in the subpaving to be inverted. As with <a class="el" href="AIASubPavings.shtml#IBTAnnular">IBTAnnular</a> above, the subpaving to be inverted is also specifed in the test and here is just the interval [-0.1, 0.1].</p>
<p><div class="fragment"><pre class="fragment"><span class="comment">// specifications of example interval boolean tests</span>
<span class="comment">// The boolean interval test can return BI_TRUE, BI_FALSE, or BI_INDET</span>

<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> <a class="code" href="Exm__3__4_8cpp.shtml#adb8d4bd4ff6d7fe76c024fbcfbc85716">IBT_ex3_4</a>(<span class="keyword">const</span> ivector&amp; x)
{
  <span class="comment">// here we test a 2-d box for inclusion in the area </span>
  <span class="comment">// such that x1^4 - x1^2 + 4x2^2 is in the interval [-0.1, 0.1]</span>

  interval ToInvert(-0.1, 0.1),Temp;
  interval Img = <a class="code" href="namespacetaylor.shtml#a09dab31240298a683a7912d43938e0bb">power</a>(x[1],4) - <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[1]) + 4*<a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[2]);

  <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Temp,Img,ToInvert)) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
  <span class="keywordflow">if</span> ( Img&lt;=ToInvert ) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>;

  <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;
}
</pre></div></p>
<p>Then we have another boolean interval test, <a class="anchor" id="IBTinverse_ex3_4"></a>IBTFinverse_ex3_4. Again this specifies a function <b>f</b>, this time <b>f</b>: R<sup>2</sup> -&gt; R<sup>2</sup>, f<sub>1</sub>(x<sub>1</sub>, x<sub>2</sub>) = (x<sub>1</sub> - 1)<sup>2</sup> -1 + x<sub>2</sub>, f<sub>2</sub>(x<sub>1</sub>, x<sub>2</sub>) = -x<sub>1</sub><sup>2</sup> + (x<sub>2</sub> - 1)<sup>2</sup>. The subpaving to invert is one of the globally defined subpaving Sc6</p>
<p><div class="fragment"><pre class="fragment"><a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> <a class="code" href="Exm__3__4_8cpp.shtml#a222ab786ba862f781778b6ab42e6d346">IBTFinverse_ex3_4</a>(<span class="keyword">const</span> ivector&amp; x)
{
  ivector Img(2);
  <span class="comment">// example in 2-d space R2</span>
  <span class="comment">// for f: R2 -&gt; R2</span>
  <span class="comment">//f1(x1, x2) = (x1-1)^2 - 1+ x2</span>
  <span class="comment">//f2(x1, x2) = -(x1^2) + (x2-1)^2</span>

  Img[1] = <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[1]) - 2*x[1] + x[2];
  Img[2] = -<a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[1]) + <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[2]) - 2*x[2] + 1;

  <span class="keywordflow">return</span> (Img&lt;=Sc6);
}

<span class="comment">// end specification of example boolean interval tests</span>
</pre></div></p>
<p>The next function is an interval vector function, <a class="anchor" id="IVF_ex3_4"></a>IVF_ex3_4. Recall that an interval vector function returns the interval vector image of an interval vector x under <b>f</b> for <b>f</b> as specified in the function and x supplied as the function argument. In this case <b>f</b> is exactly the same as in the boolean interval test <a class="el" href="Exm__3__4_8cpp.shtml#a222ab786ba862f781778b6ab42e6d346">IBTFinverse_ex3_4</a> above.</p>
<p><div class="fragment"><pre class="fragment"><span class="comment">// specification of example interval vector function </span>
<span class="comment">// (ie, vector inclusion function)</span>

ivector <a class="code" href="Exm__3__4_8cpp.shtml#a53362d503f1771845ee5bac0caf975cd">IVF_ex3_4</a>(<span class="keyword">const</span> ivector&amp; x)
{
  <span class="comment">// example in 2-d space R2</span>
  <span class="comment">// for f: R2 -&gt; R2</span>
  <span class="comment">//f1(x1, x2) = (x1-1)^2 - 1+ x2</span>
  <span class="comment">//f2(x1, x2) = -(x1^2) + (x2-1)^2</span>

  ivector Img(2);

  Img[1] = <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[1]) - 2*x[1] + x[2];
  Img[2] = -<a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[1]) + <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(x[2]) - 2*x[2] + 1;

  <span class="keywordflow">return</span> (Img);
}

<span class="comment">// end specification of example interval vector functions</span>
</pre></div></p>
<p>Then we say what namespaces we are using, start the main program, and set up an initial search box [-3.0 3.0]<sup>2</sup> and a pointer A to an <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> based on this search box.</p>
<p><div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>cxsc;
<span class="keyword">using namespace </span>std;

<span class="comment">//int main(int argc, char* argv[])</span>
<span class="keywordtype">int</span> <a class="code" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
{
  <span class="keywordtype">double</span> prec;
  clock_t start, end;

  ivector x(2);
  x[1] = interval(-3.0,3.0);
  x[2] = interval(-3.0,3.0);

  <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> A;
  A = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(x);
</pre></div></p>
<p>First we use SIVIA to get a subpaving Sc5 in 'x-space' using the function f and subpaving to invert specified in <a class="el" href="AIASubPavings.shtml#IBT_ex3_4">IBT_ex3_4</a>, ie Sc5 represents a subpaving characterisation of the set (x<sub>1</sub>, x<sub>2</sub>) such that x<sub>1</sub><sup>4</sup> - x<sub>1</sub><sup>2</sup> + 4x<sub>2</sub><sup>2</sup> is in the interval [-0.1, 0.1].</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// Using SIVIA for set inversion</span>

  <span class="comment">// Find an AIASubPaving characterisation Sc5 as in example 3.4</span>

  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc5={(x1,x2) | -0.1 &quot;</span> 
       &lt;&lt; <span class="stringliteral">&quot;&lt;= x1^4-x1^2+4x2^2 &lt;= 0.1 }&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.001): &quot;</span>;
  cin &gt;&gt; prec;

  start = clock();

  <span class="comment">// when we start we give A a box big enough to guarantee to contain </span>
  <span class="comment">// the characterisation of Sc</span>

  Sc5 = <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(<a class="code" href="Exm__3__4_8cpp.shtml#adb8d4bd4ff6d7fe76c024fbcfbc85716">IBT_ex3_4</a>,A,prec);
  end = clock();

  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
       &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Volume: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc5) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(Sc5) &lt;&lt; endl;
</pre></div></p>
<p>And send the output to a txt file.</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// To realize a file output of the AIASubPaving Sc</span>
                    <span class="comment">// Filename</span>
  ofstream os5(<span class="stringliteral">&quot;AIA3_4a.txt&quot;</span>);
  os5 &lt;&lt; 2 &lt;&lt; endl; <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Root box</span>
  os5 &lt;&lt; interval(-3.0,3.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-3.0,3.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os5 &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
                    <span class="comment">// AIASubPaving itself</span>
  os5 &lt;&lt; Sc5 &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIA3_4a.txt&quot;</span> 
</pre></div></p>
<p>Now we want to find the image of this set using the function specified in <a class="el" href="AIASubPavings.shtml#IVF_ex3_4">IVF_ex3_4</a>. <b>f</b>: R<sup>2</sup> -&gt; R<sup>2</sup>, f<sub>1</sub>(x<sub>1</sub>, x<sub>2</sub>) = (x<sub>1</sub> - 1)<sup>2</sup> -1 + x<sub>2</sub>, f<sub>2</sub>(x<sub>1</sub>, x<sub>2</sub>) = -x<sub>1</sub><sup>2</sup> + (x<sub>2</sub> - 1)<sup>2</sup>.</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// Using ImageSp to find the image of Sc5 using</span>
  <span class="comment">//  f1(x) = (x1-1)^2 - 1+ x2</span>
  <span class="comment">// &quot;    f2(x) = -(x1^2) + (x2-1)^2</span>

  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc6=f(Sc5)&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot; with Sc5 from our previous example and &quot;</span>&lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;with f1(x) = (x1-1)^2 - 1 +x2,&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;     f2(x) = -(x1^2) + (x2-1)^2&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;by realizing the image of f by ImageSp&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.01): &quot;</span>;
</pre></div></p>
<p>This function is certainly not invertible in the usual sense and we have to use ImageSp to find the image. We supply the interval vector function IVF_ex3_4, the subpaving Sc5 and the precision input by the user as arguments in the call to ImageSp.</p>
<p><div class="fragment"><pre class="fragment">  start = clock();

  <span class="comment">// use Image SP to find a characterisation of the </span>
  <span class="comment">// image of Sc5 using the function in IVF</span>
  Sc6 = <a class="code" href="classsubpavings_1_1SPnode.shtml#a5e79ff65a692b09c98ff53264ddfba9f" title="Creation of image subpaving with Interval Analysis.">ImageSp</a>(<a class="code" href="Exm__3__4_8cpp.shtml#a53362d503f1771845ee5bac0caf975cd">IVF_ex3_4</a>, Sc5, prec);

  end = clock();
</pre></div></p>
<p>Sc6 now points to a subpaving representation in 'y-space', the image of Sc5 under the function <b>f</b> in <a class="el" href="AIASubPavings.shtml#IVF_ex3_4">IVF_ex3_4</a>.</p>
<p>We report computing time, volume and number of leaves and send the suppaving output to a txt file</p>
<p><div class="fragment"><pre class="fragment">  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
      &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;The volume is &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc6) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;The number of leaves is &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(Sc6) &lt;&lt; endl;

  <span class="comment">// To realize a file output of the AIASubPaving Sc</span>
                    <span class="comment">// Filename</span>
  ofstream os6(<span class="stringliteral">&quot;AIA3_4b.txt&quot;</span>);
  os6 &lt;&lt; 2 &lt;&lt; endl; <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Domain AIASubPaving</span>
  os6 &lt;&lt; interval(-3.0,3.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-3.0,3.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os6 &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
                    <span class="comment">// Image AIASubPaving itself</span>
  os6 &lt;&lt; Sc6 &lt;&lt; endl;

  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIA3_4b.txt&quot;</span> 
</pre></div></p>
<p>Subpaving A, which will have been minced and mangled in the process of forming Sc6, is now deleted and remade to provide another initial search box.</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">//remake A</span>
  <span class="keyword">delete</span> A;

  x[1] = interval(-5.0,5.0);
  x[2] = interval(-5.0,5.0);

  A = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(x);
</pre></div></p>
<p>What happens if we now use Sivia on our ImageSp-created image Sc6 in 'y-space', inverting our image to get back to 'x-space'?</p>
<p><div class="fragment"><pre class="fragment">  <span class="comment">// set inversion using SIVIA</span>
  <span class="comment">// this uses the AIASubPaving Sc6 created by the above example</span>
  <span class="comment">// create an AIASubPaving Sc7 which contains inverse_f(Sc6)</span>

  cout &lt;&lt; <span class="stringliteral">&quot;Characterization of the set Sc7=f-1(Sc6)&quot;</span> &lt;&lt; endl
    &lt;&lt; <span class="stringliteral">&quot;with f as above  and Sc6 as above &quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;by realizing the inversion of f by Sivia&quot;</span> &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Enter a precision (between 1 and 0.01): &quot;</span>;
</pre></div></p>
<p>The boolean interval test <a class="el" href="AIASubPavings.shtml#IBTinverse_ex3_4">IBTFinverse_ex3_4</a> specifies the function and also specifies Sc6 as the subpaving to test for inclusion in. We give the new search box in the subpaving A, and the user-supplied precision.</p>
<p><div class="fragment"><pre class="fragment">  start = clock();
  Sc7 = <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(<a class="code" href="Exm__3__4_8cpp.shtml#a222ab786ba862f781778b6ab42e6d346">IBTFinverse_ex3_4</a>,A,prec);
  end = clock();
</pre></div></p>
<p>Sc7 is now points to 'x-space' subpaving characterisation of the reciprocal image of Sc6, which was in turn a subpaving characterisation of Sc5.</p>
<p>We report computing time, volume and number of leaves and output the subpaving to a txt file.</p>
<p><div class="fragment"><pre class="fragment">  cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> 
       &lt;&lt; ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC) &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Volume: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Sc7) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves: &quot;</span> &lt;&lt; <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(Sc7) &lt;&lt; endl;

  <span class="comment">// To realize a file output of the AIASubPaving Sc</span>
                    <span class="comment">// Filename</span>
  ofstream os7(<span class="stringliteral">&quot;AIA3_4c.txt&quot;</span>);
  os7 &lt;&lt; 2 &lt;&lt; endl; <span class="comment">// Dimension of the AIASubPaving</span>
                    <span class="comment">// Root box</span>
  os7 &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>
    &lt;&lt; interval(-5.0,5.0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; endl;
                    <span class="comment">// Precision used</span>
  os7 &lt;&lt; <span class="stringliteral">&quot;Precision is &quot;</span> &lt;&lt; prec &lt;&lt; endl;
                    <span class="comment">// AIASubPaving itself</span>
  os7 &lt;&lt; Sc7 &lt;&lt; endl;

  cout &lt;&lt; <span class="stringliteral">&quot;The output AIASubPaving has been written to AIA3_4c.txt&quot;</span> 
</pre></div></p>
<p>and then delete our subpavings and end the program</p>
<p><div class="fragment"><pre class="fragment">  <span class="keyword">delete</span> A;         <span class="comment">// delete all Subpavings newed in dynamic memory</span>
  <span class="keyword">delete</span> <a class="code" href="Exm__3__4_8cpp.shtml#a6121e44a51842f2e136bf41bacde57bc">Sc5</a>;
  <span class="keyword">delete</span> <a class="code" href="Exm__3__4_8cpp.shtml#a45cd2800058123a38d9a98f9b30d27c3">Sc6</a>;
  <span class="keyword">delete</span> <a class="code" href="Exm__3__4_8cpp.shtml#aabbd0f41c2d4d9a5efdb0185ff33289e">Sc7</a>;

  <span class="keywordflow">return</span> 0;
}
</pre></div></p>
<p>The subpavings produced by this program run using precision 0.05 in each case is shown graphically below.</p>
<p>As well as showing the initial subpaving (represented by Sc5), the image subpaving (represented by Sc6), and the reciprocal image of the image (Sc7), we capture an intermediate step in the process of creating Sc6 from Sc5 with ImageSp. This is the evaluation step, where we have a large set of (possibly overlapping) image boxes formed from all the minced up subboxes of the initial box ([-3.0 3.0]<sup>2</sup> chopped up so that each one is less than 0.05 wide). This set can be compared to the Sc6, the regular minimal subpaving characterisation of the image.</p>
<p>The most interesting comparison though is between the initial subpaving (Sc5) and the subpaving for a reciprocal image of the image subpaving (Sc7). The initial set (characterised by Sc5) is in there but the result is fatter due to error accumulation in the process of going to 'y-space' and back, and the final subpaving has additional parts which appear because <b>f</b>(.) is only invertible in the set-theoretic sense (AIA2001, pp. 63)</p>
<div class="image">
<img src="AIAexample3_4.png" alt="AIAexample3_4.png"/>
<div class="caption">
Results for Example 3.4 using precision 0.05</div></div>
  </div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:23 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
