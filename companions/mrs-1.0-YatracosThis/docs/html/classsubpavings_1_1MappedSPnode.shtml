<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::MappedSPnode&lt; T &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1MappedSPnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::MappedSPnode&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::MappedSPnode" --><!-- doxytag: inherits="subpavings::SPnode" -->
<p>A templated derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>.  
 <a href="classsubpavings_1_1MappedSPnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for subpavings::MappedSPnode&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1MappedSPnode__inherit__graph.png" border="0" usemap="#subpavings_1_1MappedSPnode_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="subpavings_1_1MappedSPnode_3_01T_01_4_inherit__map" id="subpavings_1_1MappedSPnode_3_01T_01_4_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::MappedSPnode&lt; T &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1MappedSPnode__coll__graph.png" border="0" usemap="#subpavings_1_1MappedSPnode_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1MappedSPnode_3_01T_01_4_coll__map" id="subpavings_1_1MappedSPnode_3_01T_01_4_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1MappedSPnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a8f23f414976c6bc3409de02288496e04">~MappedSPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a8f23f414976c6bc3409de02288496e04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#acc4eb13ea772050e37b1eae2e560b117">MappedSPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">No-argument constructor.  <a href="#acc4eb13ea772050e37b1eae2e560b117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a5c67c4c7aec0a3ce461b7ac459ad70c2">MappedSPnode</a> (const ivector &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a5c67c4c7aec0a3ce461b7ac459ad70c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a866ab9d7d7e517e5c403588f12d8e919">MappedSPnode</a> (const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a866ab9d7d7e517e5c403588f12d8e919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#afe15c759857516d725298a1392ab6f07">MappedSPnode</a> (const ivector &amp;v, const T &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#afe15c759857516d725298a1392ab6f07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a5911cc25e5152fe9cced953de14707e7">MappedSPnode</a> (const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb, const T &amp;r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a5911cc25e5152fe9cced953de14707e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a528b15231c2a8476fdeb9283137dc9b1">MappedSPnode</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a528b15231c2a8476fdeb9283137dc9b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3e0ee96e161385b67f5ccc39b4212bdf">MappedSPnode</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a3e0ee96e161385b67f5ccc39b4212bdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a9f159be71fab10b26dec5d080fec95ff">operator=</a> (<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a9f159be71fab10b26dec5d080fec95ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the parent of a node.  <a href="#a700d3bf53c72e2fdecf27446fab902ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093">getLeftChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the left child of a node.  <a href="#a31cc4a453d0c821592096b1829e43093"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9">getRightChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the right child of a node.  <a href="#a3d15d4b64a8c01fbfabdb66c37c89ad9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd">getRange</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the range.  <a href="#a3e5c6ff11f8640c1a7b3a363e9f841bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a4e3cc447b700d1a0e8e611f56762a96d">setRange</a> (T r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the range.  <a href="#a4e3cc447b700d1a0e8e611f56762a96d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ae4b153a0ff33397c3537f1ce9d87b743">nodeStringSummary</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string summary of this.  <a href="#ae4b153a0ff33397c3537f1ce9d87b743"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3f0d891bb2650f6558cc4081ce5102c6">allocateRanges</a> (const std::vector&lt; T &gt; &amp;rangesToAllocate, size_t index=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively allocate a collection of ranges to this and children.  <a href="#a3f0d891bb2650f6558cc4081ce5102c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a65c8bb39917da7dc82fb07c9572c7286">splitToShape</a> (std::string instruction)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits paving according to string instruction.  <a href="#a65c8bb39917da7dc82fb07c9572c7286"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a817b05cc2d60ff0ee1a98b0addf54131">nodeExpand</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sibling nodes to this provided this is a leaf.  <a href="#a817b05cc2d60ff0ee1a98b0addf54131"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a26af7ee7d7e9c00623dea9e6aed02d92">nodeExpand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sibling nodes to this provided this is a leaf.  <a href="#a26af7ee7d7e9c00623dea9e6aed02d92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d">range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of type T.  <a href="#a85f4e42ee09fcfa8c47835231ac3c21d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a83d5b7a4609c73e1818fe2d3231c0979">slice</a> (const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice this.  <a href="#a83d5b7a4609c73e1818fe2d3231c0979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a829001293a30ff276a50cf518893ad7f">acceptSPExpandVisitor</a> (const <a class="el" href="classsubpavings_1_1SPExpandVisitor.shtml">SPExpandVisitor</a>&lt; T &gt; &amp;visitor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a <a class="el" href="classsubpavings_1_1SPExpandVisitor.shtml">SPExpandVisitor</a>.  <a href="#a829001293a30ff276a50cf518893ad7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ab3d7c0ce1aa100e48554605b9c9c3ac7">acceptSPValueVisitor</a> (const <a class="el" href="classsubpavings_1_1SPValueVisitor.shtml">SPValueVisitor</a>&lt; T &gt; &amp;visitor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a <a class="el" href="classsubpavings_1_1SPValueVisitor.shtml">SPValueVisitor</a> visitor.  <a href="#ab3d7c0ce1aa100e48554605b9c9c3ac7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a30b1a6a37439a3d5ad3611e6ecdf37be">operator+=</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;add)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition to self operator.  <a href="#a30b1a6a37439a3d5ad3611e6ecdf37be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a1204b445f0526e62aed8ded7a92744f8">operator+</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;add) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator.  <a href="#a1204b445f0526e62aed8ded7a92744f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a11f57501aac4b67b779e3344290101b4">operator+=</a> (const T &amp;add)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-scalar addition operator.  <a href="#a11f57501aac4b67b779e3344290101b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a9c951e4722b21949175ab3997dcd3a86">operator+</a> (const T &amp;add) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar addition operator.  <a href="#a9c951e4722b21949175ab3997dcd3a86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a1ca00409cd79226e2b626acfb20ea054">operator-=</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;sub)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction from self operator.  <a href="#a1ca00409cd79226e2b626acfb20ea054"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#acf2b59252b57c2201c5184dbb02a5a20">operator-</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;sub) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator.  <a href="#acf2b59252b57c2201c5184dbb02a5a20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a6c67949c1c356830bd0edaae9f75ccbe">operator-=</a> (const T &amp;sub)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-scalar subtraction operator.  <a href="#a6c67949c1c356830bd0edaae9f75ccbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ad4bb0c01c69521b16c62a90a6e540e8f">operator-</a> (const T &amp;sub) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar subtraction operator.  <a href="#ad4bb0c01c69521b16c62a90a6e540e8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aa5949967da59e064734929aaf190fc15">operator*=</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;mult)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of self operator.  <a href="#aa5949967da59e064734929aaf190fc15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#af329c66306f63fb572c92c582640633e">operator*</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;mult) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator.  <a href="#af329c66306f63fb572c92c582640633e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a6c028eece36691537a2c824b39d0fb00">operator*=</a> (const T &amp;mult)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-scalar multiplication operator.  <a href="#a6c028eece36691537a2c824b39d0fb00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a855f75cf76d1ee0235c7aaab29b048f3">operator*</a> (const T &amp;mult) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar multiplication operator.  <a href="#a855f75cf76d1ee0235c7aaab29b048f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a793f3f3b66690ef99c8a737850f7c291">operator/=</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;div)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of self operator.  <a href="#a793f3f3b66690ef99c8a737850f7c291"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a7a92e3c463e2fbe951824badf0aa2383">operator/</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;div) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator.  <a href="#a7a92e3c463e2fbe951824badf0aa2383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aab106627889397cf17d3ea7a3626e363">operator/=</a> (const T &amp;div)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-scalar division operator.  <a href="#aab106627889397cf17d3ea7a3626e363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ad8deddac45220ce11ba734c5ff4694d0">operator/</a> (const T &amp;div) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar division operator.  <a href="#ad8deddac45220ce11ba734c5ff4694d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aceaf989b21707aa1f00a9d8372cf2551">minimiseLeaves</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change this so that it has the minimum number of leaves necessary to represent the same overall 'shape' (combination of subpaving volumes and values) as before, by recombining any pair of sibling leaves with identical ranges so that their former parent becomes a leaf with the same range as formerly belonged to each child.  <a href="#aceaf989b21707aa1f00a9d8372cf2551"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a4375171ab30bfe88e4a3306f321d3e24">swapMSPSR</a> (<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> &amp;spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the properties of this and another.  <a href="#a4375171ab30bfe88e4a3306f321d3e24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a798b65086b8c8042522fc317e73247a7">nodePrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the details of a specific node in a subpaving.  <a href="#a798b65086b8c8042522fc317e73247a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aa35a5e2e8518004e8feefb3bdea98d53">leafOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the details of a single leaf node, using tab delimiters.  <a href="#aa35a5e2e8518004e8feefb3bdea98d53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a8c3d82f771a9c88493bffc96dd1341ce">_reshapeTreesToUnion</a> (<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape this and  so that both this and rhs have identical shapes after the operation and that shape is the non-minimal union of shape the of this shape and the shape of rhs before the operation.  <a href="#a8c3d82f771a9c88493bffc96dd1341ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a5fc2d7092ac40f04bd0f83f4ee110fdc">_addRanges</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Give this a range equal to range of this and range of other.  <a href="#a5fc2d7092ac40f04bd0f83f4ee110fdc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a78e906fbd5153a29f4de538ccbdc1383">_subtractRanges</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Give this a range equal to range of this - range of other.  <a href="#a78e906fbd5153a29f4de538ccbdc1383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aa9df7035975f4d82aa605e6ac2a1ffe3">_multRanges</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Give this a range equal to range of this * range of other.  <a href="#aa9df7035975f4d82aa605e6ac2a1ffe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a7fb50e0bf02d5d5d5a3753a1ff381ae7">_divRanges</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Give this a range equal to range of this and range of other.  <a href="#a7fb50e0bf02d5d5d5a3753a1ff381ae7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a30fc46b2dd6b0ca4ad703f323a050c7b">_addNonMinimalUnion</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a non-minimal union of subpavings using addition of ranges.  <a href="#a30fc46b2dd6b0ca4ad703f323a050c7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a9880ddfe3c75fe8e7594ee6222040d79">_subtractNonMinimalUnion</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a non-minimal union of subpavings using subtraction of ranges.  <a href="#a9880ddfe3c75fe8e7594ee6222040d79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a9f6b48701e09b97fbd169db927df0758">_multiplyNonMinimalUnion</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a non-minimal union of subpavings using multiplication of ranges.  <a href="#a9f6b48701e09b97fbd169db927df0758"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a29dac80a6e0ecce51b22816ef78a298d">_divideNonMinimalUnion</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a non-minimal union of subpavings using division of ranges.  <a href="#a29dac80a6e0ecce51b22816ef78a298d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a4ef713013762306de2040ac389ec140a">_scalarAdd</a> (const T &amp;add)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment range collection of this.  <a href="#a4ef713013762306de2040ac389ec140a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a91ab734b6f270c26557964473f4977b4">_scalarSubtract</a> (const T &amp;sub)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment range collection of this.  <a href="#a91ab734b6f270c26557964473f4977b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ab716b6d35a31dcba9de12114b3139dc2">_scalarMult</a> (const T &amp;mult)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale up range of this.  <a href="#ab716b6d35a31dcba9de12114b3139dc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a21cbfaf0019ceb215b9c12df05d394f3">_scalarDiv</a> (const T &amp;div)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale down range of this.  <a href="#a21cbfaf0019ceb215b9c12df05d394f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a54fec3e936497db34a821b9138b4ad7b">_slice</a> (const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; cxsc::real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a24ca6f695181dd45e5cf05d22042bb44">sliceCheck</a> (const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check slice parameters and return a full vector of slice points.  <a href="#a24ca6f695181dd45e5cf05d22042bb44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml#acfbd13653a91c69a7091c6e9c18a6d68">oneLineOutput</a> (std::ostream &amp;os, int level) const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class subpavings::MappedSPnode&lt; T &gt;</h3>

<p>A templated derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>. </p>
<p>The base class <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is a node in the representation of a regular subpaving as a binary tree. A node represents a box (interval vector). SPnodes are linked together to form the tree. The initial box of the subpaving is the box represented by the root node of the tree. A box which has been split will be represented as node with one or two children. A subpaving of [<b>x</b>] (union of non-overlapping sub- boxes of [<b>x</b>]) is represented by the leaves (degenerate/ child-less) nodes in the tree.</p>
<p>The <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> template is parameterised on the type T of the range data mapped to (associated with) each node (i.e. with each element of the subpaving). Examples of range data types include reals, or intervals, or colours ...</p>
<p>A <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> node has a single value of type T mapped onto it. This value is referred to as the "range value" or "range".</p>
<p>This templatised class provides ways to perform some basic arithmetic-like operations on the subpaving and the data mapped to it.</p>
<p>It is probably best to regard this class as a class for non-minimal node-trees, ie a node either has two children or no children. The expand method will automatically make two children and there is no way of then creating a minimal tree by cutting off an 'unwanted' child. This means that the whole root paving is regarded as the 'support' of the mapping. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00092">92</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8f23f414976c6bc3409de02288496e04"></a><!-- doxytag: member="subpavings::MappedSPnode::~MappedSPnode" ref="a8f23f414976c6bc3409de02288496e04" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::~<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00102">102</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<a class="anchor" id="acc4eb13ea772050e37b1eae2e560b117"></a><!-- doxytag: member="subpavings::MappedSPnode::MappedSPnode" ref="acc4eb13ea772050e37b1eae2e560b117" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>No-argument constructor. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00107">107</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">{}   <span class="comment">// uses the base SPnode class default constructor</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a5c67c4c7aec0a3ce461b7ac459ad70c2"></a><!-- doxytag: member="subpavings::MappedSPnode::MappedSPnode" ref="a5c67c4c7aec0a3ce461b7ac459ad70c2" args="(const ivector &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a box. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00113">113</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v) {}
</pre></div>
</div>
</div>
<a class="anchor" id="a866ab9d7d7e517e5c403588f12d8e919"></a><!-- doxytag: member="subpavings::MappedSPnode::MappedSPnode" ref="a866ab9d7d7e517e5c403588f12d8e919" args="(const LabBox &amp;lb)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a labeled box. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00120">120</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(lb) {}
</pre></div>
</div>
</div>
<a class="anchor" id="afe15c759857516d725298a1392ab6f07"></a><!-- doxytag: member="subpavings::MappedSPnode::MappedSPnode" ref="afe15c759857516d725298a1392ab6f07" args="(const ivector &amp;v, const T &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a box and a value of T for the range. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00128">128</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v), <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>(r)
    {}
</pre></div>
</div>
</div>
<a class="anchor" id="a5911cc25e5152fe9cced953de14707e7"></a><!-- doxytag: member="subpavings::MappedSPnode::MappedSPnode" ref="a5911cc25e5152fe9cced953de14707e7" args="(const LabBox &amp;lb, const T &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a labeled box and a value of T for the range. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00136">136</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(lb), <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>(r)
    {}
</pre></div>
</div>
</div>
<a class="anchor" id="a528b15231c2a8476fdeb9283137dc9b1"></a><!-- doxytag: member="subpavings::MappedSPnode::MappedSPnode" ref="a528b15231c2a8476fdeb9283137dc9b1" args="(const SPnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies from a plain <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>.</p>
<p>Copies from given node downwards. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00146">146</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>()
    {
    <span class="keywordflow">if</span> (other.theBox != NULL) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector( other.getBox() );
    }
  
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.nodeName;

    <span class="comment">//recursion on the children</span>
    <span class="keywordflow">if</span> (other.leftChild) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#acc4eb13ea772050e37b1eae2e560b117" title="No-argument constructor.">MappedSPnode</a>(
        *(other.getLeftChild())));
    }
    <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

    <span class="keywordflow">if</span> (other.rightChild) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#acc4eb13ea772050e37b1eae2e560b117" title="No-argument constructor.">MappedSPnode</a>(
        *(other.getRightChild())));
    }
    <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3e0ee96e161385b67f5ccc39b4212bdf"></a><!-- doxytag: member="subpavings::MappedSPnode::MappedSPnode" ref="a3e0ee96e161385b67f5ccc39b4212bdf" args="(const MappedSPnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies from a MappedSPnode.</p>
<p>Copies from given node downwards. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00175">175</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>()
    {
    <span class="keywordflow">if</span> (other.theBox != NULL) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector( other.getBox() );
    }
  
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = other.range;
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.nodeName;

    <span class="comment">//recursion on the children</span>
    <span class="keywordflow">if</span> (other.leftChild) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#acc4eb13ea772050e37b1eae2e560b117" title="No-argument constructor.">MappedSPnode</a>(
        *(other.getLeftChild())));
    }
    <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

    <span class="keywordflow">if</span> (other.rightChild) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#acc4eb13ea772050e37b1eae2e560b117" title="No-argument constructor.">MappedSPnode</a>(
        *(other.getRightChild())));
    }
    <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        
    }
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a30fc46b2dd6b0ca4ad703f323a050c7b"></a><!-- doxytag: member="subpavings::MappedSPnode::_addNonMinimalUnion" ref="a30fc46b2dd6b0ca4ad703f323a050c7b" args="(const MappedSPnode&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a30fc46b2dd6b0ca4ad703f323a050c7b">_addNonMinimalUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a non-minimal union of subpavings using addition of ranges. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01180">1180</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00617">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator+=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        
    <span class="comment">//if (rhs == NULL || rhs-&gt;isEmpty()) do nothing</span>
    
    <span class="comment">// should not need to check on rhs here </span>
    <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; !rhs.isEmpty()) {

      *<span class="keyword">this</span> = MappedSPnode&lt;T&gt;(rhs);
    }
        
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() &amp;&amp; !rhs.isEmpty()) {

      <span class="comment">// make copies of rhs to reshape</span>

      MappedSPnode&lt;T&gt; rhsTemp(rhs);

      <span class="comment">// reshape</span>
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a8c3d82f771a9c88493bffc96dd1341ce" title="Reshape this and  so that both this and rhs have identical shapes after the operation and that shape ...">_reshapeTreesToUnion</a>(&amp;rhsTemp);

      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a5fc2d7092ac40f04bd0f83f4ee110fdc" title="Give this a range equal to range of this and range of other.">_addRanges</a>(&amp;rhsTemp);

    }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a5fc2d7092ac40f04bd0f83f4ee110fdc"></a><!-- doxytag: member="subpavings::MappedSPnode::_addRanges" ref="a5fc2d7092ac40f04bd0f83f4ee110fdc" args="(const MappedSPnode&lt; T &gt; *const other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a5fc2d7092ac40f04bd0f83f4ee110fdc">_addRanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give this a range equal to range of this and range of other. </p>
<p>Assumes that this and other are the same from leaves up to this and other, i.e. are roots of trees of the same shape up to the depth of this Note that other could be a taller trees than this: range collections are only combined up to the level of this. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01076">1076</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01180">subpavings::MappedSPnode&lt; cxsc::real &gt;::_addNonMinimalUnion()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (other == NULL) {
      <span class="keywordflow">throw</span> NullSubpavingPointer_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_addRanges(const MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }

    <span class="comment">// recurse on the children if any first</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_addRanges(
                          other-&gt;getLeftChild());
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_addRanges(
                          other-&gt;getRightChild());

    }

    <span class="comment">// deal with this range collection</span>
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> + other-&gt;range;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a29dac80a6e0ecce51b22816ef78a298d"></a><!-- doxytag: member="subpavings::MappedSPnode::_divideNonMinimalUnion" ref="a29dac80a6e0ecce51b22816ef78a298d" args="(const MappedSPnode&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a29dac80a6e0ecce51b22816ef78a298d">_divideNonMinimalUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a non-minimal union of subpavings using division of ranges. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this and *rhs are non-empty and and range collections same size. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01263">1263</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00842">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator/=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) || rhs.isEmpty()) {

      <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_divideNonMinimalUnion(const MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }
    
        <span class="comment">// make copies of rhs to reshape</span>

    MappedSPnode&lt;T&gt; rhsTemp(rhs);

    <span class="comment">// reshape</span>
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a8c3d82f771a9c88493bffc96dd1341ce" title="Reshape this and  so that both this and rhs have identical shapes after the operation and that shape ...">_reshapeTreesToUnion</a>(&amp;rhsTemp);

    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a7fb50e0bf02d5d5d5a3753a1ff381ae7" title="Give this a range equal to range of this and range of other.">_divRanges</a>(&amp;rhsTemp);

  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7fb50e0bf02d5d5d5a3753a1ff381ae7"></a><!-- doxytag: member="subpavings::MappedSPnode::_divRanges" ref="a7fb50e0bf02d5d5d5a3753a1ff381ae7" args="(const MappedSPnode&lt; T &gt; *const other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a7fb50e0bf02d5d5d5a3753a1ff381ae7">_divRanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give this a range equal to range of this and range of other. </p>
<p>Assumes that this and other are the same from leaves up to this and other, i.e. are roots of trees of the same shape up to the depth of this Note that other could be a taller trees than this: range collections are only combined up to the level of this. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01154">1154</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01263">subpavings::MappedSPnode&lt; cxsc::real &gt;::_divideNonMinimalUnion()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (other == NULL) {
      <span class="keywordflow">throw</span> NullSubpavingPointer_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_divRanges(const MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }

    <span class="comment">// recurse on the children if any first</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_divRanges(
                          other-&gt;getLeftChild());
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_divRanges(
                          other-&gt;getRightChild());

    }

    <span class="comment">// deal with this range collection</span>
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> / other-&gt;range;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a9f6b48701e09b97fbd169db927df0758"></a><!-- doxytag: member="subpavings::MappedSPnode::_multiplyNonMinimalUnion" ref="a9f6b48701e09b97fbd169db927df0758" args="(const MappedSPnode&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a9f6b48701e09b97fbd169db927df0758">_multiplyNonMinimalUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a non-minimal union of subpavings using multiplication of ranges. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this and *rhs are non-empty and and range collections same size. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01237">1237</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00764">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator*=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="comment">// should not need to check on rhs not null here </span>
    <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) || rhs.isEmpty()) {

      <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_multiplyNonMinimalUnion(const MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }
    
        <span class="comment">// make copies of rhs to reshape</span>

    MappedSPnode&lt;T&gt; rhsTemp(rhs);

    <span class="comment">// reshape</span>
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a8c3d82f771a9c88493bffc96dd1341ce" title="Reshape this and  so that both this and rhs have identical shapes after the operation and that shape ...">_reshapeTreesToUnion</a>(&amp;rhsTemp);

    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#aa9df7035975f4d82aa605e6ac2a1ffe3" title="Give this a range equal to range of this * range of other.">_multRanges</a>(&amp;rhsTemp);

  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa9df7035975f4d82aa605e6ac2a1ffe3"></a><!-- doxytag: member="subpavings::MappedSPnode::_multRanges" ref="aa9df7035975f4d82aa605e6ac2a1ffe3" args="(const MappedSPnode&lt; T &gt; *const other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aa9df7035975f4d82aa605e6ac2a1ffe3">_multRanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give this a range equal to range of this * range of other. </p>
<p>Assumes that this and other are the same from leaves up to this and other, i.e. are roots of trees of the same shape up to the depth of this Note that other could be a taller trees than this: range collections are only combined up to the level of this. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01128">1128</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01237">subpavings::MappedSPnode&lt; cxsc::real &gt;::_multiplyNonMinimalUnion()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (other == NULL) {
      <span class="keywordflow">throw</span> NullSubpavingPointer_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_multRanges(const MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }

    <span class="comment">// recurse on the children if any first</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_multRanges(
                          other-&gt;getLeftChild());
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_multRanges(
                          other-&gt;getRightChild());

    }

    <span class="comment">// deal with this range collection</span>
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> * other-&gt;range;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a8c3d82f771a9c88493bffc96dd1341ce"></a><!-- doxytag: member="subpavings::MappedSPnode::_reshapeTreesToUnion" ref="a8c3d82f771a9c88493bffc96dd1341ce" args="(MappedSPnode&lt; T &gt; *const rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a8c3d82f771a9c88493bffc96dd1341ce">_reshapeTreesToUnion</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reshape this and  so that both this and rhs have identical shapes after the operation and that shape is the non-minimal union of shape the of this shape and the shape of rhs before the operation. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01038">1038</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01180">subpavings::MappedSPnode&lt; cxsc::real &gt;::_addNonMinimalUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01263">subpavings::MappedSPnode&lt; cxsc::real &gt;::_divideNonMinimalUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01237">subpavings::MappedSPnode&lt; cxsc::real &gt;::_multiplyNonMinimalUnion()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01211">subpavings::MappedSPnode&lt; cxsc::real &gt;::_subtractNonMinimalUnion()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (rhs == NULL) {

      <span class="keywordflow">throw</span> NullSubpavingPointer_Error(
      <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_reshapeTreesToUnion(MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }

    <span class="comment">// this is not a leaf, rhs is a leaf</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; rhs-&gt;isLeaf()) {

      <span class="comment">//we need to expand rhs</span>
      rhs-&gt;nodeExpand();
    }

    <span class="comment">// this is a leaf, rhs is not a leaf</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !rhs-&gt;isLeaf()) {

      <span class="comment">//we need to expand this</span>
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a26af7ee7d7e9c00623dea9e6aed02d92" title="Add two sibling nodes to this provided this is a leaf.">nodeExpand</a>();
    }

    <span class="comment">// we have made sure that if at least one of them was not a leaf,</span>
    <span class="comment">// then neither are now leaves</span>
    <span class="comment">// now recurse on the children</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !rhs-&gt;isLeaf()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_reshapeTreesToUnion(rhs-&gt;getLeftChild());
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_reshapeTreesToUnion(rhs-&gt;getRightChild());

    }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a4ef713013762306de2040ac389ec140a"></a><!-- doxytag: member="subpavings::MappedSPnode::_scalarAdd" ref="a4ef713013762306de2040ac389ec140a" args="(const T &amp;add)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a4ef713013762306de2040ac389ec140a">_scalarAdd</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>add</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment range collection of this. </p>
<p>Increment range by type T scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>the scalar increment, of same type as range, to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01288">1288</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00658">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator+=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> + add;
      <span class="comment">// recurse on children</span>
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_scalarAdd(add);
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_scalarAdd(add);
    }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a21cbfaf0019ceb215b9c12df05d394f3"></a><!-- doxytag: member="subpavings::MappedSPnode::_scalarDiv" ref="a21cbfaf0019ceb215b9c12df05d394f3" args="(const T &amp;div)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a21cbfaf0019ceb215b9c12df05d394f3">_scalarDiv</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale down range of this. </p>
<p>Division this range by type T scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">div</td><td>the scalar divisor, of same type as range, to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01343">1343</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00886">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator/=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> / div;
      <span class="comment">// recurse on children</span>
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_scalarDiv(div);
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_scalarDiv(div);
    }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab716b6d35a31dcba9de12114b3139dc2"></a><!-- doxytag: member="subpavings::MappedSPnode::_scalarMult" ref="ab716b6d35a31dcba9de12114b3139dc2" args="(const T &amp;mult)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ab716b6d35a31dcba9de12114b3139dc2">_scalarMult</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mult</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale up range of this. </p>
<p>Multiplication this range by type T scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mult</td><td>the scalar multiplier, of same type as range, to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01325">1325</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00810">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator*=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> * mult;
      <span class="comment">// recurse on children</span>
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_scalarMult(mult);
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_scalarMult(mult);
    }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a91ab734b6f270c26557964473f4977b4"></a><!-- doxytag: member="subpavings::MappedSPnode::_scalarSubtract" ref="a91ab734b6f270c26557964473f4977b4" args="(const T &amp;sub)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a91ab734b6f270c26557964473f4977b4">_scalarSubtract</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment range collection of this. </p>
<p>Increment range by type T scalar. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>the scalar increment, of same type as range, to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01306">1306</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00733">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator-=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> - sub;
      <span class="comment">// recurse on children</span>
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_scalarSubtract(sub);
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>())
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_scalarSubtract(sub);
    }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a54fec3e936497db34a821b9138b4ad7b"></a><!-- doxytag: member="subpavings::MappedSPnode::_slice" ref="a54fec3e936497db34a821b9138b4ad7b" args="(const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a54fec3e936497db34a821b9138b4ad7b">_slice</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cxsc::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>slicePts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">1357</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00465">subpavings::RealMappedSPnode::makeSlice()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00447">subpavings::RealMappedSPnode::slice()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l00519">subpavings::MappedSPnode&lt; cxsc::real &gt;::slice()</a>.</p>
<div class="fragment"><pre class="fragment">  {
<span class="preprocessor">    #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;In MappedSPnodeSR&lt;T&gt;::slice, I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="keywordtype">bool</span> splitOnSliceDim = <span class="keyword">false</span>;
    
    <span class="keywordtype">int</span> splitDim = -1;
    
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\tI am not a leaf: get split dim&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      <span class="comment">/* Check whether we split on a split dim</span>
<span class="comment">        before we do anything to the children*/</span>
      splitDim = <a class="code" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371" title="Get the split dimension for this.">getSplitDim</a>();
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\tsplitDim = &quot;</span> &lt;&lt; splitDim &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      std::vector&lt; int &gt;::const_iterator found 
        = find (sliceDims.begin(), sliceDims.end(), splitDim);
    
      <span class="comment">// can we find splitDim in the sliceDims?</span>
      splitOnSliceDim = (found &lt; sliceDims.end()); 
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\tsplitOnSliceDim = &quot;</span> &lt;&lt; splitOnSliceDim &lt;&lt; std::endl;
<span class="preprocessor">      #endif </span>
<span class="preprocessor"></span>    }
    
    <span class="comment">/* if I am a leaf, or did not split on a slice dimension,</span>
<span class="comment">     * adjust the box */</span> 
    <span class="keywordflow">if</span> (!splitOnSliceDim) {
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\tI did not split on a dimension to take out, or I am a leaf: first deal with children ...&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
        <span class="comment">// Slice on the children first</span>
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_slice(sliceDims, slicePts);
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_slice(sliceDims, slicePts);
      }
      
      <span class="comment">// now deal with this node itself</span>
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;\nback in &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
          std::cout &lt;&lt; <span class="stringliteral">&quot;\tI did not split on a dimension to take out, or I am a leaf, so need to contract box&quot;</span> &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy split dimension is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371" title="Get the split dimension for this.">getSplitDim</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy box is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy range is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
      <span class="keywordtype">int</span> dim = VecLen(box);
      <span class="keywordtype">int</span> boxLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
    
      <span class="keywordtype">int</span> newDims = dim - sliceDims.size();
      ivector newBox = ivector(newDims); 
      <span class="keywordtype">int</span> index = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(newBox);
      <span class="keywordtype">int</span> oldindex = boxLB;
    
      <span class="comment">// put in the upper and lower bounds for the new box</span>
      <span class="comment">// for each dimension that stays  </span>
      <span class="keywordflow">for</span> (; oldindex &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(box); oldindex++) {
        std::vector&lt;int&gt;::const_iterator fit 
        = find (sliceDims.begin(), sliceDims.end(), (oldindex - boxLB + 1));
        <span class="keywordflow">if</span> (!(fit &lt; sliceDims.end())) { <span class="comment">// keep this one</span>
          newBox[index] = box[oldindex];
          index++;
        }
      }
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\tnew box is &quot;</span> &lt;&lt; newBox &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      <span class="comment">//store the child node locations and then temporarily detach them</span>
      MappedSPnode &lt;T&gt;* savedLC = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>();
      MappedSPnode &lt;T&gt;* savedRC = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>();
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
      
      <span class="comment">// also need to store parent</span>
      MappedSPnode &lt;T&gt;* savedParent = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef" title="Accessor for the parent of a node.">getParent</a>();
      <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = NULL;
      
      T temp = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>();
      
      <span class="comment">// replace contents of this with contents of a newly made node  </span>
      MappedSPnode &lt;T&gt; tempNode(newBox, temp);
      this-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a4375171ab30bfe88e4a3306f321d3e24" title="Swap the properties of this and another.">swapMSPSR</a>(tempNode);
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\tafter contracting, my box is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\n\tmy range is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      <span class="comment">// put the child pointers back, and reattach to parent</span>
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = savedLC;
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = savedRC;
      <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = savedParent;
      
    }
    <span class="keywordflow">else</span> {
    
      <span class="comment">/* if we split on any of the slice dimensions</span>
<span class="comment">         then we drop this from the tree entirely and</span>
<span class="comment">         replace it with the child who actually contains the slice */</span>
        
      <span class="comment">/*to do this, we just have to know where we split and look at the slice</span>
<span class="comment">       * points on the same dimension and see if they are above or below our</span>
<span class="comment">       * split. We know we are not a leaf if we are in here at all.  */</span>
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;I DID split on a dimension to take out (so I can&#39;t be a leaf)&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">      #endif </span>
<span class="preprocessor"></span>      
      real splitValue = Sup(<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()[splitDim]);  
      
      real slPt = slicePts.at(splitDim-1); <span class="comment">// vectors indexed 0 - n-1</span>
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;split dimension is &quot;</span> &lt;&lt; splitDim &lt;&lt; <span class="stringliteral">&quot; and split value is &quot;</span> &lt;&lt; splitValue &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;slPt = slicePts.at(splitDim-1) is &quot;</span> &lt;&lt; slPt &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      MappedSPnode &lt;T&gt; temp;
      
      <span class="comment">// save parent</span>
      MappedSPnode &lt;T&gt;* savedParent = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef" title="Accessor for the parent of a node.">getParent</a>();
      <span class="comment">// detach from parent temporarily</span>
      <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = NULL;
        
      <span class="keywordflow">if</span> (slPt &lt; splitValue) { <span class="comment">// crucial slice point is in left child</span>
      
<span class="preprocessor">        #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;slPt is in left child&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
          std::cout &lt;&lt; <span class="stringliteral">&quot;need to do getLeftChild()-&gt;_slice(sliceDims, slicePts) and then copy it &quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>        
        <span class="comment">// Slice on the left child</span>
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_slice(sliceDims, slicePts);
        
        <span class="comment">// copy left child</span>
        temp = *<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>();
      }
      <span class="keywordflow">else</span> { <span class="comment">// crucial slice point is in right child</span>
      
<span class="preprocessor">        #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;slPt is in right child&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
          std::cout &lt;&lt; <span class="stringliteral">&quot;need to do getRightChild()-&gt;_slice(sliceDims, slicePts) and then copy it &quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>        
        <span class="comment">// Slice on the right child</span>
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_slice(sliceDims, slicePts);
        
        <span class="comment">// copy left child</span>
        temp = *<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>();
      }
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\nback in &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tNow copy the temp into me&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy split dimension is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371" title="Get the split dimension for this.">getSplitDim</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy box is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy range is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a4375171ab30bfe88e4a3306f321d3e24" title="Swap the properties of this and another.">swapMSPSR</a>(temp); <span class="comment">//swap me and temp</span>
        
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\tre-made me out of copy of child that is sliced:&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy name (before renaming) is now &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy range is now &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tand my box is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;\tand my children (before renaming) are:&quot;</span> &lt;&lt; std::endl;
          <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;oneLineOutput(std::cout, 2);
          <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;oneLineOutput(std::cout, 2);
        }
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      <span class="comment">// restore relationship to parent</span>
      <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = savedParent;
        
        
        
    }<span class="comment">// end else</span>
    
    <span class="comment">//if we are the root, recursively rename everything</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef" title="Accessor for the parent of a node.">getParent</a>() == NULL) {
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<span class="stringliteral">&quot;X&quot;</span>); <span class="comment">// my name might be wrong</span>
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>();
<span class="preprocessor">      #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\nNow recursively rename everything from me down\n\n&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>    }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a9880ddfe3c75fe8e7594ee6222040d79"></a><!-- doxytag: member="subpavings::MappedSPnode::_subtractNonMinimalUnion" ref="a9880ddfe3c75fe8e7594ee6222040d79" args="(const MappedSPnode&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a9880ddfe3c75fe8e7594ee6222040d79">_subtractNonMinimalUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a non-minimal union of subpavings using subtraction of ranges. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this and *rhs are non-empty and and range collections same size. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01211">1211</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00690">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator-=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// should not need to check on rhs not null here </span>
    <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) || rhs.isEmpty()) {

      <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_subtractNonMinimalUnion(const MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }
    
    <span class="comment">// make copies of rhs to reshape</span>

    MappedSPnode&lt;T&gt; rhsTemp(rhs);

    <span class="comment">// reshape</span>
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a8c3d82f771a9c88493bffc96dd1341ce" title="Reshape this and  so that both this and rhs have identical shapes after the operation and that shape ...">_reshapeTreesToUnion</a>(&amp;rhsTemp);

    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a78e906fbd5153a29f4de538ccbdc1383" title="Give this a range equal to range of this - range of other.">_subtractRanges</a>(&amp;rhsTemp);

  }
</pre></div>
</div>
</div>
<a class="anchor" id="a78e906fbd5153a29f4de538ccbdc1383"></a><!-- doxytag: member="subpavings::MappedSPnode::_subtractRanges" ref="a78e906fbd5153a29f4de538ccbdc1383" args="(const MappedSPnode&lt; T &gt; *const other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a78e906fbd5153a29f4de538ccbdc1383">_subtractRanges</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give this a range equal to range of this - range of other. </p>
<p>Assumes that this and other are the same from leaves up to this and other, i.e. are roots of trees of the same shape up to the depth of this Note that other could be a taller trees than this: range collections are only combined up to the level of this. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01102">1102</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01211">subpavings::MappedSPnode&lt; cxsc::real &gt;::_subtractNonMinimalUnion()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (other == NULL) {
      <span class="keywordflow">throw</span> NullSubpavingPointer_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::_subtractRanges(const MappedSPnode&lt;T&gt; * const)&quot;</span>);
    }

    <span class="comment">// recurse on the children if any first</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;_subtractRanges(
                          other-&gt;getLeftChild());
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;_subtractRanges(
                          other-&gt;getRightChild());

    }

    <span class="comment">// deal with this range collection</span>
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> - other-&gt;range;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a829001293a30ff276a50cf518893ad7f"></a><!-- doxytag: member="subpavings::MappedSPnode::acceptSPExpandVisitor" ref="a829001293a30ff276a50cf518893ad7f" args="(const SPExpandVisitor&lt; T &gt; &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a829001293a30ff276a50cf518893ad7f">acceptSPExpandVisitor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPExpandVisitor.shtml">SPExpandVisitor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept a <a class="el" href="classsubpavings_1_1SPExpandVisitor.shtml">SPExpandVisitor</a>. </p>
<p>If this is a leaf, and if the node is willing to split, accepts the visitor and sets the range equal to the value returned by the visitor's visit operation, then recursively asks children to accept visitor too.</p>
<p>The node's willingness to split is based on the results of the <a class="el" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode()</a> method.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>a visitor capable of expanding this according to its own criteria and also of returning a value to used as the range of this. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">553</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>.</p>
<div class="fragment"><pre class="fragment">  {
<span class="preprocessor">    #ifdef MYDEBUGVISITOR</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;Using mappedspnode_sr expander accept&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="comment">// only accept the visit if this is a leaf and the node is splittable</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode</a>()) {
      <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = visitor.visit(<span class="keyword">this</span>);
<span class="preprocessor">      #ifdef MYDEBUGVISITOR</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;after visit, range value = &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>    }
    
    
<span class="preprocessor">    #ifdef MYDEBUGVISITOR</span>
<span class="preprocessor"></span>      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">isSplittableNode</a>()) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;box is too small to split: volume is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>() &lt;&lt; std::endl;
      }
    
      <span class="keywordflow">if</span>(!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) std::cout &lt;&lt; <span class="stringliteral">&quot;now visit children&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a829001293a30ff276a50cf518893ad7f" title="Accept a SPExpandVisitor.">acceptSPExpandVisitor</a>(visitor);
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a829001293a30ff276a50cf518893ad7f" title="Accept a SPExpandVisitor.">acceptSPExpandVisitor</a>(visitor);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ab3d7c0ce1aa100e48554605b9c9c3ac7"></a><!-- doxytag: member="subpavings::MappedSPnode::acceptSPValueVisitor" ref="ab3d7c0ce1aa100e48554605b9c9c3ac7" args="(const SPValueVisitor&lt; T &gt; &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ab3d7c0ce1aa100e48554605b9c9c3ac7">acceptSPValueVisitor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPValueVisitor.shtml">SPValueVisitor</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accept a <a class="el" href="classsubpavings_1_1SPValueVisitor.shtml">SPValueVisitor</a> visitor. </p>
<p>Accepts the visitor and sets the range equal to the value returned by the vistor's visit operation.</p>
<p>Recursively asks children to accept visitor too.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>a visitor capable of returning a value to be used as the range of this. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">589</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>.</p>
<div class="fragment"><pre class="fragment">  {
<span class="preprocessor">    #ifdef MYDEBUGVISITORE</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;Using mappedspnode_sr valuer accept &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = visitor.visit(<span class="keyword">this</span>);
<span class="preprocessor">    #ifdef MYDEBUGVISITORE</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;after visit, range value = &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
<span class="preprocessor">    #ifdef MYDEBUGVISITORE</span>
<span class="preprocessor"></span>      <span class="keywordflow">if</span>(!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) std::cout &lt;&lt; <span class="stringliteral">&quot;now visit children&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#ab3d7c0ce1aa100e48554605b9c9c3ac7" title="Accept a SPValueVisitor visitor.">acceptSPValueVisitor</a>(visitor);
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#ab3d7c0ce1aa100e48554605b9c9c3ac7" title="Accept a SPValueVisitor visitor.">acceptSPValueVisitor</a>(visitor);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a3f0d891bb2650f6558cc4081ce5102c6"></a><!-- doxytag: member="subpavings::MappedSPnode::allocateRanges" ref="a3f0d891bb2650f6558cc4081ce5102c6" args="(const std::vector&lt; T &gt; &amp;rangesToAllocate, size_t index=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3f0d891bb2650f6558cc4081ce5102c6">allocateRanges</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rangesToAllocate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively allocate a collection of ranges to this and children. </p>
<p>Throws a std::invalid_argument if there are fewer values in <em>rangesToAllocate</em> than there are nodes in this.</p>
<p>Allocation order is this, left child with remainder of allocation, right child with remainder.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rangesToAllocate</td><td>a collection of range values to apply to the nodes of the tree rooted at this. </td></tr>
    <tr><td class="paramname">index</td><td>is the index of the value in <em>rangesToAllocate</em> to become the value of the range for this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>rangesToAllocate.size() - index &gt;= number of nodes in tree rooted at this. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The nodes in the tree rooted at this have values taken from the values in <em>rangesToAllocate</em>, starting at the value indexed <em>index</em> which is applied to this, then allocating the following values to the left child of this and its descendants and then the right child of this and its descendants. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">299</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="MappedSPSamplingGaussian_8cpp_source.shtml#l00213">doMCMCGRAuto()</a>, <a class="el" href="ExColour2D_8cpp_source.shtml#l00036">main()</a>, <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00189">testingIntervals()</a>, <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00028">testingInts()</a>, <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00108">testingReals()</a>, and <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00277">testingRvectors()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="keywordflow">if</span> (index &gt;= rangesToAllocate.size()) {
      <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Range allocations too short&quot;</span>);

    }

    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = rangesToAllocate[index];

    std::size_t newIndex = index+1;
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
      newIndex = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;allocateRanges(rangesToAllocate, newIndex);
    }
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
      newIndex = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;allocateRanges(rangesToAllocate, newIndex);
    }

    <span class="comment">// have done all the children</span>
    <span class="comment">// if this is the root, want to check we have used all the allocations</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef" title="Accessor for the parent of a node.">getParent</a>()) {
      <span class="keywordflow">if</span> (newIndex &lt; rangesToAllocate.size()) {
        <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;More ranges than nodes in tree&quot;</span>);
      }

    }

    <span class="keywordflow">return</span> newIndex;
  
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a31cc4a453d0c821592096b1829e43093"></a><!-- doxytag: member="subpavings::MappedSPnode::getLeftChild" ref="a31cc4a453d0c821592096b1829e43093" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;* <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093">getLeftChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the left child of a node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the pointer to leftChild node, cast to this type. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00225">225</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01076">subpavings::MappedSPnode&lt; cxsc::real &gt;::_addRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01154">subpavings::MappedSPnode&lt; cxsc::real &gt;::_divRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01128">subpavings::MappedSPnode&lt; cxsc::real &gt;::_multRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01038">subpavings::MappedSPnode&lt; cxsc::real &gt;::_reshapeTreesToUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01288">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarAdd()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01343">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarDiv()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01325">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarMult()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01306">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarSubtract()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01102">subpavings::MappedSPnode&lt; cxsc::real &gt;::_subtractRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">subpavings::MappedSPnode&lt; cxsc::real &gt;::allocateRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00175">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeStringSummary()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">subpavings::MappedSPnode&lt; cxsc::real &gt;::oneLineOutput()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00161">subpavings::RealMappedSPnode::RealMappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (MappedSPnode&lt;T&gt;*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a700d3bf53c72e2fdecf27446fab902ef"></a><!-- doxytag: member="subpavings::MappedSPnode::getParent" ref="a700d3bf53c72e2fdecf27446fab902ef" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;* <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef">getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the parent of a node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the pointer to parent node, cast to this type. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00218">218</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">subpavings::MappedSPnode&lt; cxsc::real &gt;::allocateRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeStringSummary()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01591">subpavings::MappedSPnode&lt; cxsc::real &gt;::sliceCheck()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (MappedSPnode&lt;T&gt;*) <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a3e5c6ff11f8640c1a7b3a363e9f841bd"></a><!-- doxytag: member="subpavings::MappedSPnode::getRange" ref="a3e5c6ff11f8640c1a7b3a363e9f841bd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd">getRange</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the range. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the range. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">239</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">subpavings::RealMappedSPnode::_getL1distance()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00256">subpavings::RealMappedSPnode::operator&lt;()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00134">subpavings::RealMappedSPnode::RealMappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">    {   
        <span class="keywordflow">return</span> T(<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3d15d4b64a8c01fbfabdb66c37c89ad9"></a><!-- doxytag: member="subpavings::MappedSPnode::getRightChild" ref="a3d15d4b64a8c01fbfabdb66c37c89ad9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;* <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9">getRightChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the right child of a node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a copy of the pointer to rightChild node, cast this type. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00232">232</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01076">subpavings::MappedSPnode&lt; cxsc::real &gt;::_addRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01154">subpavings::MappedSPnode&lt; cxsc::real &gt;::_divRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01128">subpavings::MappedSPnode&lt; cxsc::real &gt;::_multRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01038">subpavings::MappedSPnode&lt; cxsc::real &gt;::_reshapeTreesToUnion()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01288">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarAdd()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01343">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarDiv()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01325">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarMult()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01306">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarSubtract()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01102">subpavings::MappedSPnode&lt; cxsc::real &gt;::_subtractRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">subpavings::MappedSPnode&lt; cxsc::real &gt;::allocateRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00175">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeStringSummary()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">subpavings::MappedSPnode&lt; cxsc::real &gt;::oneLineOutput()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00161">subpavings::RealMappedSPnode::RealMappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (MappedSPnode&lt;T&gt;*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="aa35a5e2e8518004e8feefb3bdea98d53"></a><!-- doxytag: member="subpavings::MappedSPnode::leafOutputTabs" ref="aa35a5e2e8518004e8feefb3bdea98d53" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aa35a5e2e8518004e8feefb3bdea98d53">leafOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the details of a single leaf node, using tab delimiters. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01005">1005</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

      <span class="comment">// output the nodeName, nodeVolume</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            real vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;

            <span class="comment">// followed by the range</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>;

            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
      os &lt;&lt; std::flush;
      
        }
    <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aceaf989b21707aa1f00a9d8372cf2551"></a><!-- doxytag: member="subpavings::MappedSPnode::minimiseLeaves" ref="aceaf989b21707aa1f00a9d8372cf2551" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#aceaf989b21707aa1f00a9d8372cf2551">minimiseLeaves</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change this so that it has the minimum number of leaves necessary to represent the same overall 'shape' (combination of subpaving volumes and values) as before, by recombining any pair of sibling leaves with identical ranges so that their former parent becomes a leaf with the same range as formerly belonged to each child. </p>
<p>Eg a node with two leafs where both children have the same value <img class="formulaInl" alt="$ r $" src="form_18.png"/> mapped to them can be represented as a single leaf with the value <img class="formulaInl" alt="$ r $" src="form_18.png"/> mapped to it. minimiseLeaves can be used after arithmetic operations on nodes to deal with cases where sibling leaf nodes in the result are equivalent in terms of their range values.</p>
<p>The minimisation process works from the leaves upwards, so that a tree could potentially be reduced to a single node if every pair of sibling leaves encountered in the process can be recombined. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">927</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// can&#39;t do anything if this is a leaf</span>
      
      <span class="comment">// recurse first</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() ) <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;minimiseLeaves();
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() ) <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;minimiseLeaves();
      
      <span class="comment">// now do me</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc" title="find if this node is a subleaf node.">isSubLeaf</a>() &amp;&amp; 
        (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>() == <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>()) ) {
        
          <span class="comment">// make this range collection one of the childrens</span>
          <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;getRange();
          <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>;
          <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
          <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;
          <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
      }
    
    }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a817b05cc2d60ff0ee1a98b0addf54131"></a><!-- doxytag: member="subpavings::MappedSPnode::nodeExpand" ref="a817b05cc2d60ff0ee1a98b0addf54131" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a817b05cc2d60ff0ee1a98b0addf54131">nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two sibling nodes to this provided this is a leaf. </p>
<p>Creates two children each with half of the box of this. Split the box in half normal to dimension set by comp. comp argument is passed to <a class="el" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper()</a> and <a class="el" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower()</a></p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the dimension on which to bisect this to create children. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4d0129dda149a950a06e9d2e3ff802c4">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">421</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01038">subpavings::MappedSPnode&lt; cxsc::real &gt;::_reshapeTreesToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// can only expand if there is a box</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
      <span class="keywordflow">throw</span> NoBox_Error(<span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::nodeExpand(int)&quot;</span>);
    }
    
    <span class="comment">// only do something if this node is a leaf</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
      
      MappedSPnode&lt;T&gt;* newLC = NULL;
      MappedSPnode&lt;T&gt;* newRC = NULL;
      
      <span class="keywordflow">try</span> {
        <span class="comment">// ivectors to become boxes for new children</span>
        ivector lC, rC;
        <span class="comment">// Call Lower() and Upper() to put split boxes</span>
        <span class="comment">// into lC and rC respectively</span>
        <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lC, comp);
        <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rC, comp);

        <span class="comment">// make and add the new children</span>
        newLC = <span class="keyword">new</span> MappedSPnode&lt;T&gt;(lC, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>);
        newRC = <span class="keyword">new</span> MappedSPnode&lt;T&gt;(rC, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>);
        
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(newLC);
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(newRC);
        <span class="comment">// both children get the same range as this</span>
        
        <span class="comment">//name the new children</span>
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;setNodeName(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;setNodeName(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);

        <span class="comment">// new children have range collection from this</span>
      }
      <span class="keywordflow">catch</span>(std::exception&amp; e) {
      <span class="comment">// overkill, but try to deal with all eventualities...</span>
        <span class="keywordflow">try</span> {
          <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>() != NULL) {
            <span class="keyword">delete</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>());
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
          }
          
          <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>() != NULL) {
            <span class="keyword">delete</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>());
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
          }
          <span class="keywordflow">if</span> (newLC != NULL) {
            <span class="keyword">delete</span> newLC;
            newLC = NULL;
          }
          <span class="keywordflow">if</span> (newRC != NULL) {
            <span class="keyword">delete</span> newRC;
            newRC = NULL;
          }
        }
        <span class="keywordflow">catch</span>(std::exception&amp; e) {} <span class="comment">//catch and swallow</span>
        
        <span class="keywordflow">throw</span>; <span class="comment">// rethrow original exception</span>
      }
    }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a26af7ee7d7e9c00623dea9e6aed02d92"></a><!-- doxytag: member="subpavings::MappedSPnode::nodeExpand" ref="a26af7ee7d7e9c00623dea9e6aed02d92" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a817b05cc2d60ff0ee1a98b0addf54131">nodeExpand</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two sibling nodes to this provided this is a leaf. </p>
<p>Creates two children each with half of the box of this. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ad60865bacd8a43978cf2da02419cbf8f">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00489">489</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01038">subpavings::MappedSPnode&lt; cxsc::real &gt;::_reshapeTreesToUnion()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l00489">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a26af7ee7d7e9c00623dea9e6aed02d92" title="Add two sibling nodes to this provided this is a leaf.">nodeExpand</a>(maxdiamcomp); <span class="comment">// complete nodeExpand</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a798b65086b8c8042522fc317e73247a7"></a><!-- doxytag: member="subpavings::MappedSPnode::nodePrint" ref="a798b65086b8c8042522fc317e73247a7" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a798b65086b8c8042522fc317e73247a7">nodePrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the details of a specific node in a subpaving. </p>
<p>Prints: nodeName [tab] "Box is" [tab] ... each interval in the box in cxsc output format ... [tab] "Box volume is" [tab] volume [tab] "range data is" [tab] range [newline]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>the stream to print to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#aaf14185437d50e955c5ea938dc6e7559">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00977">977</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// output for box in form:</span>
        <span class="comment">// box, volume, summary data</span>

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

      os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> &lt;&lt; <span class="stringliteral">&quot;\tBox is:\t&quot;</span>;

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
                <span class="comment">// c-xsc default output for intervals</span>
                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; thisBox[i];   }

            os &lt;&lt; <span class="stringliteral">&quot;\tBox volume is:\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\trange data:\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
    }
        <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ae4b153a0ff33397c3537f1ce9d87b743"></a><!-- doxytag: member="subpavings::MappedSPnode::nodeStringSummary" ref="ae4b153a0ff33397c3537f1ce9d87b743" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#ae4b153a0ff33397c3537f1ce9d87b743">nodeStringSummary</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a string summary of this. </p>
<p>Used for debugging. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">258</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">  {
    std::ostringstream oss;
    
    oss &lt;&lt; <span class="stringliteral">&quot;I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; <span class="stringliteral">&quot;(address &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="stringliteral">&quot;),\n&quot;</span>;
    oss &lt;&lt; <span class="stringliteral">&quot;Dimension is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a4caf34bf9db0dc8f116797149be0cf8b" title="Accessor for the dimension of theBox of a node.">getDimension</a>() &lt;&lt; <span class="stringliteral">&quot;, address of box is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; 
    oss &lt;&lt; <span class="stringliteral">&quot;range is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
    oss &lt;&lt; <span class="stringliteral">&quot;my parent is &quot;</span>;
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef" title="Accessor for the parent of a node.">getParent</a>() != NULL) oss &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef" title="Accessor for the parent of a node.">getParent</a>()-&gt;getNodeName();
    <span class="keywordflow">else</span> oss &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>; 
    oss &lt;&lt; <span class="stringliteral">&quot;, my left child is &quot;</span>;
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>() != NULL) oss &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;getNodeName();
    <span class="keywordflow">else</span> oss &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>; 
    oss &lt;&lt; <span class="stringliteral">&quot;, my right child is &quot;</span>;
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>() != NULL) oss &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;getNodeName();
    <span class="keywordflow">else</span> oss &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>;
    
    <span class="keywordflow">return</span> oss.str();
    
  }
</pre></div>
</div>
</div>
<a class="anchor" id="acfbd13653a91c69a7091c6e9c18a6d68"></a><!-- doxytag: member="subpavings::MappedSPnode::oneLineOutput" ref="acfbd13653a91c69a7091c6e9c18a6d68" args="(std::ostream &amp;os, int level) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#acfbd13653a91c69a7091c6e9c18a6d68">oneLineOutput</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5287c7cec21af1c8606d735c0478a6fc">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">1675</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="comment">// do me</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; level; ++i) { os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>; }
    os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; <span class="stringliteral">&quot;\tRange: &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> 
                  &lt;&lt; <span class="stringliteral">&quot;\tbox: &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
    
    <span class="comment">// do children</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;oneLineOutput(os, level+1);
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;oneLineOutput(os, level+1);
    
    <span class="keywordflow">return</span> os;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="af329c66306f63fb572c92c582640633e"></a><!-- doxytag: member="subpavings::MappedSPnode::operator*" ref="af329c66306f63fb572c92c582640633e" args="(const MappedSPnode&lt; T &gt; &amp;mult) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mult</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplication operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mult</td><td>the object to multiply this by to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non-minimal union of this and <em>mult</em> with a range equal to the the range of this before the operation multiplied by the range of <em>mult</em>. If both this and <em>mult</em> were empty before the operation, the returned object will be empty post the operation. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>mult</em> are empty or both are non-empty and the boxes match. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00796">796</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        MappedSPnode&lt;T&gt; result =(*this);
  
    result*= mult;
    
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a855f75cf76d1ee0235c7aaab29b048f3"></a><!-- doxytag: member="subpavings::MappedSPnode::operator*" ref="a855f75cf76d1ee0235c7aaab29b048f3" args="(const T &amp;mult) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mult</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar multiplication operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mult</td><td>the value to multiply this by to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a mapped paving with the same tree structure as this before the operation with range equal to the range of this before the operation multiplied by <em>mult</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00822">822</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        MappedSPnode&lt;T&gt; result =(*this);
  
    result*= mult;
  
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa5949967da59e064734929aaf190fc15"></a><!-- doxytag: member="subpavings::MappedSPnode::operator*=" ref="aa5949967da59e064734929aaf190fc15" args="(const MappedSPnode&lt; T &gt; &amp;mult)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mult</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplication of self operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mult</td><td>the object to multiply this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>mult</em> are empty or both are non-empty and the boxes match. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is a non-minimal union of this and <em>mult</em> with a range equal to the the range of this before the operation multiplied by the range of <em>mult</em>. If both this and <em>mult</em> were empty before the operation, this will be empty post the operation. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00764">764</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    
    <span class="comment">// if both empty, do nothing</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || !mult.isEmpty()) {
      
      <span class="comment">// just one empty or boxes don&#39;t match</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || mult.isEmpty() ||
        (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != mult.getBox() ) ) {
        <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::operator*=(const MappedSPnode&lt;T&gt;&amp; const)&quot;</span>);
      }
      <span class="comment">// both must be non-empty</span>
      
      this-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a9f6b48701e09b97fbd169db927df0758" title="Make a non-minimal union of subpavings using multiplication of ranges.">_multiplyNonMinimalUnion</a>(mult);

      
    }
    
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a6c028eece36691537a2c824b39d0fb00"></a><!-- doxytag: member="subpavings::MappedSPnode::operator*=" ref="a6c028eece36691537a2c824b39d0fb00" args="(const T &amp;mult)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>mult</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Self-scalar multiplication operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mult</td><td>the value to multiply this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this has the same tree structure as before the operation with a range equal to the range of this before the operation multiplied by <em>mult</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00810">810</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#ab716b6d35a31dcba9de12114b3139dc2" title="Scale up range of this.">_scalarMult</a>(mult);
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a1204b445f0526e62aed8ded7a92744f8"></a><!-- doxytag: member="subpavings::MappedSPnode::operator+" ref="a1204b445f0526e62aed8ded7a92744f8" args="(const MappedSPnode&lt; T &gt; &amp;add) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>add</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Addition operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>the object to add to this to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non-minimal union of this and <em>add</em>. with a range equal to the sum of the values in ranges of this before the operation and of <em>add</em>. If both this and <em>add</em> were empty before the operation, the object returned will be empty. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>add</em> are empty or both are non-empty and the boxes match. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00644">644</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    MappedSPnode&lt;T&gt; result =(*this);
  
    result+= add;
    
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a9c951e4722b21949175ab3997dcd3a86"></a><!-- doxytag: member="subpavings::MappedSPnode::operator+" ref="a9c951e4722b21949175ab3997dcd3a86" args="(const T &amp;add) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>add</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar addition operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>the value to add to this to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a mapped paving with the same tree structure as this before the operation with range equal to the range of this before the operation plus <em>add</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00670">670</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        MappedSPnode&lt;T&gt; result =(*this);
  
    result+= add;
  
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a30b1a6a37439a3d5ad3611e6ecdf37be"></a><!-- doxytag: member="subpavings::MappedSPnode::operator+=" ref="a30b1a6a37439a3d5ad3611e6ecdf37be" args="(const MappedSPnode&lt; T &gt; &amp;add)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>add</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Addition to self operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>the object to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>add</em> are empty or both are non-empty and the boxes match. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is a non-minimal union of this and <em>add</em> with a range equal to the sum of the values in ranges of this before the operation and of <em>add</em>. If both this and <em>add</em> were empty before the operation, this will be empty post the operation. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00617">617</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="comment">// if both empty, do nothing</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || !add.isEmpty()) {
      
      <span class="comment">// just one empty or boxes don&#39;t match</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || add.isEmpty() ||
        (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != add.getBox() ) ) {
        <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::operator+=(const MappedSPnode&lt;T&gt;&amp; const)&quot;</span>);
      }
      
      this-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a30fc46b2dd6b0ca4ad703f323a050c7b" title="Make a non-minimal union of subpavings using addition of ranges.">_addNonMinimalUnion</a>(add);
    
    }
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a11f57501aac4b67b779e3344290101b4"></a><!-- doxytag: member="subpavings::MappedSPnode::operator+=" ref="a11f57501aac4b67b779e3344290101b4" args="(const T &amp;add)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>add</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Self-scalar addition operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add</td><td>the value to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this has the same tree structure as before the operation with a range equal to the range of this before the operation plus <em>add</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00658">658</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a4ef713013762306de2040ac389ec140a" title="Increment range collection of this.">_scalarAdd</a>(add);
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="acf2b59252b57c2201c5184dbb02a5a20"></a><!-- doxytag: member="subpavings::MappedSPnode::operator&#45;" ref="acf2b59252b57c2201c5184dbb02a5a20" args="(const MappedSPnode&lt; T &gt; &amp;sub) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtraction operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>the object to subtract from this to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non-minimal union of this and <em>sub</em> with a range equal to the the value of the range of this before the operation less the range of of <em>sub</em>. If both this and <em>sub</em> were empty before the operation, the returned object will be empty post the operation. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>sub</em> are empty or both are non-empty and the boxes match. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00719">719</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        MappedSPnode&lt;T&gt; result =(*this);
  
    result-= sub;
  
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad4bb0c01c69521b16c62a90a6e540e8f"></a><!-- doxytag: member="subpavings::MappedSPnode::operator&#45;" ref="ad4bb0c01c69521b16c62a90a6e540e8f" args="(const T &amp;sub) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar subtraction operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>the value to subtract from this to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a mapped paving with the same tree structure as this before the operation with range equal to the range of this before the operation minus <em>sub</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00745">745</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        MappedSPnode&lt;T&gt; result =(*this);
  
    result-= sub;
  
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a1ca00409cd79226e2b626acfb20ea054"></a><!-- doxytag: member="subpavings::MappedSPnode::operator&#45;=" ref="a1ca00409cd79226e2b626acfb20ea054" args="(const MappedSPnode&lt; T &gt; &amp;sub)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtraction from self operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>the object to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>sub</em> are empty or both are non-empty and the boxes match. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is a non-minimal union of this and <em>sub</em> with a range equal to the the range of this before the operation less the range of <em>sub</em>. If both this and <em>sub</em> were empty before the operation, this will be empty post the operation. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00690">690</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    
    <span class="comment">// if both empty, do nothing</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || !sub.isEmpty()) {
      
      <span class="comment">// just one empty or boxes don&#39;t match</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || sub.isEmpty() ||
        (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != sub.getBox() ) ) {
        <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::operator-=(const MappedSPnode&lt;T&gt;&amp; const)&quot;</span>);
      }
      
      this-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a9880ddfe3c75fe8e7594ee6222040d79" title="Make a non-minimal union of subpavings using subtraction of ranges.">_subtractNonMinimalUnion</a>(sub);
    
    }
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a6c67949c1c356830bd0edaae9f75ccbe"></a><!-- doxytag: member="subpavings::MappedSPnode::operator&#45;=" ref="a6c67949c1c356830bd0edaae9f75ccbe" args="(const T &amp;sub)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>sub</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Self-scalar subtraction operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sub</td><td>the value to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this has the same tree structure as before the operation with a range equal to the range of this before the operation minus <em>sub</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00733">733</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a91ab734b6f270c26557964473f4977b4" title="Increment range collection of this.">_scalarSubtract</a>(sub);
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a7a92e3c463e2fbe951824badf0aa2383"></a><!-- doxytag: member="subpavings::MappedSPnode::operator/" ref="a7a92e3c463e2fbe951824badf0aa2383" args="(const MappedSPnode&lt; T &gt; &amp;div) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Division operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">div</td><td>the object to divide this by to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non-minimal union of this and <em>div</em> with a range equal to the the range of this before the operation divided by the range of <em>div</em>. If both this and <em>div</em> were empty before the operation, the returned object will be empty post the operation. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>div</em> are empty or both are non-empty and the boxes match. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00872">872</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        MappedSPnode&lt;T&gt; result =(*this);
  
    result/= div;
  
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad8deddac45220ce11ba734c5ff4694d0"></a><!-- doxytag: member="subpavings::MappedSPnode::operator/" ref="ad8deddac45220ce11ba734c5ff4694d0" args="(const T &amp;div) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar division operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">div</td><td>the value to divide this by to give the object returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an object with the same tree structure as this before the operation with a range equal to the range of this before the operation divided by <em>div</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00898">898</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        MappedSPnode&lt;T&gt; result =(*this);
  
    result/= div;
  
    <span class="keywordflow">return</span> result;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a793f3f3b66690ef99c8a737850f7c291"></a><!-- doxytag: member="subpavings::MappedSPnode::operator/=" ref="a793f3f3b66690ef99c8a737850f7c291" args="(const MappedSPnode&lt; T &gt; &amp;div)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Division of self operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">div</td><td>the object to divide this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>either both this and <em>div</em> are empty or both are non-empty and the boxes match. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is a non-minimal union of this and <em>div</em> with a range equal to the the range of this before the operation divided by the range of of <em>div</em>. If both this and <em>div</em> were empty before the operation, this will be empty post the operation. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00842">842</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="comment">// if both empty, do nothing</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || !div.isEmpty()) {
      
      <span class="comment">// just one empty or boxes don&#39;t match</span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || div.isEmpty()  ||
        (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != div.getBox() ) ) {
        <span class="keywordflow">throw</span> IncompatibleDimensions_Error(
        <span class="stringliteral">&quot;MappedSPnode&lt;T&gt;::operator/=(const MappedSPnode&lt;T&gt;&amp; const)&quot;</span>);
      }
      <span class="comment">// both must be non-empty</span>
      
      this-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a29dac80a6e0ecce51b22816ef78a298d" title="Make a non-minimal union of subpavings using division of ranges.">_divideNonMinimalUnion</a>(div);

      
    }
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aab106627889397cf17d3ea7a3626e363"></a><!-- doxytag: member="subpavings::MappedSPnode::operator/=" ref="aab106627889397cf17d3ea7a3626e363" args="(const T &amp;div)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>div</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Self-scalar division operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">div</td><td>the value to divide this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this has the same tree structure as before the operation. with a range equal to the range of this before the operation divided by <em>div</em>. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00886">886</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a21cbfaf0019ceb215b9c12df05d394f3" title="Scale down range of this.">_scalarDiv</a>(div);
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a9f159be71fab10b26dec5d080fec95ff"></a><!-- doxytag: member="subpavings::MappedSPnode::operator=" ref="a9f159be71fab10b26dec5d080fec95ff" args="(MappedSPnode&lt; T &gt; rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt;T&gt;&amp; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>
<p>Copies from given node downwards. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ad6a86d365ae237d96c7a8f842700af96">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00203">203</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        rhs.swapMSPSR(*<span class="keyword">this</span>); <span class="comment">// make sure we use our version of swap</span>
    <span class="keywordflow">return</span>(*<span class="keyword">this</span>);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4e3cc447b700d1a0e8e611f56762a96d"></a><!-- doxytag: member="subpavings::MappedSPnode::setRange" ref="a4e3cc447b700d1a0e8e611f56762a96d" args="(T r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a4e3cc447b700d1a0e8e611f56762a96d">setRange</a> </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the value for the range. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00247">247</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">    {   
        <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = r;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a83d5b7a4609c73e1818fe2d3231c0979"></a><!-- doxytag: member="subpavings::MappedSPnode::slice" ref="a83d5b7a4609c73e1818fe2d3231c0979" args="(const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a83d5b7a4609c73e1818fe2d3231c0979">slice</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cxsc::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>slicePts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Slice this. </p>
<p>Slice this on at the point jointly specified by <em>sliceDims</em> and <em>slicePts</em>. For example, if this has a 3-dimensional root box [-1,1]x[-1,1]x[-1,1], ie dimensions {1,2,3} and <em>sliceDims</em> = {2,3} and <em>slicePts</em> is (0.0,0.5) then we are slicing at point 0.0 on dimension 2, point 0.5 on dimension 3. The result will have only one-dimensional boxes on dimensions {1,2,3}2,3} = {1} and each box associated with this and its descendents will be a compressed to dimension {1} version of a box from the original this where that original box contained the point 0.0 on dimension 2 and 0.5 on dimension 3 (the range will be unchanged). Any boxes associated with the original this that did not contain the point 0.0 on dimension 2 and 0.5 on dimension 3 will not be represented in its compressed version in this</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceDims</td><td>is a vector of dimensions to slice on. </td></tr>
    <tr><td class="paramname">slicePts</td><td>is a vector of points to slice on, assumed to correspond to the dimensions in <em>sliceDims</em>, ie the ith value in <em>sliceDims</em> gives the dimension for the ith point in <em>slicePts</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000003">Todo:</a></b></dt><dd>better description. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac674f3231fb03622048986a2a855b224">subpavings::RealMappedSPnode</a>.</p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00519">519</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">  {
    
<span class="preprocessor">    #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;In MappedSPnode&lt;T&gt;::slice, I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    std::vector&lt;cxsc::real&gt; fullSlicePts = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a24ca6f695181dd45e5cf05d22042bb44" title="Check slice parameters and return a full vector of slice points.">sliceCheck</a>(sliceDims, slicePts);
      
    <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a54fec3e936497db34a821b9138b4ad7b">_slice</a>(sliceDims, fullSlicePts);
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a24ca6f695181dd45e5cf05d22042bb44"></a><!-- doxytag: member="subpavings::MappedSPnode::sliceCheck" ref="a24ca6f695181dd45e5cf05d22042bb44" args="(const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; cxsc::real &gt; <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a24ca6f695181dd45e5cf05d22042bb44">sliceCheck</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cxsc::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>slicePts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check slice parameters and return a full vector of slice points. </p>
<p>Checks that: </p>
<ul>
<li>
there is a box, </li>
<li>
that dimensions of box are compatible with sliceDims given, </li>
<li>
that slicePts is of same size as sliceDims, </li>
<li>
that both sliceDims and slicePts are non-empty, </li>
<li>
that sliceDims does not contain every dimension in this, </li>
<li>
that for the ith dimension in sliceDims, the i-th value in slicePts is inside the interval of the box on the ith dimension in sliceDims. </li>
</ul>
<p>Throws exceptions if any problems are encountered.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceDims</td><td>is a vector of dimensions to slice on. </td></tr>
    <tr><td class="paramname">slicePts</td><td>is a vector of points to slice on, assumed to correspond to the dimensions in <em>sliceDims</em>, ie the ith value in <em>sliceDims</em> gives the dimension for the ith point in <em>slicePts</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of slice points with as many elements in as the dimensions of this, with the values from <em>slicePts</em> as the positions given by <em>sliceDims</em> and 0's (dummy values) otherwise. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01591">1591</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l00519">subpavings::MappedSPnode&lt; cxsc::real &gt;::slice()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    std::vector &lt; cxsc::real &gt; fullSlicePts;
    
    <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef" title="Accessor for the parent of a node.">getParent</a>() != NULL ) {
      <span class="keywordflow">throw</span> NonRootNode_Error(
        <span class="stringliteral">&quot;sliceCheck error found&quot;</span>);
    }
    <span class="keywordflow">if</span> ( !sliceDims.empty() || !slicePts.empty()) {
      
    
      <span class="keywordflow">if</span> ( sliceDims.size() != slicePts.size()) {
        <span class="keywordflow">throw</span> std::invalid_argument(
          <span class="stringliteral">&quot;sliceCheck error found: sliceDims.size() != slicePts.size()&quot;</span>);
      }
      
      <span class="comment">/* get ordered unique values in sliceDims*/</span>
      std::set&lt;int&gt; dimsSet(sliceDims.begin(), sliceDims.end());
      
      <span class="keywordflow">if</span> ( dimsSet.size() &lt; sliceDims.size()) {
        <span class="keywordflow">throw</span> std::invalid_argument(
          <span class="stringliteral">&quot;sliceCheck error found: duplicate dimensions in sliceDims&quot;</span>);
      }
      
      <span class="keywordflow">if</span> ( dimsSet.size() &gt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#a4caf34bf9db0dc8f116797149be0cf8b" title="Accessor for the dimension of theBox of a node.">getDimension</a>()) {
        <span class="keywordflow">throw</span> std::invalid_argument(
          <span class="stringliteral">&quot;sliceCheck error found: number of dimensions to slice on &gt;= dimensions of this&quot;</span>);
      }
      
      
      <span class="comment">/* check that each of the values in sliceDims is a dimension of this*/</span>
      ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
      <span class="keywordtype">int</span> lb = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
      <span class="keywordtype">int</span> ub = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(box);  <span class="comment">// ub-lb+1 = dim of box</span>
      
      <span class="comment">// make a full vector of dim reals, 0.0&#39;s in all positions</span>
      fullSlicePts =  std::vector&lt; cxsc::real &gt;(ub-lb+1, real(0.0));
      
<span class="preprocessor">      #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;\nin slice&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
        std::cout &lt;&lt; <span class="stringliteral">&quot;lb = &quot;</span> &lt;&lt; lb &lt;&lt; <span class="stringliteral">&quot; and ub = &quot;</span> &lt;&lt; ub &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      std::vector &lt; real &gt;::const_iterator rit = slicePts.begin();
      <span class="keywordflow">for</span> ( std::vector &lt; int &gt;::const_iterator cit = sliceDims.begin();
          cit &lt; sliceDims.end();
          ++cit, ++rit) {
        <span class="keywordtype">int</span> d = *cit;
<span class="preprocessor">        #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;checking d =&quot;</span> &lt;&lt; d &lt;&lt; std::endl;
          std::cout &lt;&lt; <span class="stringliteral">&quot;*rit =&quot;</span> &lt;&lt; (*rit) &lt;&lt; std::endl;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>          
        <span class="keywordflow">if</span> (d &lt; lb || d &gt; ub) {
          <span class="keywordflow">throw</span> std::invalid_argument(
          <span class="stringliteral">&quot;sliceCheck error found: illegal dimension in sliceDims&quot;</span>);
        }
<span class="preprocessor">        #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;box[d] =&quot;</span> &lt;&lt; box[d] &lt;&lt; std::endl;
          std::cout &lt;&lt; <span class="stringliteral">&quot;(*rit) &lt;= box[d] =&quot;</span> &lt;&lt; ((*rit) &lt;= box[d]) &lt;&lt; std::endl;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>        real r = *rit;
        <span class="keywordflow">if</span> (!(r &lt;= box[d])) {
          <span class="keywordflow">throw</span> std::invalid_argument(
          <span class="stringliteral">&quot;sliceCheck error found: illegal pt in slicePts&quot;</span>);
        }
<span class="preprocessor">        #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;fullSlicePts[&quot;</span> &lt;&lt; (d-lb) &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; r &lt;&lt; std::endl;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>        
        fullSlicePts[d-lb] = r;
      }
      
    } <span class="comment">// end check at least one is non-empty</span>
    <span class="keywordflow">else</span>  { <span class="comment">// both empty</span>
      <span class="keywordflow">throw</span> std::invalid_argument(
        <span class="stringliteral">&quot;sliceCheck error found: sliceDims and slicePts both empty&quot;</span>);
    }
    <span class="keywordflow">return</span> fullSlicePts;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a65c8bb39917da7dc82fb07c9572c7286"></a><!-- doxytag: member="subpavings::MappedSPnode::splitToShape" ref="a65c8bb39917da7dc82fb07c9572c7286" args="(std::string instruction)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a65c8bb39917da7dc82fb07c9572c7286">splitToShape</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>instruction</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Splits paving according to string instruction. </p>
<p>The instruction specifies the required shape in terms of the depth of the leaf nodes, in left to right order. The depth of a leaf node is equivalent to the number of bisections of the root box required to make the box represented by that leaf. i.e., the root has depth 0 and if that were bisected, the root node would have two child nodes each of level 1. Bisection of any one of the boxes represented by a child would give two more children, each of level 2 (2 bisections), etc.</p>
<p>Leaf levels in <em>instruction</em> can be separated by commas, spaces, or both.</p>
<p>For example, an instruction string "3, 3, 2, 1" would give an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree with 4 leaves, 2 of which would be level 3 (i.e. representing boxes resulting from 3 bisections of the root box, each of which would have volume 1/8 the size of the root box). Another leaf would represent a box resulting from 2 bisections of the root box (volume 1/4 that of the root box) and the 'right-most' leaf (in a drawing of the tree) would be the result of a single bisection of the root box and would have half the volume of the root box. This is a valid instruction string because it is possible to get leaves of those levels by a series of successive bisections of the root box and the volume of the leaves adds up to the volume of the root box.</p>
<p>Throws the following exceptions: </p>
<ul>
<li>
Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if the box is NULL. </li>
<li>
Throws a <a class="el" href="classsubpavings_1_1NonRootNode__Error.shtml">NonRootNode_Error</a> if this is not a root node (ie if this has a parent node). </li>
<li>
Throws an std::invalid_argument exception if the <em>instruction</em> constain invalid characters (anything other than digits, whitespace or commas). </li>
<li>
Throws an std::logic_error if the instruction is valid but does not describe an achievable tree shape. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">instruction</td><td>specifies the required shape, eg "3, 3, 2, 1". </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the instruction could be successfully carried out, false if the instruction could not be carried out successfully. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The instruction must be valid and describe an achievable tree shape. This must be a non-empty root node. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><a class="el" href="classsubpavings_1_1SPnode.shtml#a7ea8cd3649cbf13d5743d3cb23315d72" title="Get a string of leaf node levels.">getLeafNodeLevelsString()</a> == instruction </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00373">373</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="ExColour2D_8cpp_source.shtml#l00036">main()</a>, <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00189">testingIntervals()</a>, <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00028">testingInts()</a>, <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00108">testingReals()</a>, and <a class="el" href="MappedSPTesting_8cpp_source.shtml#l00277">testingRvectors()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="keywordtype">bool</span> success = <span class="keyword">false</span>;

    <span class="comment">// checks:  is this the root?</span>
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>) {
      <span class="keywordflow">throw</span> NonRootNode_Error(<span class="stringliteral">&quot;MappedSPNodeSingleRange&lt;T&gt;::splitToShape(std::string)&quot;</span>);
    }

    <span class="comment">// checks:  is there a root box</span>
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>) {
      <span class="keywordflow">throw</span> NoBox_Error(<span class="stringliteral">&quot;MappedSPNodeSingleRange&lt;T&gt;::splitToShape(std::string)&quot;</span>);
    }


    <span class="comment">// checks: is the string properly formed?</span>
    <span class="keywordflow">if</span> (instruction.length() == 0) {
      <span class="keywordflow">throw</span> std::invalid_argument(
      <span class="stringliteral">&quot;MappedSPNodeSingleRange&lt;T&gt;::splitToShape(std::string) : No instruction&quot;</span>);
    }
    std::string legal(<span class="stringliteral">&quot;, 0123456789&quot;</span>);
    <span class="keywordflow">if</span> (instruction.find_first_not_of(legal) != std::string::npos) {
      <span class="keywordflow">throw</span> std::invalid_argument(
      <span class="stringliteral">&quot;MappedSPNodeSingleRange&lt;T&gt;::splitToShape(std::string) : Illegal character&quot;</span>);
    }

    <span class="comment">// all seems to be okay, we can start spliting the root</span>
    <span class="comment">// specify what to look for as numbers or decimal point or + or -</span>

    success = <a class="code" href="classsubpavings_1_1SPnode.shtml#a62e9df1a7c96af8f0796a6ea211b38ea" title="Split a root paving to a specified shape.">splitRootToShape</a>(instruction);

    <span class="keywordflow">if</span> (!success) {
      <span class="keywordflow">throw</span> std::logic_error(
      <span class="stringliteral">&quot;MappedSPNodeSingleRange&lt;T&gt;::splitToShape(std::string) : instruction not a proper tree&quot;</span>);
      
     }
     
    <span class="keywordflow">return</span> success;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a4375171ab30bfe88e4a3306f321d3e24"></a><!-- doxytag: member="subpavings::MappedSPnode::swapMSPSR" ref="a4375171ab30bfe88e4a3306f321d3e24" args="(MappedSPnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a4375171ab30bfe88e4a3306f321d3e24">swapMSPSR</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the properties of this and another. </p>
<p>The properties swapped include all the node properties like name, box, etc, and children, and the range.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>the node to swap with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this has the properties that <em>spn</em> had before the operation, and spn has the properties this had before the operation. </dd></dl>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l00958">958</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00196">subpavings::RealMappedSPnode::operator=()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l00203">subpavings::MappedSPnode&lt; cxsc::real &gt;::operator=()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="comment">/* theBox, parent, leftChild,</span>
<span class="comment">    rightChild and nodeName are inherited from base class */</span>
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">SPnode::swap</a>(spn); <span class="comment">// use the base version</span>
    
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>, spn.range);
  }
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a85f4e42ee09fcfa8c47835231ac3c21d"></a><!-- doxytag: member="subpavings::MappedSPnode::range" ref="a85f4e42ee09fcfa8c47835231ac3c21d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">subpavings::MappedSPnode</a>&lt; T &gt;::<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d">range</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A range of type T. </p>

<p>Definition at line <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">1693</a> of file <a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="mappedspnode_8hpp_source.shtml#l01076">subpavings::MappedSPnode&lt; cxsc::real &gt;::_addRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01154">subpavings::MappedSPnode&lt; cxsc::real &gt;::_divRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01128">subpavings::MappedSPnode&lt; cxsc::real &gt;::_multRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01288">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarAdd()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01343">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarDiv()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01325">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarMult()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01306">subpavings::MappedSPnode&lt; cxsc::real &gt;::_scalarSubtract()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; cxsc::real &gt;::_slice()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01102">subpavings::MappedSPnode&lt; cxsc::real &gt;::_subtractRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00553">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPExpandVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00589">subpavings::MappedSPnode&lt; cxsc::real &gt;::acceptSPValueVisitor()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00299">subpavings::MappedSPnode&lt; cxsc::real &gt;::allocateRanges()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01005">subpavings::MappedSPnode&lt; cxsc::real &gt;::leafOutputTabs()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00175">subpavings::MappedSPnode&lt; cxsc::real &gt;::MappedSPnode()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00927">subpavings::MappedSPnode&lt; cxsc::real &gt;::minimiseLeaves()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00421">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeExpand()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00977">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodePrint()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00258">subpavings::MappedSPnode&lt; cxsc::real &gt;::nodeStringSummary()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01675">subpavings::MappedSPnode&lt; cxsc::real &gt;::oneLineOutput()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00247">subpavings::MappedSPnode&lt; cxsc::real &gt;::setRange()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l00958">subpavings::MappedSPnode&lt; cxsc::real &gt;::swapMSPSR()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mappedspnode_8hpp_source.shtml">mappedspnode.hpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:39 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
