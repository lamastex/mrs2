<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::RealMappedSPnode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1RealMappedSPnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::RealMappedSPnode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::RealMappedSPnode" --><!-- doxytag: inherits="MappedSPnode&lt; cxsc::real &gt;" -->
<p>A derived class based on <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> &lt; cxsc::real &gt;.  
 <a href="classsubpavings_1_1RealMappedSPnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for subpavings::RealMappedSPnode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1RealMappedSPnode__inherit__graph.png" border="0" usemap="#subpavings_1_1RealMappedSPnode_inherit__map" alt="Inheritance graph"/></div>
<map name="subpavings_1_1RealMappedSPnode_inherit__map" id="subpavings_1_1RealMappedSPnode_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::RealMappedSPnode:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1RealMappedSPnode__coll__graph.png" border="0" usemap="#subpavings_1_1RealMappedSPnode_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1RealMappedSPnode_coll__map" id="subpavings_1_1RealMappedSPnode_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1RealMappedSPnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode_1_1Measurer.shtml">Measurer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner interface for types measuring nodes.  <a href="classsubpavings_1_1RealMappedSPnode_1_1Measurer.shtml#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">Ptrs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Ptrs::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8414841542df48678ae521df3ae92800">PtrsItr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; const <br class="typebreak"/>
<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">ConstPtrs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ConstPtrs::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a528463bd540e2e3d4dc907ce78a3b03c">ConstPtrsItr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list<br class="typebreak"/>
&lt; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a13d2adc6fa08d7b1e70a7956eac1affe">ListPtrs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ListPtrs::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ad10e24d2efdb436ae6f65306c8ff736e">ListPtrsItr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; const <br class="typebreak"/>
<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#aba04df267c93463fbb6a90d85e11b627">ListConstPtrs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
ListConstPtrs::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac4e7b7e57068590fc47a5951453754b2">ListConstPtrsItr</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a55594a45ac82b31b5ae7592143079794">~RealMappedSPnode</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">No-argument constructor.  <a href="#a21248dfec3fc7415a604f2f1a5d58ce6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8f2de173f1eb55690cafb07020bfa5e5">RealMappedSPnode</a> (const ivector &amp;v)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initialised constructor.  <a href="#a8f2de173f1eb55690cafb07020bfa5e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a6ca684686609263ecb8579a95276e2bf">RealMappedSPnode</a> (const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a6ca684686609263ecb8579a95276e2bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a77bada00301c6333863d80ca002fd86c">RealMappedSPnode</a> (const ivector &amp;v, const cxsc::real &amp;<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d">range</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a77bada00301c6333863d80ca002fd86c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a12af9b0be5c63f0e1af1849d70b1b647">RealMappedSPnode</a> (const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb, const cxsc::real &amp;<a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d">range</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a12af9b0be5c63f0e1af1849d70b1b647"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#add6e4bba67a9d900ebebf07f420ad813">RealMappedSPnode</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initialised with an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>.  <a href="#add6e4bba67a9d900ebebf07f420ad813"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4ec458c112685446a703ae73fe812b84">RealMappedSPnode</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;spn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#aea3c023626616315bdf71aaee45fa32f">RealMappedSPnode</a> (const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aea3c023626616315bdf71aaee45fa32f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#afcd2676e416102b713d9ce735bc27889">RealMappedSPnode</a> (const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; cxsc::real &gt; &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#afcd2676e416102b713d9ce735bc27889"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8c4a201d04c81a5f21301d6a325e740d">operator=</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a8c4a201d04c81a5f21301d6a325e740d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ad6a86d365ae237d96c7a8f842700af96">operator=</a> (<a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; cxsc::real &gt; rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ad6a86d365ae237d96c7a8f842700af96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the parent of a node.  <a href="#a04fef135a04c4d165c08395c531581dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4">getLeftChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the left child of a node.  <a href="#a71ad37450934fcd212d1c13c9f8830d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9">getRightChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the right child of a node.  <a href="#a19cb07beb697f0f8613a63c0b476ddd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a1ac4214b1e335289374edece1b5d8c43">operator&lt;</a> (const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator.  <a href="#a1ac4214b1e335289374edece1b5d8c43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9409b660d7a7f1f35fc7f2d1904386c2">findContainingNode</a> (const cxsc::rvector &amp;pt, <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a> childInd=<a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac4cadaec6d96f2a315218dc16a082f8a">hasNegativeRangeInTree</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4d0129dda149a950a06e9d2e3ff802c4">nodeExpand</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sibling child nodes to this provided this is a leaf.  <a href="#a4d0129dda149a950a06e9d2e3ff802c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ad60865bacd8a43978cf2da02419cbf8f">nodeExpand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two sibling child nodes to this provided this is a leaf.  <a href="#ad60865bacd8a43978cf2da02419cbf8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#abae5bea82b46019e23d98756973c6860">getMaxRangeForLeavesInTree</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum value of the range for any of the leaves of the tree rooted at this.  <a href="#abae5bea82b46019e23d98756973c6860"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#acf2399376e990903e5787b0a68eb350c">marginalise</a> (const std::vector&lt; int &gt; &amp;reqDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginalise this.  <a href="#acf2399376e990903e5787b0a68eb350c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ab3ac1ccd24132d04f136a0fab3d0b610">makeMarginalised</a> (const std::vector&lt; int &gt; &amp;reqDims) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a marginalised version of this.  <a href="#ab3ac1ccd24132d04f136a0fab3d0b610"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8b02632446a3c28a352f15f511e35caa">normalise</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalise this.  <a href="#a8b02632446a3c28a352f15f511e35caa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a66a8b6deef3ba770a80a5b0b0418f5fc">makeNormalised</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a normalised version of this.  <a href="#a66a8b6deef3ba770a80a5b0b0418f5fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac674f3231fb03622048986a2a855b224">slice</a> (const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice this.  <a href="#ac674f3231fb03622048986a2a855b224"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a2541f9ce5af2fcb753644d1f7e1f9297">makeSlice</a> (const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a RealMappedSPnode that is a slice of this.  <a href="#a2541f9ce5af2fcb753644d1f7e1f9297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#af243ad67d0ff141d345e800b651a87e1">getL1Distance</a> (const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;other) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a116f7a6b92d5c442be9d8393b6e0e73f">getLogLikelihood</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;spn) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 'log likelihood' using positive values from this and counts from <em>spn</em>.  <a href="#a116f7a6b92d5c442be9d8393b6e0e73f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a153b19ceeba356f0ada4e27dfcf6ab37">getRealAreaRangeWithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "area" of the range and the box of this.  <a href="#a153b19ceeba356f0ada4e27dfcf6ab37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8f083e792f8980eec67298253428c5c9">getDotPrecisionAreaRangeWithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "area" of the range and the box of this as a dotprecision type.  <a href="#a8f083e792f8980eec67298253428c5c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a23ef95e66b4b920f205739d9cf42f96f">getTotalLeafAreaRangeWithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total "area" for the leaves of this of the real ranges and boxes.  <a href="#a23ef95e66b4b920f205739d9cf42f96f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f769639fd1e13ea5449bb12dc53c998">getTotalDotPrecisionLeafAreaRangeWithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total "area" of the range and the box of this as a dotprecision type.  <a href="#a4f769639fd1e13ea5449bb12dc53c998"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277">getTotalAbsLeafAreaRangeWithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total absolute "area" for the leaves of this of the real ranges and boxes.  <a href="#a972c5dbc0bedd9cad3af4f2af43be277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a2901c49d51615810f146a38ccb503fda">getTotalDotPrecisionAbsLeafAreaRangeWithBox</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total absolute "area" of the range and the box of this as a dotprecision type.  <a href="#a2901c49d51615810f146a38ccb503fda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a0660b7981cce44ca09c2e0d68a6c1a21">getTotalAbsDiffLeafAreaRangeWithBox</a> (const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;rmsp) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total over the leaves of the absolute value of the difference between the leaf "area" for this and for <em>rmsp</em>.  <a href="#a0660b7981cce44ca09c2e0d68a6c1a21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual cxsc::dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a74ba255a0781497c5dc76e8458969278">getTotalDotPrecisionAbsDiffLeafAreaRangeWithBox</a> (const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;rmsp) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total over the leaves of the absolute value of the difference between the leaf "area" for this and for <em>rmsp</em> as a dotprecision type.  <a href="#a74ba255a0781497c5dc76e8458969278"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">Ptrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a866601879aed0044333a5f28a773f677">getLeaves</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">Ptrs</a> &amp;leaves)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to a container of nodes.  <a href="#a866601879aed0044333a5f28a773f677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">ConstPtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#aea6a4c6aa2fe8eb944000db6790f9d8c">getConstLeaves</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">ConstPtrs</a> &amp;leaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to a container of const nodes.  <a href="#aea6a4c6aa2fe8eb944000db6790f9d8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">Ptrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a561d20d602eafff9592fdd0ee912ffcc">getSubLeaves</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">Ptrs</a> &amp;subleaves)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to a container of nodes.  <a href="#a561d20d602eafff9592fdd0ee912ffcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">ConstPtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac6e092c4b19b8747f154eefd56d3e864">getConstSubLeaves</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">ConstPtrs</a> &amp;subleaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to a container of const nodes.  <a href="#ac6e092c4b19b8747f154eefd56d3e864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#af2612c2a420a9f91c8bca09f0bb6ab42">swapRMSPSR</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;spn)</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f2a09e57bff1fd459e8bf631019b07f">_start_marginalise</a> (const std::vector&lt; int &gt; &amp;reqDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-public version of marginalisation to have only the required dimensions.  <a href="#a4f2a09e57bff1fd459e8bf631019b07f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a14871e233412eac80e1b742967d7ab2b">_marginalise</a> (const std::vector&lt; int &gt; &amp;outDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-public version of marginalisation to take out the unwanted dimensions.  <a href="#a14871e233412eac80e1b742967d7ab2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a185405d2c7b3231a75b33ec249292e2d">_normalise</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-public version of normalisation.  <a href="#a185405d2c7b3231a75b33ec249292e2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::dotprecision &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a769c7c79a6ce88db0854b2cbffb97747">_getL1distance</a> (cxsc::dotprecision &amp;disL1, const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *const other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate L1 distance between leaf descendents of this and leaf descendents of node pointed to by <em>other</em> into <em>disL1</em>.  <a href="#a769c7c79a6ce88db0854b2cbffb97747"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::dotprecision &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a3171d7822ccbcb05ed2b997c678b325a">nodeL1Distance</a> (cxsc::dotprecision &amp;disL1, cxsc::real other_v) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate L1 distance between this and another identical node with value <em>other_v</em> mapped onto it, ie add nodevolume*(range - other_v) onto <em>disL1</em>.  <a href="#a3171d7822ccbcb05ed2b997c678b325a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::dotprecision &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#aa65475d7ae1efb7ba1c7cd5bd0c13c5d">_getLogLikelihood</a> (cxsc::dotprecision &amp;loglik, int &amp;isnan, int &amp;isposinf, int &amp;isneginf, const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const spn) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate log likelihood using positive values from this and counts from <em>spn</em>.  <a href="#aa65475d7ae1efb7ba1c7cd5bd0c13c5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5287c7cec21af1c8606d735c0478a6fc">oneLineOutput</a> (std::ostream &amp;os, int level=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A quick one-line summary of a node.  <a href="#a5287c7cec21af1c8606d735c0478a6fc"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A derived class based on <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> &lt; cxsc::real &gt;. </p>
<p>The base class <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> is a node in the representation of a mapped regular subpaving as a binary tree, where the type mapped to the nodes is a real. A node represents a box (interval vector). MappedSPnodes are linked together to form the tree. The initial box of the subpaving is the box represented by the root node of the tree. A box which has been split will be represented as node with one or two children. A subpaving of [<b>x</b>] (union of non-overlapping sub- boxes of [<b>x</b>]) is represented by the leaves (degenerate/ child-less) nodes in the tree. Each node will have a single real value mapped to it.</p>
<p>A <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> provides the functionality of the MappedSPNode &lt;real&gt; and extended functionality appropriate for real mapped nodes, such as marginalisation.</p>
<p>Note that arithmetical operations with non-real operands can take place provided that there is an implicit conversion from the operand type to a cxsc::real, eg the operations this += 2 or this + 2 will give the same results as this += cxsc::real(2.0) or this + cxsc::real(2.0) respectively, because there is a implicit conversion from an integer to a cxsc::real in the cxsc library. Similarly, operations with operands of type double will also succeed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.shtml#_todo000007">Todo:</a></b></dt><dd>Really it seems like we should not have both the <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> and the <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> classes. Should look at the collator stuff and see if that can be the <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> and just replace all this code by that and rename it. That would mean that we lose the connection with the templatised <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> class which would be a good thing really - the <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> is adding functionality to the extent that it is not appropriate to see it as a derived class from the mapped nodes any more. Combining collators and real mapped spnodes would deal with all the duplication of code that there is at present. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00073">73</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a5fc20ec0cd33f031e874f50251156e65"></a><!-- doxytag: member="subpavings::RealMappedSPnode::ConstPtrs" ref="a5fc20ec0cd33f031e874f50251156e65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>* &gt; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">subpavings::RealMappedSPnode::ConstPtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00086">86</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a528463bd540e2e3d4dc907ce78a3b03c"></a><!-- doxytag: member="subpavings::RealMappedSPnode::ConstPtrsItr" ref="a528463bd540e2e3d4dc907ce78a3b03c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ConstPtrs::const_iterator <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a528463bd540e2e3d4dc907ce78a3b03c">subpavings::RealMappedSPnode::ConstPtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00088">88</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba04df267c93463fbb6a90d85e11b627"></a><!-- doxytag: member="subpavings::RealMappedSPnode::ListConstPtrs" ref="aba04df267c93463fbb6a90d85e11b627" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt; const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>* &gt; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#aba04df267c93463fbb6a90d85e11b627">subpavings::RealMappedSPnode::ListConstPtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00094">94</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4e7b7e57068590fc47a5951453754b2"></a><!-- doxytag: member="subpavings::RealMappedSPnode::ListConstPtrsItr" ref="ac4e7b7e57068590fc47a5951453754b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ListConstPtrs::const_iterator <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac4e7b7e57068590fc47a5951453754b2">subpavings::RealMappedSPnode::ListConstPtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00096">96</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a13d2adc6fa08d7b1e70a7956eac1affe"></a><!-- doxytag: member="subpavings::RealMappedSPnode::ListPtrs" ref="a13d2adc6fa08d7b1e70a7956eac1affe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>* &gt; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a13d2adc6fa08d7b1e70a7956eac1affe">subpavings::RealMappedSPnode::ListPtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00090">90</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad10e24d2efdb436ae6f65306c8ff736e"></a><!-- doxytag: member="subpavings::RealMappedSPnode::ListPtrsItr" ref="ad10e24d2efdb436ae6f65306c8ff736e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ListPtrs::iterator <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ad10e24d2efdb436ae6f65306c8ff736e">subpavings::RealMappedSPnode::ListPtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00092">92</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9591975c77c7e7da92bbdcdf62a74d1a"></a><!-- doxytag: member="subpavings::RealMappedSPnode::Ptrs" ref="a9591975c77c7e7da92bbdcdf62a74d1a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>* &gt; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">subpavings::RealMappedSPnode::Ptrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00082">82</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8414841542df48678ae521df3ae92800"></a><!-- doxytag: member="subpavings::RealMappedSPnode::PtrsItr" ref="a8414841542df48678ae521df3ae92800" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Ptrs::iterator <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8414841542df48678ae521df3ae92800">subpavings::RealMappedSPnode::PtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8hpp_source.shtml#l00084">84</a> of file <a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a55594a45ac82b31b5ae7592143079794"></a><!-- doxytag: member="subpavings::RealMappedSPnode::~RealMappedSPnode" ref="a55594a45ac82b31b5ae7592143079794" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a55594a45ac82b31b5ae7592143079794">RealMappedSPnode::~RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00040">40</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<a class="anchor" id="a21248dfec3fc7415a604f2f1a5d58ce6"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="a21248dfec3fc7415a604f2f1a5d58ce6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>No-argument constructor. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00044">44</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">nodeExpand()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">RealMappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">  : <a class="code" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode&lt;cxsc::real&gt;</a>() {}   <span class="comment">// uses the base SPnode class default constructor</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a8f2de173f1eb55690cafb07020bfa5e5"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="a8f2de173f1eb55690cafb07020bfa5e5" args="(const ivector &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialised constructor. </p>
<p>Initialised with a box. Range is set to 0.0. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00050">50</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">  : <a class="code" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode&lt;cxsc::real&gt;</a>(v, real(0.0)) {}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ca684686609263ecb8579a95276e2bf"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="a6ca684686609263ecb8579a95276e2bf" args="(const LabBox &amp;lb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a labeled box. Range is set to 0.0. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00057">57</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">  : <a class="code" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode&lt;cxsc::real&gt;</a>(lb, real(0.0)) {}
</pre></div>
</div>
</div>
<a class="anchor" id="a77bada00301c6333863d80ca002fd86c"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="a77bada00301c6333863d80ca002fd86c" args="(const ivector &amp;v, const cxsc::real &amp;range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::real &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a box and and a real value for the range. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00065">65</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">  : <a class="code" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode&lt;cxsc::real&gt;</a>(v, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>) {}
</pre></div>
</div>
</div>
<a class="anchor" id="a12af9b0be5c63f0e1af1849d70b1b647"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="a12af9b0be5c63f0e1af1849d70b1b647" args="(const LabBox &amp;lb, const cxsc::real &amp;range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::real &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a labeled box and a real value for the rangeCollection. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00073">73</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">  : <a class="code" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode&lt;cxsc::real&gt;</a>(lb, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>) {}
</pre></div>
</div>
</div>
<a class="anchor" id="add6e4bba67a9d900ebebf07f420ad813"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="add6e4bba67a9d900ebebf07f420ad813" args="(const SPnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor initialised with an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>. </p>
<p>Range is set to csxc::real(0.0);</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>An <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>spn</em> must have a box. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>This has a subpaving identical to <em>spn</em> and the value mapped onto each node of this is 0.0. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00080">80</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00044">RealMappedSPnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) { 
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector( spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() );
  }
  <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
  <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = 0.0;
  
  <span class="comment">//recursion on the children</span>
  <span class="keywordflow">if</span> (spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

  <span class="keywordflow">if</span> (spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a4ec458c112685446a703ae73fe812b84"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="a4ec458c112685446a703ae73fe812b84" args="(const SPSnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor initialised with an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>.</p>
<p>A <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> is thrown if <em>other</em> has no box.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>An <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>spn</em> must have a box. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>This has a subpaving identical to <em>spn</em> and the value mapped onto each node of this is the value of count/nodeVolume from the equivalent node in <em>spn</em>. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00108">108</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00465">subpavings::SPnode::nodeRealVolume()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00044">RealMappedSPnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) { 
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector( spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() );
  }
  <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
  <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = (1.0*spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>()/<a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>());
  
  <span class="comment">//recursion on the children</span>
  <span class="keywordflow">if</span> (spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

  <span class="keywordflow">if</span> (spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;

}
</pre></div>
</div>
</div>
<a class="anchor" id="aea3c023626616315bdf71aaee45fa32f"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="aea3c023626616315bdf71aaee45fa32f" args="(const RealMappedSPnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies from given RealMappedSPnode downwards. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00134">134</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; T &gt;::getRange()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00044">RealMappedSPnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  <span class="keywordflow">if</span> (other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector( other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() );
  }
  <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
  <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = other.<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>();
  
  <span class="comment">//recursion on the children</span>
  <span class="keywordflow">if</span> (other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(other.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

  <span class="keywordflow">if</span> (other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(other.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;

}
</pre></div>
</div>
</div>
<a class="anchor" id="afcd2676e416102b713d9ce735bc27889"></a><!-- doxytag: member="subpavings::RealMappedSPnode::RealMappedSPnode" ref="afcd2676e416102b713d9ce735bc27889" args="(const MappedSPnode&lt; cxsc::real &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6">RealMappedSPnode::RealMappedSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; cxsc::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Copies from a given MappedSPnode&lt;cxsc::real&gt; node downwards. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00161">161</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00225">subpavings::MappedSPnode&lt; T &gt;::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; T &gt;::getRange()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00232">subpavings::MappedSPnode&lt; T &gt;::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00044">RealMappedSPnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (!other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector( other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() );
  }
  <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>();
  <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> = other.<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>();
  
  <span class="comment">//recursion on the children</span>
  <span class="keywordflow">if</span> (other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(other.<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093" title="Accessor for the left child of a node.">getLeftChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

  <span class="keywordflow">if</span> (other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(
      *(other.<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9" title="Accessor for the right child of a node.">getRightChild</a>())));
  }
  <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a769c7c79a6ce88db0854b2cbffb97747"></a><!-- doxytag: member="subpavings::RealMappedSPnode::_getL1distance" ref="a769c7c79a6ce88db0854b2cbffb97747" args="(cxsc::dotprecision &amp;disL1, const RealMappedSPnode *const other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::dotprecision &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a769c7c79a6ce88db0854b2cbffb97747">RealMappedSPnode::_getL1distance</a> </td>
          <td>(</td>
          <td class="paramtype">cxsc::dotprecision &amp;&#160;</td>
          <td class="paramname"><em>disL1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> *const&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate L1 distance between leaf descendents of this and leaf descendents of node pointed to by <em>other</em> into <em>disL1</em>. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">971</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">_getL1distance()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; T &gt;::getRange()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">nodeL1Distance()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">_getL1distance()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00484">getL1Distance()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">  #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\nIn _getL1distance, I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  <span class="comment">// other is not a leaf</span>
  <span class="keywordflow">if</span> (!other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    
<span class="preprocessor">    #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;Other is not a leaf, other name is &quot;</span> &lt;&lt; other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
      
<span class="preprocessor">      #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;I am a leaf&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>    
      <span class="comment">// turn it around and use nodeL1Distance with other</span>
      other-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a3171d7822ccbcb05ed2b997c678b325a" title="Accumulate L1 distance between this and another identical node with value other_v mapped onto it...">nodeL1Distance</a>(disL1, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>());
    }
    
    <span class="keywordflow">else</span> { <span class="comment">// I am not a leaf, so recurse</span>
    
<span class="preprocessor">      #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;I am not a leaf: recursing&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">      #endif</span>
<span class="preprocessor"></span>      
      <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a769c7c79a6ce88db0854b2cbffb97747" title="Accumulate L1 distance between leaf descendents of this and leaf descendents of node pointed to by ot...">_getL1distance</a>(disL1, other-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>());
      <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a769c7c79a6ce88db0854b2cbffb97747" title="Accumulate L1 distance between leaf descendents of this and leaf descendents of node pointed to by ot...">_getL1distance</a>(disL1, other-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>());
    }
  }
  
  <span class="keywordflow">else</span> { <span class="comment">// other is a leaf</span>
  
<span class="preprocessor">    #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;Other is a leaf, other name is &quot;</span> &lt;&lt; other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a3171d7822ccbcb05ed2b997c678b325a" title="Accumulate L1 distance between this and another identical node with value other_v mapped onto it...">nodeL1Distance</a>(disL1, other-&gt;<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>());
  
  }
  
  <span class="keywordflow">return</span> disL1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa65475d7ae1efb7ba1c7cd5bd0c13c5d"></a><!-- doxytag: member="subpavings::RealMappedSPnode::_getLogLikelihood" ref="aa65475d7ae1efb7ba1c7cd5bd0c13c5d" args="(cxsc::dotprecision &amp;loglik, int &amp;isnan, int &amp;isposinf, int &amp;isneginf, const SPSnode *const spn) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::dotprecision &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#aa65475d7ae1efb7ba1c7cd5bd0c13c5d">RealMappedSPnode::_getLogLikelihood</a> </td>
          <td>(</td>
          <td class="paramtype">cxsc::dotprecision &amp;&#160;</td>
          <td class="paramname"><em>loglik</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>isnan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>isposinf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>isneginf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate log likelihood using positive values from this and counts from <em>spn</em>. </p>
<p>For all leaf nodes with positive values (ie &gt; 0.0) in the intersection of the tree rooted at this and the tree rooted at <em>spn</em>, including this if this is a leaf, accumulates n_j * ln(v_j) into <em>loglik</em> where v_j is the value on the leaf node of this and n_j is the count from the corresponding leaf node of <em>spn</em>.</p>
<p>If v_j &lt; 0.0 (including -infinity) is encountered for any leaf where <em>spn</em> has points, the isnan flag is set to 1. Otherwise if v_j == 0.0 is encountered for any leaf where <em>spn</em> has points, the isneginf flag is set to 1 and the log likelihood becomes -infinity. Otherwise if v_j == infinity is encountered for any leaf where <em>spn</em> has points, the isposinf flag is set to 1 and log likelihood becomes +infinity. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">1065</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">_getLogLikelihood()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00960">taylor::ln()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">_getLogLikelihood()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00508">getLogLikelihood()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">  #ifdef DEBUG_LL</span>
<span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\nIn _getLogLikelihood, I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() 
    &lt;&lt; <span class="stringliteral">&quot;, and loglik is &quot;</span> &lt;&lt; (rnd(loglik)) &lt;&lt; endl;
    &lt;&lt; <span class="stringliteral">&quot;, and isnan is &quot;</span> &lt;&lt; isnan &lt;&lt; <span class="stringliteral">&quot;, and isinf is &quot;</span> &lt;&lt; isinf &lt;&lt;  &lt;&lt; endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;\nspn is &quot;</span> &lt;&lt; spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  <span class="comment">// not already nan , and neither this nor spn is a leaf, so we recurse</span>
  <span class="keywordflow">if</span> (!isnan &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !(spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>())) {
    
<span class="preprocessor">    #ifdef DEBUG_LL</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;All okay and neither I nor spn is a leaf&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    loglik = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#aa65475d7ae1efb7ba1c7cd5bd0c13c5d" title="Accumulate log likelihood using positive values from this and counts from spn.">_getLogLikelihood</a>(loglik, 
                isnan, isposinf, isneginf,
                spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>() );
    <span class="keywordflow">if</span> (!isnan) { <span class="comment">// check again on isnan</span>
      loglik = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#aa65475d7ae1efb7ba1c7cd5bd0c13c5d" title="Accumulate log likelihood using positive values from this and counts from spn.">_getLogLikelihood</a>(loglik, 
                isnan, isposinf, isneginf,
                spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>() );
    }
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isnan) { <span class="comment">// this is a leaf OR spn is a leaf - can already be inf</span>
  
    <span class="comment">// add in nj*log(hj) for me</span>
    <span class="keywordtype">size_t</span> n = spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    
<span class="preprocessor">    #ifdef DEBUG_LL</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;I am a leaf, my range value is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>() &lt;&lt; endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;, and spn-&gt;getCounter is &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>      
    <span class="keywordflow">if</span> (n &gt; 0) {
      
      <span class="comment">/* if already +infinity we can reset this to nan (- range) or -infinity (0 range)</span>
<span class="comment">      * if already -infinity we can reset this to nan (-range) */</span>
    
      real rng = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>();
      
      <span class="keywordflow">if</span> (rng &lt; 0.0) { <span class="comment">// nan whenever we find a negative range even if n ==0;</span>
        isnan = 1; <span class="comment">// change by ref</span>
<span class="preprocessor">        #ifdef DEBUG_LL</span>
<span class="preprocessor"></span>          std::cout &lt;&lt; <span class="stringliteral">&quot;rng &lt; 0.0: adding nothing to log lik, &quot;</span>;
          std::cout &lt;&lt; <span class="stringliteral">&quot;and isnan = &quot;</span> &lt;&lt; isnan &lt;&lt; std::endl;
          std::cout &lt;&lt; <span class="stringliteral">&quot;loglik is now: &quot;</span> &lt;&lt; (rnd(loglik)) &lt;&lt; std::endl;
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span>      }
      
      <span class="comment">// -inf will be &lt; 0 and also IsInfinity so the else if gives +infs</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isneginf) {
        <span class="keywordflow">if</span> ( gsl_isinf(_double(rng)) ) {
          <span class="keywordflow">if</span> (!isposinf ) {
            <span class="comment">// only reset to +ve infinity if not already infinity (+ve or n-ve)</span>
            isposinf = 1; <span class="comment">// change by ref</span>
            loglik = cxsc::dotprecision(cxsc::Infinity);
<span class="preprocessor">            #ifdef DEBUG_LL</span>
<span class="preprocessor"></span>              std::cout &lt;&lt; <span class="stringliteral">&quot;rng is Infinity: log lik = inf, &quot;</span>;
              std::cout &lt;&lt; <span class="stringliteral">&quot;and isposinf = &quot;</span> &lt;&lt; isposinf &lt;&lt; std::endl;
              std::cout &lt;&lt; <span class="stringliteral">&quot;loglik is now: &quot;</span> &lt;&lt; (rnd(loglik)) &lt;&lt; std::endl;
<span class="preprocessor">            #endif</span>
<span class="preprocessor"></span>          }
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rng &gt; 0.0) { <span class="comment">// not +ve infinity</span>
          <span class="keywordflow">if</span> (!isposinf) {
            accumulate(loglik, (1.0*n), <a class="code" href="namespacetaylor.shtml#a41b79fca8d7b9a92dee56066fe632560">cxsc::ln</a>(<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>()));
<span class="preprocessor">            #ifdef DEBUG_LL</span>
<span class="preprocessor"></span>              std::cout &lt;&lt; <span class="stringliteral">&quot;adding the following to log lik: &quot;</span>;
              std::cout &lt;&lt; (n * <a class="code" href="namespacetaylor.shtml#a41b79fca8d7b9a92dee56066fe632560">cxsc::ln</a>(rng)) &lt;&lt; std::endl;
<span class="preprocessor">            #endif</span>
<span class="preprocessor"></span>          }
        }
        <span class="keywordflow">else</span> { <span class="comment">// range must be 0.0 </span>
          isneginf = 1; <span class="comment">// change by ref</span>
          loglik = cxsc::dotprecision(-cxsc::Infinity);
<span class="preprocessor">          #ifdef DEBUG_LL</span>
<span class="preprocessor"></span>            std::cout &lt;&lt; <span class="stringliteral">&quot;rng is 0.0: log lik = -inf, &quot;</span>;
            std::cout &lt;&lt; <span class="stringliteral">&quot;and isneginf = &quot;</span> &lt;&lt; isneginf &lt;&lt; std::endl;
            std::cout &lt;&lt; <span class="stringliteral">&quot;loglik is now: &quot;</span> &lt;&lt; (rnd(loglik)) &lt;&lt; std::endl;
<span class="preprocessor">          #endif</span>
<span class="preprocessor"></span>        }
      }
    }
      
  }
  
  <span class="keywordflow">return</span> loglik;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a14871e233412eac80e1b742967d7ab2b"></a><!-- doxytag: member="subpavings::RealMappedSPnode::_marginalise" ref="a14871e233412eac80e1b742967d7ab2b" args="(const std::vector&lt; int &gt; &amp;outDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a14871e233412eac80e1b742967d7ab2b">RealMappedSPnode::_marginalise</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outDims</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-public version of marginalisation to take out the unwanted dimensions. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">783</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00211">getParent()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00515">subpavings::SPnode::getSplitDim()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">oneLineOutput()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00044">RealMappedSPnode()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00285">realVolume()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">subpavings::SPnode::recursiveRename()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00721">swapRMSPSR()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00731">_start_marginalise()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">  #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
  
  <span class="comment">// find if this node split on one of the given dimensions</span>
  <span class="comment">// returns -1 if no split</span>
  <span class="comment">// make sure we do this before fiddling with the children!</span>
  <span class="keywordtype">int</span> splitDim = <a class="code" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371" title="Get the split dimension for this.">getSplitDim</a>();
  
  <span class="comment">// deal with children first</span>
  <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;not a leaf - marginalising children\n&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>  
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a14871e233412eac80e1b742967d7ab2b" title="Non-public version of marginalisation to take out the unwanted dimensions.">_marginalise</a>(outDims);    
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a14871e233412eac80e1b742967d7ab2b" title="Non-public version of marginalisation to take out the unwanted dimensions.">_marginalise</a>(outDims); 
  }               
          
  <span class="comment">// now deal with this node itself</span>
<span class="preprocessor">  #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) std::cout &lt;&lt; <span class="stringliteral">&quot;\nback in &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy split dimension is &quot;</span> &lt;&lt; splitDim &lt;&lt; std::endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  std::vector&lt;int&gt;::const_iterator found 
      = find (outDims.begin(), outDims.end(), splitDim);
  
  <span class="comment">/* if we split on any of the given dimensions</span>
<span class="comment">   then we drop this from the tree entirely and</span>
<span class="comment">   replace it with the result</span>
<span class="comment">   of adding the two new children together */</span>
  <span class="keywordflow">if</span> (found &lt; outDims.end()) { <span class="comment">// split on one of the outDims</span>
    <span class="comment">// so this will become the result of adding together</span>
    <span class="comment">// the two marginlised children</span>
    <span class="comment">// note - can never be in here if this is a leaf</span>
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy split dim is one of the dimensions to be removed&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="comment">// save who our parent is</span>
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* savedParent = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd" title="Accessor for the parent of a node.">getParent</a>();
    
    <span class="comment">// and detach ourselves from parent</span>
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = NULL;
    
    <span class="comment">// make a copy of the addition left and</span>
    <span class="comment">// right children - use the copy constructor to</span>
    <span class="comment">// make a temporary, do addition and then just swap </span>
    
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> temp(*<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>());
    
    <span class="comment">// keep the same number of elements in the range collection</span>
    temp += (*<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>());
    
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#af2612c2a420a9f91c8bca09f0bb6ab42">swapRMSPSR</a>(temp); <span class="comment">//swap me and temp</span>
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;\tre-made me out of parallel addition collation of my children:&quot;</span> 
                  &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy range collection is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;\tand my box is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
      <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;\tand my children (before renaming) are:&quot;</span> &lt;&lt; std::endl;
        <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a5287c7cec21af1c8606d735c0478a6fc" title="A quick one-line summary of a node.">oneLineOutput</a>(std::cout, 2);
        <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a5287c7cec21af1c8606d735c0478a6fc" title="A quick one-line summary of a node.">oneLineOutput</a>(std::cout, 2);
      }
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="comment">// restore relationship to parent</span>
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = savedParent;
    
  }
  <span class="keywordflow">else</span> { <span class="comment">// did not split on an outdim or is a leaf</span>
    <span class="comment">// have to contract this</span>
    <span class="comment">// marginalised children (if any) will still be attached</span>
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;\tI did not split on a dimension to take out, or I am a leaf, so need to contract box&quot;</span> &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;\tmy box is &quot;</span> &lt;&lt; box &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="keywordtype">int</span> dim = VecLen(box);
    <span class="keywordtype">int</span> boxLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
  
    <span class="keywordtype">int</span> newDims = dim - outDims.size();
    ivector newBox = ivector(newDims); 
    <span class="keywordtype">int</span> index = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(newBox);
    <span class="keywordtype">int</span> oldindex = boxLB;
  
    <span class="comment">// put in the upper and lower bounds for the new box</span>
    <span class="comment">// for each dimension that stays  </span>
    <span class="keywordflow">for</span> (; oldindex &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(box); oldindex++) {
      std::vector&lt;int&gt;::const_iterator fit 
      = find (outDims.begin(), outDims.end(), (oldindex - boxLB + 1));
      <span class="keywordflow">if</span> (!(fit &lt; outDims.end())) { <span class="comment">// keep this one</span>
        newBox[index] = box[oldindex];
        index++;
      }
    }
    
    <span class="comment">// find the volume we missed</span>
    cxsc::real missingVol = <a class="code" href="toolz_8cpp.shtml#acdd3d20a2f2c8114e1195f5e6baa078f" title="Return the volume of box x as a real.">realVolume</a>(box)/<a class="code" href="toolz_8cpp.shtml#acdd3d20a2f2c8114e1195f5e6baa078f" title="Return the volume of box x as a real.">realVolume</a>(newBox);
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;\tnew box is &quot;</span> &lt;&lt; newBox &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;\tmissing volume is &quot;</span> &lt;&lt; missingVol &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="comment">//store the child node locations and then temporarily detach them</span>
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* savedLC = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>();
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* savedRC = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>();
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
    
    <span class="comment">// also need to store parent</span>
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* savedParent = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd" title="Accessor for the parent of a node.">getParent</a>();
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = NULL;
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;\tcurrent range is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>  
    cxsc::real temp = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>();
    
    temp *= missingVol;
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;scaled up range is &quot;</span> &lt;&lt; temp &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="comment">// replace contents of this with contents of a newly made node  </span>
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> 
        tempNode( <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(newBox, temp) );
    this-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#af2612c2a420a9f91c8bca09f0bb6ab42">swapRMSPSR</a>(tempNode);
    
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;\tafter contracting, my box is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;\tand after scaling up my range ,&quot;</span>;
      std::cout &lt;&lt; <span class="stringliteral">&quot;\n\tmy range is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    <span class="comment">// put the child pointers back, and reattach to parent</span>
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = savedLC;
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = savedRC;
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> = savedParent;
    
  } <span class="comment">// finished else</span>
  
  <span class="comment">//if we are the root, recursively rename everything</span>
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd" title="Accessor for the parent of a node.">getParent</a>() == NULL) {
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>();
<span class="preprocessor">    #ifdef MARG_OUTPUT</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;\nNow recursively rename everything from me down\n\n&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a185405d2c7b3231a75b33ec249292e2d"></a><!-- doxytag: member="subpavings::RealMappedSPnode::_normalise" ref="a185405d2c7b3231a75b33ec249292e2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a185405d2c7b3231a75b33ec249292e2d">RealMappedSPnode::_normalise</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-public version of normalisation. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00949">949</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00583">getTotalAbsLeafAreaRangeWithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00437">makeNormalised()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00428">normalise()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a>(
      <span class="stringliteral">&quot;RealMappedSPnode::_normalise()&quot;</span>);
  }
  
  cxsc::real normaliser = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox</a>();
  <span class="keywordflow">if</span> (normaliser == cxsc::Infinity) {
    <span class="keywordflow">throw</span> std::runtime_error(
      <span class="stringliteral">&quot;RealMappedSPnode::_normalise() : Normalising constant is Infinity&quot;</span>);
  }
  <span class="keywordflow">if</span> (normaliser &lt;= 0.0) {
    <span class="keywordflow">throw</span> std::runtime_error(
      <span class="stringliteral">&quot;RealMappedSPnode::_normalise() : Normalising constant is &lt;= 0.0&quot;</span>);
  }
  (*this) /= normaliser;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4f2a09e57bff1fd459e8bf631019b07f"></a><!-- doxytag: member="subpavings::RealMappedSPnode::_start_marginalise" ref="a4f2a09e57bff1fd459e8bf631019b07f" args="(const std::vector&lt; int &gt; &amp;reqDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f2a09e57bff1fd459e8bf631019b07f">RealMappedSPnode::_start_marginalise</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>reqDims</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-public version of marginalisation to have only the required dimensions. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00731">731</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00418">makeMarginalised()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00407">marginalise()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a>(
    <span class="stringliteral">&quot;RealMappedSPnode::_start_marginalise(const std::vector&lt;int&gt;&amp;)&quot;</span>);
  }
  
  
  <span class="keywordflow">if</span> (reqDims.empty()) {
    <span class="keywordflow">throw</span> std::invalid_argument(
      <span class="stringliteral">&quot;RealMappedSPnode::_start_marginalise(const std::vector&lt;int&gt;&amp;) : reqDims.empty()&quot;</span>);
  }
  
  <span class="comment">// want to find what dimensions to take out given required dimensions</span>
  ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
  <span class="keywordtype">int</span> dim = VecLen(box);
  <span class="keywordtype">int</span> boxLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
  <span class="keywordtype">int</span> boxUB = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(box);
  <span class="comment">//each of the required dims must be there</span>
  std::vector&lt;int&gt; sorted = reqDims;
  sort(sorted.begin(), sorted.end());
  
  <span class="comment">// remove any duplicates</span>
  vector&lt;int&gt;::iterator it = unique (sorted.begin(), sorted.end());
  sorted.resize( it - sorted.begin() );

  <span class="keywordflow">if</span> ( (*(sorted.begin()) &lt; 1)) {
    <span class="keywordflow">throw</span> std::invalid_argument(
    <span class="stringliteral">&quot;RealMappedSPnode::_start_marginalise(const std::vector&lt;int&gt;&amp;) : Dimensions &lt; 1&quot;</span>);
  }
  
  <span class="keywordflow">if</span> (*(sorted.rbegin()) &gt; boxUB - boxLB + 1)  {
    <span class="keywordflow">throw</span> std::invalid_argument(
    <span class="stringliteral">&quot;RealMappedSPnode::_start_marginalise(const std::vector&lt;int&gt;&amp;) : Dimension too large for box&quot;</span>);
  }
  <span class="comment">// could use min and max, but we want the not-req dims anyway</span>
  std::vector&lt;int&gt; outDims;
  
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= dim; i++) {
    <span class="keywordflow">if</span> (!(find(reqDims.begin(), reqDims.end(), i) &lt; reqDims.end())) {
      <span class="comment">// dim of box was not in reqDims </span>
      outDims.push_back(i);
    }
  }
  
  <span class="comment">// now we have the dimensions to take out</span>
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a14871e233412eac80e1b742967d7ab2b" title="Non-public version of marginalisation to take out the unwanted dimensions.">_marginalise</a>(outDims); <span class="comment">// use internal version</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9409b660d7a7f1f35fc7f2d1904386c2"></a><!-- doxytag: member="subpavings::RealMappedSPnode::findContainingNode" ref="a9409b660d7a7f1f35fc7f2d1904386c2" args="(const cxsc::rvector &amp;pt, OPERATIONS_ON childInd=ON_PARENT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9409b660d7a7f1f35fc7f2d1904386c2">RealMappedSPnode::findContainingNode</a> </td>
          <td>(</td>
          <td class="paramtype">const cxsc::rvector &amp;&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a>&#160;</td>
          <td class="paramname"><em>childInd</em> = <code><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a pointer to the leaf node descendent of this whose box contains the point <em>pt</em>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL if no leaf node descendent of this contains <em>pt</em>, otherwise a pointer to the leaf node descendent of this whose box contains the point <em>pt</em>. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">265</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01043">subpavings::SPnode::nodeContains()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_RIGHT</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a>(
    <span class="stringliteral">&quot;RealMappedSPnode::findContainingNode(const cxsc::rvector&amp;, OPERATIONS_ON)&quot;</span>);
  }
  <span class="comment">// start at the top</span>
  <span class="keyword">const</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* retObj = NULL;
  
  <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#aaefe6100d8c62dc84849cd2adb733ffb" title="Check if the box a node represents contains a datapoint p.">nodeContains</a>(pt, childInd)) {
    
    <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {

      <span class="comment">// give this node as return value</span>
      retObj = <span class="keyword">this</span>;

    } <span class="comment">// end of isLeaf</span>

    <span class="comment">// if not a leaf and contains data</span>
    <span class="comment">// recurse on the children if any</span>
    <span class="keywordflow">else</span> {

      <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()){
        
        retObj =
        (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a9409b660d7a7f1f35fc7f2d1904386c2">findContainingNode</a>(
          pt, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>);
        
      }
      <span class="comment">// only try left if we did not find on the right</span>
      <span class="keywordflow">if</span>(retObj == NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
        retObj =
        (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a9409b660d7a7f1f35fc7f2d1904386c2">findContainingNode</a>(
          pt, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>);
        
      }
    }

  } <span class="comment">// end if node contains</span>

  <span class="comment">// will return null if does not contain the data</span>
  
  <span class="keywordflow">return</span> retObj;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aea6a4c6aa2fe8eb944000db6790f9d8c"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getConstLeaves" ref="aea6a4c6aa2fe8eb944000db6790f9d8c" args="(ConstPtrs &amp;leaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">RealMappedSPnode::ConstPtrs</a> &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#aea6a4c6aa2fe8eb944000db6790f9d8c">RealMappedSPnode::getConstLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">RealMappedSPnode::ConstPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to a container of const nodes. </p>
<p>Contents of container are the leaves descended from this, or this if this is a leaf, left to right order. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">656</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">getConstLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">getConstLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//if children, recurse on the children</span>
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#aea6a4c6aa2fe8eb944000db6790f9d8c" title="Return a reference to a container of const nodes.">getConstLeaves</a>(leaves);
  }

  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#aea6a4c6aa2fe8eb944000db6790f9d8c" title="Return a reference to a container of const nodes.">getConstLeaves</a>(leaves);
  }

  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) { <span class="comment">// this is a leaf</span>
    leaves.push_back(<span class="keyword">this</span>);
  }
  <span class="keywordflow">return</span> leaves;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac6e092c4b19b8747f154eefd56d3e864"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getConstSubLeaves" ref="ac6e092c4b19b8747f154eefd56d3e864" args="(ConstPtrs &amp;subleaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">RealMappedSPnode::ConstPtrs</a> &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac6e092c4b19b8747f154eefd56d3e864">RealMappedSPnode::getConstSubLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5fc20ec0cd33f031e874f50251156e65">RealMappedSPnode::ConstPtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>subleaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to a container of const nodes. </p>
<p>Contents of container are the sub-leaves descended from this, or this if this is a sub-leaf, left to right order.</p>
<p>A sub-leaf (aka "cherry") is a node with two leaf child nodes. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00703">703</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00703">getConstSubLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00443">subpavings::SPnode::isSubLeaf()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00703">getConstSubLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc" title="find if this node is a subleaf node.">isSubLeaf</a>()) { <span class="comment">// this is a subleaf</span>
    subleaves.push_back(<span class="keyword">this</span>);
  }
  <span class="comment">//if children, recurse on the children</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#ac6e092c4b19b8747f154eefd56d3e864" title="Return a reference to a container of const nodes.">getConstSubLeaves</a>(subleaves);
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#ac6e092c4b19b8747f154eefd56d3e864" title="Return a reference to a container of const nodes.">getConstSubLeaves</a>(subleaves);
  }

  
  <span class="keywordflow">return</span> subleaves;
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8f083e792f8980eec67298253428c5c9"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getDotPrecisionAreaRangeWithBox" ref="a8f083e792f8980eec67298253428c5c9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::dotprecision <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8f083e792f8980eec67298253428c5c9">RealMappedSPnode::getDotPrecisionAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the "area" of the range and the box of this as a dotprecision type. </p>
<p>The "area" returned should be the dotprecision product of the volume of the box represented by this and the real range of this. <b>But</b> note that if the range is cxsc::Infinity, the dotprecision result is the same as dotprecision(0.0). This is due to the working of the cxsc library. The results can therefore be highly misleading if the range is cxsc::Infinity</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dotprecision product of volume of box represented by this and real range of this. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Range of this is not cxsc::Infinity. </dd>
<dd>
this must have a boxe. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00551">551</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00465">subpavings::SPnode::nodeRealVolume()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00595">getTotalDotPrecisionAbsLeafAreaRangeWithBox()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00572">getTotalDotPrecisionLeafAreaRangeWithBox()</a>.</p>
<div class="fragment"><pre class="fragment">{
  cxsc::dotprecision result(0.0);
  cxsc::accumulate(result, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>(), <a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>());
  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af243ad67d0ff141d345e800b651a87e1"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getL1Distance" ref="af243ad67d0ff141d345e800b651a87e1" args="(const RealMappedSPnode &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#af243ad67d0ff141d345e800b651a87e1">RealMappedSPnode::getL1Distance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the L1 distance between this and another RealMappedSPnode.</p>
<p>The L1 distance is defined as the sum of the absolute values of the differences in 'area' represented by the leaf nodes of this and the other paving. The 'area' represented by a leaf node is the absolute value mapped to that leaf node multiplied by the volume of the box associated with the node.</p>
<p>Throws the following exceptions: </p>
<ul>
<li>
Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if either this or by <em>other</em> have no box. </li>
<li>
Throws a <a class="el" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a> if the dimensions and sizes of the boxes of this and <em>other</em> are not the same. </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>This will not attempt to adjust for any difference in total integral between this and <em>other:</em> the L1 distance is simply taken as the difference between the 'areas' of the leaf boxes.</dd>
<dd>
If this or <em>other</em> has leaf nodes with infinite ranges then the L1 distance between them will be infinite (cxsc::Infinity).</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the root of a RealMappedSPnode tree to calculate the L1 distance against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Both this and <em>other</em> must have boxes and those boxes must be the same. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this will be unchanged. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00484">484</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">_getL1distance()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a>(
      <span class="stringliteral">&quot;RealMappedSPnode::getL1Distance(const RealMappedSPnode&amp;)&quot;</span>);
  }
  
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a>(
      <span class="stringliteral">&quot;RealMappedSPnode::getL1Distance(const RealMappedSPnode&amp;)&quot;</span>);
  }
  
  
  
  cxsc::dotprecision retDP(0.0);
  
  <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp; other) retDP = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a769c7c79a6ce88db0854b2cbffb97747" title="Accumulate L1 distance between leaf descendents of this and leaf descendents of node pointed to by ot...">_getL1distance</a>(retDP, &amp;other);
  
  <span class="keywordflow">return</span> cxsc::rnd(retDP);
    
}
</pre></div>
</div>
</div>
<a class="anchor" id="a866601879aed0044333a5f28a773f677"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getLeaves" ref="a866601879aed0044333a5f28a773f677" args="(Ptrs &amp;leaves)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">RealMappedSPnode::Ptrs</a> &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a866601879aed0044333a5f28a773f677">RealMappedSPnode::getLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">RealMappedSPnode::Ptrs</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to a container of nodes. </p>
<p>Contents of container are the leaves descended from this, or this if this is a leaf, left to right order. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">632</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">getLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">getLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//if children, recurse on the children</span>
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a866601879aed0044333a5f28a773f677" title="Return a reference to a container of nodes.">getLeaves</a>(leaves);
  }

  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a866601879aed0044333a5f28a773f677" title="Return a reference to a container of nodes.">getLeaves</a>(leaves);
  }

  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) { <span class="comment">// this is a leaf</span>
    leaves.push_back(<span class="keyword">this</span>);
  }
  <span class="keywordflow">return</span> leaves;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a71ad37450934fcd212d1c13c9f8830d4"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getLeftChild" ref="a71ad37450934fcd212d1c13c9f8830d4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4">RealMappedSPnode::getLeftChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the left child of a node. </p>
<p>Returns a copy of the pointer to leftChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a31cc4a453d0c821592096b1829e43093">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">217</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">_getL1distance()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">_getLogLikelihood()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">findContainingNode()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">getConstLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00703">getConstSubLeaves()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">getLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00392">getMaxRangeForLeavesInTree()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00680">getSubLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00595">getTotalDotPrecisionAbsLeafAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00572">getTotalDotPrecisionLeafAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">hasInfiniteRangeInTree()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00227">hasNegativeRangeInTree()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">nodeExpand()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">nodeL1Distance()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00118">normHeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">oneLineOutput()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00134">RealMappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a116f7a6b92d5c442be9d8393b6e0e73f"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getLogLikelihood" ref="a116f7a6b92d5c442be9d8393b6e0e73f" args="(const SPSnode &amp;spn) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a116f7a6b92d5c442be9d8393b6e0e73f">RealMappedSPnode::getLogLikelihood</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a 'log likelihood' using positive values from this and counts from <em>spn</em>. </p>
<p>Treats the rages mapped onto the nodes of this like function values and uses the counts from <em>spn</em> together with these values to calculate a 'log-likelihood'.</p>
<p>If range &lt; 0.0 (including -infinity) is encountered for any leaf where <em>spn</em> has points, the method will return cxsc::SignalingNaN. Otherwise if range == 0.0 is encountered for any leaf where <em>spn</em> has points, the method will return -cxsc::Infinity. Otherwise if range == infinity is encountered for any leaf where <em>spn</em> has points, the method will return -cxsc::Infinity.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>is the root of an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree which provides information about counts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum over the leaf nodes with positive values in the intersection of the tree rooted at this and the tree rooted at <em>spn</em> of the product of the log of the value on the leaf descendent of this and the count on the corresponding leaf descendent of <em>spn</em>. Returns cxsc::SignalingNaN if negative ranges are encountered, else returns -cxsc::Infinity if zero ranges are encountered, else returns cxsc::Infinity if any infinite ranges are encountered. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this and <em>spn</em> are both non-empty and both have the same box. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00508">508</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">_getLogLikelihood()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a>(
      <span class="stringliteral">&quot;RealMappedSPnode::getLogLikelihood(const SPSnode&amp;)&quot;</span>);
  }
  
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != spn.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a>(
      <span class="stringliteral">&quot;RealMappedSPnode::getLogLikelihood(const SPSnode&amp;)&quot;</span>);
  }
  cxsc::real result(0.0);
  
  <span class="keywordflow">if</span> (spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &gt; 0) {
    
    cxsc::dotprecision loglik(0.0);
    
    <span class="keywordtype">int</span> isnan = 0;
    <span class="keywordtype">int</span> isposinf =0;
    <span class="keywordtype">int</span> isneginf =0; <span class="comment">// all these 3 changed by ref</span>
    
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#aa65475d7ae1efb7ba1c7cd5bd0c13c5d" title="Accumulate log likelihood using positive values from this and counts from spn.">_getLogLikelihood</a>(loglik, isnan, isposinf, isneginf, &amp;spn);
    
    <span class="comment">/*nan if nan flag is set*/</span>
    <span class="keywordflow">if</span> (isnan ) result = cxsc::SignalingNaN;
    <span class="keywordflow">else</span> result = cxsc::rnd(loglik);
    <span class="comment">/* result could be -inf if there are 0 ranges in tree where spn </span>
<span class="comment">     * has points or inf if there are inf ranges in tree where spn has points*/</span> 
  }

  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abae5bea82b46019e23d98756973c6860"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getMaxRangeForLeavesInTree" ref="abae5bea82b46019e23d98756973c6860" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#abae5bea82b46019e23d98756973c6860">RealMappedSPnode::getMaxRangeForLeavesInTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get maximum value of the range for any of the leaves of the tree rooted at this. </p>
<p>Returns the range of this if this is a leaf.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum value of the range for any of the leaves of the tree rooted at this. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00392">392</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00392">getMaxRangeForLeavesInTree()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00392">getMaxRangeForLeavesInTree()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>();
  }
  <span class="keywordflow">else</span> {
    cxsc::real rLC = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#abae5bea82b46019e23d98756973c6860" title="Get maximum value of the range for any of the leaves of the tree rooted at this.">getMaxRangeForLeavesInTree</a>();
    cxsc::real rRC = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#abae5bea82b46019e23d98756973c6860" title="Get maximum value of the range for any of the leaves of the tree rooted at this.">getMaxRangeForLeavesInTree</a>();
    <span class="keywordflow">return</span> (rLC &gt; rRC? rLC : rRC);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a04fef135a04c4d165c08395c531581dd"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getParent" ref="a04fef135a04c4d165c08395c531581dd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd">RealMappedSPnode::getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the parent of a node. </p>
<p>Returns a copy of the pointer to parent node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a700d3bf53c72e2fdecf27446fab902ef">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00211">211</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00407">marginalise()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00428">normalise()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a153b19ceeba356f0ada4e27dfcf6ab37"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getRealAreaRangeWithBox" ref="a153b19ceeba356f0ada4e27dfcf6ab37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a153b19ceeba356f0ada4e27dfcf6ab37">RealMappedSPnode::getRealAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the "area" of the range and the box of this. </p>
<p>The "area" returned is calculated as the volume of the box represented by this multiplied by the real range of this (which can also be seen as the volume of the box represented by this with another dimension equal to an interval that has Inf 0 and Sup equal to the range of this).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>volume of box represented by this multiplied by real range of this. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this must have a boxe. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00543">543</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00465">subpavings::SPnode::nodeRealVolume()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>() * <a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a19cb07beb697f0f8613a63c0b476ddd9"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getRightChild" ref="a19cb07beb697f0f8613a63c0b476ddd9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> * <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9">RealMappedSPnode::getRightChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the right child of a node. </p>
<p>Returns a copy of the pointer to rightChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a3d15d4b64a8c01fbfabdb66c37c89ad9">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">223</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">_getL1distance()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">_getLogLikelihood()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00265">findContainingNode()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00077">getAllWeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00656">getConstLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00703">getConstSubLeaves()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00096">getHeightAndBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00632">getLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00392">getMaxRangeForLeavesInTree()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00680">getSubLeaves()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00595">getTotalDotPrecisionAbsLeafAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00572">getTotalDotPrecisionLeafAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">hasInfiniteRangeInTree()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00227">hasNegativeRangeInTree()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">nodeExpand()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">nodeL1Distance()</a>, <a class="el" href="MappedFiniteMixtureLeafCounts_8cpp_source.shtml#l00118">normHeights()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">oneLineOutput()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00134">RealMappedSPnode()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a561d20d602eafff9592fdd0ee912ffcc"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getSubLeaves" ref="a561d20d602eafff9592fdd0ee912ffcc" args="(Ptrs &amp;subleaves)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">RealMappedSPnode::Ptrs</a> &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a561d20d602eafff9592fdd0ee912ffcc">RealMappedSPnode::getSubLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a9591975c77c7e7da92bbdcdf62a74d1a">RealMappedSPnode::Ptrs</a> &amp;&#160;</td>
          <td class="paramname"><em>subleaves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to a container of nodes. </p>
<p>Contents of container are the sub-leaves descended from this, or this if this is a sub-leaf, left to right order.</p>
<p>A sub-leaf (aka "cherry") is a node with two leaf child nodes. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00680">680</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00680">getSubLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00443">subpavings::SPnode::isSubLeaf()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00680">getSubLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc" title="find if this node is a subleaf node.">isSubLeaf</a>()) { <span class="comment">// this is a subleaf</span>
    subleaves.push_back(<span class="keyword">this</span>);
  }
  
  <span class="comment">//if children, recurse on the children</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a561d20d602eafff9592fdd0ee912ffcc" title="Return a reference to a container of nodes.">getSubLeaves</a>(subleaves);
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a561d20d602eafff9592fdd0ee912ffcc" title="Return a reference to a container of nodes.">getSubLeaves</a>(subleaves);
  }

  <span class="keywordflow">return</span> subleaves;
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0660b7981cce44ca09c2e0d68a6c1a21"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getTotalAbsDiffLeafAreaRangeWithBox" ref="a0660b7981cce44ca09c2e0d68a6c1a21" args="(const RealMappedSPnode &amp;rmsp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a0660b7981cce44ca09c2e0d68a6c1a21">RealMappedSPnode::getTotalAbsDiffLeafAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rmsp</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total over the leaves of the absolute value of the difference between the leaf "area" for this and for <em>rmsp</em>. </p>
<p>For each leaf descendent of the subpaving union of this and <em>rmsp</em> the "area" returned is calculated as the volume of the box represented multiplied by the absolute value of the difference between the range on that leaf for this and for <em>rmsp</em> real.</p>
<p>This method should return the same as if the method <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> was called on a node which is the difference between this and <em>rmsp</em> (ie *this - rmsp).</p>
<p>If there are an infinite ranges in the tree rooted at this, or <em>rmps</em>, the method will return cxsc::Infinity.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rmsp</td><td>the RealMappedSPnode to calculate the difference against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>total over the leaves of the union of this and <em>rmsp</em> of the absolute value of the difference between the leaf "area" for this and for <em>rmsp</em> (returns cxsc::Infinity if <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree()</a> or if rmsp.hasInfiniteRangeInTree()). </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this and <em>rmsp</em> have the same box. </dd>
<dd>
all leaf descendents of this and <em>rmsp</em> must have boxes. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00606">606</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00583">getTotalAbsLeafAreaRangeWithBox()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">hasInfiniteRangeInTree()</a>.</p>
<div class="fragment"><pre class="fragment">{
  cxsc::real total = cxsc::Infinity;
  
  <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree</a>() &amp;&amp; !rmsp.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree</a>()) {
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> diff = *<span class="keyword">this</span> - rmsp;
    total = diff.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox</a>();
    
  }
  <span class="keywordflow">return</span> total;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a972c5dbc0bedd9cad3af4f2af43be277"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getTotalAbsLeafAreaRangeWithBox" ref="a972c5dbc0bedd9cad3af4f2af43be277" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277">RealMappedSPnode::getTotalAbsLeafAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total absolute "area" for the leaves of this of the real ranges and boxes. </p>
<p>For each leaf descendent of this the "area" returned is calculated as the volume of the box represented multiplied by the absolute value of the real range of the node (which can also be seen as the volume of the box represented with another dimension equal to an interval that has Inf 0 and Sup equal to the range of the node).</p>
<p>If there are an infinite ranges in the tree rooted at this, the method will return cxsc::Infinity.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>total over all leaf descendents of this of abs(volume of box represented multiplied by real range) (returns cxsc::Infinity if <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree()</a>). </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>all leaf descendents of this must have boxes. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00583">583</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00595">getTotalDotPrecisionAbsLeafAreaRangeWithBox()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">hasInfiniteRangeInTree()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00949">_normalise()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00606">getTotalAbsDiffLeafAreaRangeWithBox()</a>.</p>
<div class="fragment"><pre class="fragment">{
  cxsc::real total = cxsc::Infinity;
  
  <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree</a>()) {
    total = rnd(<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a2901c49d51615810f146a38ccb503fda" title="Get the total absolute &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionAbsLeafAreaRangeWithBox</a>());
  }
  
  <span class="keywordflow">return</span> total;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a74ba255a0781497c5dc76e8458969278"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getTotalDotPrecisionAbsDiffLeafAreaRangeWithBox" ref="a74ba255a0781497c5dc76e8458969278" args="(const RealMappedSPnode &amp;rmsp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::dotprecision <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a74ba255a0781497c5dc76e8458969278">RealMappedSPnode::getTotalDotPrecisionAbsDiffLeafAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rmsp</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total over the leaves of the absolute value of the difference between the leaf "area" for this and for <em>rmsp</em> as a dotprecision type. </p>
<p>For each leaf descendent of the subpaving union of this and <em>rmsp</em> the "area" returned is calculated as the volume of the box represented multiplied by the absolute value of the difference between the range on that leaf for this and for <em>rmsp</em> real. <b>But</b> note that if the range of a leaf node of this or <em>rmsp</em> is cxsc::Infinity, the dotprecision result for that leaf is the same as dotprecision(0.0). This is due to the working of the cxsc library. The results can therefore be highly misleading if any leaf node in this or <em>rmsp</em> has range cxsc::Infinity.</p>
<p>This method should return the same as if the method <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a2901c49d51615810f146a38ccb503fda" title="Get the total absolute &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionAbsLeafAreaRangeWithBox()</a> was called on a node which is the difference between this and <em>rmsp</em> (ie *this - rmsp).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rmsp</td><td>the RealMappedSPnode to calculate the difference against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dotprecision sum over the leaves of the union of this and <em>rmsp</em> of the absolute value of the difference between the leaf "area" for this and for <em>rmsp</em>. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this and <em>rmsp</em> have the same box. </dd>
<dd>
!hasInfiniteRangeInTree() and !rmsp.<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree()</a>. </dd>
<dd>
all leaf descendents of this and <em>rmsp</em> must have boxes. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00621">621</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00595">getTotalDotPrecisionAbsLeafAreaRangeWithBox()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> diff = *<span class="keyword">this</span> - rmsp;
  <span class="keywordflow">return</span> diff.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a2901c49d51615810f146a38ccb503fda" title="Get the total absolute &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionAbsLeafAreaRangeWithBox</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2901c49d51615810f146a38ccb503fda"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getTotalDotPrecisionAbsLeafAreaRangeWithBox" ref="a2901c49d51615810f146a38ccb503fda" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::dotprecision <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a2901c49d51615810f146a38ccb503fda">RealMappedSPnode::getTotalDotPrecisionAbsLeafAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total absolute "area" of the range and the box of this as a dotprecision type. </p>
<p>The "area" returned should be the sum over all the leaves of this of the absolute value of the dotprecision product of the volume of the box represented by the leaf node and the real range of the leaf note. <b>But</b> note that if the range of a leaf node is cxsc::Infinity, the dotprecision result for that leaf is the same as dotprecision(0.0). This is due to the working of the cxsc library. The results can therefore be highly misleading if any leaf node has range cxsc::Infinity.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dotprecision sum over leaf nodes of absolute value of the dotprecision product of volume of box represented by the leaf and the range of the leaf. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!hasInfiniteRangeInTree(). </dd>
<dd>
all leaf descendents of this must have boxes. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00595">595</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00551">getDotPrecisionAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00583">getTotalAbsLeafAreaRangeWithBox()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00621">getTotalDotPrecisionAbsDiffLeafAreaRangeWithBox()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) <span class="keywordflow">return</span> cxsc::abs(<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a8f083e792f8980eec67298253428c5c9" title="Get the &quot;area&quot; of the range and the box of this as a dotprecision type.">getDotPrecisionAreaRangeWithBox</a>());
  <span class="keywordflow">else</span> {
    <span class="keywordflow">return</span> ( <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a2901c49d51615810f146a38ccb503fda" title="Get the total absolute &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionAbsLeafAreaRangeWithBox</a>()
      + <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a2901c49d51615810f146a38ccb503fda" title="Get the total absolute &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionAbsLeafAreaRangeWithBox</a>() );
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4f769639fd1e13ea5449bb12dc53c998"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getTotalDotPrecisionLeafAreaRangeWithBox" ref="a4f769639fd1e13ea5449bb12dc53c998" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::dotprecision <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f769639fd1e13ea5449bb12dc53c998">RealMappedSPnode::getTotalDotPrecisionLeafAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total "area" of the range and the box of this as a dotprecision type. </p>
<p>The "area" returned should be the sum over all the leaves of this of the dotprecision product of the volume of the box represented by the leaf node and the real range of the leaf note. <b>But</b> note that if the range of a leaf node is cxsc::Infinity, the dotprecision result for that leaf is the same as dotprecision(0.0). This is due to the working of the cxsc library. The results can therefore be highly misleading if any leaf node has range cxsc::Infinity.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dotprecision sum over leaf nodes of dotprecision product of volume of box represented by the leaf and the range of the leaf. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>!hasInfiniteRangeInTree(). </dd>
<dd>
all leaf descendents of this must have boxes. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00572">572</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00551">getDotPrecisionAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00559">getTotalLeafAreaRangeWithBox()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a8f083e792f8980eec67298253428c5c9" title="Get the &quot;area&quot; of the range and the box of this as a dotprecision type.">getDotPrecisionAreaRangeWithBox</a>();
  <span class="keywordflow">else</span> {
    <span class="keywordflow">return</span> ( <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f769639fd1e13ea5449bb12dc53c998" title="Get the total &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionLeafAreaRangeWithBox</a>()
      + <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f769639fd1e13ea5449bb12dc53c998" title="Get the total &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionLeafAreaRangeWithBox</a>() );
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a23ef95e66b4b920f205739d9cf42f96f"></a><!-- doxytag: member="subpavings::RealMappedSPnode::getTotalLeafAreaRangeWithBox" ref="a23ef95e66b4b920f205739d9cf42f96f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a23ef95e66b4b920f205739d9cf42f96f">RealMappedSPnode::getTotalLeafAreaRangeWithBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total "area" for the leaves of this of the real ranges and boxes. </p>
<p>For each leaf descendent of this the "area" returned is calculated as the volume of the box represented multiplied by the real range of the node (which can also be seen as the volume of the box represented with another dimension equal to an interval that has Inf 0 and Sup equal to the range of the node).</p>
<p>If there are an infinite ranges in the tree rooted at this, the method will return cxsc::Infinity.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>total over all leaf descendents of this of (volume of box represented multiplied by real range) (returns cxsc::Infinity if <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree()</a>). </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>all leaf descendents of this must have boxes. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00559">559</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00572">getTotalDotPrecisionLeafAreaRangeWithBox()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">hasInfiniteRangeInTree()</a>.</p>
<div class="fragment"><pre class="fragment">{
  cxsc::real total = cxsc::Infinity;
  
  <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree</a>()) {
    total = rnd(<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f769639fd1e13ea5449bb12dc53c998" title="Get the total &quot;area&quot; of the range and the box of this as a dotprecision type.">getTotalDotPrecisionLeafAreaRangeWithBox</a>());
  }
  
  <span class="keywordflow">return</span> total;

}
</pre></div>
</div>
</div>
<a class="anchor" id="a738f4ef504214f9dd3a533f052f6d4cb"></a><!-- doxytag: member="subpavings::RealMappedSPnode::hasInfiniteRangeInTree" ref="a738f4ef504214f9dd3a533f052f6d4cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">RealMappedSPnode::hasInfiniteRangeInTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get whether there is an infinite range in the tree rooted at this. The tree rooted at this includes this node, subterminal nodes and leaf nodes).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the tree rooted at this has a node with an infinite range (ie range cxsc::Infinity) . </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">242</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">hasInfiniteRangeInTree()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00606">getTotalAbsDiffLeafAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00583">getTotalAbsLeafAreaRangeWithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00559">getTotalLeafAreaRangeWithBox()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00242">hasInfiniteRangeInTree()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> == cxsc::Infinity) {
    retValue = <span class="keyword">true</span>;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    retValue = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree</a>();
    <span class="keywordflow">if</span> (!retValue) retValue = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a738f4ef504214f9dd3a533f052f6d4cb">hasInfiniteRangeInTree</a>();
  }
  <span class="keywordflow">return</span> retValue;
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac4cadaec6d96f2a315218dc16a082f8a"></a><!-- doxytag: member="subpavings::RealMappedSPnode::hasNegativeRangeInTree" ref="ac4cadaec6d96f2a315218dc16a082f8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac4cadaec6d96f2a315218dc16a082f8a">RealMappedSPnode::hasNegativeRangeInTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get whether there is a negative range in the tree rooted at this. The tree rooted at this includes this node, subterminal nodes and leaf nodes).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the tree rooted at this has a node with a negative range. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00227">227</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00227">hasNegativeRangeInTree()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00227">hasNegativeRangeInTree()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a> &lt; real(0.0)) {
    retValue = <span class="keyword">true</span>;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    retValue = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#ac4cadaec6d96f2a315218dc16a082f8a">hasNegativeRangeInTree</a>();
    <span class="keywordflow">if</span> (!retValue) retValue = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#ac4cadaec6d96f2a315218dc16a082f8a">hasNegativeRangeInTree</a>();
  }
  <span class="keywordflow">return</span> retValue;
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab3ac1ccd24132d04f136a0fab3d0b610"></a><!-- doxytag: member="subpavings::RealMappedSPnode::makeMarginalised" ref="ab3ac1ccd24132d04f136a0fab3d0b610" args="(const std::vector&lt; int &gt; &amp;reqDims) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ab3ac1ccd24132d04f136a0fab3d0b610">RealMappedSPnode::makeMarginalised</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>reqDims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a marginalised version of this. </p>
<p>Makes a new RealMappedSPnode tree that s the marginal of this, marginalising to take out the unwanted dimensions and adjust the range so that node vol x range is the same as before, and does this recursively for all children so that after the marginalisation the sum over all leaves of (node vol x range) of the new tree is the same as for this.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>allowed dimensions start at 1, ie dimensions to marginalise on can include 1, 2, ... d where d = dimensions of this.</dd></dl>
<p>Throws the following exceptions: </p>
<ul>
<li>
Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if this is empty (has no box). </li>
<li>
Throws an std::invalid_argument if the required dimensions <em>reqDim</em> is empty or contains dimensions outside the range of the dimensions of this. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reqDims</td><td>is a vector of the dimensions to include in marginal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> with a subpaving that is the result of the marginalisation of the subpaving of this to include only the required dimensions and a range adjusted to preserve the range x node volume given the change in the volume of the subpaving box that the node represents compared to that in this. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>reqDims</em> must be compatible with current dimensions and this must have a box. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00418">418</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00731">_start_marginalise()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> result = *<span class="keyword">this</span>;

  result.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f2a09e57bff1fd459e8bf631019b07f" title="Non-public version of marginalisation to have only the required dimensions.">_start_marginalise</a>(reqDims);
  
  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a66a8b6deef3ba770a80a5b0b0418f5fc"></a><!-- doxytag: member="subpavings::RealMappedSPnode::makeNormalised" ref="a66a8b6deef3ba770a80a5b0b0418f5fc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a66a8b6deef3ba770a80a5b0b0418f5fc">RealMappedSPnode::makeNormalised</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a normalised version of this. </p>
<p>Makes a new RealMappedSPnode tree that is the normalised version of this, ie has the same subpaving but the total over all leaf nodes of the sum of (box volumes x range) is 1.0.</p>
<p>Throws the following exceptions: </p>
<ul>
<li>
Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if this is empty (has no box). </li>
<li>
Throws an std::runtime_error if this has no 'area', ie <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> &lt;= 0. </li>
<li>
Throws an std::runtime_error if this has no 'area', ie <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> == Infinity. </li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> with a subpaving that is the the same as the subpaving of this this with ranges such that the total over all leaf nodes of the sum of (box volumes x range) is 1.0. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this must have a box and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> != 0 and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> != Infinity. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00437">437</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00949">_normalise()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> result = *<span class="keyword">this</span>;

  result.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a185405d2c7b3231a75b33ec249292e2d" title="Non-public version of normalisation.">_normalise</a>();
  
  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2541f9ce5af2fcb753644d1f7e1f9297"></a><!-- doxytag: member="subpavings::RealMappedSPnode::makeSlice" ref="a2541f9ce5af2fcb753644d1f7e1f9297" args="(const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a2541f9ce5af2fcb753644d1f7e1f9297">RealMappedSPnode::makeSlice</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cxsc::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>slicePts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a RealMappedSPnode that is a slice of this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceDims</td><td>is a vector of dimensions to slice on. </td></tr>
    <tr><td class="paramname">slicePts</td><td>is a vector of points to slice on, assumed to correspond to the dimensions in <em>sliceDims</em>, ie the ith value in <em>sliceDims</em> gives the dimension for the ith point in <em>slicePts</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A RealMappedSPnode that is a slice of this on dimensions <em>sliceDims</em> at points <em>slicePts</em>. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00465">465</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; T &gt;::_slice()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01591">subpavings::MappedSPnode&lt; cxsc::real &gt;::sliceCheck()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  std::vector&lt;cxsc::real&gt; fullSlicePts = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a24ca6f695181dd45e5cf05d22042bb44" title="Check slice parameters and return a full vector of slice points.">sliceCheck</a>(sliceDims, slicePts);
  
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> result(*<span class="keyword">this</span>);
  result._slice(sliceDims, fullSlicePts);
  <span class="keywordflow">return</span> result;

}
</pre></div>
</div>
</div>
<a class="anchor" id="acf2399376e990903e5787b0a68eb350c"></a><!-- doxytag: member="subpavings::RealMappedSPnode::marginalise" ref="acf2399376e990903e5787b0a68eb350c" args="(const std::vector&lt; int &gt; &amp;reqDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#acf2399376e990903e5787b0a68eb350c">RealMappedSPnode::marginalise</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>reqDims</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Marginalise this. </p>
<p>Marginalises to take out the unwanted dimensions and adjust the range so that node vol x range is the same as before marginalisation, and does this recursively for all children of this so that after the marginalisation the sum over all leaves of (node vol x range) is the same as before marginalisation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>allowed dimensions start at 1, ie dimensions to marginalise on can include 1, 2, ... d where d = dimensions of this.</dd></dl>
<p>Throws the following exceptions: </p>
<ul>
<li>
Throws a <a class="el" href="classsubpavings_1_1NonRootNode__Error.shtml">NonRootNode_Error</a> if this has a parent (ie. is not a root node). </li>
<li>
Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if this is empty (has no box). </li>
<li>
Throws an std::invalid_argument if the required dimensions <em>reqDim</em> is empty or contains dimensions outside the range of the dimensions of this. </li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">reqDims</td><td>is a vector of the dimensions to include in marginal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>reqDims</em> must be compatible with current dimensions and this must be a root node (have no parent) with a box. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>This will have a tree structure that is the result of the marginalisation of the original subpaving to include only the required dimensions and will have a range adjusted to preserve the total range x volume given the change in the volume of the subpaving box that the node represents. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00407">407</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00731">_start_marginalise()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00211">getParent()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd" title="Accessor for the parent of a node.">getParent</a>() != NULL ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NonRootNode__Error.shtml">NonRootNode_Error</a>(
      <span class="stringliteral">&quot;RealMappedSPnode::marginalise(const std::vector&lt;int&gt;&amp;)&quot;</span>);
  }
  
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a4f2a09e57bff1fd459e8bf631019b07f" title="Non-public version of marginalisation to have only the required dimensions.">_start_marginalise</a>(reqDims);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4d0129dda149a950a06e9d2e3ff802c4"></a><!-- doxytag: member="subpavings::RealMappedSPnode::nodeExpand" ref="a4d0129dda149a950a06e9d2e3ff802c4" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4d0129dda149a950a06e9d2e3ff802c4">RealMappedSPnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two sibling child nodes to this provided this is a leaf. </p>
<p>Each new child gets half of the box associated with this, splitting the box in half normal to dimension set by comp. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a817b05cc2d60ff0ee1a98b0addf54131">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00316">316</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00044">RealMappedSPnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">subpavings::SPnode::setNodeName()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// can only expand if there is a box</span>
  <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a>(<span class="stringliteral">&quot;RealMappedSPnode::nodeExpand(int)&quot;</span>);
  }

  <span class="comment">// only do something if this node is a leaf</span>
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* newLC = NULL;
    <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a>* newRC = NULL;
    
    <span class="keywordflow">try</span> {

      <span class="comment">// ivectors to become boxes for new children</span>
      ivector lC, rC;
      <span class="comment">// Call Lower() and Upper() to put split boxes</span>
      <span class="comment">// into lC and rC respectively</span>
      <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lC, comp);
      <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rC, comp);

      <span class="comment">// make and add the new children</span>
      newLC = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(lC, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>);
      newRC = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a21248dfec3fc7415a604f2f1a5d58ce6" title="No-argument constructor.">RealMappedSPnode</a>(rC, <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>);
      
      <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(newLC);
      <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(newRC);
      <span class="comment">// both children get the same range as this</span>
      
      <span class="comment">//name the new children</span>
      <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
      <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);

      <span class="comment">// new children have summary from this</span>
    }
    <span class="keywordflow">catch</span>(std::exception&amp; e) {
    <span class="comment">// overkill, but try to deal with all eventualities...</span>
      <span class="keywordflow">try</span> {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>() != NULL) {
          <span class="keyword">delete</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>());
          <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
        }
        
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>() != NULL) {
          <span class="keyword">delete</span> (<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>());
          <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
        }
        <span class="keywordflow">if</span> (newLC != NULL) {
          <span class="keyword">delete</span> newLC;
          newLC = NULL;
        }
        <span class="keywordflow">if</span> (newRC != NULL) {
          <span class="keyword">delete</span> newRC;
          newRC = NULL;
        }
      }
      <span class="keywordflow">catch</span>(std::exception&amp; e) {} <span class="comment">//catch and swallow</span>
      
      <span class="keywordflow">throw</span>; <span class="comment">// rethrow original exception</span>
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad60865bacd8a43978cf2da02419cbf8f"></a><!-- doxytag: member="subpavings::RealMappedSPnode::nodeExpand" ref="ad60865bacd8a43978cf2da02419cbf8f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a4d0129dda149a950a06e9d2e3ff802c4">RealMappedSPnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two sibling child nodes to this provided this is a leaf. </p>
<p>Each new child gets half of the box associated with this, splitting the box in half normal to the first longest dimension of the box associated with this. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a26af7ee7d7e9c00623dea9e6aed02d92">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00384">384</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
  <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#ad60865bacd8a43978cf2da02419cbf8f" title="Add two sibling child nodes to this provided this is a leaf.">nodeExpand</a>(maxdiamcomp); <span class="comment">// complete nodeExpand</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3171d7822ccbcb05ed2b997c678b325a"></a><!-- doxytag: member="subpavings::RealMappedSPnode::nodeL1Distance" ref="a3171d7822ccbcb05ed2b997c678b325a" args="(cxsc::dotprecision &amp;disL1, cxsc::real other_v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::dotprecision &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a3171d7822ccbcb05ed2b997c678b325a">RealMappedSPnode::nodeL1Distance</a> </td>
          <td>(</td>
          <td class="paramtype">cxsc::dotprecision &amp;&#160;</td>
          <td class="paramname"><em>disL1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cxsc::real&#160;</td>
          <td class="paramname"><em>other_v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate L1 distance between this and another identical node with value <em>other_v</em> mapped onto it, ie add nodevolume*(range - other_v) onto <em>disL1</em>. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">1020</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">nodeL1Distance()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00465">subpavings::SPnode::nodeRealVolume()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00971">_getL1distance()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l01020">nodeL1Distance()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="preprocessor">  #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;\nIn nodeL1distance, I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() 
    &lt;&lt; <span class="stringliteral">&quot;, and disL1 is &quot;</span> &lt;&lt; (rnd(disL1)) &lt;&lt; endl;
    std::cout &lt;&lt; <span class="stringliteral">&quot;\nother_v is &quot;</span> &lt;&lt; other_v &lt;&lt; std::endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>    
  <span class="comment">// this is not a leaf</span>
  <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
    
<span class="preprocessor">    #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;I am not a leaf&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
    disL1 = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a3171d7822ccbcb05ed2b997c678b325a" title="Accumulate L1 distance between this and another identical node with value other_v mapped onto it...">nodeL1Distance</a>(disL1,  other_v );
    disL1 = <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a3171d7822ccbcb05ed2b997c678b325a" title="Accumulate L1 distance between this and another identical node with value other_v mapped onto it...">nodeL1Distance</a>(disL1, other_v );
  }
  <span class="keywordflow">else</span> { <span class="comment">// this is a leaf</span>
  
    <span class="comment">// for me, calculate difference to other_v</span>
    accumulate(disL1, 
        cxsc::abs(cxsc::abs(<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>) - cxsc::abs(other_v)),
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>() );
      
<span class="preprocessor">    #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>      std::cout &lt;&lt; <span class="stringliteral">&quot;I am a leaf, my range value is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>() &lt;&lt; endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;, and other value is &quot;</span> &lt;&lt; other_v &lt;&lt; std::endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;my volume is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>() &lt;&lt; endl;
      std::cout &lt;&lt; <span class="stringliteral">&quot;adding the following to disL1: &quot;</span>;
      std::cout &lt;&lt; (cxsc::abs(cxsc::abs(<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>) - cxsc::abs(other_v))*<a class="code" href="classsubpavings_1_1SPnode.shtml#ad219abf12ef0e39222748004e1ff1347" title="Throws a NoBox_Error if theBox is NULL.">nodeRealVolume</a>()) &lt;&lt; std::endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>    
  }
  
<span class="preprocessor">  #ifdef DEBUG_L1</span>
<span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;disL1 is now: &quot;</span> &lt;&lt; (rnd(disL1)) &lt;&lt; std::endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  <span class="keywordflow">return</span> disL1;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8b02632446a3c28a352f15f511e35caa"></a><!-- doxytag: member="subpavings::RealMappedSPnode::normalise" ref="a8b02632446a3c28a352f15f511e35caa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a8b02632446a3c28a352f15f511e35caa">RealMappedSPnode::normalise</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalise this. </p>
<p>Normalising means changing the range of each node so that the total over all leaf nodes of the sum of (box volumes xabs(range)) is 1.0.</p>
<p>Throws the following exceptions: </p>
<ul>
<li>
Throws a <a class="el" href="classsubpavings_1_1NonRootNode__Error.shtml">NonRootNode_Error</a> if this has a parent (ie. is not a root node). </li>
<li>
Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if this is empty (has no box). </li>
<li>
Throws an std::runtime_error if this has no 'area', ie <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> &lt;= 0. </li>
<li>
Throws an std::runtime_error if this has no 'area', ie <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> == Infinity. </li>
</ul>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>this must be a root node (have no parent) with a box and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> != 0 and <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> != Infinity. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this will have the same tree structure as before and the ranges on the nodes will be adjusted so that <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a972c5dbc0bedd9cad3af4f2af43be277" title="Get the total absolute &quot;area&quot; for the leaves of this of the real ranges and boxes.">getTotalAbsLeafAreaRangeWithBox()</a> = 1.0. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00428">428</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00949">_normalise()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00211">getParent()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a04fef135a04c4d165c08395c531581dd" title="Accessor for the parent of a node.">getParent</a>() != NULL ) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NonRootNode__Error.shtml">NonRootNode_Error</a>(
      <span class="stringliteral">&quot;RealMappedSPnode::normalise()&quot;</span>);
  }
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a185405d2c7b3231a75b33ec249292e2d" title="Non-public version of normalisation.">_normalise</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5287c7cec21af1c8606d735c0478a6fc"></a><!-- doxytag: member="subpavings::RealMappedSPnode::oneLineOutput" ref="a5287c7cec21af1c8606d735c0478a6fc" args="(std::ostream &amp;os, int level=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#a5287c7cec21af1c8606d735c0478a6fc">RealMappedSPnode::oneLineOutput</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A quick one-line summary of a node. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Controls number of tabs indenting output. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#acfbd13653a91c69a7091c6e9c18a6d68">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">1160</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00217">getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00223">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">oneLineOutput()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l01693">subpavings::MappedSPnode&lt; cxsc::real &gt;::range</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l01160">oneLineOutput()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// do me</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; level; ++i) { os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>; }
  os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; <span class="stringliteral">&quot;\tRange: &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a85f4e42ee09fcfa8c47835231ac3c21d" title="A range of type T.">range</a>;
  os &lt;&lt; <span class="stringliteral">&quot;\tbox: &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() &lt;&lt; std::endl;
  
  <span class="comment">// do children</span>
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a71ad37450934fcd212d1c13c9f8830d4" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a5287c7cec21af1c8606d735c0478a6fc" title="A quick one-line summary of a node.">oneLineOutput</a>(os, level+1);
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a19cb07beb697f0f8613a63c0b476ddd9" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#a5287c7cec21af1c8606d735c0478a6fc" title="A quick one-line summary of a node.">oneLineOutput</a>(os, level+1);
  
  <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1ac4214b1e335289374edece1b5d8c43"></a><!-- doxytag: member="subpavings::RealMappedSPnode::operator&lt;" ref="a1ac4214b1e335289374edece1b5d8c43" args="(const RealMappedSPnode &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RealMappedSPnode::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less-than operator. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff the range of this is &lt; range of <em>rhs</em>. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00256">256</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; cxsc::real &gt;::getRange()</a>, and <a class="el" href="mappedspnode_8hpp_source.shtml#l00239">subpavings::MappedSPnode&lt; T &gt;::getRange()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>() &lt; rhs.<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a3e5c6ff11f8640c1a7b3a363e9f841bd" title="Accessor for the range.">getRange</a>());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8c4a201d04c81a5f21301d6a325e740d"></a><!-- doxytag: member="subpavings::RealMappedSPnode::operator=" ref="a8c4a201d04c81a5f21301d6a325e740d" args="(RealMappedSPnode rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp; RealMappedSPnode::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>
<p>Copies from given RealMappedSPnode downwards. </p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00187">187</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="realmappedspnode_8cpp_source.shtml#l00721">swapRMSPSR()</a>.</p>
<div class="fragment"><pre class="fragment">{
  rhs.<a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#af2612c2a420a9f91c8bca09f0bb6ab42">swapRMSPSR</a>(*<span class="keyword">this</span>); <span class="comment">// make sure we use our version of swap</span>
  <span class="keywordflow">return</span>(*<span class="keyword">this</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad6a86d365ae237d96c7a8f842700af96"></a><!-- doxytag: member="subpavings::RealMappedSPnode::operator=" ref="ad6a86d365ae237d96c7a8f842700af96" args="(MappedSPnode&lt; cxsc::real &gt; rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp; RealMappedSPnode::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a>&lt; cxsc::real &gt;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>
<p>Copies from a given MappedSPnode&lt;cxsc::real&gt; node downwards. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a9f159be71fab10b26dec5d080fec95ff">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00196">196</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="mappedspnode_8hpp_source.shtml#l00958">subpavings::MappedSPnode&lt; T &gt;::swapMSPSR()</a>.</p>
<div class="fragment"><pre class="fragment">{
  rhs.<a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a4375171ab30bfe88e4a3306f321d3e24" title="Swap the properties of this and another.">swapMSPSR</a>(*<span class="keyword">this</span>); <span class="comment">// make sure we use our version of swap</span>
  <span class="keywordflow">return</span>(*<span class="keyword">this</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac674f3231fb03622048986a2a855b224"></a><!-- doxytag: member="subpavings::RealMappedSPnode::slice" ref="ac674f3231fb03622048986a2a855b224" args="(const std::vector&lt; int &gt; &amp;sliceDims, const std::vector&lt; cxsc::real &gt; &amp;slicePts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#ac674f3231fb03622048986a2a855b224">RealMappedSPnode::slice</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; cxsc::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>slicePts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Slice this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sliceDims</td><td>is a vector of dimensions to slice on. </td></tr>
    <tr><td class="paramname">slicePts</td><td>is a vector of points to slice on, assumed to correspond to the dimensions in <em>sliceDims</em>, ie the ith value in <em>sliceDims</em> gives the dimension for the ith point in <em>slicePts</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1MappedSPnode.shtml#a83d5b7a4609c73e1818fe2d3231c0979">subpavings::MappedSPnode&lt; cxsc::real &gt;</a>.</p>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00447">447</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>References <a class="el" href="mappedspnode_8hpp_source.shtml#l01357">subpavings::MappedSPnode&lt; T &gt;::_slice()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="mappedspnode_8hpp_source.shtml#l01591">subpavings::MappedSPnode&lt; cxsc::real &gt;::sliceCheck()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00721">swapRMSPSR()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
<span class="preprocessor">  #ifdef SLICE_OUTPUT</span>
<span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;In RealMappedSPnode::slice, I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; std::endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
  std::vector&lt;cxsc::real&gt; fullSlicePts = <a class="code" href="classsubpavings_1_1MappedSPnode.shtml#a24ca6f695181dd45e5cf05d22042bb44" title="Check slice parameters and return a full vector of slice points.">sliceCheck</a>(sliceDims, slicePts);
  
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> temp(*<span class="keyword">this</span>);
  temp._slice(sliceDims, fullSlicePts);
  <a class="code" href="classsubpavings_1_1RealMappedSPnode.shtml#af2612c2a420a9f91c8bca09f0bb6ab42">swapRMSPSR</a>(temp);

}
</pre></div>
</div>
</div>
<a class="anchor" id="af2612c2a420a9f91c8bca09f0bb6ab42"></a><!-- doxytag: member="subpavings::RealMappedSPnode::swapRMSPSR" ref="af2612c2a420a9f91c8bca09f0bb6ab42" args="(RealMappedSPnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml#af2612c2a420a9f91c8bca09f0bb6ab42">RealMappedSPnode::swapRMSPSR</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l00721">721</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l00783">_marginalise()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00187">operator=()</a>, and <a class="el" href="realmappedspnode_8cpp_source.shtml#l00447">slice()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">/* theBox, parent, leftChild,</span>
<span class="comment">  rightChild and nodeName are inherited from base class */</span>
  <a class="code" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode &lt; cxsc::real &gt;::swapMSPSR</a>(spn); <span class="comment">// use the MSP version</span>
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="realmappedspnode_8hpp_source.shtml">realmappedspnode.hpp</a></li>
<li><a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:40 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
