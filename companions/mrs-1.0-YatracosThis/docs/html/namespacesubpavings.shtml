<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespacesubpavings.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">subpavings Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace subpavings.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper or manager for an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> aka StatsSubPaving in conjunction with massive amounts of sample data.  <a href="classsubpavings_1_1AdaptiveHistogram.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1HistException.shtml">HistException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1HistDescription.shtml">HistDescription</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for the histogram description.  <a href="classsubpavings_1_1HistDescription.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper or manager for a CollatorSPSnode.  <a href="classsubpavings_1_1AdaptiveHistogramCollator.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper or manager for an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> aka StatsSubPavingVal in conjunction with massive amounts of sample data.  <a href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper or manager for a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>.  <a href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for creating summaries.  <a href="classsubpavings_1_1CollatorSPnode.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for creating summaries.  <a href="classsubpavings_1_1CollatorSPVnode.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1HistEvalObj.shtml">HistEvalObj</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Virtual class providing a way to stop histogram changes.  <a href="classsubpavings_1_1HistEvalObj.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLeaves__GTE.shtml">CritLeaves_GTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the number of bins of a histogram.  <a href="classsubpavings_1_1CritLeaves__GTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLeaves__LTE.shtml">CritLeaves_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the number of bins of a histogram.  <a href="classsubpavings_1_1CritLeaves__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritSmallestCount__LTE.shtml">CritSmallestCount_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the count of the node with the smallest count in histogram's subpaving.  <a href="classsubpavings_1_1CritSmallestCount__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLargestCount__LTE.shtml">CritLargestCount_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the count of the node with the largest count in histogram's subpaving.  <a href="classsubpavings_1_1CritLargestCount__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritSmallestVol__LTE.shtml">CritSmallestVol_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the volume of the box with the smallest volume in the histogram's subpaving.  <a href="classsubpavings_1_1CritSmallestVol__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLargestVol__LTE.shtml">CritLargestVol_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the volume of the box with the largest volume in the histogram's subpaving.  <a href="classsubpavings_1_1CritLargestVol__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritCOPERRChange__GTE.shtml">CritCOPERRChange_GTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the change in COPERR score from splitting.  <a href="classsubpavings_1_1CritCOPERRChange__GTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritAICChange__GTE.shtml">CritAICChange_GTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the change in AIC score from splitting.  <a href="classsubpavings_1_1CritAICChange__GTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritCOPERRChangeOrLeaves__GTE.shtml">CritCOPERRChangeOrLeaves_GTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing change in COPERR or number leaves from splitting.  <a href="classsubpavings_1_1CritCOPERRChangeOrLeaves__GTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritAICChangeOrLeaves__GTE.shtml">CritAICChangeOrLeaves_GTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing change in AIC or number leaves from splitting.  <a href="classsubpavings_1_1CritAICChangeOrLeaves__GTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritCOPERRChangeOrLargestCount__LTE.shtml">CritCOPERRChangeOrLargestCount_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing change in COPERR or largest count from splitting.  <a href="classsubpavings_1_1CritCOPERRChangeOrLargestCount__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritAICChangeOrLargestCount__LTE.shtml">CritAICChangeOrLargestCount_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing change in AIC or largest count from splitting.  <a href="classsubpavings_1_1CritAICChangeOrLargestCount__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritCOPERRMergeChange__GTE.shtml">CritCOPERRMergeChange_GTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the change in COPERR score from merging.  <a href="classsubpavings_1_1CritCOPERRMergeChange__GTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritAICMergeChange__GTE.shtml">CritAICMergeChange_GTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the change in AIC score from merging.  <a href="classsubpavings_1_1CritAICMergeChange__GTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritCOPERRMergeChangeOrLeaves__LTE.shtml">CritCOPERRMergeChangeOrLeaves_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing change in COPERR or number leaves from merging.  <a href="classsubpavings_1_1CritCOPERRMergeChangeOrLeaves__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritAICMergeChangeOrLeaves__LTE.shtml">CritAICMergeChangeOrLeaves_LTE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing change in AIC or number leaves from merging.  <a href="classsubpavings_1_1CritAICMergeChangeOrLeaves__LTE.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritStopAll.shtml">CritStopAll</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to bale out of priority queue splitting.  <a href="classsubpavings_1_1CritStopAll.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1HistEvalObjVal.shtml">HistEvalObjVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Virtual class providing a way to stop histogram changes.  <a href="classsubpavings_1_1HistEvalObjVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLeaves__GTEV.shtml">CritLeaves_GTEV</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the number of bins of a histogram.  <a href="classsubpavings_1_1CritLeaves__GTEV.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLeaves__LTEV.shtml">CritLeaves_LTEV</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the number of bins of a histogram.  <a href="classsubpavings_1_1CritLeaves__LTEV.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritSmallestCount__LTEV.shtml">CritSmallestCount_LTEV</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the count of the node with the smallest count in histogram's subpaving.  <a href="classsubpavings_1_1CritSmallestCount__LTEV.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLargestCount__LTEV.shtml">CritLargestCount_LTEV</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the count of the node with the largest count in histogram's subpaving.  <a href="classsubpavings_1_1CritLargestCount__LTEV.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritSmallestVol__LTEV.shtml">CritSmallestVol_LTEV</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the volume of the box with the smallest volume in the histogram's subpaving.  <a href="classsubpavings_1_1CritSmallestVol__LTEV.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritLargestVol__LTEV.shtml">CritLargestVol_LTEV</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for testing the volume of the box with the largest volume in the histogram's subpaving.  <a href="classsubpavings_1_1CritLargestVol__LTEV.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CritStopAllV.shtml">CritStopAllV</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to bale out of priority queue splitting.  <a href="classsubpavings_1_1CritStopAllV.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1LogMCMCPrior.shtml">LogMCMCPrior</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for MCMC priors.  <a href="classsubpavings_1_1LogMCMCPrior.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1LogCatalanPrior.shtml">LogCatalanPrior</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for a log prior based on a Catalan number prior.  <a href="classsubpavings_1_1LogCatalanPrior.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1LogTemperaturePrior.shtml">LogTemperaturePrior</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MCMCProposal.shtml">MCMCProposal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for MCMC proposal distributions.  <a href="classsubpavings_1_1MCMCProposal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1UniformProposal.shtml">UniformProposal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1EquiProbProposal.shtml">EquiProbProposal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PenObj.shtml">PenObj</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for objects with penalty function for histogram fit.  <a href="classsubpavings_1_1PenObj.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PenLeaves.shtml">PenLeaves</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Penalty function as number of leaves in histogram.  <a href="classsubpavings_1_1PenLeaves.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PenAIC1.shtml">PenAIC1</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for penalty function 1 for AIC.  <a href="classsubpavings_1_1PenAIC1.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PenAIC2.shtml">PenAIC2</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for penalty function 2 for AIC.  <a href="classsubpavings_1_1PenAIC2.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PenAIC3.shtml">PenAIC3</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for penalty function 3 for AIC.  <a href="classsubpavings_1_1PenAIC3.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PenAIC4.shtml">PenAIC4</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for penalty function 4 for AIC.  <a href="classsubpavings_1_1PenAIC4.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PenAIC5.shtml">PenAIC5</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for penalty function 5 for AIC.  <a href="classsubpavings_1_1PenAIC5.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedFobj.shtml">MappedFobj</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedFobj1000D.shtml">MappedFobj1000D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for target function objects on 10-dimensional real space.  <a href="classsubpavings_1_1MappedFobj1000D.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedFobj100D.shtml">MappedFobj100D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for target function objects on 10-dimensional real space.  <a href="classsubpavings_1_1MappedFobj100D.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedFobj10D.shtml">MappedFobj10D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for target function objects on 10-dimensional real space.  <a href="classsubpavings_1_1MappedFobj10D.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedFobj1D.shtml">MappedFobj1D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedFobj2D.shtml">MappedFobj2D</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedFobj9D.shtml">MappedFobj9D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract class for target function objects on 10-dimensional real space.  <a href="classsubpavings_1_1MappedFobj9D.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnode.shtml">MappedSPnode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>.  <a href="classsubpavings_1_1MappedSPnode.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MappedSPnodeVisitorExpand.shtml">MappedSPnodeVisitorExpand</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1NodeCompObj.shtml">NodeCompObj</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Virtual class providing a way to compare spsnodes.  <a href="classsubpavings_1_1NodeCompObj.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompCount.shtml">CompCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing on count of data points associated with a node.  <a href="classsubpavings_1_1CompCount.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompVol.shtml">CompVol</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing on volume of box of node.  <a href="classsubpavings_1_1CompVol.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompEMPSumChangeCOPERR.shtml">CompEMPSumChangeCOPERR</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing change in EMP under COPERR from splitting 2 nodes.  <a href="classsubpavings_1_1CompEMPSumChangeCOPERR.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompEMPSumChangeAIC.shtml">CompEMPSumChangeAIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing change in EMP under AIC from splitting 2 nodes.  <a href="classsubpavings_1_1CompEMPSumChangeAIC.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompEMPSumChangeMergeCOPERR.shtml">CompEMPSumChangeMergeCOPERR</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing change in EMP under COPERR from merging 2 nodes.  <a href="classsubpavings_1_1CompEMPSumChangeMergeCOPERR.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompEMPSumChangeMergeAIC.shtml">CompEMPSumChangeMergeAIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing change in EMP under AIC from merging 2 nodes.  <a href="classsubpavings_1_1CompEMPSumChangeMergeAIC.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompNothing.shtml">CompNothing</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing nodes to give no change in ordering.  <a href="classsubpavings_1_1CompNothing.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHeight.shtml">CompHeight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing on count/volume (ie histogram height) of box of node.  <a href="classsubpavings_1_1CompHeight.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompArea.shtml">CompArea</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the area of a histogram.  <a href="classsubpavings_1_1CompArea.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompExtArea.shtml">CompExtArea</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the "extended"area of a histogram.  <a href="classsubpavings_1_1CompExtArea.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompMean.shtml">CompMean</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the mean and uniform mean.  <a href="classsubpavings_1_1CompMean.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompMeanMass.shtml">CompMeanMass</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the mean and uniform mean multiplied with the emprical mass.  <a href="classsubpavings_1_1CompMeanMass.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompCovar.shtml">CompCovar</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompCovar.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompCovarMass.shtml">CompCovarMass</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompCovarMass.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDist1D.shtml">CompHellingerDist1D</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDist1D.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDist1DMass.shtml">CompHellingerDist1DMass</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDist1DMass.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDist1DMassDiam.shtml">CompHellingerDist1DMassDiam</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDist1DMassDiam.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDistMass.shtml">CompHellingerDistMass</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDistMass.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDistMassDiam.shtml">CompHellingerDistMassDiam</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDistMassDiam.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompVolInv.shtml">CompVolInv</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing volume multiplied with the inverse of the empirical mass.  <a href="classsubpavings_1_1CompVolInv.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1NodeCompObjMapped.shtml">NodeCompObjMapped</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Virtual class providing a way to compare spnodes visited by mappedspnodes.  <a href="classsubpavings_1_1NodeCompObjMapped.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompSPArea.shtml">CompSPArea</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the approximate area of a box by multiplying the box volume with the diameter of its range enclosure.  <a href="classsubpavings_1_1CompSPArea.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1NodeCompObjVal.shtml">NodeCompObjVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Virtual class providing a way to compare SPSVnodes.  <a href="classsubpavings_1_1NodeCompObjVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompCountVal.shtml">CompCountVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing on count of data points associated with a node.  <a href="classsubpavings_1_1CompCountVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompVolVal.shtml">CompVolVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing on volume of box of node.  <a href="classsubpavings_1_1CompVolVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompNothingVal.shtml">CompNothingVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing nodes to give no change in ordering.  <a href="classsubpavings_1_1CompNothingVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHeightVal.shtml">CompHeightVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing on count/volume (ie histogram height) of box of node.  <a href="classsubpavings_1_1CompHeightVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompAreaVal.shtml">CompAreaVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the area of a histogram.  <a href="classsubpavings_1_1CompAreaVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompMeanVal.shtml">CompMeanVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the mean and uniform mean.  <a href="classsubpavings_1_1CompMeanVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompMeanMassVal.shtml">CompMeanMassVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the mean and uniform mean multiplied with the emprical mass.  <a href="classsubpavings_1_1CompMeanMassVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompCovarVal.shtml">CompCovarVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompCovarVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompCovarMassVal.shtml">CompCovarMassVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompCovarMassVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDist1DVal.shtml">CompHellingerDist1DVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDist1DVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDist1DMassVal.shtml">CompHellingerDist1DMassVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDist1DMassVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDist1DMassDiamVal.shtml">CompHellingerDist1DMassDiamVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDist1DMassDiamVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDistMassVal.shtml">CompHellingerDistMassVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDistMassVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CompHellingerDistMassDiamVal.shtml">CompHellingerDistMassDiamVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class comparing the Chebyshev distance between the var-covar and uniform var-covar multiplied with the empirical mass.  <a href="classsubpavings_1_1CompHellingerDistMassDiamVal.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml">PiecewiseConstantFunction</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper or manager for an <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml" title="A derived class based on MappedSPnode &lt; cxsc::real &gt;.">RealMappedSPnode</a> tree representing a piecewise constant function.  <a href="classsubpavings_1_1PiecewiseConstantFunction.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RangeCollectionClass.shtml">RangeCollectionClass</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for range collection objects.  <a href="classsubpavings_1_1RangeCollectionClass.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RangeCollectionHist.shtml">RangeCollectionHist</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RangeCollectionException.shtml">RangeCollectionException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived class based on <a class="el" href="classsubpavings_1_1MappedSPnode.shtml" title="A templated derived class based on SPnode.">MappedSPnode</a> &lt; cxsc::real &gt;.  <a href="classsubpavings_1_1RealMappedSPnode.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPCheckVisitor.shtml">SPCheckVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SplittableCheck.shtml">SplittableCheck</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that visits  SPnodes to check if they are splittable.  <a href="classsubpavings_1_1SplittableCheck.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1IntervalImageToleranceCheck.shtml">IntervalImageToleranceCheck</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that visits  SPnodes to check if they meet an interval image tolerance requirement.  <a href="classsubpavings_1_1IntervalImageToleranceCheck.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1ReimannDiffToleranceCheck.shtml">ReimannDiffToleranceCheck</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that visits  SPnodes to check if they meet a 'Reimann Difference' tolerance requirement.  <a href="classsubpavings_1_1ReimannDiffToleranceCheck.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPExpandVisitor.shtml">SPExpandVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPValueVisitor.shtml">SPValueVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Virtual class providing decisions on whether to split spsnodes.  <a href="classsubpavings_1_1SplitDecisionObj.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SplitOnK.shtml">SplitOnK</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes derived from <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml" title="A Virtual class providing decisions on whether to split spsnodes.">SplitDecisionObj</a>.  <a href="classsubpavings_1_1SplitOnK.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SplitOnVolDivK.shtml">SplitOnVolDivK</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for splitting based on average volume per point of a node.  <a href="classsubpavings_1_1SplitOnVolDivK.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SplitNever.shtml">SplitNever</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for never splitting.  <a href="classsubpavings_1_1SplitNever.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SplitOnKandVol.shtml">SplitOnKandVol</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for splitting based on node volume and number of points in a node (specific to the air traffic problem).  <a href="classsubpavings_1_1SplitOnKandVol.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SPnodes are nodes in the representation of a subpaving as a binary tree.  <a href="classsubpavings_1_1SPnode.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPnodeVisitor.shtml">SPnodeVisitor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for processing sample data.  <a href="classsubpavings_1_1SPSnode.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived class based on <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> for processing sample data split to training and validation sets.  <a href="classsubpavings_1_1SPSVnode.shtml#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1IO__Error.shtml">IO_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1NullSubpavingPointer__Error.shtml">NullSubpavingPointer_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1MalconstructedBox__Error.shtml">MalconstructedBox_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1IncompatibleLabel__Error.shtml">IncompatibleLabel_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1NonRootNode__Error.shtml">NonRootNode_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1UnfulfillableRequest__Error.shtml">UnfulfillableRequest_Error</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1GaussianFobj.shtml">GaussianFobj</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1UniformFobj.shtml">UniformFobj</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a7e50e3fe54ef41646fbb6155160805cc">SubPaving</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SubPaving is an alias for a pointer to an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>.  <a href="#a7e50e3fe54ef41646fbb6155160805cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ace6b16f0adf0db13eeb38e124d5328c6">StatsSubPaving</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">StatsSubPaving is an alias for a pointer to an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>.  <a href="#ace6b16f0adf0db13eeb38e124d5328c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a2ef81a0baf365fed575183b748d8b8ff">StatsSubPavingVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">StatsSubPavingVal is an alias for a pointer to an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>.  <a href="#a2ef81a0baf365fed575183b748d8b8ff"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs for function pointers.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a4ca48fac31a3dcc26d5b51b1ee3cd0d9">PIBT</a> )(const ivector &amp;x, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type "Pointer to an interval boolean test".  <a href="#a4ca48fac31a3dcc26d5b51b1ee3cd0d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ivector(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a> )(const ivector &amp;x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type "Pointer to an interval vector function".  <a href="#af9ec133810ddce70b48381d444e2ec22"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs for containers and iterators.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type IntVec as a container for ints.  <a href="#aed8e75b2af342b9c1460431c223dca8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef IntVec::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ac37614ffc671c9e95013493ff9dc5137">IntVecItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type IntVecItr as iterator over IntVec.  <a href="#ac37614ffc671c9e95013493ff9dc5137"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type Size_tVec as a container for size_t.  <a href="#a612fc5639b45583b9fd33bd304354f81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef IntVec::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a764c7dafc0022ded276050b8cd056904">Size_tVecItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type Size_tVecItr as iterator over Size_tVec.  <a href="#a764c7dafc0022ded276050b8cd056904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type RealVec as a container for reals.  <a href="#af2d57bb6e12f4a73169f2e496d6a641f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RealVec::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aca205cec2a67bee00aee408d0cc6f3a1">RealVecItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type RealVecItr as iterator over RealVec.  <a href="#aca205cec2a67bee00aee408d0cc6f3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; rvector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type RVecData as a container for rvectors.  <a href="#a30e15e24c8d81a2160d7422ef3c39d68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RVecData::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a0e6592215c5f3504143e6c5ac38dcfec">RVecDataCItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type RVecDataCItr as const_iterator over RVecData.  <a href="#a0e6592215c5f3504143e6c5ac38dcfec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef RVecData::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa990935cb163d8eb54f28df1a3508af0">RVecDataItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type RVecDataItr as iterator over RVecData.  <a href="#aa990935cb163d8eb54f28df1a3508af0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49">SPnodePtrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPnodePtrs as container of pointers to SPnodes.  <a href="#ad64ec5e254ada5d913b9f7b46dcddc49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SPnodePtrs::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6">SPnodePtrsItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPnodePtrsItr as an iterator over SPnodePtrs.  <a href="#aa5240e1b99487f2c24014904cf761fc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; const <br class="typebreak"/>
<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a0c617b55345023a4c205603c167801b6">SPnodeConstPtrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPnodeConstPtrs as container of pointers to const SPnodes.  <a href="#a0c617b55345023a4c205603c167801b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
SPnodeConstPtrs::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a4a185637f88fb7f6b082fca3a8d90537">SPnodeConstPtrsItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPnodeConstPtrsItr as an iterator over SPnodeConstPtrs.  <a href="#a4a185637f88fb7f6b082fca3a8d90537"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; SPMinimalnode * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ad21343865a1d93618e0fad6b4b08e53e">SPMinimalnodePtrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPMinimalnodePtrs as container of pointers to SPMinimalnodes.  <a href="#ad21343865a1d93618e0fad6b4b08e53e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SPMinimalnodePtrs::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a0799ad5c6a6d3cd3b7afef68e5dfce51">SPMinimalnodePtrsItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPMinimalnodePtrsItr as an iterator over SPMinimalnodePtrs.  <a href="#a0799ad5c6a6d3cd3b7afef68e5dfce51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; ivector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">BoxVec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type BoxVec as a container of boxes.  <a href="#a322c2661740f6e6cc815fff0bfbd2623"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef BoxVec::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a8ea214a381f9c2027d0f605f2af25483">BoxVecItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type BoxVecItr as iterator over BoxVec.  <a href="#a8ea214a381f9c2027d0f605f2af25483"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; ivector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type ImageList as a container for images of boxes.  <a href="#acf161e8d79f04bf197a33277dd633f6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ImageList::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a8553bcc272ba9d0b7b9b6bd991b3bc00">ImageListItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type iterator over ImageList.  <a href="#a8553bcc272ba9d0b7b9b6bd991b3bc00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPSnodePtrs as container of pointers to SPSnodes.  <a href="#ad23942a388da964ca7487e496d0f2923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SPSnodePtrs::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9">SPSnodePtrsItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.  <a href="#a3d06253195e32236cc10b1c2050073c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">SPSVnodePtrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPSVnodePtrs as container of pointers to SPSVnodes.  <a href="#a90b5f0e33fa46403066cc5a89929e6a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SPSVnodePtrs::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0">SPSVnodePtrsItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs.  <a href="#ab5ab2047c25b17d5bb636a25ff65b0b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">SPSnodeList</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPSnodeList as a list of pointers to SPSnodes.  <a href="#ae7645253328c3b5fc137829039d971e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef SPSnodeList::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2">SPSnodeListItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type SPSnodeListItr as an iterator over SPSnodeList.  <a href="#a984883a654b8d040041f722f8ead7dc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; rvector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">BigDataCollection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type BigData Collection as a container for data.  <a href="#aa79f33663da92502ce1a37f3fd1f3d85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef BigDataCollection::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">BigDataItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type BigDataItr as an iterator BigData.  <a href="#a8792314c11b28ac2b8c4c85c47526f3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">BigDataItr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type NodeData as a container for iterators a BigData.  <a href="#af005697b49cff9ea37fc3bc9ed19da30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NodeData::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff">NodeDataItr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type NodeDataItr as a NodeData iterator.  <a href="#af79bf496cfc0df4bddcbe13a62f12bff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; dotprecision &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type VecDotPrec as a container of cxsc dotprecision variables.  <a href="#ad8f0a077ee1c4678bcd1868f3aecd605"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VecDotPrec::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173">VecDotPrecIt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type VecDotPrecIt as an iterator over VecDotPrec container.  <a href="#a80a828acc57552427c90b1f3119af173"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type VecDbl as a container of doubles.  <a href="#a6b4d2e61b2f0b65cacc9c9322d89bc37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VecDbl::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab">VecDblIt</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type VecDblIt as an iterator over VecDbl/.  <a href="#a0b710d91e323ef0b7c2c811a535c5fab"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs for enums.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a> { <a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>, 
<a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>, 
<a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define type "Interval Booleans".  <a href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a> { <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a> =  -1, 
<a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a> =  1, 
<a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a> =  0
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a type OPERATION_ON.  <a href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">LOGGING_LEVEL</a> { <br/>
&#160;&#160;<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a> =  0, 
<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a> =  1, 
<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a> =  2, 
<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a01fa38b021a34fb52083fdc234ab8eff">GRAPHSAMPLES</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a09aa6a27c1d242b63005aa5d78b45aba">LOGSAMPLES</a> =  4, 
<a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089afec51793a7c8838aa61a4e1b21d1245d">LOGANDGRAPHSAMPLES</a> =  5
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a type LOGGING_LEVEL.  <a href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a7b0c2cba5230c058d175234c14d4f3af">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1HistDescription.shtml">HistDescription</a> &amp;hd)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the <a class="el" href="classsubpavings_1_1HistDescription.shtml" title="A class for the histogram description.">HistDescription</a> object.  <a href="#a7b0c2cba5230c058d175234c14d4f3af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a91aca11d8ef070d592dcd968dd82d89d">operator&lt;</a> (const <a class="el" href="classsubpavings_1_1HistDescription.shtml">HistDescription</a> &amp;lhs, const <a class="el" href="classsubpavings_1_1HistDescription.shtml">HistDescription</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator for the histogram description.  <a href="#a91aca11d8ef070d592dcd968dd82d89d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa76489a659f3ddc671bcd47d227baad1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;adh)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the contents of an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object.  <a href="#aa76489a659f3ddc671bcd47d227baad1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a653a8836d9a2c6067d19fe172adda889">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator</a> &amp;adhc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the contents of an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml" title="A wrapper or manager for a CollatorSPSnode.">AdaptiveHistogramCollator</a> object.  <a href="#a653a8836d9a2c6067d19fe172adda889"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a4dca88e1718f95fecdf1429d1ebbfd11">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for CollatorSPnodes.  <a href="#a4dca88e1718f95fecdf1429d1ebbfd11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a31f92daeace87913f55ad41125368359">nodeCompTotalSummary</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of CollatorSPnodes using total of summaries.  <a href="#a31f92daeace87913f55ad41125368359"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a3580c30693d7d662e28a0fa26f45f837">nodeCompTotalSummaryAv</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison of CollatorSPnodes using the average of the total of summaries.  <a href="#a3580c30693d7d662e28a0fa26f45f837"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a6cbced3edaaea51ec4f60020f4b68410">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for CollatorSPVnodes.  <a href="#a6cbced3edaaea51ec4f60020f4b68410"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a97b57336ffc5ebac59abfb36dbd5405b">opNegate</a> (double d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate a double.  <a href="#a97b57336ffc5ebac59abfb36dbd5405b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a014371dd680ff6750f99952e6eb92cf9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml">subpavings::PiecewiseConstantFunction</a> &amp;pcf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the contents of an <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> object.  <a href="#a014371dd680ff6750f99952e6eb92cf9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a3aaa0e2846fcc501bf57373ab4fcfcb3">hullOperator</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cxsc::interval&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a70d818982b5c40190ee76257be4f9027">hullOperator&lt; cxsc::interval &gt;</a> (const cxsc::interval &amp;x, const cxsc::interval &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">cxsc::ivector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a6daf9a90fd58f9f6c19e684172661284">hullOperator&lt; cxsc::ivector &gt;</a> (const cxsc::ivector &amp;x, const cxsc::ivector &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVec.shtml">Vec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a0f22db67f4e7e059f3acff280a8441f8">hullOperator&lt; Vec &gt;</a> (const <a class="el" href="classVec.shtml">Vec</a> &amp;x, const <a class="el" href="classVec.shtml">Vec</a> &amp;y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ab16dccf5fd03eee9a6071072432e38bc">nodePtrCompare</a> (const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">subpavings::RealMappedSPnode</a> *lhs, const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">subpavings::RealMappedSPnode</a> *rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-than operator using pointers.  <a href="#ab16dccf5fd03eee9a6071072432e38bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a9d7eaadb31b3f9c2a28ad4af1f977a15">Mince</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mince up a subpaving.  <a href="#a9d7eaadb31b3f9c2a28ad4af1f977a15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af397899ec8f3bb396271e6b4fea28dea">Sivia</a> (<a class="el" href="namespacesubpavings.shtml#a4ca48fac31a3dcc26d5b51b1ee3cd0d9">PIBT</a> BoolTest, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const toInvert, <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const search, const double eps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa47cfd8c78e0be2e255006d743ffd214">Evaluate</a> (<a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn, <a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a> &amp;evalImages, ivector &amp;hull)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalutes images of subpaving.  <a href="#aa47cfd8c78e0be2e255006d743ffd214"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af6d00551176ec8a60444c7115aa08ca0">ImageSp</a> (<a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *spn, double eps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af0cce4ab9cf30918f62b403ce840776b">ImageSpNonMinimal</a> (<a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">PIVF</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *spn, double eps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a">Expand</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn, int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to have two child nodes.  <a href="#a6bce1a57598248196dd6b3e6010e724a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a2f85b5496c772efbfd75e50c16a5ab01">Expand</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to have two child nodes.  <a href="#a2f85b5496c772efbfd75e50c16a5ab01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a6a89808457c34dbca09c2c75ef57c169">ExpandWithValid</a> (<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn, bool boolVal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node to have two child nodes.  <a href="#a6a89808457c34dbca09c2c75ef57c169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a7288149f86d1e0c956f45dcd849a08fc">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the contents of a SubPaving.  <a href="#a7288149f86d1e0c956f45dcd849a08fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aca1892906e63d34720305016dd41156d">operator&lt;=</a> (const ivector &amp;z, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for containment of interval vector in the SubPaving.  <a href="#aca1892906e63d34720305016dd41156d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8">isLeaf</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a node is a leaf.  <a href="#a6ce5e0d7ef8daa51a49872efc2ef56d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15">isEmpty</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a SubPaving is empty.  <a href="#a72386487753f5334a70250b068f97f15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a8bfd50d3105ff4944ae6e42e0138ffb6">spVolume</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the volume of the subpaving represented by spn.  <a href="#a8bfd50d3105ff4944ae6e42e0138ffb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#acd777346441d8790899ec09af3b11d61">spLeaves</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of leaves of a tree (boxes in the subpaving)  <a href="#acd777346441d8790899ec09af3b11d61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa737c3b183c306abbef9b3d515f632fb">spTotalNodes</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of leaves of a tree (boxes in the subpaving)  <a href="#aa737c3b183c306abbef9b3d515f632fb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec">Reunite</a> (T *lChild, T *rChild, ivector x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to reunite two nodes into to form a single leaf.  <a href="#aa20ef6d47135f798ecc95164f0e6fdec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a45a1b2decaa4425e57280110a635cf0d">Adopt</a> (T *lChild, T *rChild, ivector x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adopt nodes to build a non-minimal subpaving.  <a href="#a45a1b2decaa4425e57280110a635cf0d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a331c50e79d716580fed8a900bfee2b1a">Regularize</a> (ivector &amp;hull, <a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a> &amp;ivectorList, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a minimal image subpaving.  <a href="#a331c50e79d716580fed8a900bfee2b1a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ab59f7407c562f2b1b4f051e479c9736f">RegularizeNonMinimal</a> (ivector &amp;hull, <a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">ImageList</a> &amp;ivectorList, double eps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms a non-minimal image subpaving.  <a href="#ab59f7407c562f2b1b4f051e479c9736f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">getUniqueFilename</a> (string baseFileName, string suffix=&quot;.txt&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a unique filename from base and timestamp number.  <a href="#ae23d4a36711d5b768cacab3fdb72b609"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">outputFile</a> (const string &amp;s, const string line, bool append=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a line to a txt file.  <a href="#aa5b5b66715568bc59cafea064eb8b1a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#afb8564fbbb2536bafcd19a5cc56e6531">outputFileStart</a> (const string &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opening line of a txt log file.  <a href="#afb8564fbbb2536bafcd19a5cc56e6531"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a57aa1d6f86ddd18d459fd36a710ae737">outputFile</a> (const std::string &amp;s, <a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;vals, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a tab delimited list seq of values as a line in log file.  <a href="#a57aa1d6f86ddd18d459fd36a710ae737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a11f846091a8b802ae4173e061b1b55f2">outputFile</a> (const std::string &amp;s, const std::string intro, <a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;vals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a tab delimited list seq of values as a line in log file.  <a href="#a11f846091a8b802ae4173e061b1b55f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a577225f9ff8ccb0b27420ff962fc978f">outputFile</a> (const std::string &amp;s, std::vector&lt; string &gt; &amp;strings, int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a tab delimited list seq of strings as a line in log file.  <a href="#a577225f9ff8ccb0b27420ff962fc978f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a0973b1623e6e12ba060db40d9cceece1">parseForGraphDot</a> (string s, string toParse)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string to make lines for a dot graph.  <a href="#a0973b1623e6e12ba060db40d9cceece1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#abb4671c14005974aeea8f0dd39600ec6">makeDotImage</a> (string s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">make a Dot graph png image given a dot file.  <a href="#abb4671c14005974aeea8f0dd39600ec6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a5928e5a1c7fc26e6df9c5bf9eb4a37a2">countLinesInTxt</a> (const string &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to count lines in a txt file.  <a href="#a5928e5a1c7fc26e6df9c5bf9eb4a37a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a498313e6b9ea0e6fb60d63ea3f2d0128">parseSpacings</a> (string line, <a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;spacings)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a .vtk header line for spacings data.  <a href="#a498313e6b9ea0e6fb60d63ea3f2d0128"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ab55a3f1bfa1cae218886328f19b2208f">getCoordinatesFromVtk</a> (<a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;Xs, <a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;Ys, <a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> &amp;Zs, const string &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coordinates from a .vtk file.  <a href="#ab55a3f1bfa1cae218886328f19b2208f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a19b79319876fc25305936396f24e5a6c">volCompare</a> (const ivector &amp;a, const ivector &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for comparing ivectors based on volume.  <a href="#a19b79319876fc25305936396f24e5a6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ada0daf400b54e571b4f8d83bd32861c5">tryExp</a> (real r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Work arround for c-xsc math library for exponentiation of reals.  <a href="#ada0daf400b54e571b4f8d83bd32861c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a6f8c4a15a4428e18b5ef0369782c86ae">makeDoubleIntoRvector</a> (const double d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a double into an rvector.  <a href="#a6f8c4a15a4428e18b5ef0369782c86ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af62c725dd362922c15d45983e2d8f6cf">checkString</a> (const string &amp;s, const int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A quick check on a data string: expecting only numbers white space or decimal points.  <a href="#af62c725dd362922c15d45983e2d8f6cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a4160d2d9f357dddf86d43f70c9bb8063">countNumbers</a> (const string &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of 'blocks' of numbers in a properly formatted string of numbers.  <a href="#a4160d2d9f357dddf86d43f70c9bb8063"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a535c4c5b9e6a042ec418db09ed956cda">readOneDimDataFromTxt</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const string &amp;s, const std::size_t headerlines=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in one-dimensional data from a txt file.  <a href="#a535c4c5b9e6a042ec418db09ed956cda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a7918dddb1a8e32f72835e1e7b4442ca6">readRvectorsFromTxt</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, const string &amp;s, const std::size_t headerlines=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in rvectors from a txt file.  <a href="#a7918dddb1a8e32f72835e1e7b4442ca6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a211cb10f439ff2bdb92ce92906159792">getRvectorsFromRVec</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;data, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all rvectors from a container of rvectors.  <a href="#a211cb10f439ff2bdb92ce92906159792"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ad2d24521f44422db117d54d6287bc314">getSampleRvectorsFromRVec</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;data, gsl_rng *rgsl, size_t samplesize, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sample of rvectors from an a container.  <a href="#ad2d24521f44422db117d54d6287bc314"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ae988c56fd983d75dd9f60a5ef8f87660">getSampleRvectorsFromRSSample</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;data, gsl_rng *rgsl, size_t samplesize, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, int label)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sample of rvectors from an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object.  <a href="#ae988c56fd983d75dd9f60a5ef8f87660"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ad435f1951db3078702d178b718018651">getRvectorsFromRSSample</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;data, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, int label)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all rvectors from an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object.  <a href="#ad435f1951db3078702d178b718018651"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ad26b1f7572cd78c11b5f9a423a80a258">getRvectorsFromRSSampleForSampling</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;allData, <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;sampleData, size_t samplesize, const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rss, int label)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object to take samples from.  <a href="#ad26b1f7572cd78c11b5f9a423a80a258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a4605f09553766eb8702c7c58b8074cf2">getSampleFromContainer</a> (size_t samplesize, gsl_rng *rgsl, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;allData, <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;sampleData)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sample from data in a container.  <a href="#a4605f09553766eb8702c7c58b8074cf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a1e3a19279d328b2178aaac44beaaf2d6">pointMassFilter</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, std::map&lt; rvector, size_t, std::less&lt; rvector &gt; &gt; &amp;CountsMap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Point mass filtering from data in a RVecData container. Takes an RVecData container and sieves through the data to obtain "point mass" data, i.e. data that falls on the same location with precision up to instrument settings or user's definition.  <a href="#a1e3a19279d328b2178aaac44beaaf2d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#ab434c49dd2b267948d0048075ab0298c">labelDataFromFilter</a> (<a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;theData, <a class="el" href="classRSSample.shtml">RSSample</a> &amp;labData, std::map&lt; rvector, size_t, std::less&lt; rvector &gt; &gt; &amp;CountsMap, std::map&lt; rvector, double, std::less&lt; rvector &gt; &gt; &amp;EMFMap)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Labels an RVecData object and store as an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. Takes an RVecData container and its corresponding map to label the points. Point mass data gets label 0 and the rest gets label 1. The labelled data is then stored in an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object.  <a href="#ab434c49dd2b267948d0048075ab0298c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#af04d789b7f68d18ba75461caa4627c39">checkNodeCountForSplit</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">subpavings::SPSnode</a> *const spn, size_t minChildPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to do checking for whether a node is splittable.  <a href="#af04d789b7f68d18ba75461caa4627c39"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">String representations of collections.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Formatted to have ", " or "," (<em>compact</em> = true) between the elements of the collection.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the collection to describe in the output. </td></tr>
    <tr><td class="paramname">compact</td><td>indicator for whether format should be compact. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>string representation of <em>vecints</em>. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml#a1c85cfc0ad8721fc6b480d66d51a653d">toString</a> (const <a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">subpavings::IntVec</a> vec, bool compact=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">String representation of an IntVec.  <a href="#a1c85cfc0ad8721fc6b480d66d51a653d"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The namespace subpavings. </p>
<p>A class for range collections for histograms.</p>
<p>An abstract class for target function objects on 2-dimensional real space.</p>
<p>An abstract class for target function objects on 1-dimensional real space.</p>
<p>An abstract class for target function objects.</p>
<p>The namespace is used for all classes and non-member methods related to subpavings.</p>
<p>The underlying container should be some kind of sequence container.</p>
<p>This implementation uses an stl::vector as the implementation container </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa79f33663da92502ce1a37f3fd1f3d85"></a><!-- doxytag: member="subpavings::BigDataCollection" ref="aa79f33663da92502ce1a37f3fd1f3d85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;rvector&gt; <a class="el" href="namespacesubpavings.shtml#aa79f33663da92502ce1a37f3fd1f3d85">subpavings::BigDataCollection</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type BigData Collection as a container for data. </p>
<p>Used in HistogramWrappers and <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> as the container for sample data. This container must not be vulnerable to iterator, pointer and reference invalidation. std::list has been chosen because it is a node-based container. The disadvantages of std::list is that it is heavy on memory because of the need to maintain pointers to other members, and it does not offer a random access iterator. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00248">248</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8792314c11b28ac2b8c4c85c47526f3a"></a><!-- doxytag: member="subpavings::BigDataItr" ref="a8792314c11b28ac2b8c4c85c47526f3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BigDataCollection::iterator <a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">subpavings::BigDataItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type BigDataItr as an iterator BigData. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00252">252</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a322c2661740f6e6cc815fff0bfbd2623"></a><!-- doxytag: member="subpavings::BoxVec" ref="a322c2661740f6e6cc815fff0bfbd2623" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;ivector&gt; <a class="el" href="namespacesubpavings.shtml#a322c2661740f6e6cc815fff0bfbd2623">subpavings::BoxVec</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type BoxVec as a container of boxes. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00198">198</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ea214a381f9c2027d0f605f2af25483"></a><!-- doxytag: member="subpavings::BoxVecItr" ref="a8ea214a381f9c2027d0f605f2af25483" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef BoxVec::iterator <a class="el" href="namespacesubpavings.shtml#a8ea214a381f9c2027d0f605f2af25483">subpavings::BoxVecItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type BoxVecItr as iterator over BoxVec. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00202">202</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf161e8d79f04bf197a33277dd633f6d"></a><!-- doxytag: member="subpavings::ImageList" ref="acf161e8d79f04bf197a33277dd633f6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;ivector&gt; <a class="el" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d">subpavings::ImageList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type ImageList as a container for images of boxes. </p>
<p>Used in <a class="el" href="namespacesubpavings.shtml#aa47cfd8c78e0be2e255006d743ffd214" title="Evalutes images of subpaving.">Evaluate()</a> for list of function images. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00208">208</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8553bcc272ba9d0b7b9b6bd991b3bc00"></a><!-- doxytag: member="subpavings::ImageListItr" ref="a8553bcc272ba9d0b7b9b6bd991b3bc00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ImageList::iterator <a class="el" href="namespacesubpavings.shtml#a8553bcc272ba9d0b7b9b6bd991b3bc00">subpavings::ImageListItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type iterator over ImageList. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00212">212</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed8e75b2af342b9c1460431c223dca8e"></a><!-- doxytag: member="subpavings::IntVec" ref="aed8e75b2af342b9c1460431c223dca8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;int&gt; <a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">subpavings::IntVec</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type IntVec as a container for ints. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00135">135</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac37614ffc671c9e95013493ff9dc5137"></a><!-- doxytag: member="subpavings::IntVecItr" ref="ac37614ffc671c9e95013493ff9dc5137" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IntVec::iterator <a class="el" href="namespacesubpavings.shtml#ac37614ffc671c9e95013493ff9dc5137">subpavings::IntVecItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type IntVecItr as iterator over IntVec. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00139">139</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af005697b49cff9ea37fc3bc9ed19da30"></a><!-- doxytag: member="subpavings::NodeData" ref="af005697b49cff9ea37fc3bc9ed19da30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">BigDataItr</a>&gt; <a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">subpavings::NodeData</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type NodeData as a container for iterators a BigData. </p>
<p>Used by <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> to hold iterators to the data associated with node. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00258">258</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af79bf496cfc0df4bddcbe13a62f12bff"></a><!-- doxytag: member="subpavings::NodeDataItr" ref="af79bf496cfc0df4bddcbe13a62f12bff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef NodeData::iterator <a class="el" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff">subpavings::NodeDataItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type NodeDataItr as a NodeData iterator. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00262">262</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ca48fac31a3dcc26d5b51b1ee3cd0d9"></a><!-- doxytag: member="subpavings::PIBT" ref="a4ca48fac31a3dcc26d5b51b1ee3cd0d9" args=")(const ivector &amp;x, const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a>(* <a class="el" href="namespacesubpavings.shtml#a4ca48fac31a3dcc26d5b51b1ee3cd0d9">subpavings::PIBT</a>)(const ivector &amp;x, const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const spn)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type "Pointer to an interval boolean test". </p>
<p>The test is for containment of the inclusion function image of an ivector in a subpaving. The inclusion function is specified in the body of the interval boolean test function. The test returns BI_INDET if the inclusion function image overlaps the subpaving border.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the interval vector whose image is found and compared to the subpaving. </td></tr>
    <tr><td class="paramname">spn</td><td>a pointer to the node representing a subpaving we want to test for containment in. This parameter is added to the <a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>::(*AIA_PIBT) to replace the use of globals there. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00115">115</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af9ec133810ddce70b48381d444e2ec22"></a><!-- doxytag: member="subpavings::PIVF" ref="af9ec133810ddce70b48381d444e2ec22" args=")(const ivector &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ivector(* <a class="el" href="namespacesubpavings.shtml#af9ec133810ddce70b48381d444e2ec22">subpavings::PIVF</a>)(const ivector &amp;x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type "Pointer to an interval vector function". </p>
<p>PIVF is an interval vector inclusion function, ie a function which returns the interval vector which encloses f(x) for f as specified in the function and x given in the function parameter. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00124">124</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2d57bb6e12f4a73169f2e496d6a641f"></a><!-- doxytag: member="subpavings::RealVec" ref="af2d57bb6e12f4a73169f2e496d6a641f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;real&gt; <a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">subpavings::RealVec</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type RealVec as a container for reals. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00151">151</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca205cec2a67bee00aee408d0cc6f3a1"></a><!-- doxytag: member="subpavings::RealVecItr" ref="aca205cec2a67bee00aee408d0cc6f3a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RealVec::iterator <a class="el" href="namespacesubpavings.shtml#aca205cec2a67bee00aee408d0cc6f3a1">subpavings::RealVecItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type RealVecItr as iterator over RealVec. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00155">155</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a30e15e24c8d81a2160d7422ef3c39d68"></a><!-- doxytag: member="subpavings::RVecData" ref="a30e15e24c8d81a2160d7422ef3c39d68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;rvector&gt; <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">subpavings::RVecData</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type RVecData as a container for rvectors. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00160">160</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e6592215c5f3504143e6c5ac38dcfec"></a><!-- doxytag: member="subpavings::RVecDataCItr" ref="a0e6592215c5f3504143e6c5ac38dcfec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RVecData::const_iterator <a class="el" href="namespacesubpavings.shtml#a0e6592215c5f3504143e6c5ac38dcfec">subpavings::RVecDataCItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type RVecDataCItr as const_iterator over RVecData. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00164">164</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa990935cb163d8eb54f28df1a3508af0"></a><!-- doxytag: member="subpavings::RVecDataItr" ref="aa990935cb163d8eb54f28df1a3508af0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef RVecData::iterator <a class="el" href="namespacesubpavings.shtml#aa990935cb163d8eb54f28df1a3508af0">subpavings::RVecDataItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type RVecDataItr as iterator over RVecData. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00168">168</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a612fc5639b45583b9fd33bd304354f81"></a><!-- doxytag: member="subpavings::Size_tVec" ref="a612fc5639b45583b9fd33bd304354f81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;size_t&gt; <a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">subpavings::Size_tVec</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type Size_tVec as a container for size_t. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00143">143</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a764c7dafc0022ded276050b8cd056904"></a><!-- doxytag: member="subpavings::Size_tVecItr" ref="a764c7dafc0022ded276050b8cd056904" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IntVec::iterator <a class="el" href="namespacesubpavings.shtml#a764c7dafc0022ded276050b8cd056904">subpavings::Size_tVecItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type Size_tVecItr as iterator over Size_tVec. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00147">147</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad21343865a1d93618e0fad6b4b08e53e"></a><!-- doxytag: member="subpavings::SPMinimalnodePtrs" ref="ad21343865a1d93618e0fad6b4b08e53e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;SPMinimalnode*&gt; <a class="el" href="namespacesubpavings.shtml#ad21343865a1d93618e0fad6b4b08e53e">subpavings::SPMinimalnodePtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPMinimalnodePtrs as container of pointers to SPMinimalnodes. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00189">189</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0799ad5c6a6d3cd3b7afef68e5dfce51"></a><!-- doxytag: member="subpavings::SPMinimalnodePtrsItr" ref="a0799ad5c6a6d3cd3b7afef68e5dfce51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SPMinimalnodePtrs::iterator <a class="el" href="namespacesubpavings.shtml#a0799ad5c6a6d3cd3b7afef68e5dfce51">subpavings::SPMinimalnodePtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPMinimalnodePtrsItr as an iterator over SPMinimalnodePtrs. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00193">193</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0c617b55345023a4c205603c167801b6"></a><!-- doxytag: member="subpavings::SPnodeConstPtrs" ref="a0c617b55345023a4c205603c167801b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>*&gt; <a class="el" href="namespacesubpavings.shtml#a0c617b55345023a4c205603c167801b6">subpavings::SPnodeConstPtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPnodeConstPtrs as container of pointers to const SPnodes. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00180">180</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a185637f88fb7f6b082fca3a8d90537"></a><!-- doxytag: member="subpavings::SPnodeConstPtrsItr" ref="a4a185637f88fb7f6b082fca3a8d90537" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SPnodeConstPtrs::const_iterator <a class="el" href="namespacesubpavings.shtml#a4a185637f88fb7f6b082fca3a8d90537">subpavings::SPnodeConstPtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPnodeConstPtrsItr as an iterator over SPnodeConstPtrs. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00184">184</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad64ec5e254ada5d913b9f7b46dcddc49"></a><!-- doxytag: member="subpavings::SPnodePtrs" ref="ad64ec5e254ada5d913b9f7b46dcddc49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>*&gt; <a class="el" href="namespacesubpavings.shtml#ad64ec5e254ada5d913b9f7b46dcddc49">subpavings::SPnodePtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPnodePtrs as container of pointers to SPnodes. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00172">172</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa5240e1b99487f2c24014904cf761fc6"></a><!-- doxytag: member="subpavings::SPnodePtrsItr" ref="aa5240e1b99487f2c24014904cf761fc6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SPnodePtrs::iterator <a class="el" href="namespacesubpavings.shtml#aa5240e1b99487f2c24014904cf761fc6">subpavings::SPnodePtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPnodePtrsItr as an iterator over SPnodePtrs. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00176">176</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7645253328c3b5fc137829039d971e3"></a><!-- doxytag: member="subpavings::SPSnodeList" ref="ae7645253328c3b5fc137829039d971e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a>*&gt; <a class="el" href="namespacesubpavings.shtml#ae7645253328c3b5fc137829039d971e3">subpavings::SPSnodeList</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPSnodeList as a list of pointers to SPSnodes. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00232">232</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a984883a654b8d040041f722f8ead7dc2"></a><!-- doxytag: member="subpavings::SPSnodeListItr" ref="a984883a654b8d040041f722f8ead7dc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SPSnodeList::iterator <a class="el" href="namespacesubpavings.shtml#a984883a654b8d040041f722f8ead7dc2">subpavings::SPSnodeListItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPSnodeListItr as an iterator over SPSnodeList. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00236">236</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad23942a388da964ca7487e496d0f2923"></a><!-- doxytag: member="subpavings::SPSnodePtrs" ref="ad23942a388da964ca7487e496d0f2923" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a>*&gt; <a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">subpavings::SPSnodePtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPSnodePtrs as container of pointers to SPSnodes. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00216">216</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d06253195e32236cc10b1c2050073c9"></a><!-- doxytag: member="subpavings::SPSnodePtrsItr" ref="a3d06253195e32236cc10b1c2050073c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SPSnodePtrs::iterator <a class="el" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9">subpavings::SPSnodePtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPSnodePtrsItr as an iterator over SPSnodePtrs. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00220">220</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90b5f0e33fa46403066cc5a89929e6a9"></a><!-- doxytag: member="subpavings::SPSVnodePtrs" ref="a90b5f0e33fa46403066cc5a89929e6a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a>*&gt; <a class="el" href="namespacesubpavings.shtml#a90b5f0e33fa46403066cc5a89929e6a9">subpavings::SPSVnodePtrs</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPSVnodePtrs as container of pointers to SPSVnodes. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00224">224</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5ab2047c25b17d5bb636a25ff65b0b0"></a><!-- doxytag: member="subpavings::SPSVnodePtrsItr" ref="ab5ab2047c25b17d5bb636a25ff65b0b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SPSVnodePtrs::iterator <a class="el" href="namespacesubpavings.shtml#ab5ab2047c25b17d5bb636a25ff65b0b0">subpavings::SPSVnodePtrsItr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type SPSVnodePtrsItr as an iterator over SPSVnodePtrs. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00228">228</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace6b16f0adf0db13eeb38e124d5328c6"></a><!-- doxytag: member="subpavings::StatsSubPaving" ref="ace6b16f0adf0db13eeb38e124d5328c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a>* <a class="el" href="namespacesubpavings.shtml#ace6b16f0adf0db13eeb38e124d5328c6">subpavings::StatsSubPaving</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>StatsSubPaving is an alias for a pointer to an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00042">42</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2ef81a0baf365fed575183b748d8b8ff"></a><!-- doxytag: member="subpavings::StatsSubPavingVal" ref="a2ef81a0baf365fed575183b748d8b8ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a>* <a class="el" href="namespacesubpavings.shtml#a2ef81a0baf365fed575183b748d8b8ff">subpavings::StatsSubPavingVal</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>StatsSubPavingVal is an alias for a pointer to an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>. </p>

<p>Definition at line <a class="el" href="spsvnode_8hpp_source.shtml#l00043">43</a> of file <a class="el" href="spsvnode_8hpp_source.shtml">spsvnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e50e3fe54ef41646fbb6155160805cc"></a><!-- doxytag: member="subpavings::SubPaving" ref="a7e50e3fe54ef41646fbb6155160805cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>* <a class="el" href="namespacesubpavings.shtml#a7e50e3fe54ef41646fbb6155160805cc">subpavings::SubPaving</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SubPaving is an alias for a pointer to an <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>. </p>

<p>Definition at line <a class="el" href="spnode_8hpp_source.shtml#l00045">45</a> of file <a class="el" href="spnode_8hpp_source.shtml">spnode.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b4d2e61b2f0b65cacc9c9322d89bc37"></a><!-- doxytag: member="subpavings::VecDbl" ref="a6b4d2e61b2f0b65cacc9c9322d89bc37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;double&gt; <a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">subpavings::VecDbl</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type VecDbl as a container of doubles. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00281">281</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b710d91e323ef0b7c2c811a535c5fab"></a><!-- doxytag: member="subpavings::VecDblIt" ref="a0b710d91e323ef0b7c2c811a535c5fab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VecDbl::iterator <a class="el" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab">subpavings::VecDblIt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type VecDblIt as an iterator over VecDbl/. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00285">285</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8f0a077ee1c4678bcd1868f3aecd605"></a><!-- doxytag: member="subpavings::VecDotPrec" ref="ad8f0a077ee1c4678bcd1868f3aecd605" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;dotprecision&gt; <a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">subpavings::VecDotPrec</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type VecDotPrec as a container of cxsc dotprecision variables. </p>
<p>Can be used to hold accumulators for rvector elements. Used to hold representations of the sum of data points on each of the relevant dimensions. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00271">271</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80a828acc57552427c90b1f3119af173"></a><!-- doxytag: member="subpavings::VecDotPrecIt" ref="a80a828acc57552427c90b1f3119af173" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef VecDotPrec::iterator <a class="el" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173">subpavings::VecDotPrecIt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type VecDotPrecIt as an iterator over VecDotPrec container. </p>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00277">277</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="abf44b15764c504d6ffa87c62b45b01a6"></a><!-- doxytag: member="subpavings::BOOL_INTERVAL" ref="abf44b15764c504d6ffa87c62b45b01a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">subpavings::BOOL_INTERVAL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define type "Interval Booleans". </p>
<p>This is used to extend the usual booleans TRUE and FALSE for use with intervals. With intervals the result of a test may be indeterminate at a particular level of accuracy rather than clearly true or false. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce"></a><!-- doxytag: member="BI_TRUE" ref="abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce" args="" -->BI_TRUE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226"></a><!-- doxytag: member="BI_FALSE" ref="abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226" args="" -->BI_FALSE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea"></a><!-- doxytag: member="BI_INDET" ref="abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea" args="" -->BI_INDET</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00074">74</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>,<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>,<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>} <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a>;
</pre></div>
</div>
</div>
<a class="anchor" id="aef8e51096b59ecaf1a1e9b2ee24b6089"></a><!-- doxytag: member="subpavings::LOGGING_LEVEL" ref="aef8e51096b59ecaf1a1e9b2ee24b6089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089">subpavings::LOGGING_LEVEL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define a type LOGGING_LEVEL. </p>
<p>This is used to determine the level of logging output.</p>
<p>If a logging level &gt; 1 is specified by the user but is not supported by the method, a level of TXT will be used. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737"></a><!-- doxytag: member="NOLOG" ref="aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737" args="" -->NOLOG</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3"></a><!-- doxytag: member="TXT" ref="aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3" args="" -->TXT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118"></a><!-- doxytag: member="TXTANDGRAPH" ref="aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118" args="" -->TXTANDGRAPH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aef8e51096b59ecaf1a1e9b2ee24b6089a01fa38b021a34fb52083fdc234ab8eff"></a><!-- doxytag: member="GRAPHSAMPLES" ref="aef8e51096b59ecaf1a1e9b2ee24b6089a01fa38b021a34fb52083fdc234ab8eff" args="" -->GRAPHSAMPLES</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aef8e51096b59ecaf1a1e9b2ee24b6089a09aa6a27c1d242b63005aa5d78b45aba"></a><!-- doxytag: member="LOGSAMPLES" ref="aef8e51096b59ecaf1a1e9b2ee24b6089a09aa6a27c1d242b63005aa5d78b45aba" args="" -->LOGSAMPLES</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aef8e51096b59ecaf1a1e9b2ee24b6089afec51793a7c8838aa61a4e1b21d1245d"></a><!-- doxytag: member="LOGANDGRAPHSAMPLES" ref="aef8e51096b59ecaf1a1e9b2ee24b6089afec51793a7c8838aa61a4e1b21d1245d" args="" -->LOGANDGRAPHSAMPLES</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00093">93</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>
<div class="fragment"><pre class="fragment">                {<a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a> = 0, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089ab2890a6eb7493029f41cf871d43877c3">TXT</a> = 1, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a37f328b2c4c91409b43fc74e7f299118">TXTANDGRAPH</a> = 2, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a01fa38b021a34fb52083fdc234ab8eff">GRAPHSAMPLES</a> = 3,
                <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a09aa6a27c1d242b63005aa5d78b45aba">LOGSAMPLES</a> = 4, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089afec51793a7c8838aa61a4e1b21d1245d">LOGANDGRAPHSAMPLES</a> = 5} <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a>;
</pre></div>
</div>
</div>
<a class="anchor" id="ae1ea349cda4812634df03761ebfc1c98"></a><!-- doxytag: member="subpavings::OPERATIONS_ON" ref="ae1ea349cda4812634df03761ebfc1c98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">subpavings::OPERATIONS_ON</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define a type OPERATION_ON. </p>
<p>This is used in <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> to indicate whether an operation is on a parent node or on the left or right child of a parent. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe"></a><!-- doxytag: member="ON_LEFT" ref="ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe" args="" -->ON_LEFT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107"></a><!-- doxytag: member="ON_RIGHT" ref="ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107" args="" -->ON_RIGHT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781"></a><!-- doxytag: member="ON_PARENT" ref="ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781" args="" -->ON_PARENT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="sptypes_8hpp_source.shtml#l00082">82</a> of file <a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a> = -1, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a> = 1, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a> = 0} <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98" title="Define a type OPERATION_ON.">OPERATIONS_ON</a>;
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a45a1b2decaa4425e57280110a635cf0d"></a><!-- doxytag: member="subpavings::Adopt" ref="a45a1b2decaa4425e57280110a635cf0d" args="(T *lChild, T *rChild, ivector x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="namespacesubpavings.shtml#a45a1b2decaa4425e57280110a635cf0d">subpavings::Adopt</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adopt nodes to build a non-minimal subpaving. </p>
<p>Make a new node and graft the two proposed children on as children. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lChild</td><td>a pointer to the leftChild node to be adopted </td></tr>
    <tr><td class="paramname">rChild</td><td>a pointer to the rightChild node to be adopted </td></tr>
    <tr><td class="paramname">x</td><td>is the box of the new subpaving to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non-minimal subpaving from two sibling subpavings </dd></dl>

<p>Definition at line <a class="el" href="sptemplates_8hpp_source.shtml#l00125">125</a> of file <a class="el" href="sptemplates_8hpp_source.shtml">sptemplates.hpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* newNode = NULL; <span class="comment">// pointer to new node to be returned</span>

    <span class="keywordflow">try</span>
    {
        newNode = <span class="keyword">new</span> T(x);


        <span class="comment">// both proposed children are empty, return null</span>
        <span class="keywordflow">if</span>(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(lChild) &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(rChild)) {
            newNode = NULL;
        }

        <span class="comment">// add the new right child if there is one</span>
        <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(rChild)) {
            <span class="comment">//graft right child on</span>
            newNode-&gt;nodeAdoptRight(rChild);
        }

        <span class="comment">// add the new left child if there is one</span>
        <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(lChild)) {
            <span class="comment">//graft left child on</span>
            newNode-&gt;nodeAdoptLeft(lChild);
        }

    }

    <span class="keywordflow">catch</span> (bad_alloc&amp;)
    {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in Adopt()&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">throw</span>;
    }

    <span class="keywordflow">return</span> newNode;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af04d789b7f68d18ba75461caa4627c39"></a><!-- doxytag: member="subpavings::checkNodeCountForSplit" ref="af04d789b7f68d18ba75461caa4627c39" args="(const subpavings::SPSnode *const spn, size_t minChildPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#af04d789b7f68d18ba75461caa4627c39">subpavings::checkNodeCountForSplit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">subpavings::SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to do checking for whether a node is splittable. </p>
<p>Decides whether a node is splittable based on checking number of points that would result in child nodes on split.</p>
<p>If there is a minChildPoints&gt;0 specified, then either the node must have at least minChildPoints and all the points go to one of the children (the other getting none) or the smallest number of points which would go to the either of the prospective new children must be &gt;= minChildPoints</p>
<p>Thus in general the method will only return true if the given node satisfies test that if it were to be split, both children would have at least minChildPoints data points, but if all the data points would go to one child (none) to the other, this is considered to also satisfy the minChildPoints test.</p>
<p>If the node has already been split, the test will use the actual numbers of points in the children; if the node is a leaf (ie not split) then the test will consider the number of points that would go to the each child if it were to be split.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>is a pointer to the target node. </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points that there would be in the children if the node were to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if has been a test conditions satisfied, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="auto__tools_8cpp_source.shtml#l00035">35</a> of file <a class="el" href="auto__tools_8cpp_source.shtml">auto_tools.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01198">subpavings::SPSnode::getMinChildCountIfSplit()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="MappedSPSamplingGaussian_8cpp_source.shtml#l00213">doMCMCGRAuto()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
  
  <span class="keywordtype">size_t</span> minChildCount = 0;
  <span class="keywordtype">size_t</span> counter = spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
  <span class="keywordflow">if</span> (spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) minChildCount = spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08" title="Smallest number of points in either child if this was split.">getMinChildCountIfSplit</a>();
  <span class="keywordflow">else</span> {
    <span class="keywordtype">size_t</span> lcCount = spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
    <span class="keywordtype">size_t</span> rcCount = counter - lcCount;
    minChildCount = (lcCount &lt; rcCount ? lcCount : rcCount);
  }
  
  <span class="keywordflow">if</span> ((minChildPoints == 0)
            || (minChildPoints &gt; 0
                &amp;&amp;
                ((counter &gt;= minChildPoints) &amp;&amp;
                    ((minChildCount == 0)
                    ||
                    (minChildCount &gt;= minChildPoints))
                ))
        ) { retValue = <span class="keyword">true</span>; }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af62c725dd362922c15d45983e2d8f6cf"></a><!-- doxytag: member="subpavings::checkString" ref="af62c725dd362922c15d45983e2d8f6cf" args="(const string &amp;s, const int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#af62c725dd362922c15d45983e2d8f6cf">subpavings::checkString</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A quick check on a data string: expecting only numbers white space or decimal points. </p>
<p>Checks for illegal characters and checks number of decimal points. Used for checking txt file input. For example, a string "12.04 1.00005e-10 -30.0006" contains no illegal characters and 3 decimal points and would pass the test if the value of n is 3. For example, a string "12.04ab 1.00005e-10 -30" only has 2 decimal points ('-30' is not a valid format since it does not have its decimal point) and the string also has illegal characters 'a' and 'b'. Allowing 'e' could lead to problems but is necessary to be be able to accept numbers in floating point format.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a reference to the string to check. </td></tr>
    <tr><td class="paramname">n</td><td>the number of decimal points to expect, which is taken to indicate how many blocks of numbers the string should contain since each number block is expected to contain a decimal point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the string passed the test, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00077">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a5928e5a1c7fc26e6df9c5bf9eb4a37a2"></a><!-- doxytag: member="subpavings::countLinesInTxt" ref="a5928e5a1c7fc26e6df9c5bf9eb4a37a2" args="(const string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacesubpavings.shtml#a5928e5a1c7fc26e6df9c5bf9eb4a37a2">subpavings::countLinesInTxt</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to count lines in a txt file. </p>
<p>Counts all lines with no data checking. Used for counting lines before setting up an adaptive histogram.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the name of the txt file in which to count the lines. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of lines in the file. </dd></dl>

<p>Referenced by <a class="el" href="MCMCGRSimsDbl_8cpp_source.shtml#l00133">doMCMCGRAuto()</a>, and <a class="el" href="AirTraffic_8cpp_source.shtml#l00043">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a4160d2d9f357dddf86d43f70c9bb8063"></a><!-- doxytag: member="subpavings::countNumbers" ref="a4160d2d9f357dddf86d43f70c9bb8063" args="(const string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacesubpavings.shtml#a4160d2d9f357dddf86d43f70c9bb8063">subpavings::countNumbers</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the number of 'blocks' of numbers in a properly formatted string of numbers. </p>
<p>Properly formatted means each number includes a decimal point. Blocks of numbers are assessed by looking for numerical characters including 'e', '+', '-' and also looking for decimal points '.'. Used for checking txt file input. For example, a string "12.04 1.00005e-10 -30.0006" contains 3 blocks of numbers. Allowing 'e' could lead to problems but is necessary to be be able to accept numbers in floating point format. Returns 0 if not all numbers have a decimal point or if the string contains anything not in ".123456789 \t"</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>a reference to the string to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of 'blocks' of numbers found. </dd></dl>

<p>Referenced by <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00077">main()</a>.</p>

</div>
</div>
<a class="anchor" id="aa47cfd8c78e0be2e255006d743ffd214"></a><!-- doxytag: member="subpavings::Evaluate" ref="aa47cfd8c78e0be2e255006d743ffd214" args="(PIVF f, const SPnode *const spn, ImageList &amp;evalImages, ivector &amp;hull)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#aa47cfd8c78e0be2e255006d743ffd214">subpavings::Evaluate</a> </td>
          <td>(</td>
          <td class="paramtype">PIVF&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageList &amp;&#160;</td>
          <td class="paramname"><em>evalImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evalutes images of subpaving. </p>
<p>Fills in the list of images using f of the subpaving boxes and update the hull of all the images.</p>
<p>Evaluate is now a non-friend non-member function (compare to <a class="el" href="classAIASPnode.shtml#a1032a6cd48f87337e0980fe290c140b8" title="Evaluate the image.">AIASPnode::Evaluate()</a>) which now uses public member functions in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a pointer to an interval vector function which returns the image box under f of some an interval vector </td></tr>
    <tr><td class="paramname">spn</td><td>the node of the subpaving to be evaluated </td></tr>
    <tr><td class="paramname">evalImages</td><td>a container of image interval vectors </td></tr>
    <tr><td class="paramname">hull</td><td>the interval hull of the image interval vectors </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00174">174</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">Evaluate()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02192">isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// later on if we want to generalise this,</span>
        <span class="comment">// we might have a base Box class and then</span>
        <span class="comment">// use list&lt;Box&gt;&amp; evalImages and Box&amp; hull</span>

        <span class="keywordflow">if</span> (spn!=NULL &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn)) {
            <span class="comment">// get image using PIVF function f on box of this node</span>
            ivector image = <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>(spn-&gt;getBox());

            <span class="comment">// if no images in image set yet, make hull the image</span>
            <span class="comment">// if are images in image set, hull is convex hull of</span>
            <span class="comment">// the current hull and ivector image from f(Box(A))</span>
            <span class="keywordflow">if</span> (evalImages.size() == 0) hull = image;
            <span class="keywordflow">else</span> hull = (hull | image);

            <span class="comment">// add the image to the list of images</span>
            evalImages.push_back(image);
        } <span class="comment">// end of is a leaf</span>

        <span class="comment">// recurse on children</span>
        <span class="keywordflow">if</span> (spn!=NULL &amp;&amp; !<a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn)) {

            <a class="code" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, spn-&gt;getLeftChild(), evalImages, hull);
            <a class="code" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, spn-&gt;getRightChild(), evalImages, hull);

        } <span class="comment">// end of if is not a leaf</span>

        <span class="comment">// case where A == NULL does nothing, just returns</span>

        <span class="keywordflow">return</span>;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6bce1a57598248196dd6b3e6010e724a"></a><!-- doxytag: member="subpavings::Expand" ref="a6bce1a57598248196dd6b3e6010e724a" args="(SPnode *const spn, int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a">subpavings::Expand</a> </td>
          <td>(</td>
          <td class="paramtype">SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to have two child nodes. </p>
<p>Uses nodeExpand() method for the type of spn (base/derived) at runtime.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>a pointer to the node to be expanded. </td></tr>
    <tr><td class="paramname">comp</td><td>is the dimension to split on. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00302">302</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01305">subpavings::SPnode::nodeExpand()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {

            <span class="comment">// uses nodeExpand for type of object pointed to by spn</span>
            <span class="keywordflow">if</span> (spn!=NULL) spn-&gt;nodeExpand(comp);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in Expand&quot;</span>
                                    &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2f85b5496c772efbfd75e50c16a5ab01"></a><!-- doxytag: member="subpavings::Expand" ref="a2f85b5496c772efbfd75e50c16a5ab01" args="(SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#a6bce1a57598248196dd6b3e6010e724a">subpavings::Expand</a> </td>
          <td>(</td>
          <td class="paramtype">SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to have two child nodes. </p>
<p>Uses nodeExpand() method for the type of spn (base/derived) at runtime and this nodeExpand() method will find the dimension to split on.</p>
<p>Expand is now a non-friend non-member function (compare to <a class="el" href="classAIASPnode.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa" title="Expand a leaf node to have two child nodes.">AIASPnode::Expand()</a>) which now uses public member functions in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>a pointer to the node to be expanded. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00319">319</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01305">subpavings::SPnode::nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {
            <span class="comment">// uses nodeExpand() for type of object pointed to by spn</span>
            <span class="keywordflow">if</span> (spn!=NULL) spn-&gt;nodeExpand();
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in Expand&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6a89808457c34dbca09c2c75ef57c169"></a><!-- doxytag: member="subpavings::ExpandWithValid" ref="a6a89808457c34dbca09c2c75ef57c169" args="(SPnode *const spn, bool boolVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#a6a89808457c34dbca09c2c75ef57c169">subpavings::ExpandWithValid</a> </td>
          <td>(</td>
          <td class="paramtype">SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>boolVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node to have two child nodes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>a pointer to the node to be expanded. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00335">335</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01305">subpavings::SPnode::nodeExpand()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {
          
            <span class="comment">// uses nodeExpand for type of object pointed to by spn</span>
            <span class="keywordflow">if</span> (spn!=NULL) {
              spn-&gt;nodeExpand(boolVal);
            }
         }
        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in ExpandWithValid&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab55a3f1bfa1cae218886328f19b2208f"></a><!-- doxytag: member="subpavings::getCoordinatesFromVtk" ref="ab55a3f1bfa1cae218886328f19b2208f" args="(IntVec &amp;Xs, IntVec &amp;Ys, IntVec &amp;Zs, const string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> <a class="el" href="namespacesubpavings.shtml#ab55a3f1bfa1cae218886328f19b2208f">subpavings::getCoordinatesFromVtk</a> </td>
          <td>(</td>
          <td class="paramtype">IntVec &amp;&#160;</td>
          <td class="paramname"><em>Xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;&#160;</td>
          <td class="paramname"><em>Ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;&#160;</td>
          <td class="paramname"><em>Zs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get coordinates from a .vtk file. </p>
<p>Expects structured point format data. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">Xs</td><td>a container of integers to put x-coordinate data into. </td></tr>
    <tr><td class="paramname">Ys</td><td>a container of integers to put y-coordinate data into. </td></tr>
    <tr><td class="paramname">Zs</td><td>a container of integers to put z-coordinate data into. </td></tr>
    <tr><td class="paramname">s</td><td>the filename to get the data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>empty containers for Xs, Ys, Zs and a properly formated file s. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>containers Xs, Ys, Zs filled with coordinate data. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of the coordinate spacing in the x, y, z direction. </dd></dl>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01957">subpavings::SPnode::vtkPaving()</a>.</p>

</div>
</div>
<a class="anchor" id="ad435f1951db3078702d178b718018651"></a><!-- doxytag: member="subpavings::getRvectorsFromRSSample" ref="ad435f1951db3078702d178b718018651" args="(RVecData &amp;data, const RSSample &amp;rss, int label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacesubpavings.shtml#ad435f1951db3078702d178b718018651">subpavings::getRvectorsFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all rvectors from an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. </p>
<p>Takes the rvector part of labeled points in the Samples data member of an RSS object, where the label on the point matches the label supplied as a function argument.</p>
<p><a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> objects can have Samples containing points with different labels and points with different labels can have different dimensions.</p>
<p>The container theData is assumed to be empty but this will work even if it is not empty provided that the data added has the same dimension as the existing data, since we are only pushing back: new data will just get put in after the stuff already there.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is a reference to a container of data into which to place the data once read. </td></tr>
    <tr><td class="paramname">rss</td><td>is the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object with the data we want. </td></tr>
    <tr><td class="paramname">label</td><td>is the label for the points that we want from rss. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData, assumed to be empty, in which to store data. theData should support push_back() method. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The container theData contains the valid rvectors read in. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of data points matching label, and matching dimensions data points already in data if any, found in rss.Samples. Returns 0 if no data points with the correct label found or if dimensions did not match existing data points in data. </dd></dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l01021">1021</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00241">RSSample::Samples</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00184">subpavings::AdaptiveHistogramCollator::collateFromRSSample()</a>, <a class="el" href="sptools_8cpp_source.shtml#l01115">getRvectorsFromRSSampleForSampling()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01817">subpavings::AdaptiveHistogram::insertFromRSSample()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00778">subpavings::AdaptiveHistogramValidation::insertFromRSSampleForHoldOut()</a>.</p>
<div class="fragment"><pre class="fragment">{

    <span class="keywordtype">size_t</span> retValue = 0;
    <span class="keywordtype">bool</span> cancontinue = <span class="keyword">true</span>;

    <span class="keywordflow">if</span> (!data.empty()) { <span class="comment">// data already in data, print a warning</span>
        std::cout
            &lt;&lt; <span class="stringliteral">&quot;Warning: adding to existing data &quot;</span>
            &lt;&lt; <span class="stringliteral">&quot;- mixing datasets&quot;</span>
            &lt;&lt; std::endl;

        <span class="comment">// assume we will be adding all the data from rss.Samples</span>
        data.reserve((rss.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>).size() +
                            data.size());
    }

    <span class="keywordflow">else</span> {
        data.reserve((rss.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>).size());
    }

    <span class="comment">//get the data with the appropriate label out of rss</span>

    <span class="comment">// transform would be better but we would have to assume that</span>
    <span class="comment">// we wanted all the data in rss.Samples, but we know that</span>
    <span class="comment">// an RSSample object can contain samples with with different labels</span>
    <span class="comment">// and with different dimensions</span>

    <span class="keywordtype">bool</span> foundfirst = <span class="keyword">false</span>;
    rvector first;

    <span class="keywordflow">if</span> (cancontinue) {
        <span class="comment">//find the first point with the right label and</span>
        <span class="comment">// check dimensions</span>
        vector&lt;LabPnt&gt;::const_iterator cit = rss.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.begin();

        <span class="keywordflow">while</span> (!foundfirst &amp;&amp; (cit&lt;(rss.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>).end())) {
            <span class="keywordflow">if</span> ((*cit).L == label) {
                foundfirst = <span class="keyword">true</span>;
                first = cit-&gt;Pnt;
            }
            cit++;
        }<span class="comment">// end while</span>
    }

    <span class="keywordflow">if</span> (!foundfirst) { <span class="comment">// could not find points with the right label</span>
        std::cout &lt;&lt; <span class="stringliteral">&quot;Could not find any points in RSSample object &quot;</span>
            &lt;&lt; <span class="stringliteral">&quot; with label &quot;</span> &lt;&lt; label &lt;&lt; <span class="stringliteral">&quot;- aborting &quot;</span>
            &lt;&lt; std::endl;
        cancontinue = <span class="keyword">false</span>;
    }

    <span class="keywordflow">if</span> (cancontinue &amp;&amp; !data.empty()) {
        <span class="comment">//find the data dimensions from the first datapoint fount</span>
        <span class="keywordtype">int</span> dim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(first) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(first) + 1;
        <span class="comment">//find the data dimensions from the existing data</span>
        <span class="keywordtype">int</span> dataDim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*data.begin()) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*data.begin()) + 1;
        <span class="keywordflow">if</span> (dim != dataDim) {
            std::cout
                &lt;&lt; <span class="stringliteral">&quot;Existing data different dimension &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot; to data in RSSample object - &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot; aborting&quot;</span>
                &lt;&lt; std::endl;
            cancontinue = <span class="keyword">false</span>;
        }
    }

    <span class="comment">// if cancontinue is still true we know there is data we can take</span>

    <span class="keywordflow">if</span> (cancontinue) {

        <span class="keywordtype">size_t</span> countIn = 0; <span class="comment">// track points inserted</span>

        <span class="comment">//iterate through the rss.Samples and take points</span>
        <span class="comment">//that match the supplied label</span>
        vector&lt;LabPnt&gt;::const_iterator cit;

        <span class="keywordflow">for</span> (cit=(rss.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>).begin();cit&lt;(rss.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>).end();cit++){
            <span class="keywordflow">if</span> (cit-&gt;L == label) {
                data.push_back(cit-&gt;Pnt);
                countIn++;
            }
        }

        retValue = countIn;    <span class="comment">// some data successfully read in</span>
    }

    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad26b1f7572cd78c11b5f9a423a80a258"></a><!-- doxytag: member="subpavings::getRvectorsFromRSSampleForSampling" ref="ad26b1f7572cd78c11b5f9a423a80a258" args="(RVecData &amp;allData, RVecData &amp;sampleData, size_t samplesize, const RSSample &amp;rss, int label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacesubpavings.shtml#ad26b1f7572cd78c11b5f9a423a80a258">subpavings::getRvectorsFromRSSampleForSampling</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>allData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>sampleData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get data from an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object to take samples from. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">allData</td><td>is the container to put all the data found into. </td></tr>
    <tr><td class="paramname">sampleData</td><td>is the container which the sample wll eventually go into. </td></tr>
    <tr><td class="paramname">samplesize</td><td>is the size of the sampel to be drawn. </td></tr>
    <tr><td class="paramname">rss</td><td>is the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object to sample data from. </td></tr>
    <tr><td class="paramname">label</td><td>is the label for the labeled points we want to find in rss. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of data points taken as a sample from rss.Samples. Returns 0 if no data points with the correct label found in rss.Samples or if dimensions did not match existing data points in data. </dd></dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l01115">1115</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="sptools_8cpp_source.shtml#l01021">getRvectorsFromRSSample()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="sptools_8cpp_source.shtml#l00996">getSampleRvectorsFromRSSample()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordtype">size_t</span> retValue = 0;

        <span class="comment">//use getRvectorsFromRSSample to put rvectors from labeled points in</span>
        <span class="comment">// rss.Samples into allData where the labeled point label matches label</span>
        <span class="keywordtype">size_t</span> numberFound = <a class="code" href="namespacesubpavings.shtml#ad435f1951db3078702d178b718018651" title="Get all rvectors from an RSSample object.">getRvectorsFromRSSample</a>(allData, rss, label);

        <span class="keywordtype">bool</span> cancontinue = (numberFound &gt; 0);
        <span class="comment">// cancontinue will be false if there was a problem getting data points</span>
        <span class="comment">// if cancontinue is true data should contain at least some data points</span>

        <span class="keywordflow">if</span> (cancontinue &amp;&amp; (allData.size() &lt; samplesize)) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Warning: Sample size required is greater than &quot;</span>
                &lt;&lt; allData.size() &lt;&lt; <span class="stringliteral">&quot; the number of available data points &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;matching label &quot;</span> &lt;&lt; label &lt;&lt; <span class="stringliteral">&quot;in the RSSample object&#39;s Samples&quot;</span>
                &lt;&lt; std::endl;
        }

        <span class="comment">// data already in data, print a warning</span>
        <span class="keywordflow">if</span> (cancontinue &amp;&amp; !sampleData.empty()) {
            std::cout
                &lt;&lt; <span class="stringliteral">&quot;Warning: adding to existing data &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;- mixing datasets&quot;</span>
                &lt;&lt; std::endl;

             <span class="comment">//find the data dimensions from the first datapoint in allData</span>
            <span class="keywordtype">int</span> dim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*allData.begin()) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*allData.begin()) + 1;
            <span class="comment">//find the data dimensions from the existing data</span>
            <span class="keywordtype">int</span> dataDim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*sampleData.begin()) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*sampleData.begin()) + 1;
            <span class="keywordflow">if</span> (dim != dataDim) {
                std::cout
                    &lt;&lt; <span class="stringliteral">&quot;Existing data different dimension &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot; to data in RSSample object - aborting&quot;</span> &lt;&lt; std::endl;
                cancontinue = <span class="keyword">false</span>;
            }
        }

        <span class="keywordflow">if</span> (cancontinue) {

            retValue = numberFound;    <span class="comment">// some data successfully read in</span>
        }

        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a211cb10f439ff2bdb92ce92906159792"></a><!-- doxytag: member="subpavings::getRvectorsFromRVec" ref="a211cb10f439ff2bdb92ce92906159792" args="(RVecData &amp;data, const RVecData &amp;rvec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacesubpavings.shtml#a211cb10f439ff2bdb92ce92906159792">subpavings::getRvectorsFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get all rvectors from a container of rvectors. </p>
<p>The container theData is assumed to be empty but this will work even if it is not empty provided that the data added has the same dimension as the existing data, since we are only pushing back: new data will just get put in after the stuff already there.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is a reference to a container of data into which to place the data once read. </td></tr>
    <tr><td class="paramname">rvec</td><td>is the container of rvectors with the data we want. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of data points read in from the container rvec, which should be the number of data points in rvec provided that they match the dimension of data points already in data if any. Returns 0 if dimensions did not match existing data points in data. </dd></dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l00930">930</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00641">subpavings::AdaptiveHistogramValidation::insertFromRVec()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01568">subpavings::AdaptiveHistogram::insertFromRVec()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00709">subpavings::AdaptiveHistogramValidation::insertFromRVecForHoldOut()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordtype">size_t</span> retValue = 0;
        <span class="keywordtype">bool</span> cancontinue = <span class="keyword">true</span>;

        <span class="keywordflow">if</span> (!data.empty()) { <span class="comment">// data already in data, print a warning</span>
            std::cout
                &lt;&lt; <span class="stringliteral">&quot;Warning: adding to existing data &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;- mixing datasets&quot;</span>
                &lt;&lt; std::endl;

            <span class="comment">// assume we will be adding all the data from rss.Samples</span>
            data.reserve(rvec.size() +
                                data.size());
        }

        <span class="keywordflow">else</span> {
            data.reserve(rvec.size());
        }

        <span class="keywordflow">if</span> (cancontinue &amp;&amp; !data.empty()) { <span class="comment">// check dimensions</span>
            <span class="comment">//find the data dimensions from the first datapoint</span>
            <span class="keywordtype">int</span> dim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*rvec.begin()) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*rvec.begin()) + 1;
            <span class="comment">//find the data dimensions from the existing data</span>
            <span class="keywordtype">int</span> dataDim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*data.begin()) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*data.begin()) + 1;
            <span class="keywordflow">if</span> (dim != dataDim) {
                std::cout
                    &lt;&lt; <span class="stringliteral">&quot;Existing data different dimension &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot; to data in container: aborting insertion&quot;</span>
                    &lt;&lt; std::endl;
                cancontinue = <span class="keyword">false</span>;
            }
        }

        <span class="comment">// if cancontinue is still true we know there is data we can take</span>
        <span class="keywordflow">if</span> (cancontinue) {

            data.insert(data.end(), rvec.begin(),rvec.end());

            retValue = rvec.size();    <span class="comment">// data read in</span>
        }

        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4605f09553766eb8702c7c58b8074cf2"></a><!-- doxytag: member="subpavings::getSampleFromContainer" ref="a4605f09553766eb8702c7c58b8074cf2" args="(size_t samplesize, gsl_rng *rgsl, const RVecData &amp;allData, RVecData &amp;sampleData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#a4605f09553766eb8702c7c58b8074cf2">subpavings::getSampleFromContainer</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>allData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>sampleData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a sample from data in a container. </p>
<p>A function to get a random sample of of a specified size from a given container of data. Sampling is with replacement.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">samplesize</td><td>is the size of the sample to get. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a random number generator. </td></tr>
    <tr><td class="paramname">allData</td><td>is the container of data points from which to draw the sample. </td></tr>
    <tr><td class="paramname">sampleData</td><td>is a container into which to put the sample drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>sampleData has samplesize data points from allData, drawn with replacement. </dd></dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l01165">1165</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>Referenced by <a class="el" href="sptools_8cpp_source.shtml#l00996">getSampleRvectorsFromRSSample()</a>, and <a class="el" href="sptools_8cpp_source.shtml#l00982">getSampleRvectorsFromRVec()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// make space to add the sample in addition to existing data</span>
        <span class="keywordflow">if</span> (sampleData.empty()) {
            sampleData.reserve(samplesize);
        }
        <span class="keywordflow">else</span> {
            sampleData.reserve(sampleData.size() + samplesize);
        }

        <span class="comment">//get a sample of the data out of allData</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; samplesize; i++) {
            <span class="comment">//draw a random number in [0,1)</span>
            <span class="keywordtype">double</span> rand = gsl_rng_uniform(rgsl);
            <span class="comment">//turn this into an index in [0, samplesize-1]</span>
            <span class="keywordtype">int</span> index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(ceil(rand*samplesize - 1));
            <span class="comment">//put element in allData indexed into data</span>
            sampleData.push_back(allData[index]);
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ae988c56fd983d75dd9f60a5ef8f87660"></a><!-- doxytag: member="subpavings::getSampleRvectorsFromRSSample" ref="ae988c56fd983d75dd9f60a5ef8f87660" args="(RVecData &amp;data, gsl_rng *rgsl, size_t samplesize, const RSSample &amp;rss, int label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacesubpavings.shtml#ae988c56fd983d75dd9f60a5ef8f87660">subpavings::getSampleRvectorsFromRSSample</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a sample of rvectors from an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. </p>
<p>A function to get a sample of rvectors from the labeled point sample data held by an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object</p>
<p>Uses getRvectorsFromSample to get something to sample from. Then samples with replacement to find required sample size</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is a reference to a container of data into which to place the data once read. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a random number generator </td></tr>
    <tr><td class="paramname">samplesize</td><td>is the size of the required sample </td></tr>
    <tr><td class="paramname">rss</td><td>is the <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object with the data we want. </td></tr>
    <tr><td class="paramname">label</td><td>is the label for the points that we want from rss. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData, assumed to be empty, in which to store data sampled from rss. theData should support push_back() method. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The container theData contains a sample of rvectors from rss. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of data points taken as a sample from rss.Samples. Returns 0 if no data points with the correct label found in rss.Samples or if dimensions did not match existing data points in data. </dd></dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l00996">996</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="sptools_8cpp_source.shtml#l01115">getRvectorsFromRSSampleForSampling()</a>, and <a class="el" href="sptools_8cpp_source.shtml#l01165">getSampleFromContainer()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01875">subpavings::AdaptiveHistogram::insertSampleFromRSSample()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> allData; <span class="comment">// a container for all the rvectors from rss.Samples</span>

        <span class="comment">//use getRvectorsFromRSSampleForSampling to put rvectors from labeled</span>
        <span class="comment">//points in rss.Samples into allData where the labeled point label</span>
        <span class="comment">//matches label</span>
        <span class="keywordtype">size_t</span> numberAll = <a class="code" href="namespacesubpavings.shtml#ad26b1f7572cd78c11b5f9a423a80a258" title="Get data from an RSSample object to take samples from.">getRvectorsFromRSSampleForSampling</a>(allData,
                        data, samplesize, rss, label);

        <span class="comment">// get the sample</span>
        <span class="keywordflow">if</span> (numberAll &gt; 0) {
            <a class="code" href="namespacesubpavings.shtml#a4605f09553766eb8702c7c58b8074cf2" title="Get a sample from data in a container.">getSampleFromContainer</a>(samplesize, rgsl, allData, data);
        }

        <span class="keywordflow">return</span> data.size();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad2d24521f44422db117d54d6287bc314"></a><!-- doxytag: member="subpavings::getSampleRvectorsFromRVec" ref="ad2d24521f44422db117d54d6287bc314" args="(RVecData &amp;data, gsl_rng *rgsl, size_t samplesize, const RVecData &amp;rvec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacesubpavings.shtml#ad2d24521f44422db117d54d6287bc314">subpavings::getSampleRvectorsFromRVec</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rgsl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samplesize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a sample of rvectors from an a container. </p>
<p>Samples with replacement to find required sample size.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is a reference to a container of data into which to place the data once read. </td></tr>
    <tr><td class="paramname">rgsl</td><td>is a pointer to a random number generator </td></tr>
    <tr><td class="paramname">samplesize</td><td>is the size of the required sample </td></tr>
    <tr><td class="paramname">rvec</td><td>is the container with the data we want to sample from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of data points taken as a sample from the container. Returns 0 if dimensions did not match existing data points in data. </dd></dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l00982">982</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="sptools_8cpp_source.shtml#l01165">getSampleFromContainer()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01635">subpavings::AdaptiveHistogram::insertSampleFromRVec()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#a4605f09553766eb8702c7c58b8074cf2" title="Get a sample from data in a container.">getSampleFromContainer</a>(samplesize, rgsl, rvec, data);

        <span class="keywordflow">return</span> data.size();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ae23d4a36711d5b768cacab3fdb72b609"></a><!-- doxytag: member="subpavings::getUniqueFilename" ref="ae23d4a36711d5b768cacab3fdb72b609" args="(string baseFileName, string suffix=&quot;.txt&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>baseFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>suffix</em> = <code>&quot;.txt&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a unique filename from base and timestamp number. </p>
<p>Waits until timestamp number combined with baseFileName gives a name for a file that does not yet exist.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseFileName</td><td>the base to use as the filename </td></tr>
    <tr><td class="paramname">suffix</td><td>to put on filename, defaults to ".txt" </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a unique filename with baseFileName suffix, timestamp number prefix </dd></dl>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">subpavings::AdaptiveHistogramValidation::insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">subpavings::AdaptiveHistogram::insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogram::insertOne()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00292">MultiTreeManager::makeAndGraphOutcomeSpace()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00177">MultiTreeManager::mapPavings()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">subpavings::AdaptiveHistogram::MCMCsamples()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01005">subpavings::SPnode::outputGraphDot()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02372">subpavings::SPSnode::reshapeToUnion()</a>.</p>

</div>
</div>
<a class="anchor" id="a3aaa0e2846fcc501bf57373ab4fcfcb3"></a><!-- doxytag: member="subpavings::hullOperator" ref="a3aaa0e2846fcc501bf57373ab4fcfcb3" args="(const T &amp;x, const T &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespacesubpavings.shtml#a3aaa0e2846fcc501bf57373ab4fcfcb3">subpavings::hullOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="rangecollection_8hpp_source.shtml#l00059">59</a> of file <a class="el" href="rangecollection_8hpp_source.shtml">rangecollection.hpp</a>.</p>

<p>Referenced by <a class="el" href="rangecollection_8hpp_source.shtml#l00219">subpavings::RangeCollectionClass&lt; T &gt;::hullCollection()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> x &gt; y ? x : y;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a70d818982b5c40190ee76257be4f9027"></a><!-- doxytag: member="subpavings::hullOperator&lt; cxsc::interval &gt;" ref="a70d818982b5c40190ee76257be4f9027" args="(const cxsc::interval &amp;x, const cxsc::interval &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cxsc::interval <a class="el" href="namespacesubpavings.shtml#a3aaa0e2846fcc501bf57373ab4fcfcb3">subpavings::hullOperator</a>&lt; cxsc::interval &gt; </td>
          <td>(</td>
          <td class="paramtype">const cxsc::interval &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::interval &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6daf9a90fd58f9f6c19e684172661284"></a><!-- doxytag: member="subpavings::hullOperator&lt; cxsc::ivector &gt;" ref="a6daf9a90fd58f9f6c19e684172661284" args="(const cxsc::ivector &amp;x, const cxsc::ivector &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cxsc::ivector <a class="el" href="namespacesubpavings.shtml#a3aaa0e2846fcc501bf57373ab4fcfcb3">subpavings::hullOperator</a>&lt; cxsc::ivector &gt; </td>
          <td>(</td>
          <td class="paramtype">const cxsc::ivector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cxsc::ivector &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f22db67f4e7e059f3acff280a8441f8"></a><!-- doxytag: member="subpavings::hullOperator&lt; Vec &gt;" ref="a0f22db67f4e7e059f3acff280a8441f8" args="(const Vec &amp;x, const Vec &amp;y)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVec.shtml">Vec</a> <a class="el" href="namespacesubpavings.shtml#a3aaa0e2846fcc501bf57373ab4fcfcb3">subpavings::hullOperator</a>&lt; <a class="el" href="classVec.shtml">Vec</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVec.shtml">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVec.shtml">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ExVector3D_8cpp_source.shtml#l00023">23</a> of file <a class="el" href="ExVector3D_8cpp_source.shtml">ExVector3D.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
       <span class="keywordflow">return</span> x + y; <span class="comment">// addition</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af6d00551176ec8a60444c7115aa08ca0"></a><!-- doxytag: member="subpavings::ImageSp" ref="af6d00551176ec8a60444c7115aa08ca0" args="(PIVF f, SPnode *spn, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>* <a class="el" href="namespacesubpavings.shtml#af6d00551176ec8a60444c7115aa08ca0">subpavings::ImageSp</a> </td>
          <td>(</td>
          <td class="paramtype">PIVF&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPnode *&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00214">214</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">Evaluate()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> images;
        ivector hull;

        <span class="keywordflow">try</span> {

            <a class="code" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a>(spn, eps);

            <a class="code" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, spn, images, hull);

            <span class="comment">/* the output of eval is not included in the AIA examples,</span>
<span class="comment">            but it makes an interesting comparison to final subpaving */</span>
            ofstream os2(<span class="stringliteral">&quot;eval.txt&quot;</span>);            <span class="comment">// Filename</span>
            list&lt;ivector&gt;::iterator it;
            <span class="keywordflow">for</span> (it=images.begin(); it!=images.end(); it++) {
                ivector box = *it;
                os2 &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(box[1]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(box[1])
                    &lt;&lt; <span class="stringliteral">&quot; ] , [ &quot;</span> &lt;&lt; Inf(box[2]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span>
                    &lt;&lt; Sup(box[2]) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span> &lt;&lt;  endl;
            }
            <span class="comment">// end of difference from AIA examples</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
        {
            <span class="keywordtype">string</span> msg(ba.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in ImageSp&quot;</span> &lt;&lt; std::endl;
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
        }
        <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
            <span class="keywordtype">string</span> msg(spe.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in ImageSp: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordtype">string</span> msg(e.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in ImageSp: original error &quot;</span> &lt;&lt; msg &lt;&lt; endl;
        }

        <span class="comment">// make a minimal subpaving out of images, with root box hull</span>
        <span class="keywordflow">return</span> (Regularize&lt;SPnode&gt;(hull, images, eps));

    }
</pre></div>
</div>
</div>
<a class="anchor" id="af0cce4ab9cf30918f62b403ce840776b"></a><!-- doxytag: member="subpavings::ImageSpNonMinimal" ref="af0cce4ab9cf30918f62b403ce840776b" args="(PIVF f, SPnode *spn, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>* <a class="el" href="namespacesubpavings.shtml#af0cce4ab9cf30918f62b403ce840776b">subpavings::ImageSpNonMinimal</a> </td>
          <td>(</td>
          <td class="paramtype">PIVF&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPnode *&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00263">263</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">Evaluate()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> images;
        ivector hull;

        <span class="keywordflow">try</span> {

            <a class="code" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a>(spn, eps);

            <a class="code" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, spn, images, hull);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
        {
            <span class="keywordtype">string</span> msg(ba.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in ImageSpNonMinimal&quot;</span>
                                                &lt;&lt; std::endl;
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
        }
        <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
            <span class="keywordtype">string</span> msg(spe.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in ImageSpNonMinimal: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordtype">string</span> msg(e.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in ImageSpNonMinimal: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }

        <span class="comment">// make a non-minimal subpaving from images,</span>
        <span class="comment">// with root box hull</span>
        <span class="keywordflow">return</span> (RegularizeNonMinimal&lt;SPnode&gt;(hull, images, eps));

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a72386487753f5334a70250b068f97f15"></a><!-- doxytag: member="subpavings::isEmpty" ref="a72386487753f5334a70250b068f97f15" args="(const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15">subpavings::isEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a SubPaving is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the given node is NULL or <a class="el" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">SPnode::isEmpty()</a> is true </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02206">2206</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="sptemplates_8hpp_source.shtml#l00125">Adopt()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00170">subpavings::AdaptiveHistogramValidation::haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00171">subpavings::AdaptiveHistogram::haveMadePaving()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogram::insertOne()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">Mince()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02155">operator&lt;&lt;()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00072">Reunite()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">Sivia()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02236">spLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02257">spTotalNodes()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02214">spVolume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// return true if spn is a null pointer or</span>
        <span class="comment">// node spn points to is empty</span>
        <span class="keywordflow">return</span> ((spn==NULL) || (spn-&gt;isEmpty()));
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6ce5e0d7ef8daa51a49872efc2ef56d8"></a><!-- doxytag: member="subpavings::isLeaf" ref="a6ce5e0d7ef8daa51a49872efc2ef56d8" args="(const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8">subpavings::isLeaf</a> </td>
          <td>(</td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a node is a leaf. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the given node is not NULL and <a class="el" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">SPnode::isLeaf()</a> is true. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02192">2192</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l00157">subpavings::SPnode::_reshapeToUnion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00629">subpavings::SPSnode::_reshapeToUnion()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">subpavings::CollatorSPnode::dotDiffPaving()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00174">Evaluate()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">Mince()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00170">subpavings::SPSVnode::nodeExpansionOnly()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00171">subpavings::SPSnode::nodeExpansionOnly()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02155">operator&lt;&lt;()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">Sivia()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02236">spLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00088">subpavings::SPnode::splitLeft()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02214">spVolume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// FALSE if spn is a null pointer, true if spn is not NULL</span>
        <span class="keywordtype">bool</span> retVal = (spn!=NULL);


        <span class="keywordflow">if</span> (retVal) { <span class="comment">// if spn points to a non-empty node</span>
            retVal = spn-&gt;isLeaf();
        }

        <span class="keywordflow">return</span> retVal;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab434c49dd2b267948d0048075ab0298c"></a><!-- doxytag: member="subpavings::labelDataFromFilter" ref="ab434c49dd2b267948d0048075ab0298c" args="(RVecData &amp;theData, RSSample &amp;labData, std::map&lt; rvector, size_t, std::less&lt; rvector &gt; &gt; &amp;CountsMap, std::map&lt; rvector, double, std::less&lt; rvector &gt; &gt; &amp;EMFMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#ab434c49dd2b267948d0048075ab0298c">subpavings::labelDataFromFilter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>labData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; rvector, size_t, std::less&lt; rvector &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>CountsMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; rvector, double, std::less&lt; rvector &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMFMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Labels an RVecData object and store as an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. Takes an RVecData container and its corresponding map to label the points. Point mass data gets label 0 and the rest gets label 1. The labelled data is then stored in an <a class="el" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a> object. </p>
<p>The EMF of the point mass data is also returned and stored in a map.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>is the container to put all the data found into. </td></tr>
    <tr><td class="paramname">CountsMap</td><td>is passed in by reference and stores the empirical mass function of the data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l01207">1207</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="SmallClasses_8hpp_source.shtml#l00035">LabPnt::L</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00033">LabPnt::Pnt</a>, and <a class="el" href="SmallClasses_8hpp_source.shtml#l00241">RSSample::Samples</a>.</p>

<p>Referenced by <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, and <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="namespacesubpavings.shtml#aa990935cb163d8eb54f28df1a3508af0" title="Define type RVecDataItr as iterator over RVecData.">RVecDataItr</a> dataIt;
    <span class="keywordflow">for</span> (dataIt = theData.begin(); dataIt &lt; theData.end(); dataIt++){
      <span class="keywordflow">if</span> (CountsMap[(*dataIt)] &gt; 1 ) { <span class="comment">//for non-unique points</span>
      <span class="comment">//if (CountsMap[(*dataIt)] &gt; int(theData.size()*0.01) ) { //for loosely non-unique points</span>
        <span class="comment">// insert into RSSample object with label 0</span>
        <a class="code" href="classLabPnt.shtml" title="A labeled point class.">LabPnt</a> data0;
        data0.<a class="code" href="classLabPnt.shtml#a57c17e6672679825de3ba13b7486d276" title="specifies the point as cxsc::rvector Pnt of the labeled point LabPnt">Pnt</a> = *dataIt;
        data0.<a class="code" href="classLabPnt.shtml#ac63f9c6a9263427b84e7f576a122ae44" title="specifies the label L of the labeled point LabPnt">L</a> = 0;
           <span class="comment">// cout &lt;&lt; &quot;non-unique point: &quot;; </span>
        <span class="comment">//data0.Print(cout);</span>
        labData.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.push_back(data0);
        <span class="comment">//Also store the EMF of (*dataIt)</span>
                                <span class="comment">//TODO: this is crazy GT?? Every time you insert multiple pointmass events at the same point you update the same thing???this EMFMap should be removed and weights obtained from CountsMap directly (perhaps replace size_t with double for value in CountsMap map)</span>
        EMFMap[(*dataIt)] = (double(CountsMap[(*dataIt)])*1.0)/(double(theData.size())*1.0);
      }
      <span class="keywordflow">else</span> {
        <span class="comment">// insert into RSSample object with label 1</span>
        <a class="code" href="classLabPnt.shtml" title="A labeled point class.">LabPnt</a> data1;
        data1.<a class="code" href="classLabPnt.shtml#a57c17e6672679825de3ba13b7486d276" title="specifies the point as cxsc::rvector Pnt of the labeled point LabPnt">Pnt</a> = *dataIt;
        data1.<a class="code" href="classLabPnt.shtml#ac63f9c6a9263427b84e7f576a122ae44" title="specifies the label L of the labeled point LabPnt">L</a> = 1;
        <span class="comment">//cout &lt;&lt; &quot;unique point: &quot;;</span>
        <span class="comment">//data1.Print(cout);</span>
        labData.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.push_back(data1);       
      }     
    } <span class="comment">// end of iterating through data</span>
  }
</pre></div>
</div>
</div>
<a class="anchor" id="abb4671c14005974aeea8f0dd39600ec6"></a><!-- doxytag: member="subpavings::makeDotImage" ref="abb4671c14005974aeea8f0dd39600ec6" args="(string s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#abb4671c14005974aeea8f0dd39600ec6">subpavings::makeDotImage</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>make a Dot graph png image given a dot file. </p>
<p>Prints out a line to console with name of image file</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the .dot file to make the graph out of. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="multitreemanager_8cpp_source.shtml#l00292">MultiTreeManager::makeAndGraphOutcomeSpace()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">subpavings::AdaptiveHistogram::MCMCsamples()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01005">subpavings::SPnode::outputGraphDot()</a>.</p>

</div>
</div>
<a class="anchor" id="a6f8c4a15a4428e18b5ef0369782c86ae"></a><!-- doxytag: member="subpavings::makeDoubleIntoRvector" ref="a6f8c4a15a4428e18b5ef0369782c86ae" args="(const double d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="namespacesubpavings.shtml#a6f8c4a15a4428e18b5ef0369782c86ae">subpavings::makeDoubleIntoRvector</a> </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a double into an rvector. </p>
<p>Used for processing input to an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object. </p>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l00490">490</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        rvector newdata = _rvector(d);
        <span class="comment">// 1-d rvector, only element is the implicit cast of d to real</span>
        <span class="comment">// note that cxsc allows an implicit cast from double to real</span>
        <span class="keywordflow">return</span> newdata;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a9d7eaadb31b3f9c2a28ad4af1f977a15"></a><!-- doxytag: member="subpavings::Mince" ref="a9d7eaadb31b3f9c2a28ad4af1f977a15" args="(SPnode *const spn, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#a9d7eaadb31b3f9c2a28ad4af1f977a15">subpavings::Mince</a> </td>
          <td>(</td>
          <td class="paramtype">SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mince up a subpaving. </p>
<p>Mince minces recursively until each leaf has maximum diameter smaller than eps.</p>
<p>Mince is now a non-friend non-member function (compare to the <a class="el" href="classAIASPnode.shtml#ab7921c5bd80f01985ee134c5d2ab595d" title="Mince up a subpaving.">AIASPnode::Mince()</a>) which now uses public member functions in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>a pointer to the node whose box is to be minced </td></tr>
    <tr><td class="paramname">eps</td><td>the maximum diameter any box in the subpaving should be </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">53</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02192">isLeaf()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {
            <span class="comment">// only try to expand if we have a non-empty leaf</span>
            <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn) &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn)) {

                <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// valued with MaxDiam function below</span>

                <span class="comment">// if the leaf&#39;s box is &gt;= to eps, keep expanding</span>
                <span class="keywordflow">if</span>(<a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(spn-&gt;getBox(), maxdiamcomp) &gt;= eps) {
                    <span class="comment">// comp is the dimension to split on</span>

                    <span class="comment">// if leaf and box not &lt; eps then expand</span>
                    <a class="code" href="AIAsubpaving_8cpp.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a>(spn, maxdiamcomp);
                }

            } <span class="comment">// end !isEmpty() &amp;&amp; isLeaf()</span>

            <span class="comment">// not a leaf, so Mince the children</span>
            <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn) &amp;&amp; !<a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn)) {
                <a class="code" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a>(spn-&gt;getRightChild(), eps);
                <a class="code" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a>(spn-&gt;getLeftChild(), eps);
            }

            <span class="comment">// if spn points to an empty subpaving, nothing happens</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;in Mince(...)&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a31f92daeace87913f55ad41125368359"></a><!-- doxytag: member="subpavings::nodeCompTotalSummary" ref="a31f92daeace87913f55ad41125368359" args="(const CollatorSPnode *const lhs, const CollatorSPnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a31f92daeace87913f55ad41125368359">subpavings::nodeCompTotalSummary</a> </td>
          <td>(</td>
          <td class="paramtype">const CollatorSPnode *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CollatorSPnode *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparison of CollatorSPnodes using total of summaries. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01963">1963</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01744">subpavings::CollatorSPnode::getTotalSummary()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> (lhs-&gt;getTotalSummary() &lt; rhs-&gt;getTotalSummary());
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a3580c30693d7d662e28a0fa26f45f837"></a><!-- doxytag: member="subpavings::nodeCompTotalSummaryAv" ref="a3580c30693d7d662e28a0fa26f45f837" args="(const CollatorSPnode *const lhs, const CollatorSPnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a3580c30693d7d662e28a0fa26f45f837">subpavings::nodeCompTotalSummaryAv</a> </td>
          <td>(</td>
          <td class="paramtype">const CollatorSPnode *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CollatorSPnode *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparison of CollatorSPnodes using the average of the total of summaries. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01970">1970</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01753">subpavings::CollatorSPnode::getTotalSummaryAv()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00987">subpavings::AdaptiveHistogramCollator::findDensityRegion()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">return</span> (lhs-&gt;getTotalSummaryAv() &lt; rhs-&gt;getTotalSummaryAv());
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ab16dccf5fd03eee9a6071072432e38bc"></a><!-- doxytag: member="subpavings::nodePtrCompare" ref="ab16dccf5fd03eee9a6071072432e38bc" args="(const subpavings::RealMappedSPnode *lhs, const subpavings::RealMappedSPnode *rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#ab16dccf5fd03eee9a6071072432e38bc">subpavings::nodePtrCompare</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">subpavings::RealMappedSPnode</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">subpavings::RealMappedSPnode</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Less-than operator using pointers. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true iff *lhs &lt; *rhs. </dd></dl>

<p>Definition at line <a class="el" href="realmappedspnode_8cpp_source.shtml#l01175">1175</a> of file <a class="el" href="realmappedspnode_8cpp_source.shtml">realmappedspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> ((*lhs) &lt; (*rhs));
} 
</pre></div>
</div>
</div>
<a class="anchor" id="a91aca11d8ef070d592dcd968dd82d89d"></a><!-- doxytag: member="subpavings::operator&lt;" ref="a91aca11d8ef070d592dcd968dd82d89d" args="(const HistDescription &amp;lhs, const HistDescription &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool subpavings::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistDescription.shtml">HistDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistDescription.shtml">HistDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Comparison operator for the histogram description. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05890">5890</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l02059">subpavings::HistDescription::getDepthString()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> lhs.<a class="code" href="classsubpavings_1_1HistDescription.shtml#a35a0b15e904f1987b6603c7ffeb22f75" title="Get the depthString.">getDepthString</a>() &lt; rhs.<a class="code" href="classsubpavings_1_1HistDescription.shtml#a35a0b15e904f1987b6603c7ffeb22f75" title="Get the depthString.">getDepthString</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a653a8836d9a2c6067d19fe172adda889"></a><!-- doxytag: member="subpavings::operator&lt;&lt;" ref="a653a8836d9a2c6067d19fe172adda889" args="(std::ostream &amp;os, const AdaptiveHistogramCollator &amp;adhc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; subpavings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml">AdaptiveHistogramCollator</a> &amp;&#160;</td>
          <td class="paramname"><em>adhc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the contents of an <a class="el" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml" title="A wrapper or manager for a CollatorSPSnode.">AdaptiveHistogramCollator</a> object. </p>
<p>Verbose output for an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object. </p>

<p>Definition at line <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l01807">1807</a> of file <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml">adaptivehistogramcollator.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00465">subpavings::AdaptiveHistogramCollator::getSubPaving()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL != adhc.<a class="code" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml#ac7545dd3425c4570bd9e0fde17ad9294" title="Return a pointer to the CollatorPSnode this manages.">getSubPaving</a>()) {
        os &lt;&lt; (adhc.<a class="code" href="classsubpavings_1_1AdaptiveHistogramCollator.shtml#ac7545dd3425c4570bd9e0fde17ad9294" title="Return a pointer to the CollatorPSnode this manages.">getSubPaving</a>())-&gt;nodesAllOutput(os, 1) &lt;&lt; std::endl;
    }

    <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a014371dd680ff6750f99952e6eb92cf9"></a><!-- doxytag: member="subpavings::operator&lt;&lt;" ref="a014371dd680ff6750f99952e6eb92cf9" args="(std::ostream &amp;os, const subpavings::PiecewiseConstantFunction &amp;pcf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; subpavings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml">subpavings::PiecewiseConstantFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>pcf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the contents of an <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> object. </p>
<p>Verbose output for an <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> object, including all boxes (not just leaves), data, and summary statistics. </p>

</div>
</div>
<a class="anchor" id="a6cbced3edaaea51ec4f60020f4b68410"></a><!-- doxytag: member="subpavings::operator&lt;&lt;" ref="a6cbced3edaaea51ec4f60020f4b68410" args="(std::ostream &amp;os, const CollatorSPVnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; subpavings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CollatorSPVnode &amp;&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator for CollatorSPVnodes. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01526">1526</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00960">subpavings::SPnode::nodesAllOutput()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        os &lt;&lt; spn.nodesAllOutput(os, 1) &lt;&lt; std::endl;
        <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4dca88e1718f95fecdf1429d1ebbfd11"></a><!-- doxytag: member="subpavings::operator&lt;&lt;" ref="a4dca88e1718f95fecdf1429d1ebbfd11" args="(std::ostream &amp;os, const CollatorSPnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; subpavings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CollatorSPnode &amp;&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output operator for CollatorSPnodes. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01955">1955</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00960">subpavings::SPnode::nodesAllOutput()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        os &lt;&lt; spn.nodesAllOutput(os, 1) &lt;&lt; std::endl;
        <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7b0c2cba5230c058d175234c14d4f3af"></a><!-- doxytag: member="subpavings::operator&lt;&lt;" ref="a7b0c2cba5230c058d175234c14d4f3af" args="(std::ostream &amp;os, const HistDescription &amp;hd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; subpavings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1HistDescription.shtml">HistDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>hd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the <a class="el" href="classsubpavings_1_1HistDescription.shtml" title="A class for the histogram description.">HistDescription</a> object. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05882">5882</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8hpp_source.shtml#l02059">subpavings::HistDescription::getDepthString()</a>.</p>
<div class="fragment"><pre class="fragment">{
    os &lt;&lt; hd.<a class="code" href="classsubpavings_1_1HistDescription.shtml#a35a0b15e904f1987b6603c7ffeb22f75" title="Get the depthString.">getDepthString</a>();
    <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa76489a659f3ddc671bcd47d227baad1"></a><!-- doxytag: member="subpavings::operator&lt;&lt;" ref="aa76489a659f3ddc671bcd47d227baad1" args="(std::ostream &amp;os, const AdaptiveHistogram &amp;adh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; subpavings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>adh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the contents of an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object. </p>
<p>Verbose output for an <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> object, including all boxes (not just leaves), data, and summary statistics. </p>

<p>Definition at line <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05902">5902</a> of file <a class="el" href="adaptivehistogram_8cpp_source.shtml">adaptivehistogram.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">subpavings::AdaptiveHistogram::getSubPaving()</a>.</p>
<div class="fragment"><pre class="fragment">{
    os &lt;&lt; (adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#aecbdfe366fa381c0b3f7a7b00447dedb" title="Return a pointer to the SPSnode this manages.">getSubPaving</a>())-&gt;nodesAllOutput(os, 1) &lt;&lt; std::endl;

    <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7288149f86d1e0c956f45dcd849a08fc"></a><!-- doxytag: member="subpavings::operator&lt;&lt;" ref="a7288149f86d1e0c956f45dcd849a08fc" args="(std::ostream &amp;os, const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; subpavings::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the contents of a SubPaving. </p>
<p>Calls nodePrint recursively for each leaf node. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02155">2155</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02192">isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00877">subpavings::SPnode::nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// uses nodePrint to generate node output</span>

        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn)) &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn)) { <span class="comment">// spn is non-empty leaf</span>
            spn-&gt;nodePrint(os);
        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn)) &amp;&amp; !(<a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn))) {
            os &lt;&lt; (spn-&gt;getLeftChild());
            os &lt;&lt; (spn-&gt;getRightChild());
        }

        <span class="comment">//in the case where spn is empty we just return os</span>

        <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aca1892906e63d34720305016dd41156d"></a><!-- doxytag: member="subpavings::operator&lt;=" ref="aca1892906e63d34720305016dd41156d" args="(const ivector &amp;z, const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6">BOOL_INTERVAL</a> subpavings::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check for containment of interval vector in the SubPaving. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>the interval vector we are testing for containment in a subpaving </td></tr>
    <tr><td class="paramname">spn</td><td>a pointer to the subpaving node we are testing to see if it contains z </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a BOOL_INTERVAL, ie BI_TRUE, or BI_FALSE, or BI_INDET if z overlaps the boundary of the subpaving spn. </dd></dl>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02175">2175</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="sptypes_8hpp_source.shtml#l00074">BI_FALSE</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00382">subpavings::SPnode::getDimension()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> retValue = <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;

        <span class="keywordflow">if</span> (spn!=NULL)
        {
            <span class="keywordflow">if</span> (VecLen(z) != spn-&gt;getDimension()) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Dimension do not match&quot;</span>);
            }

            retValue = (*spn).spContains(z);
        }
        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a97b57336ffc5ebac59abfb36dbd5405b"></a><!-- doxytag: member="subpavings::opNegate" ref="a97b57336ffc5ebac59abfb36dbd5405b" args="(double d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacesubpavings.shtml#a97b57336ffc5ebac59abfb36dbd5405b">subpavings::opNegate</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate a double. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01534">1534</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> -d;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa5b5b66715568bc59cafea064eb8b1a7"></a><!-- doxytag: member="subpavings::outputFile" ref="aa5b5b66715568bc59cafea064eb8b1a7" args="(const string &amp;s, const string line, bool append=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>append</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a line to a txt file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">line</td><td>the line to append to the file. </td></tr>
    <tr><td class="paramname">append</td><td>controls whether line is appended to file, defaults to true. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l00629">subpavings::SPSnode::_reshapeToUnion()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00058">MultiTreeManager::addToOutcomeSpaceAndGraph()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03368">subpavings::AdaptiveHistogram::changeMCMCState()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">subpavings::AdaptiveHistogram::decisionMCMCSplit()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">subpavings::AdaptiveHistogramValidation::insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">subpavings::AdaptiveHistogram::insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogram::insertOne()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00423">subpavings::AdaptiveHistogram::logMCMCDeltas()</a>, <a class="el" href="MCMCGRAuto_8cpp_source.shtml#l00038">main()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00292">MultiTreeManager::makeAndGraphOutcomeSpace()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00177">MultiTreeManager::mapPavings()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00484">subpavings::AdaptiveHistogram::MCMCLogFinalState()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">subpavings::AdaptiveHistogram::MCMCsamples()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00444">subpavings::AdaptiveHistogram::MCMCStartLogFile()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01005">subpavings::SPnode::outputGraphDot()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>.</p>

</div>
</div>
<a class="anchor" id="a57aa1d6f86ddd18d459fd36a710ae737"></a><!-- doxytag: member="subpavings::outputFile" ref="a57aa1d6f86ddd18d459fd36a710ae737" args="(const std::string &amp;s, RealVec &amp;vals, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a tab delimited list seq of values as a line in log file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">vals</td><td>is a vector of values to add to the file </td></tr>
    <tr><td class="paramname">i</td><td>the number of pass (ie, 0, 1, 2, 3 etc) in process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11f846091a8b802ae4173e061b1b55f2"></a><!-- doxytag: member="subpavings::outputFile" ref="a11f846091a8b802ae4173e061b1b55f2" args="(const std::string &amp;s, const std::string intro, RealVec &amp;vals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>intro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a tab delimited list seq of values as a line in log file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">intro</td><td>is the introduction before the rest is put in, all on one line. </td></tr>
    <tr><td class="paramname">vals</td><td>is a vector of values to add to the file </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l00170">170</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        ofstream os(s.c_str(), ios::app);         <span class="comment">// append</span>
        <span class="keywordflow">if</span> (os.is_open()) {
            os &lt;&lt; intro &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
            ostream_iterator&lt;rvector&gt; out_it (os,<span class="stringliteral">&quot;\t&quot;</span>);
            copy ( vals.begin(), vals.end(), out_it );
            os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

            os.close();
        }
        <span class="keywordflow">else</span> {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error: could not open file named &quot;</span>
                &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a577225f9ff8ccb0b27420ff962fc978f"></a><!-- doxytag: member="subpavings::outputFile" ref="a577225f9ff8ccb0b27420ff962fc978f" args="(const std::string &amp;s, std::vector&lt; string &gt; &amp;strings, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a tab delimited list seq of strings as a line in log file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
    <tr><td class="paramname">strings</td><td>is a vector of strings to add to the file </td></tr>
    <tr><td class="paramname">i</td><td>the number of pass (ie, 0, 1, 2, 3 etc) in process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb8564fbbb2536bafcd19a5cc56e6531"></a><!-- doxytag: member="subpavings::outputFileStart" ref="afb8564fbbb2536bafcd19a5cc56e6531" args="(const string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#afb8564fbbb2536bafcd19a5cc56e6531">subpavings::outputFileStart</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opening line of a txt log file. </p>
<p>Starts the log file with file name and date and time </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the txt file to send output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00065">main()</a>, and <a class="el" href="MCMCGRtools_8cpp_source.shtml#l00047">outputToFileVertical()</a>.</p>

</div>
</div>
<a class="anchor" id="a0973b1623e6e12ba060db40d9cceece1"></a><!-- doxytag: member="subpavings::parseForGraphDot" ref="a0973b1623e6e12ba060db40d9cceece1" args="(string s, string toParse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a0973b1623e6e12ba060db40d9cceece1">subpavings::parseForGraphDot</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>toParse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse a string to make lines for a dot graph. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the file to output to </td></tr>
    <tr><td class="paramname">toParse</td><td>the string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if parsing worked, false if problems encountered </dd></dl>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l01005">subpavings::SPnode::outputGraphDot()</a>.</p>

</div>
</div>
<a class="anchor" id="a498313e6b9ea0e6fb60d63ea3f2d0128"></a><!-- doxytag: member="subpavings::parseSpacings" ref="a498313e6b9ea0e6fb60d63ea3f2d0128" args="(string line, IntVec &amp;spacings)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">IntVec</a> <a class="el" href="namespacesubpavings.shtml#a498313e6b9ea0e6fb60d63ea3f2d0128">subpavings::parseSpacings</a> </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;&#160;</td>
          <td class="paramname"><em>spacings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>parse a .vtk header line for spacings data. </p>
<p>Expects a line of the form "DIMENSIONS 32 32 32" </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>is the line to be parsed. </td></tr>
    <tr><td class="paramname">spacings</td><td>is an empty container for the spacings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the container of spacings filled up from the data in the line. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e3a19279d328b2178aaac44beaaf2d6"></a><!-- doxytag: member="subpavings::pointMassFilter" ref="a1e3a19279d328b2178aaac44beaaf2d6" args="(RVecData &amp;theData, std::map&lt; rvector, size_t, std::less&lt; rvector &gt; &gt; &amp;CountsMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacesubpavings.shtml#a1e3a19279d328b2178aaac44beaaf2d6">subpavings::pointMassFilter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; rvector, size_t, std::less&lt; rvector &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>CountsMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Point mass filtering from data in a RVecData container. Takes an RVecData container and sieves through the data to obtain "point mass" data, i.e. data that falls on the same location with precision up to instrument settings or user's definition. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>is the container to put all the data found into. </td></tr>
    <tr><td class="paramname">CountsMap</td><td>is passed in by reference and stores the empirical mass function of the data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l01190">1190</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>Referenced by <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, and <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="namespacesubpavings.shtml#aa990935cb163d8eb54f28df1a3508af0" title="Define type RVecDataItr as iterator over RVecData.">RVecDataItr</a> dataIt;
    std::pair&lt;map&lt;rvector, size_t, less&lt;rvector&gt; &gt;::iterator, <span class="keywordtype">bool</span>&gt; boolCount;
     <span class="comment">//go through the dataset</span>
    <span class="keywordflow">for</span> (dataIt = theData.begin(); dataIt &lt; theData.end(); dataIt++) {
      <span class="comment">//insert into map</span>
      boolCount = CountsMap.insert(make_pair(*dataIt,1));   
      <span class="comment">//Check if insertion is successful - a unique set will render a successful insertion.</span>
      <span class="keywordflow">if</span>(!(boolCount.second)) { <span class="comment">//if there are repeated points</span>
          <span class="comment">//increment count for this key</span>
          CountsMap[(*dataIt)] += 1;  
      }  
    } <span class="comment">// end of going through each data in this dataset</span>
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a535c4c5b9e6a042ec418db09ed956cda"></a><!-- doxytag: member="subpavings::readOneDimDataFromTxt" ref="a535c4c5b9e6a042ec418db09ed956cda" args="(RVecData &amp;theData, const string &amp;s, const std::size_t headerlines=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a535c4c5b9e6a042ec418db09ed956cda">subpavings::readOneDimDataFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">RVecData &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read in one-dimensional data from a txt file. </p>
<p>Reads in lines of data representing integers or doubles from a txt file. Expects one line per integer or double and will ignore any further numbers on a line. Will ignore lines where first 'word' (block of characters terminated by white space or endofline character) found cannot be converted to an integer or double, and print a message to console about ignored line.</p>
<p>For example, a string "12.04 1.00005e-10 -30.0006" will be read as a 12.04. A string "30 abc 12.04.0006" will be read as 30, and a string "abc 30 12.04.0006" will be rejected.</p>
<p>The container theData is assumed to be empty but this will work even if it is not empty provided that the data already there is also 1-dimensional.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>is a reference to a container of data into which to place the data once read. </td></tr>
    <tr><td class="paramname">s</td><td>is the name of the txt file from which to read the data. </td></tr>
    <tr><td class="paramname">headerlines</td><td>is number of headerlines to skip before reading data. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData, assumed to be empty, in which to store data. theData should support push_back() method. </dd>
<dd>
A file with filename s in the same directory as <a class="el" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> or with the filename incorporating directory location. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The container theData contains the valid rvectors read in. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data was read in, false if the file could not be opened, if the file contained no data, or if no valid data was found in the file. </dd></dl>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01458">subpavings::AdaptiveHistogram::insertOneDimDataFromTxt()</a>.</p>

</div>
</div>
<a class="anchor" id="a7918dddb1a8e32f72835e1e7b4442ca6"></a><!-- doxytag: member="subpavings::readRvectorsFromTxt" ref="a7918dddb1a8e32f72835e1e7b4442ca6" args="(RVecData &amp;theData, const string &amp;s, const std::size_t headerlines=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a7918dddb1a8e32f72835e1e7b4442ca6">subpavings::readRvectorsFromTxt</a> </td>
          <td>(</td>
          <td class="paramtype">RVecData &amp;&#160;</td>
          <td class="paramname"><em>theData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>headerlines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read in rvectors from a txt file. </p>
<p>Reads in lines of data representing rvectors from a txt file. The dimensions of the rvector are deduced from the input format and all the data then is expected to have the same dimension. Any data not matching the expected dimensions, based on assessing the first valid line found, will be rejected. Expects one line per rvector with the elements separated by white space (space or tabs), with no non-numeric characters. Carries out basic data checking through <a class="el" href="namespacesubpavings.shtml#af62c725dd362922c15d45983e2d8f6cf" title="A quick check on a data string: expecting only numbers white space or decimal points.">checkString()</a>. Input lines which do not pass are printed to standard output with an error message but the entire file will continue to be processed and valid lines converted to rvectors which are stored in theData. Conversion to rvectors is via the cxsc::operator&lt;&lt; which allows an rvector to be constructed from a stream. Can read 1-d rvector data from doubles or floats but insists on a decimal point in each number (otherwise the number is rejected).</p>
<p>For example, a string "12.04 1.00005e-10 -30.0006" will be read as a 3-dimensional rvector, a string "-30.0006" will be read as a 1-dimensional rvector, and a string "30" will be rejected.</p>
<p>The container theData is assumed to be empty but this will work even if it is not empty provided that the data added has the same dimension as the existing data, since we are only pushing back: new data will just get put in after the stuff already there.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theData</td><td>is a reference to a container of data into which to place the data once read. </td></tr>
    <tr><td class="paramname">s</td><td>is the name of the txt file from which to read the data. </td></tr>
    <tr><td class="paramname">headerlines</td><td>is number of headerlines to skip before reading data. Defaults to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>A container theData, assumed to be empty, in which to store data. theData should support push_back() method. </dd>
<dd>
A file with filename s in the same directory as <a class="el" href="Exm__3__3_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a> or with the filename incorporating directory location. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>The container theData contains the valid rvectors read in. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if at least some data was read in, false if the file could not be opened, if the file contained no data, or if no valid data was found in the file. </dd></dl>

<p>Referenced by <a class="el" href="AHABCObsMCMCDblHurdle_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00589">subpavings::AdaptiveHistogramValidation::insertRvectorsFromTxt()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01517">subpavings::AdaptiveHistogram::insertRvectorsFromTxt()</a>, and <a class="el" href="AHABCSimThreeMethods_8cpp_source.shtml#l00044">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a331c50e79d716580fed8a900bfee2b1a"></a><!-- doxytag: member="subpavings::Regularize" ref="a331c50e79d716580fed8a900bfee2b1a" args="(ivector &amp;hull, ImageList &amp;ivectorList, double eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="namespacesubpavings.shtml#a331c50e79d716580fed8a900bfee2b1a">subpavings::Regularize</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageList &amp;&#160;</td>
          <td class="paramname"><em>ivectorList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forms a minimal image subpaving. </p>
<p>Make a minimal subpaving from a list of interval vector images. The root of the subpaving will have Box = hull, where hull has already been formed from the union of all the ivectors in the ivectorList. Regularize is applied recursively on bisected half of hull and new lists until either there are no images in the list or the diameter of the hull is below eps.</p>
<p>Uses <a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec" title="Tries to reunite two nodes into to form a single leaf.">Reunite()</a> and recursive calls to <a class="el" href="namespacesubpavings.shtml#a331c50e79d716580fed8a900bfee2b1a" title="Forms a minimal image subpaving.">Regularize()</a> to work upwards to form a minimal subpaving</p>
<p>Regularize is now a templatised non-friend non-member function (compare to <a class="el" href="classAIASPnode.shtml#a1b1148d30745256482cbc7cca090253d" title="Forms a minimal image subpaving from a list of interval vector images.">AIASPnode::Regularize()</a>) which now uses public member functions in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hull</td><td>the interval hull of all the interval vectors in the image list </td></tr>
    <tr><td class="paramname">ivectorList</td><td>a collection of possibly overlapping interval vectors to be made into a regular subpaving </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a regular minimal subpaving with root box hull </dd></dl>

<p>Definition at line <a class="el" href="sptemplates_8hpp_source.shtml#l00184">184</a> of file <a class="el" href="sptemplates_8hpp_source.shtml">sptemplates.hpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00397">volCompare()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* newNode = NULL;  <span class="comment">// for return value</span>

    <span class="comment">/*sort the list: volCompare makes the sort largest to smallest</span>
<span class="comment">    Jaulin et al do not have this step because they have their own</span>
<span class="comment">    IMAGELIST class which acts like a set and keeps contents in order</span>
<span class="comment">    But we are using the stl std::list and so it is unsorted when</span>
<span class="comment">    it is passed to Regularize.  It is more effient to sort it once</span>
<span class="comment">    per call to Regularise than to keep it sorted as it is</span>
<span class="comment">    being built because the sorted order is only needed when</span>
<span class="comment">    the entire list has been built.</span>
<span class="comment">    */</span>
    <span class="keywordflow">try</span> {

        <span class="comment">//sort using the volCompare function</span>
        ivectorList.sort(<a class="code" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74" title="Compare volumes of two boxes.">volCompare</a>);   <span class="comment">// sorts smallest to largest</span>

        <span class="comment">// test if hull is contained in the first (largest) box in list</span>

        <span class="keywordtype">int</span> maxdiamcomp = 0;  <span class="comment">// to take value calculated from MaxDiam</span>

        <span class="comment">// find the maximum diameter and</span>
        <span class="keywordtype">double</span> maxDiamHull = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(hull, maxdiamcomp);

        <span class="comment">// test if hull is equal to the largest image element, ie the last one</span>
        <span class="keywordtype">bool</span> isHullEqual = (hull == (*ivectorList.rbegin()));

        <span class="comment">// test if hull is smaller than eps</span>
        <span class="keywordtype">bool</span> isHullSmall = (maxDiamHull &lt; eps);

        <span class="comment">// if the list has some images in it</span>
        <span class="comment">// and either if the hull is equal to the largest box in the list</span>
        <span class="comment">// or if the hull max diameter is &lt; eps</span>
        <span class="comment">// return a new node based on hull</span>
        <span class="keywordflow">if</span> (!(ivectorList.empty()) &amp;&amp; (isHullEqual || isHullSmall)) {
                newNode = <span class="keyword">new</span> T(hull);
        }

        <span class="comment">// if the list has some images in it</span>
        <span class="comment">// and the hull is not equal to the largest box in the list</span>
        <span class="comment">// and the hull max diameter is not &lt; eps</span>
        <span class="comment">// return look at the left and right boxes</span>
        <span class="keywordflow">if</span> (!(ivectorList.empty()) &amp;&amp; !isHullEqual &amp;&amp; !isHullSmall) {

            <span class="comment">// new ivectors from splitting hull along its biggest dimension</span>
            ivector lefthull = <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(hull, maxdiamcomp);
            ivector righthull = <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(hull, maxdiamcomp);

            <span class="comment">// create two empty lists for the left and right side</span>
            <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> leftlist, rightlist;

            <a class="code" href="namespacesubpavings.shtml#a8553bcc272ba9d0b7b9b6bd991b3bc00" title="Define type iterator over ImageList.">ImageListItr</a> it; <span class="comment">// iterator to for the list</span>

            <span class="comment">// iterate through the current list and put the intersection of any</span>
            <span class="comment">// element with the lefthull into new left list, and the intersection</span>
            <span class="comment">// of any element with the new right hull into the new right list</span>
            <span class="keywordflow">for</span> (it=ivectorList.begin(); it!=ivectorList.end(); it++) {
                ivector interLeft;  <span class="comment">// intersection with left hull</span>
                ivector interRight;  <span class="comment">// intersection with right hull</span>

                <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interLeft, *it, lefthull)) {
                    leftlist.push_back(interLeft);
                }

                <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interRight, *it, righthull)) {
                    rightlist.push_back(interRight);
                }

            } <span class="comment">// end of iteration through list elements</span>

            <span class="comment">// recursively call Regularize with lefthull, leftlist</span>
            <span class="comment">// and righthull, rightlist</span>
            <span class="comment">// reunite the results using hull as the box for parent node</span>
            <span class="comment">// Regularize creates a minimal subpaving</span>
            <span class="comment">// (no sibling child nodes) on the hull</span>

            newNode = Reunite&lt;T&gt;(Regularize&lt;T&gt;(lefthull, leftlist, eps),
                                Regularize&lt;T&gt;(righthull,
                                            rightlist, eps), hull);

        } <span class="comment">// end of is list has elements and first box does not contain hull</span>
            <span class="comment">// and hull is large enough to warrent further splitting</span>

        <span class="comment">// if there is nothing in the list we return the default</span>
            <span class="comment">// initialisation value of NULL</span>
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
    {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in Regularize&quot;</span> &lt;&lt; std::endl;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
    }
    <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in Regularize: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; endl;
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error in Regularize: original error &quot;</span> &lt;&lt; msg &lt;&lt; endl;
    }

    <span class="keywordflow">return</span> newNode;

}
</pre></div>
</div>
</div>
<a class="anchor" id="ab59f7407c562f2b1b4f051e479c9736f"></a><!-- doxytag: member="subpavings::RegularizeNonMinimal" ref="ab59f7407c562f2b1b4f051e479c9736f" args="(ivector &amp;hull, ImageList &amp;ivectorList, double eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="namespacesubpavings.shtml#ab59f7407c562f2b1b4f051e479c9736f">subpavings::RegularizeNonMinimal</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageList &amp;&#160;</td>
          <td class="paramname"><em>ivectorList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forms a non-minimal image subpaving. </p>
<p>Make a non-minimal subpaving from a list of interval vector images The root of the subpaving will have Box = hull, where hull has already been formed from the union of all the ivectors in the ivectorList. RegularizeNonMinimal is applied recursively on bisected half of hull and new lists until either there are no images in the list or the diameter of the hull is below eps.</p>
<p>Uses <a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec" title="Tries to reunite two nodes into to form a single leaf.">Reunite()</a> and recursive calls to <a class="el" href="namespacesubpavings.shtml#ab59f7407c562f2b1b4f051e479c9736f" title="Forms a non-minimal image subpaving.">RegularizeNonMinimal()</a> to work upwards to form a non-minimal subpaving. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hull</td><td>the interval hull of all the interval vectors in the image list </td></tr>
    <tr><td class="paramname">ivectorList</td><td>a collection of possibly overlapping interval vectors to be made into a regular subpaving </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a regular non-minimal subpaving with root box hull </dd></dl>

<p>Definition at line <a class="el" href="sptemplates_8hpp_source.shtml#l00309">309</a> of file <a class="el" href="sptemplates_8hpp_source.shtml">sptemplates.hpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00397">volCompare()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* newNode = NULL;  <span class="comment">// for return value</span>

    <span class="keywordflow">try</span> {

        <span class="comment">// sort the list: volCompare makes the sort largest to smallest</span>
        <span class="comment">// Jaulin et al do not have this step because they have their own</span>
        <span class="comment">// IMAGELIST class which acts like a set and keeps contents in order</span>
        <span class="comment">// But we are using the stl std::list and so it is unsorted when</span>
        <span class="comment">// it is passed to Regularize.  It is more efficient to sort it once</span>
        <span class="comment">// per call to Regularise than to keep it sorted as it is</span>
        <span class="comment">// being built because the sorted order is only needed when</span>
        <span class="comment">// the entire list has been built.</span>

        <span class="comment">// sort using the volCompare function</span>
        ivectorList.sort(<a class="code" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74" title="Compare volumes of two boxes.">volCompare</a>);   <span class="comment">// sorts smallest to largest</span>

        <span class="comment">// test if hull is contained in the first (largest) box in the list</span>

        <span class="keywordtype">int</span> maxdiamcomp = 0;  <span class="comment">// to take value from MaxDiam</span>

        <span class="comment">// find the maximum diameter</span>
        <span class="keywordtype">double</span> maxDiamHull = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(hull, maxdiamcomp);

        <span class="comment">// test if hull is equal to the</span>
            <span class="comment">// largest image element, ie the last one</span>
        <span class="keywordtype">bool</span> isHullEqual = (hull==(*ivectorList.rbegin()));
        <span class="keywordtype">bool</span> isHullSmall = (maxDiamHull &lt; eps);

        <span class="comment">// if the list has some images in it</span>
        <span class="comment">// and either if the hull is equal to the largest box in the list</span>
        <span class="comment">// or if the hull max diameter is &lt; eps</span>
        <span class="comment">// return a new node based on hull</span>
        <span class="keywordflow">if</span> (!(ivectorList.empty()) &amp;&amp; (isHullEqual || isHullSmall)) {
            newNode = <span class="keyword">new</span> T(hull);
        }

        <span class="comment">// if the list has some images in it</span>
        <span class="comment">// and the hull is not contained in the first box in the list</span>
        <span class="comment">// and the hull max diameter is not &lt; eps</span>
        <span class="comment">// return look at the left and right boxes</span>
        <span class="keywordflow">if</span> (!(ivectorList.empty()) &amp;&amp; !isHullEqual &amp;&amp; !isHullSmall) {

            <span class="comment">// new ivectors from splitting hull along its biggest dimension</span>
            ivector lefthull = <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(hull, maxdiamcomp);
            ivector righthull = <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(hull, maxdiamcomp);

            <span class="comment">// create two empty lists for the left and right side</span>
            <a class="code" href="namespacesubpavings.shtml#acf161e8d79f04bf197a33277dd633f6d" title="Define type ImageList as a container for images of boxes.">ImageList</a> leftlist, rightlist;

            <a class="code" href="namespacesubpavings.shtml#a8553bcc272ba9d0b7b9b6bd991b3bc00" title="Define type iterator over ImageList.">ImageListItr</a> it; <span class="comment">// iterator to for the list</span>

            <span class="comment">// iterate through the current list and put the intersection of any</span>
            <span class="comment">// element with the lefthull into new left list, and the intersection</span>
            <span class="comment">// of any element with the new right hull into the new right list</span>
            <span class="keywordflow">for</span> (it=ivectorList.begin(); it!=ivectorList.end(); it++) {
                ivector interLeft;  <span class="comment">// intersection with left hull</span>
                ivector interRight;  <span class="comment">// intersection with right hull</span>

                <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interLeft, *it, lefthull)) {
                    leftlist.push_back(interLeft);
                }

                <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interRight, *it, righthull)) {
                    rightlist.push_back(interRight);
                }

            } <span class="comment">// end of iteration through list elements</span>

            <span class="comment">// recursively call RegularizeNonMinimal with lefthull,</span>
            <span class="comment">// leftlist and righthull, rightlist</span>
            <span class="comment">// adopt the results using hull as the box for parent node</span>
            <span class="comment">// RegularizeNonMinimal creates a non-minimal subpaving</span>
            <span class="comment">// (ie has sibling child nodes) on the hull</span>

            newNode = Adopt&lt;T&gt;(RegularizeNonMinimal&lt;T&gt;(lefthull, leftlist,
                                                    eps),
                            RegularizeNonMinimal&lt;T&gt;(righthull,
                                                    rightlist,
                                                    eps),
                                            hull);

        } <span class="comment">// end of is list has elements and first box does not contain hull</span>
        <span class="comment">// and hull is large enough to warrent further splitting</span>

        <span class="comment">// if there is nothing in the list we return the default</span>
            <span class="comment">// initialisation value of NULL</span>
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
    {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in SRegularizeNonMinimal&quot;</span>
                                            &lt;&lt; std::endl;
        std::cout &lt;&lt; msg &lt;&lt; std::endl;
    }
    <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.what());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in RegularizeNonMinimal: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; endl;
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in RegularizeNonMinimal: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; endl;
    }

    <span class="keywordflow">return</span> newNode;

}
</pre></div>
</div>
</div>
<a class="anchor" id="aa20ef6d47135f798ecc95164f0e6fdec"></a><!-- doxytag: member="subpavings::Reunite" ref="aa20ef6d47135f798ecc95164f0e6fdec" args="(T *lChild, T *rChild, ivector x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec">subpavings::Reunite</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to reunite two nodes into to form a single leaf. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Node types used with these templates should implement default constructor and constructor taking ivector argument and also implement nodeExpand(), nodeReunite(), nodeAdoptLeft() and nodeAdoptRight() functions.</dd></dl>
<p>Note that the nodes provided, lChild and rChild, are potential children for the node to be created and returned in this function. nodeReunite is used in building a tree upwards (rather than in pruning leaves of formed tree from the bottom up).</p>
<p>If two potential children are provided and they are both leaves, combines the two leaf siblings into the returned node. If the potential children are not leaves or if only one potential child is provided, graft the potential child/children onto the node to be created and returned as its child/children.</p>
<p>Calls nodeReunite method for the type of spn (base or derived) at runtime.</p>
<p>Reunite is now a templatised non-friend non-member function (compare to <a class="el" href="namespacesubpavings.shtml#aa20ef6d47135f798ecc95164f0e6fdec" title="Tries to reunite two nodes into to form a single leaf.">AIASPnode::Reunite()</a>) which now uses public member functions in the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lChild</td><td>a pointer to the leftChild node to be reunited </td></tr>
    <tr><td class="paramname">rChild</td><td>a pointer to the rightChild node to be reunited </td></tr>
    <tr><td class="paramname">x</td><td>is the box of the new subpaving to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal subpaving from two sibling subpavings </dd></dl>

<p>Definition at line <a class="el" href="sptemplates_8hpp_source.shtml#l00072">72</a> of file <a class="el" href="sptemplates_8hpp_source.shtml">sptemplates.hpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>.</p>
<div class="fragment"><pre class="fragment">{
    T* newNode = NULL; <span class="comment">// pointer to new node to be returned</span>

    <span class="keywordflow">try</span>
    {
        newNode = <span class="keyword">new</span> T(x);

        <span class="comment">// both proposed children are empty, return null</span>
        <span class="keywordflow">if</span>(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(lChild) &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(rChild)) {
            newNode = NULL;
        }

        <span class="comment">// only given a right child, left child is NULL</span>
        <span class="keywordflow">if</span> (<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(lChild) &amp;&amp; !<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(rChild)) {
            <span class="comment">//graft right child on</span>
            newNode-&gt;nodeAdoptRight(rChild);
        }

        <span class="comment">// only given a left child, right child is NULL</span>
        <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(lChild) &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(rChild)) {
            <span class="comment">//graft left child on</span>
            newNode-&gt;nodeAdoptLeft(lChild);
        }

        <span class="comment">// both children exist</span>
        <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(lChild) &amp;&amp; !<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(rChild)) {

            <span class="comment">// otherwise reunite the proposed children on this node</span>
            newNode-&gt;nodeReunite(lChild, rChild);
        }
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp;)
    {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in Reunite()&quot;</span>
            &lt;&lt; std::endl;
        <span class="keywordflow">throw</span>;
    }

    <span class="keywordflow">return</span> newNode;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af397899ec8f3bb396271e6b4fea28dea"></a><!-- doxytag: member="subpavings::Sivia" ref="af397899ec8f3bb396271e6b4fea28dea" args="(PIBT BoolTest, const SPnode *const toInvert, SPnode *const search, const double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a>* <a class="el" href="namespacesubpavings.shtml#af397899ec8f3bb396271e6b4fea28dea">subpavings::Sivia</a> </td>
          <td>(</td>
          <td class="paramtype">PIBT&#160;</td>
          <td class="paramname"><em>BoolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>toInvert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPnode *const&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">97</a> of file <a class="el" href="spalgorithms_8cpp_source.shtml">spalgorithms.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00038">BI_FALSE</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00038">BI_TRUE</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02192">isLeaf()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">Sivia()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        SPnode* newNode = NULL;  <span class="comment">// for return value</span>

        <span class="keywordflow">try</span> {
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> test = <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;

            <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(search)) { <span class="comment">// if search is not null or empty</span>

                <span class="comment">// test the box of the given searchsubpaving</span>
                <span class="comment">// using given test (gives f) and given image to invert</span>
                test = BoolTest(search-&gt;getBox(), toInvert);
            }

            <span class="keywordflow">if</span> (!<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(search) &amp;&amp; test!=<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>) {

                <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// for MaxDiam() below</span>

                <span class="keywordtype">double</span> boxMaxDiam = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(search-&gt;getBox(), maxdiamcomp);

                <span class="comment">// we know that the test was not BI_FALSE,</span>
                <span class="comment">// so it could be BI_TRUE or BI_INDET</span>
                <span class="comment">// if it is BI_INDET and the box maximum diameter</span>
                <span class="comment">// is &gt;= eps then we keep trying to expand</span>
                <span class="keywordflow">if</span> (test==<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a> || boxMaxDiam &lt; eps) {

                    newNode = <span class="keyword">new</span> SPnode(*search);
                }

                <span class="comment">// if test is BI_INDET and the box maximum diameter</span>
                <span class="comment">// is &gt;= eps then we keep trying to expand</span>
                <span class="keywordflow">else</span>  {

                    <span class="comment">// expand search if search is a leaf</span>
                    <span class="keywordflow">if</span> (<a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(search)) <a class="code" href="AIAsubpaving_8cpp.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a>(search,
                                            maxdiamcomp);

                    <span class="comment">// ReUnite is used to get a minimal subpaving</span>
                    <span class="comment">// from merging two subpavings</span>
                    newNode = Reunite&lt;SPnode&gt;(
                                <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(BoolTest, toInvert,
                                search-&gt;getLeftChild(), eps),
                            <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(BoolTest, toInvert,
                            search-&gt;getRightChild(), eps),
                                            search-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>());
                }


            } <span class="comment">// end !isEmpty(search) &amp;&amp; test!=BI_FALSE</span>

            <span class="comment">// if isEmpty(search) or test==BI_FALSE,</span>
            <span class="comment">// newNode will be the initialisation value of NULL</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba)
        {
            <span class="keywordtype">string</span> msg(ba.what());
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in Sivia&quot;</span> &lt;&lt; std::endl;
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
        }
        <span class="keywordflow">catch</span> (SPnodeException&amp; spe) {
            <span class="keywordtype">string</span> msg(spe.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in Sivia: original error &quot;</span>
                                                &lt;&lt; msg &lt;&lt; endl;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordtype">string</span> msg(e.what());
            std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in Sivia: original error &quot;</span> &lt;&lt; msg &lt;&lt; endl;
        }

        <span class="keywordflow">return</span> newNode;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="acd777346441d8790899ec09af3b11d61"></a><!-- doxytag: member="subpavings::spLeaves" ref="acd777346441d8790899ec09af3b11d61" args="(const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacesubpavings.shtml#acd777346441d8790899ec09af3b11d61">subpavings::spLeaves</a> </td>
          <td>(</td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of leaves of a tree (boxes in the subpaving) </p>
<p>Counts leaves recursively. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02236">2236</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02192">isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="multitreemanager_8cpp_source.shtml#l00114">MultiTreeManager::addToOutcomeSpace()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00058">MultiTreeManager::addToOutcomeSpaceAndGraph()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00552">subpavings::AdaptiveHistogramValidation::getRootLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">subpavings::AdaptiveHistogram::getRootLeaves()</a>, <a class="el" href="Coverage_8cpp_source.shtml#l00051">main()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00177">MultiTreeManager::mapPavings()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00068">subpavings::CritLeaves_GTEV::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00071">subpavings::CritLeaves_GTE::operator()()</a>, <a class="el" href="histpenalty_8hpp_source.shtml#l00081">subpavings::PenLeaves::operator()()</a>, <a class="el" href="histevalobjval_8hpp_source.shtml#l00088">subpavings::CritLeaves_LTEV::operator()()</a>, and <a class="el" href="histevalobj_8hpp_source.shtml#l00091">subpavings::CritLeaves_LTE::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> retVal=0;

        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn)) &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn)) retVal = 1; <span class="comment">// leaf</span>

        <span class="comment">// recurse on children</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn)) &amp;&amp; !(<a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn))) {

            retVal += <a class="code" href="namespacesubpavings.shtml#acd777346441d8790899ec09af3b11d61" title="Get the number of leaves of a tree (boxes in the subpaving)">spLeaves</a>(spn-&gt;getLeftChild());
            retVal += <a class="code" href="namespacesubpavings.shtml#acd777346441d8790899ec09af3b11d61" title="Get the number of leaves of a tree (boxes in the subpaving)">spLeaves</a>(spn-&gt;getRightChild());

        }

        <span class="comment">// if spn is empty we will return retVal = 0 by default</span>

        <span class="keywordflow">return</span> retVal;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa737c3b183c306abbef9b3d515f632fb"></a><!-- doxytag: member="subpavings::spTotalNodes" ref="aa737c3b183c306abbef9b3d515f632fb" args="(const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="namespacesubpavings.shtml#aa737c3b183c306abbef9b3d515f632fb">subpavings::spTotalNodes</a> </td>
          <td>(</td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of leaves of a tree (boxes in the subpaving) </p>
<p>Counts leaves recursively. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02257">2257</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01377">subpavings::AdaptiveHistogramVCollator::getTotalNodes()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00269">subpavings::AdaptiveHistogramValidation::insertDataFromContainer()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> retVal=0;
        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn))) retVal = 1; <span class="comment">// leaf</span>
        <span class="comment">// recurse on children</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn))) {
            retVal += <a class="code" href="namespacesubpavings.shtml#aa737c3b183c306abbef9b3d515f632fb" title="Get the number of leaves of a tree (boxes in the subpaving)">spTotalNodes</a>(spn-&gt;getLeftChild());
            retVal += <a class="code" href="namespacesubpavings.shtml#aa737c3b183c306abbef9b3d515f632fb" title="Get the number of leaves of a tree (boxes in the subpaving)">spTotalNodes</a>(spn-&gt;getRightChild());
        }
        <span class="comment">// if spn is empty we will return retVal = 0 by default</span>
        <span class="keywordflow">return</span> retVal;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8bfd50d3105ff4944ae6e42e0138ffb6"></a><!-- doxytag: member="subpavings::spVolume" ref="a8bfd50d3105ff4944ae6e42e0138ffb6" args="(const SPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacesubpavings.shtml#a8bfd50d3105ff4944ae6e42e0138ffb6">subpavings::spVolume</a> </td>
          <td>(</td>
          <td class="paramtype">const SPnode *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the volume of the subpaving represented by spn. </p>
<p>Uses nodeVolume() recursively on the leaf nodes. </p>

<p>Definition at line <a class="el" href="spnode_8cpp_source.shtml#l02214">2214</a> of file <a class="el" href="spnode_8cpp_source.shtml">spnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02206">isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02192">isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="ImageSetDiff_8cpp_source.shtml#l00038">main()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">double</span> retVal =0.0;

        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn)) &amp;&amp; <a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn)) {

            retVal = spn-&gt;nodeVolume();
        }

        <span class="comment">// recurse on children</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="namespacesubpavings.shtml#a72386487753f5334a70250b068f97f15" title="Check if a SubPaving is empty.">isEmpty</a>(spn)) &amp;&amp; !(<a class="code" href="namespacesubpavings.shtml#a6ce5e0d7ef8daa51a49872efc2ef56d8" title="Check if a node is a leaf.">isLeaf</a>(spn))) {

            retVal += <a class="code" href="namespacesubpavings.shtml#a8bfd50d3105ff4944ae6e42e0138ffb6" title="Get the volume of the subpaving represented by spn.">spVolume</a>(spn-&gt;getLeftChild());
            retVal += <a class="code" href="namespacesubpavings.shtml#a8bfd50d3105ff4944ae6e42e0138ffb6" title="Get the volume of the subpaving represented by spn.">spVolume</a>(spn-&gt;getRightChild());
        }

        <span class="comment">// case of isEmpty(spn) retValue = 0 by default</span>

        <span class="keywordflow">return</span> retVal;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a1c85cfc0ad8721fc6b480d66d51a653d"></a><!-- doxytag: member="subpavings::toString" ref="a1c85cfc0ad8721fc6b480d66d51a653d" args="(const subpavings::IntVec vec, bool compact=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="namespacesubpavings.shtml#a1c85cfc0ad8721fc6b480d66d51a653d">subpavings::toString</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e">subpavings::IntVec</a>&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>String representation of an IntVec. </p>
<p>String representation of a VecDbl.</p>
<p>String representation of a RealVec. </p>

<p>Referenced by <a class="el" href="TestGaussianFobj_8cpp_source.shtml#l00040">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ada0daf400b54e571b4f8d83bd32861c5"></a><!-- doxytag: member="subpavings::tryExp" ref="ada0daf400b54e571b4f8d83bd32861c5" args="(real r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="namespacesubpavings.shtml#ada0daf400b54e571b4f8d83bd32861c5">subpavings::tryExp</a> </td>
          <td>(</td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Work arround for c-xsc math library for exponentiation of reals. </p>
<p>The library handling exponentiation of reals cannot deal with large reals. This function tries the exponentiation after conversion to a double and converting the results back to a real if success. </p>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l00471">471</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00423">subpavings::AdaptiveHistogram::logMCMCDeltas()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        real result = 0.0;
        <span class="keywordflow">try</span>
        {
            result = _real(<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(_double(r)));

        }
        <span class="keywordflow">catch</span> (...)
        {
            <span class="comment">// exponentiation error</span>

        }
        <span class="keywordflow">return</span> result;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a19b79319876fc25305936396f24e5a6c"></a><!-- doxytag: member="subpavings::volCompare" ref="a19b79319876fc25305936396f24e5a6c" args="(const ivector &amp;a, const ivector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacesubpavings.shtml#a19b79319876fc25305936396f24e5a6c">subpavings::volCompare</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function for comparing ivectors based on volume. </p>
<p>Used in sorting a list of ivectors ordered by volume.</p>
<p>Uses <a class="el" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume()</a> as defined in toolz. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the Volume of a is strictly less than Volume of b. </dd></dl>

<p>Definition at line <a class="el" href="sptools_8cpp_source.shtml#l00450">450</a> of file <a class="el" href="sptools_8cpp_source.shtml">sptools.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l02032">subpavings::SPnode::makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">subpavings::SPnode::makeTreeFromVoxels()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00184">Regularize()</a>, and <a class="el" href="sptemplates_8hpp_source.shtml#l00309">RegularizeNonMinimal()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">bool</span> returnValue = 0;

        <span class="comment">// Make sure vectors have same number of elements</span>
        <span class="comment">// and at least one element each</span>
        <span class="keywordflow">if</span>( (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(a)-<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(a)) == (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(b)-<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(b)) &amp;&amp; (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(a)-<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(a))&gt;=0 ) {
            <span class="comment">// compare the two volumes</span>
            returnValue = ((<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(a)&lt;<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(b)));

        }
        <span class="keywordflow">else</span> {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error in volCompare : comparing &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;ivectors of different dimensions&quot;</span>
                &lt;&lt; std::endl;
        }

        <span class="keywordflow">return</span> returnValue;
    }
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:30 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
