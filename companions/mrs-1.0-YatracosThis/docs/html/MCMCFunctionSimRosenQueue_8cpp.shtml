<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: MCMCFunctionSimRosenQueue.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('MCMCFunctionSimRosenQueue_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MCMCFunctionSimRosenQueue.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Testing StatsSubPavings (aka SPSnodes) with MCMC new style (May 2012) and Rosenbrock data generated from a function estimate.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="histall_8hpp_source.shtml">histall.hpp</a>&quot;</code><br/>
<code>#include &quot;intervalmappedspnode_measurers.hpp&quot;</code><br/>
<code>#include &quot;functionestimator_interval.hpp&quot;</code><br/>
<code>#include &quot;<a class="el" href="piecewise__constant__function_8hpp_source.shtml">piecewise_constant_function.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="RosenDensityFobj_8hpp_source.shtml">RosenDensityFobj.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="SmallClasses_8hpp_source.shtml">SmallClasses.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Fobj_8hpp_source.shtml">Fobj.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="FRosenbrock_8hpp_source.shtml">FRosenbrock.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="MRSampler_8hpp_source.shtml">MRSampler.hpp</a>&quot;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
</div>
<p><a href="MCMCFunctionSimRosenQueue_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MCMCFunctionSimRosenQueue_8cpp.shtml#a0c0402be9ebd7abad750822814d38f99">ProduceMRSamples</a> (<a class="el" href="classFobj.shtml">Fobj</a> &amp;<a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, int n_boxes, int n_samples, double Alb, unsigned seed, bool use_f_scale, <a class="el" href="classRSSample.shtml">RSSample</a> &amp;rs_sample)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MCMCFunctionSimRosenQueue_8cpp.shtml#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Testing StatsSubPavings (aka SPSnodes) with MCMC new style (May 2012) and Rosenbrock data generated from a function estimate. </p>

<p>Definition in file <a class="el" href="MCMCFunctionSimRosenQueue_8cpp_source.shtml">MCMCFunctionSimRosenQueue.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="MCMCFunctionSimRosenQueue.cpp::main" ref="a0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ImageSetDiff_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MCMCFunctionSimRosenQueue_8cpp_source.shtml#l00104">104</a> of file <a class="el" href="MCMCFunctionSimRosenQueue_8cpp_source.shtml">MCMCFunctionSimRosenQueue.cpp</a>.</p>

<p>References <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a2499c322fa30a4f07d8ad7360a8d7d95">subpavings::PiecewiseConstantFunction::getIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01366">subpavings::AdaptiveHistogram::getRootBox()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01247">subpavings::AdaptiveHistogram::getRootLeaves()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375">subpavings::PiecewiseConstantFunction::getTotalIntegral()</a>, <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00018">Height</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01023">subpavings::AdaptiveHistogram::insertFromRSSample()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">subpavings::AdaptiveHistogram::insertFromRVec()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">subpavings::PiecewiseConstantFunction::normalise()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">subpavings::PiecewiseConstantFunction::outputToTxtTabs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">subpavings::AdaptiveHistogram::outputToTxtTabs()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01150">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01781">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="MooreImpSam_2CFN3_2CFN3_8cpp_source.shtml#l00058">ProduceMRSamples()</a>, <a class="el" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854">subpavings::PiecewiseConstantFunction::simulateData()</a>, and <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00017">Tinverse</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// sort out user-defined parameters------------------//</span>
  <span class="keywordflow">if</span> ( argc &lt; 20 ) {
    cerr &lt;&lt; <span class="stringliteral">&quot;Syntax: &quot;</span> &lt;&lt; argv[0] &lt;&lt; 
    <span class="stringliteral">&quot;d maxLeavesEst n states symmetryIndicator seed burnin thinout [log_full]&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Syntax: &quot;</span> + std::string(argv[0]) + <span class="stringliteral">&quot;d n states, symmetryIndicator&quot;</span>);
  }
  
  <span class="keywordtype">int</span> d = atoi(argv[1]);  <span class="comment">// dimensions</span>
  <span class="keywordtype">size_t</span> maxLeavesEst = atoi(argv[2]);  <span class="comment">// number of leaves in estimator</span>
  <span class="keyword">const</span> <span class="keywordtype">int</span> n = atoi(argv[3]);  <span class="comment">// number of points to generate</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loops = atoi(argv[4]); <span class="comment">// number of states to loop through</span>
  <span class="keywordtype">int</span> symmetryIndicator = atoi(argv[5]); <span class="comment">// 1 for symmetric, 0 otherwise</span>
  <span class="keywordtype">int</span> dataSeed = atoi(argv[6]); <span class="comment">// seed for data generation</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> burnin = atoi(argv[7]); 
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> thinout = atoi(argv[8]); 

  <span class="keywordtype">size_t</span> hist1Crit = atoi(argv[9]);
  <span class="keywordtype">size_t</span> hist2Crit = atoi(argv[10]);
  <span class="keywordtype">size_t</span> hist3Crit = atoi(argv[11]);
  
  <span class="keywordtype">size_t</span> hist1CritLeaf = atoi(argv[12]);
  <span class="keywordtype">size_t</span> hist2CritLeaf = atoi(argv[13]);
  
  <span class="keywordtype">size_t</span> NumStatesChosen = atoi(argv[14]);
  
  <span class="keywordtype">bool</span> computeIAE = atoi(argv[15]);
  
  <span class="keywordtype">int</span> n_boxes = atoi(argv[16]); <span class="comment">// for mrs</span>
  
  <span class="keywordtype">size_t</span> minPoints = 1;
  <span class="keywordtype">size_t</span> minPQPoints1 = 1;
  <span class="keywordtype">size_t</span> minPQPoints2 = 1;
  <span class="keywordtype">size_t</span> minPQPoints3 = 1;

  <span class="keywordtype">bool</span> shiftCatalan = 0;

  <span class="keywordtype">bool</span> minVolControl = atoi(argv[17]);
  <span class="keywordtype">int</span> loggingType = atoi(argv[18]); <span class="comment">//1 - NOLOG; 2 - LOGSTATETRACE</span>
  <span class="keywordtype">bool</span> IAEPQ = atoi(argv[19]);
  
  <span class="comment">/* for logging to output the logposterior for the sample average and current state */</span>
  <span class="comment">/* use LOGSTATETRACE only for current state */</span>
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logging;
  
  <span class="keywordflow">if</span> ( loggingType == 1) { logging = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( loggingType == 2 ) { logging = LOGSTATETRACE; }
  
  cout &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; : process id is &quot;</span> &lt;&lt; getpid() &lt;&lt; std::endl;

  <span class="comment">// set up proposal distribution object</span>
  <a class="code" href="classsubpavings_1_1UniformProposal.shtml">UniformProposal</a> proposal;
  <span class="comment">// set up prior distribution object</span>
  <a class="code" href="classsubpavings_1_1LogCatalanPrior.shtml" title="A class for a log prior based on a Catalan number prior.">LogCatalanPrior</a> logPrior;
    
  interval pavingIntervalSym(-6,6);
  interval pavingIntervalNonSym(-6.5,7);

  interval pavingInterval = pavingIntervalSym; <span class="comment">// if we are doing symmetric case</span>
  <span class="comment">// but if we&#39;ve asked for non-symmetric, change this</span>
  <span class="keywordflow">if</span> (!symmetryIndicator) pavingInterval = pavingIntervalNonSym;

  <span class="comment">// for output purposes</span>
  <span class="comment">// string formatting</span>
  ofstream oss;         <span class="comment">// ofstream object</span>
   oss &lt;&lt; scientific;  <span class="comment">// set formatting for input to oss</span>
   oss.precision(10);

  <span class="comment">//=======get the root box from the actual data==============//</span>
  <span class="comment">// set up a random number generator and use mt19937 for generator</span>
  gsl_rng * r = gsl_rng_alloc (gsl_rng_mt19937); <span class="comment">// set up with default seed</span>
  <span class="comment">//long unsigned int seed = 1234;</span>
  gsl_rng_set (r, dataSeed); <span class="comment">// change the seed</span>
  cout &lt;&lt; <span class="stringliteral">&quot;Data seed is &quot;</span> &lt;&lt; dataSeed &lt;&lt; endl;
  
  ios::sync_with_stdio ();  <span class="comment">// call this function so iostream works with stdio</span>
  cout &lt;&lt; SetPrecision (20, 15);  <span class="comment">// Number of mantissa digits in I/O</span>
  
  <span class="comment">// set default values</span>
  <span class="keywordtype">int</span> n_dimensions = d; 
  <span class="keywordtype">int</span> n_samples = 1000000;
  <span class="keywordtype">double</span> Alb = 1.0;<span class="comment">// partition until lower bound on Acceptance Prob. is &gt; Alb</span>
  <span class="keywordtype">unsigned</span> theSeed = dataSeed;
  
  <span class="comment">//Parameters specific to the Rosenbrock target</span>
  real <a class="code" href="RosenFobj2D_8cpp.shtml#aec5c4d9798cfa73539577e4a2206ab1a">Tinverse</a> = 1.0;
  real <a class="code" href="RosenFobj2D_8cpp.shtml#ab0eb64c1a8d085bcf238d947f3fa839f">Height</a> = 100.0;
  real RosenDomainLimit = 10.0;
  
  cout &lt;&lt; <span class="stringliteral">&quot;# n_dimensions: &quot;</span> &lt;&lt; n_dimensions &lt;&lt; <span class="stringliteral">&quot;  n_boxes: &quot;</span> &lt;&lt; n_boxes 
       &lt;&lt; <span class="stringliteral">&quot;  n_samples: &quot;</span> &lt;&lt; n_samples &lt;&lt; <span class="stringliteral">&quot;  rng_seed = &quot;</span> &lt;&lt; theSeed  
       &lt;&lt; endl; <span class="comment">//getchar();</span>
  
  <span class="keywordtype">bool</span> UseLogPi = <span class="keyword">false</span>; <span class="comment">// log scale won&#39;t work naively</span>
  <span class="keywordtype">bool</span> use_f_scale = <span class="keyword">false</span>;
  
  <span class="comment">// make the function object</span>
  <a class="code" href="classFRosenbrock.shtml" title="n-dimensional Rosenbrock density as a function object class">FRosenbrock</a> FRosen (n_dimensions, 
                      Tinverse, Height, RosenDomainLimit, UseLogPi);
  
  <span class="comment">// produce the samples</span>
  <a class="code" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a>* tempDataPtr = <span class="keyword">new</span> <a class="code" href="classRSSample.shtml" title="A class for the status of a Rejection Sampler.">RSSample</a>; 
  <a class="code" href="MooreImpSam_2CFN3_2CFN3_8cpp.shtml#a631ece91d072eb67cffd058e11c49468">ProduceMRSamples</a>(FRosen, n_boxes, n_samples, 
                   Alb, theSeed, use_f_scale, *tempDataPtr);


  <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>* tempHist = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a>; 
  tempHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a6f049bec17097067ae9e2a7c9f42bd60">insertFromRSSample</a>(*tempDataPtr, 0, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>);
  ivector pavingBoxEst = tempHist-&gt;<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a936a3426494278163afada104df26ecc" title="Get the box of the subpaving managed by this.">getRootBox</a>();
  <span class="keyword">delete</span> tempHist;
  <span class="keyword">delete</span> tempDataPtr;
  <span class="comment">//=========end of getting a root box from the actual data=============</span>
  
  <span class="comment">//============== make estimate ============//</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nMake the function estimator to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
  
  <span class="comment">// specify function object (from /examples/MappedTargets</span>
  <a class="code" href="classRosenDensityFobj.shtml">RosenDensityFobj</a> fobj;
  
  <span class="comment">/* function estimate is going to use same box as the histograms */</span>
  <span class="comment">//ivector pavingBoxEst(d);</span>
  <span class="comment">//for(int k=1; k &lt;= d; k++) pavingBoxEst[k] = pavingInterval;</span>
  
  <span class="comment">// Use fobj and pavingBox to get an estimator</span>
  FunctionEstimatorInterval estimator(pavingBoxEst, fobj);
  
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logEst = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; <span class="comment">// logging for making estimator</span>
  
<span class="preprocessor">  #if(1)</span>
<span class="preprocessor"></span>  <span class="keywordtype">size_t</span> maxLeavesEstDown = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(1.2*maxLeavesEst); <span class="comment">// go down to 1.2 x max</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span><span class="preprocessor">  #if(0)</span>
<span class="preprocessor"></span>    <span class="keywordtype">size_t</span> maxLeavesEstDown = maxLeavesEst;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;pq down to max leaves &quot;</span> &lt;&lt; maxLeavesEstDown &lt;&lt; endl;
  
  clock_t startEst = clock();
  
  <span class="comment">// priority split driven by splitting leaf with max reimann diff</span>
  ReimannDiffMeasurer measurer;
  estimator.prioritySplit(measurer, maxLeavesEstDown, logEst);
      
  <span class="comment">// stop recording time here</span>
  clock_t endEst = clock();
  cout &lt;&lt; <span class="stringliteral">&quot;Number of leaves in estimate: &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;  
  cout &lt;&lt; <span class="stringliteral">&quot;After split, getTotalAreaOfIntervalBand() = &quot;</span>
    &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
  <span class="keywordtype">double</span> timingEst1 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for pq split in estimate: &quot;</span> &lt;&lt; timingEst1 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
  startEst = clock();
  
<span class="preprocessor">  #if(1) </span>
<span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;Hull propagation&quot;</span> &lt;&lt; endl;
    estimator.hullPropagation();
    
    cout &lt;&lt; <span class="stringliteral">&quot;Priority merge to &quot;</span> &lt;&lt; maxLeavesEst &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;
<span class="preprocessor">    #if(0)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by minimising increase the reimann diff</span>
    estimator.priorityMergeOnLoss(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span><span class="preprocessor">    #if(1)</span>
<span class="preprocessor"></span>    <span class="comment">// priority merge driven by merging cherry with minimum reimann diff</span>
    estimator.priorityMerge(maxLeavesEst, logEst);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>          
    <span class="comment">// stop recording time here</span>
    endEst = clock(); 
    <span class="keywordtype">double</span> timingEst2 = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endEst - startEst)) / CLOCKS_PER_SEC);
    cout &lt;&lt; <span class="stringliteral">&quot;Computing time for hull propagate and merge up in estimate: &quot;</span> &lt;&lt; timingEst2 &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
    
    cout &lt;&lt; <span class="stringliteral">&quot;After propagation and priority merge, getTotalAreaOfIntervalBand() = &quot;</span> 
          &lt;&lt; estimator.getTotalAreaOfIntervalBand() &lt;&lt; endl;
    cout &lt;&lt; <span class="stringliteral">&quot;number of leaves is = &quot;</span> &lt;&lt; estimator.getRootLeaves() &lt;&lt; endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  
  cout &lt;&lt; <span class="stringliteral">&quot;Making estimate and normalising&quot;</span> &lt;&lt; endl;
  <span class="comment">// Make PiecewiseConstantFunction estimate from estimator</span>
  <a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> estimate = estimator.makePiecewiseConstantFunction();
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#aae1c0cd836577f309def9d7a8d9a534a">normalise</a>();
  
  cout &lt;&lt; <span class="stringliteral">&quot;estimate has integral &quot;</span> &lt;&lt; estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ade6c94a0c5b7ffc5ec2ca5ab5e9c6375" title="Get the total integral of the piecewise constant function represented by this.">getTotalIntegral</a>() &lt;&lt; endl;
  
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">outputToTxtTabs</a>(<span class="stringliteral">&quot;MappedFunction.txt&quot;</span>);
  
  <span class="comment">//===========end of estimating function using PCF=========================//</span>

  <span class="comment">//===========generate data==============================================//</span>
  <span class="comment">// Use PiecewiseConstantFunction to generate data, supplying our own rng</span>
  cout &lt;&lt; <span class="stringliteral">&quot;\nGenerating data for simulation&quot;</span> &lt;&lt; endl;

  <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>* theDataPtr = <span class="keyword">new</span> <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a>;   <span class="comment">// a container for all the points generated</span>

  clock_t startData = clock();

  <span class="comment">// Gaussian data</span>
  estimate.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a3fd630a95c48dda0a828bb2229c9d854" title="Simulator taking a random number generator argument.">simulateData</a>(*theDataPtr, n, r);

  <span class="comment">// stop recording time here</span>
  clock_t endData = clock();  
  <span class="keywordtype">double</span> timingData = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(endData - startData)) / CLOCKS_PER_SEC);
  cout &lt;&lt; <span class="stringliteral">&quot;Computing time for simulating data: &quot;</span> &lt;&lt; timingData &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;

  cout &lt;&lt; (*theDataPtr).size() &lt;&lt; <span class="stringliteral">&quot; points generated&quot;</span> &lt;&lt; endl;
  
  <span class="keywordflow">try</span> {
    gsl_rng_free (r);
    r = NULL;
  }
  <span class="keywordflow">catch</span>(...) {}<span class="comment">// catch and swallow</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;\nStart example: n = &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; and d = &quot;</span> &lt;&lt; d &lt;&lt; endl;
  <span class="comment">//cout &lt;&lt; &quot;Paving interval is &quot; &lt;&lt; pavingInterval &lt;&lt; endl;</span>

  <span class="comment">//===========end of generating data=================================//</span>

  <span class="comment">//==============MCMC with different starting states========================//</span>
  <span class="keywordtype">int</span> numFunc = 1;
  
  ostringstream stmSeed;
  stmSeed &lt;&lt; dataSeed;
  
  <span class="comment">// parameters needed to start the PQ</span>
  <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089" title="Define a type LOGGING_LEVEL.">LOGGING_LEVEL</a> logPQ = <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>; <span class="comment">// logging level  </span>
  <a class="code" href="classsubpavings_1_1CompVol.shtml" title="Class comparing on volume of box of node.">CompVol</a> comp2; 
  CompVolMassMinus comp1;
  <a class="code" href="classsubpavings_1_1CompCount.shtml" title="Class comparing on count of data points associated with a node.">CompCount</a> compCount;
  vector&lt;real&gt; IAEContainer; <span class="comment">//for MCMC </span>
  vector&lt;double&gt; Times; <span class="comment">// for MCMC times</span>

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> func = 0; func &lt; numFunc; func++) {
    cout &lt;&lt; <span class="stringliteral">&quot;\n========Function : &quot;</span> &lt;&lt; func &lt;&lt; <span class="stringliteral">&quot;========&quot;</span> &lt;&lt; endl; 
    ostringstream stm;
    stm &lt;&lt; func; <span class="comment">// for output purposes</span>
    vector&lt;size_t&gt; LeafContainer; <span class="comment">// to store the number of leaf nodes from which the optimal posterior support is at</span>
    
    <span class="keywordtype">double</span> minVolB = 0.0;
    
    <span class="comment">/*</span>
<span class="comment">    // make the paving box</span>
<span class="comment">    ivector pavingBox(d);</span>
<span class="comment">    for(int k=1; k &lt;= d; k++) pavingBox[k] = pavingInterval;</span>
<span class="comment">    */</span>
    
    <span class="comment">// make an Adaptive Histogram with the given pavingBox and, by default,</span>
    <span class="comment">// holdAllStats = false so that the underlying rootPaving managed by the</span>
    <span class="comment">// myHistFirst will not maintain all available stats, only counts</span>
    <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myHistFirst(pavingBoxEst); <span class="comment">// still let the data decide the box</span>

    <span class="comment">// put in the data in a &#39;pulse&#39; with no splitting, ie into root box</span>
    <span class="keywordtype">bool</span> successfulInsertion = myHistFirst.insertFromRVec(*theDataPtr);

    <span class="keywordflow">if</span> (successfulInsertion) {

      vector&lt;real&gt; ChosenStateMaxPosterior;
      vector&lt;AdaptiveHistogram&gt; ChosenStateSubset;

      <span class="comment">//===== start the SEB-PQ from the root node as a sanity check====//</span>
      {
      cout &lt;&lt; <span class="stringliteral">&quot;Starting the SEB-PQ from the root node:&quot;</span> &lt;&lt; endl;
      <span class="comment">// initialize containers</span>
      vector&lt;real&gt; PosteriorChosen;
      vector&lt;double&gt; EmptyBoxChosen;
      vector&lt;real&gt; PosteriorSupportChosen;
      vector&lt;real&gt; IAEContainerChosen;

      <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHist(pavingBoxEst);
      myChosenHist.insertFromRVec(*theDataPtr);

      <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critStop(hist3Crit);
      cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ to &quot;</span>  &lt;&lt; (hist3Crit) &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
      <span class="keywordtype">int</span> Txt = 9000 + func*100 + NumStatesChosen;
      <span class="keywordflow">if</span> (func == 0) {
        myChosenHist.prioritySplitMCMC(compCount, critStop, 
        logPQ, minPQPoints1, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, 
        PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, IAEPQ);
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
        myChosenHist.prioritySplitMCMC(compCount, critStop, 
        logPQ, minPQPoints2, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, 
        PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, IAEPQ);
      }

      <span class="keywordflow">if</span> (minVolControl == <span class="keyword">true</span>) { 
        minVolB = myChosenHist.getBoxMinVol(); 
        cout &lt;&lt; <span class="stringliteral">&quot;Minimum volume: &quot;</span> &lt;&lt; minVolB &lt;&lt; endl;
      }
      <span class="keywordflow">else</span> { minVolB = 0.0; }
      
      ostringstream stm1;
      stm1 &lt;&lt; NumStatesChosen;
      
      
      <span class="comment">// optional</span>
      <span class="comment">// output log-posterior</span>
      <span class="keywordtype">string</span> PostFileName = <span class="stringliteral">&quot;PosteriorChosen&quot;</span>;
      PostFileName += stm.str(); <span class="comment">//for func</span>
      PostFileName += stm1.str(); 
      PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      oss.open(PostFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
        oss &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;
      }
      oss &lt;&lt; flush;
      oss.close();
    
      <span class="comment">// output support log-posterior </span>
      PostFileName = <span class="stringliteral">&quot;PosteriorSupportChosen&quot;</span>;
      PostFileName += stm.str();
      PostFileName += stm1.str();
      PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      oss.open(PostFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorSupportChosen.size(); i++) {
        oss &lt;&lt; PosteriorSupportChosen[i] &lt;&lt; endl;
      }
      oss &lt;&lt; flush;
      oss.close();
  <span class="comment">/*</span>
<span class="comment">      // output the cumulative ratio of empty boxes</span>
<span class="comment">      EmptyFileName = &quot;EmptyChosen&quot;;</span>
<span class="comment">      EmptyFileName += stm.str();</span>
<span class="comment">      EmptyFileName += stm1.str();</span>
<span class="comment">      EmptyFileName += &quot;.txt&quot;;</span>
<span class="comment">      oss.open(EmptyFileName.c_str());</span>
<span class="comment">      for (size_t i = 0; i &lt; EmptyBoxChosen.size(); i++) {</span>
<span class="comment">        oss &lt;&lt; EmptyBoxChosen[i] &lt;&lt; endl;</span>
<span class="comment">      }</span>
<span class="comment">      oss &lt;&lt; flush;</span>
<span class="comment">      oss.close();</span>
<span class="comment">      */</span>

      <span class="comment">//output IAE from second stage</span>
      <span class="keywordtype">string</span> IAEFileName = <span class="stringliteral">&quot;IAEPQChosen&quot;</span>;
      IAEFileName += stmSeed.str();
      IAEFileName += stm1.str();
      IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
      oss.open(IAEFileName.c_str());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; IAEContainerChosen.size(); i++) {
        oss &lt;&lt; IAEContainerChosen[i] &lt;&lt; endl;
      }
      oss &lt;&lt; flush;
      oss.close();

      <span class="comment">// get the max position for this sub-set</span>
      <span class="keywordtype">size_t</span> maxPosition = 0;
      real maxPosterior = -1*(numeric_limits&lt;double&gt;::infinity());
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> (PosteriorChosen[i] &gt; maxPosterior) {
          maxPosterior = PosteriorChosen[i];
          maxPosition = i;
        }
      }
      cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ from root node has log-posterior highest at index &quot;</span> &lt;&lt; maxPosition;
      ChosenStateMaxPosterior.push_back(PosteriorChosen[maxPosition]);

      <span class="comment">// now get the posterior-optimal histogram for this subset using PQ-SEB</span>
      <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHistSubset(pavingBoxEst);
      myChosenHistSubset.insertFromRVec(*theDataPtr);
      <span class="comment">// be careful here</span>
      <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critValMaxSubset(maxPosition+1);
      
      <span class="keywordflow">if</span> (func == 0) {
        myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, 
        logPQ, minPQPoints1);
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
        myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, 
        logPQ, minPQPoints2);
      }
      cout &lt;&lt; <span class="stringliteral">&quot; and has &quot;</span> &lt;&lt; myChosenHistSubset.getRootLeaves() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
      <span class="comment">//keep this histogram in a container</span>
      ChosenStateSubset.push_back(myChosenHistSubset);
      cout &lt;&lt; <span class="stringliteral">&quot;-----------------------------&quot;</span> &lt;&lt; endl;
      }
      <span class="comment">//-------------end of getting from the root node------------------//</span>

      <span class="comment">//===========A carved-in PQ======================//</span>
      <span class="keywordtype">size_t</span> histCrit;
      <span class="keywordflow">if</span> (func == 0) { histCrit = hist1Crit; }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func==1) { histCrit = hist2Crit; }
      <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critStop(histCrit);
      cout &lt;&lt; <span class="stringliteral">&quot;Carving-in PQ to &quot;</span>  &lt;&lt; histCrit &lt;&lt; <span class="stringliteral">&quot; leaves&quot;</span> &lt;&lt; endl;

      <span class="comment">//containers to store needed outputs</span>
      vector&lt;real&gt; Posterior;
      vector&lt;real&gt; PosteriorSupport;
      vector&lt;double&gt; EmptyBox;
      <span class="keywordtype">int</span> Txt = func;
      vector&lt;real&gt; IAEPQContainer;

      <span class="keywordtype">bool</span> successfulHist = <span class="keyword">false</span>;
      <span class="comment">// start the carving PQ here</span>
      <span class="keywordflow">if</span> (func == 0) {
        successfulHist = myHistFirst.prioritySplitMCMC(comp1, critStop, 
        logPQ, minPQPoints1, minVolB, Posterior, logPrior, Txt, EmptyBox, 
        PosteriorSupport, IAEPQContainer, estimate, shiftCatalan, IAEPQ);
      }
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
        successfulHist = myHistFirst.prioritySplitMCMC(comp2, critStop, 
        logPQ, minPQPoints2, minVolB, Posterior, logPrior, Txt, EmptyBox,
        PosteriorSupport, IAEPQContainer, estimate, shiftCatalan, IAEPQ);
      }

      <span class="keywordflow">if</span> (successfulHist) {
        
        <span class="comment">// output log-posterior</span>
        <span class="keywordtype">string</span> PostFileName;
        PostFileName = <span class="stringliteral">&quot;Posterior&quot;</span>;
        PostFileName += stm.str();
        PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(PostFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; Posterior.size(); i++) {
          oss &lt;&lt; Posterior[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        
        
        <span class="comment">// output support log-posterior </span>
        PostFileName = <span class="stringliteral">&quot;PosteriorSupport&quot;</span>;
        PostFileName += stm.str();
        PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(PostFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorSupport.size(); i++) {
          oss &lt;&lt; PosteriorSupport[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        
        <span class="comment">/*</span>
<span class="comment">        // output the cumulative ratio of empty boxes</span>
<span class="comment">        string EmptyFileName;</span>
<span class="comment">        EmptyFileName = &quot;Empty&quot;;</span>
<span class="comment">        EmptyFileName += stm.str();</span>
<span class="comment">        EmptyFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(EmptyFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; EmptyBox.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; EmptyBox[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        */</span>
        
        <span class="comment">//output IAE from second stage</span>
        <span class="keywordtype">string</span> IAEFileName = <span class="stringliteral">&quot;IAEPQZoomIn&quot;</span>;
        IAEFileName += stm.str();
        IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(IAEFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; IAEPQContainer.size(); i++) {
          oss &lt;&lt; IAEPQContainer[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        <span class="comment">//=============end of carving in====================//</span>
        
        <span class="comment">//==== get K number of states with a local highest posterior ====//</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Choosing &quot;</span> &lt;&lt; NumStatesChosen &lt;&lt; <span class="stringliteral">&quot; states&quot;</span> &lt;&lt; endl;
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; NumStatesChosen; j++) {
          ostringstream stmj;
          stmj &lt;&lt; j;
          <span class="keywordtype">int</span> step = int(1.0*PosteriorSupport.size()/(1.0*NumStatesChosen));
          <span class="comment">//find where the posterior/log-posterior/emptyVol is the highest</span>
          <span class="keywordtype">size_t</span> maxPosition = 0;
          real maxPosterior = -1*(numeric_limits&lt;double&gt;::infinity());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; step; i++) {
            <span class="keywordtype">size_t</span> thisPosition = j*step + i;
            <span class="comment">//cout &lt;&lt; thisPosition &lt;&lt; &quot;\t&quot; &lt;&lt; PosteriorSupport[thisPosition] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> (PosteriorSupport[thisPosition] &gt; maxPosterior) {
              maxPosterior = PosteriorSupport[thisPosition];
              maxPosition = thisPosition;
            }
          }
          cout &lt;&lt; <span class="stringliteral">&quot;----------------------------------&quot;</span> &lt;&lt; endl;
          <span class="comment">//cout &lt;&lt; j &lt;&lt; &quot;-th subset: &quot;&lt;&lt; endl;</span>
          cout &lt;&lt; <span class="stringliteral">&quot;log posterior highest at split &quot;</span> &lt;&lt; maxPosition;
          <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critValMax(maxPosition+1);
          LeafContainer.push_back(maxPosition+1);

          <span class="comment">// now get the posterior-optimal histogram</span>
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHist(pavingBoxEst);
          myChosenHist.insertFromRVec(*theDataPtr);
          
          <span class="comment">// get the corresponding histogram</span>
          <span class="keywordflow">if</span> (func == 0) {
            myChosenHist.prioritySplit(comp1, critValMax, logPQ, minPQPoints1);
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
            myChosenHist.prioritySplit(comp2, critValMax, logPQ, minPQPoints2);
          }
          <span class="keywordtype">size_t</span> chosenHistLeaves = myChosenHist.getRootLeaves(); 
          cout &lt;&lt; <span class="stringliteral">&quot; and has &quot;</span> &lt;&lt; chosenHistLeaves &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;

          <span class="comment">//========SEB-PQ from chosen histograms======================//</span>
          <span class="comment">// initialize containers</span>
          vector&lt;real&gt; PosteriorChosen;
          vector&lt;double&gt; EmptyBoxChosen;
          vector&lt;real&gt; PosteriorSupportChosen;
          vector&lt;real&gt; IAEContainerChosen;

          <span class="keywordflow">if</span> (func == 0) { histCrit = hist1CritLeaf; }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func==1) { histCrit = hist2CritLeaf; }
          <a class="code" href="classsubpavings_1_1CritLargestCount__LTE.shtml" title="Class for testing the count of the node with the largest count in histogram&#39;s subpaving.">CritLargestCount_LTE</a> critLeaf(histCrit);
          cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ to at most &quot;</span>  &lt;&lt; (histCrit) &lt;&lt; <span class="stringliteral">&quot; points in each node&quot;</span> &lt;&lt; endl;
          Txt = 900 + func*10 + j;

          <span class="keywordflow">if</span> (func == 0) {
            successfulHist = myChosenHist.prioritySplitMCMC(compCount, critLeaf, 
            logPQ, minPQPoints1, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, 
            PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, IAEPQ);
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
            successfulHist = myChosenHist.prioritySplitMCMC(compCount, critLeaf, 
            logPQ, minPQPoints2, PosteriorChosen, logPrior, Txt, EmptyBoxChosen, 
            PosteriorSupportChosen, IAEContainerChosen, estimate, shiftCatalan, IAEPQ);
          }

          <span class="comment">// optional</span>
          <span class="comment">// output log-posterior</span>
          PostFileName = <span class="stringliteral">&quot;PosteriorChosen&quot;</span>;
          PostFileName += stm.str(); <span class="comment">//for func</span>
          PostFileName += stmj.str(); <span class="comment">//for j</span>
          PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
          oss.open(PostFileName.c_str());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
            oss &lt;&lt; PosteriorChosen[i] &lt;&lt; endl;
          }
          oss &lt;&lt; flush;
          oss.close();
          
          
          <span class="comment">// output support log-posterior </span>
          PostFileName = <span class="stringliteral">&quot;PosteriorSupportChosen&quot;</span>;
          PostFileName += stm.str();
          PostFileName += stmj.str();
          PostFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
          oss.open(PostFileName.c_str());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorSupportChosen.size(); i++) {
            oss &lt;&lt; PosteriorSupportChosen[i] &lt;&lt; endl;
          }
          oss &lt;&lt; flush;
          oss.close();
  <span class="comment">/*</span>
<span class="comment">          // output the cumulative ratio of empty boxes</span>
<span class="comment">          EmptyFileName = &quot;EmptyChosen&quot;;</span>
<span class="comment">          EmptyFileName += stm.str();</span>
<span class="comment">          EmptyFileName += stmj.str();</span>
<span class="comment">          EmptyFileName += &quot;.txt&quot;;</span>
<span class="comment">          oss.open(EmptyFileName.c_str());</span>
<span class="comment">          for (size_t i = 0; i &lt; EmptyBoxChosen.size(); i++) {</span>
<span class="comment">            oss &lt;&lt; EmptyBoxChosen[i] &lt;&lt; endl;</span>
<span class="comment">          }</span>
<span class="comment">          oss &lt;&lt; flush;</span>
<span class="comment">          oss.close();</span>
<span class="comment">          */</span>
          
          <span class="comment">//output IAE from second stage</span>
          <span class="keywordtype">string</span> IAEFileName = <span class="stringliteral">&quot;IAEPQChosen&quot;</span>;
          IAEFileName += stm.str();
          IAEFileName += stmj.str();
          IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
          oss.open(IAEFileName.c_str());
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; IAEContainerChosen.size(); i++) {
            oss &lt;&lt; IAEContainerChosen[i] &lt;&lt; endl;
          }
          oss &lt;&lt; flush;
          oss.close();
          
          <span class="comment">// get the max position for this sub-set</span>
          maxPosition = 0;
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; PosteriorChosen.size(); i++) {
            <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; PosteriorChosen[i] &lt;&lt; endl; </span>
            <span class="keywordflow">if</span> (PosteriorChosen[i] &gt; maxPosterior) {
              maxPosterior = PosteriorChosen[i];
              maxPosition = i;
            }
          }
          cout &lt;&lt; <span class="stringliteral">&quot;SEB-PQ using carved support has log-posterior highest at index &quot;</span> &lt;&lt; maxPosition;
          ChosenStateMaxPosterior.push_back(PosteriorChosen[maxPosition]);
          
          <span class="comment">// now get the posterior-optimal histogram for this subset using PQ-SEB</span>
          <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myChosenHistSubset(pavingBoxEst);
          myChosenHistSubset.insertFromRVec(*theDataPtr);
          <span class="comment">// be careful here</span>
          <a class="code" href="classsubpavings_1_1CritLeaves__GTE.shtml" title="Class for testing the number of bins of a histogram.">CritLeaves_GTE</a> critValMaxSubset(chosenHistLeaves+maxPosition);
          
          <span class="keywordflow">if</span> (func == 0) {
            myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, 
            logPQ, minPQPoints1);
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (func == 1) {
            myChosenHistSubset.prioritySplit(compCount, critValMaxSubset, 
            logPQ, minPQPoints2);
          }
          cout &lt;&lt; <span class="stringliteral">&quot; and has &quot;</span> &lt;&lt; myChosenHistSubset.getRootLeaves() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span> &lt;&lt; endl;
          <span class="comment">//keep this histogram in a container</span>
          ChosenStateSubset.push_back(myChosenHistSubset);
        } <span class="comment">// end of going through NumStatesChosen</span>
        cout &lt;&lt; <span class="stringliteral">&quot;-----------------------------------------------&quot;</span> &lt;&lt; endl;
        <span class="comment">//========end of selecting K sub-sets===========================//</span>

        <span class="comment">//=======find the maximum over the maximum======================//</span>
        cout &lt;&lt; <span class="stringliteral">&quot;-----------------------------&quot;</span> &lt;&lt; endl;
        <span class="comment">// find which subset gives the maximum posterior</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Find the maximum over the maximum log-posteriors: &quot;</span> &lt;&lt; endl;
        <span class="keywordtype">int</span> maxPosition = 0;
        real maxPosterior=-1*(numeric_limits&lt;double&gt;::infinity());
        <span class="keywordflow">if</span> ( ChosenStateMaxPosterior.size() != (1+NumStatesChosen) ) {
          cerr &lt;&lt; <span class="stringliteral">&quot;Number of states is incompatible.&quot;</span> &lt;&lt; endl;
          exit(0);
        }
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ChosenStateMaxPosterior.size(); i++) {
          cout &lt;&lt; <span class="stringliteral">&quot;Subset: &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; ChosenStateMaxPosterior[i] &lt;&lt; endl;
          <span class="keywordflow">if</span> (ChosenStateMaxPosterior[i] &gt; maxPosterior) {
            maxPosterior = ChosenStateMaxPosterior[i];
            maxPosition = i;
          }
        }
        cout &lt;&lt; <span class="stringliteral">&quot;Final optimal histogram is from subset &quot;</span> &lt;&lt; maxPosition;

        <span class="comment">// use this histogram as the starting state for MCMC</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myPosOptHist;
        myPosOptHist = ChosenStateSubset[maxPosition];
        cout &lt;&lt; <span class="stringliteral">&quot; and has &quot;</span> &lt;&lt; myPosOptHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &lt;&lt; <span class="stringliteral">&quot; leaf nodes.&quot;</span>  &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;
        
        <span class="comment">//output the leaf container</span>
        <span class="keywordtype">string</span> LeafFileName = <span class="stringliteral">&quot;LeafChosen&quot;</span>;
        LeafFileName += stm.str();
        LeafFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(LeafFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; LeafContainer.size(); i++) {
          oss &lt;&lt; LeafContainer[i] &lt;&lt; endl;
        }
        oss &lt;&lt; 1 &lt;&lt; endl;
        oss &lt;&lt; flush;
        oss.close();
        
        <span class="comment">//----------End of getting an initial state---------------//</span>

        <span class="comment">//============start MCMC==============================//</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Starting MCMC PiecewiseConstantFunction samples with a state that has &quot;</span> &lt;&lt;  
        myPosOptHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#ae4a71d928009eda0a6332f20fd951e35" title="Gets number of leaf nodes in the root paving.">getRootLeaves</a>() &lt;&lt; <span class="stringliteral">&quot; leaf nodes:&quot;</span> &lt;&lt; endl;
        
        <span class="comment">//optional hist output</span>
        myPosOptHist.<a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml#a49a8ff01e1398420cd45642d5b1d3106" title="Output the subpaving managed by this to a txt file.">outputToTxtTabs</a>(<span class="stringliteral">&quot;SelectedStartingHistogram.txt&quot;</span>);
        
        <span class="comment">//set up containers to get needed traceplots</span>
        <span class="keywordtype">bool</span> toIAE = computeIAE;
        cout &lt;&lt; <span class="stringliteral">&quot;Comuting IAE of curr and avg: &quot;</span> &lt;&lt; computeIAE &lt;&lt; endl;
            std::vector&lt;real&gt; IAEAvgHist;
            std::vector&lt;real&gt; IAECurrHist;
            vector&lt;real&gt; LogLikAvg;
            vector&lt;real&gt; LogLikCurr;
        
        clock_t start, end;
        start = clock();

        cout &lt;&lt; <span class="stringliteral">&quot;clock started: &quot;</span> &lt;&lt; endl;
        <a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml" title="A wrapper or manager for an RealMappedSPnode tree representing a piecewise constant function...">PiecewiseConstantFunction</a> mcmcAv = myPosOptHist.MCMCNEWPost(
                            loops, burnin, thinout,
                            proposal, logPrior,
                            minPoints, logging, estimate, toIAE,
                            stm.str(), IAEAvgHist, IAECurrHist,
                            LogLikAvg, LogLikCurr);
        end = clock();

        <span class="keywordtype">double</span> timing = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC);
        cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span>
         &lt;&lt; timing &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
         
         Times.push_back(timing);

        cout &lt;&lt; <span class="stringliteral">&quot;Finished MCMC sample averaging&quot;</span> &lt;&lt; endl;
        
        <span class="comment">//optional</span>
        <span class="keywordtype">string</span> mcmcAvFilename = <span class="stringliteral">&quot;pcfAverage.txt&quot;</span>;
        mcmcAv.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#ad542b85e0f7364a34a6504721d65c1b3">outputToTxtTabs</a>(mcmcAvFilename); 

        <span class="comment">// now get the IAE of mcmcAv against the estimate</span>
        cout &lt;&lt; <span class="stringliteral">&quot;Get the IAE&quot;</span> &lt;&lt; endl;
        real thisIAE = mcmcAv.<a class="code" href="classsubpavings_1_1PiecewiseConstantFunction.shtml#a2499c322fa30a4f07d8ad7360a8d7d95" title="Get the total integrated absolute error (IAE) between this and another PiecewiseConstantFunction.">getIAE</a>(estimate);
        IAEContainer.push_back(thisIAE);
        cout &lt;&lt; <span class="stringliteral">&quot;IAE against the estimate is &quot;</span> &lt;&lt; thisIAE &lt;&lt; endl;
        
        <span class="comment">//output the current IAEs</span>
        cout &lt;&lt; IAECurrHist.size() &lt;&lt; endl;
        IAEFileName = <span class="stringliteral">&quot;IAECurrMCMCState&quot;</span>;
        IAEFileName += stm.str();
        IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(IAEFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; IAECurrHist.size(); i++) {
          oss &lt;&lt; IAECurrHist[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        
        <span class="comment">//output the current IAEs of the averaged state</span>
        IAEFileName = <span class="stringliteral">&quot;IAECurrMCMCAvg&quot;</span>;
        IAEFileName += stm.str();
        IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
        oss.open(IAEFileName.c_str());
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; IAEAvgHist.size(); i++) {
          oss &lt;&lt; IAEAvgHist[i] &lt;&lt; endl;
        }
        oss &lt;&lt; flush;
        oss.close();
        
      <span class="comment">/*  </span>
<span class="comment">        // output log-likelihood</span>
<span class="comment">        IAEFileName = &quot;LogLikCurrMCMC&quot;;</span>
<span class="comment">        IAEFileName += stm.str();</span>
<span class="comment">        IAEFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(IAEFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; LogLikCurr.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; LogLikCurr[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        cout &lt;&lt; &quot;Log-lik output to &quot; &lt;&lt; IAEFileName &lt;&lt; endl;</span>
<span class="comment">          </span>
<span class="comment">        // output log-likelihood</span>
<span class="comment">        IAEFileName = &quot;LogLikAvgMCMC&quot;;</span>
<span class="comment">        IAEFileName += stm.str();</span>
<span class="comment">        IAEFileName += &quot;.txt&quot;;</span>
<span class="comment">        oss.open(IAEFileName.c_str());</span>
<span class="comment">        for (size_t i = 0; i &lt; LogLikAvg.size(); i++) {</span>
<span class="comment">          oss &lt;&lt; LogLikAvg[i] &lt;&lt; endl;</span>
<span class="comment">        }</span>
<span class="comment">        oss &lt;&lt; flush;</span>
<span class="comment">        oss.close();</span>
<span class="comment">        cout &lt;&lt; &quot;Log-lik output to &quot; &lt;&lt; IAEFileName &lt;&lt; endl;</span>
<span class="comment">        */</span>
      }
      <span class="keywordflow">else</span> cout &lt;&lt; <span class="stringliteral">&quot;Failed to insert data&quot;</span> &lt;&lt; endl;
      
    } <span class="comment">// end of successfulHist condition</span>
  } <span class="comment">// end of loop</span>
  <span class="comment">//=======================End of Chains=================================//</span>



  <span class="comment">// output IAE from MCMC</span>
  <span class="keywordtype">string</span> IAEFileName;
  IAEFileName = <span class="stringliteral">&quot;IAEMCMC&quot;</span>;
  IAEFileName += stmSeed.str();
  IAEFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
  oss.open(IAEFileName.c_str());
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; IAEContainer.size(); i++) {
    oss &lt;&lt; IAEContainer[i] &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Times[i] &lt;&lt; endl;
  }
  oss &lt;&lt; flush;
  oss.close();
  cout &lt;&lt; <span class="stringliteral">&quot;IAE output to &quot;</span> &lt;&lt; IAEFileName &lt;&lt; endl;

  <span class="keyword">delete</span> theDataPtr;

   <span class="keywordflow">return</span> 0;

} <span class="comment">// end of MCMC test program</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a0c0402be9ebd7abad750822814d38f99"></a><!-- doxytag: member="MCMCFunctionSimRosenQueue.cpp::ProduceMRSamples" ref="a0c0402be9ebd7abad750822814d38f99" args="(Fobj &amp;f, int n_boxes, int n_samples, double Alb, unsigned seed, bool use_f_scale, RSSample &amp;rs_sample)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="SEBPQFunctionSimRosen_8cpp.shtml#a0c0402be9ebd7abad750822814d38f99">ProduceMRSamples</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFobj.shtml">Fobj</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_boxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Alb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_f_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRSSample.shtml">RSSample</a> &amp;&#160;</td>
          <td class="paramname"><em>rs_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="MCMCFunctionSimRosenQueue_8cpp_source.shtml#l00051">51</a> of file <a class="el" href="MCMCFunctionSimRosenQueue_8cpp_source.shtml">MCMCFunctionSimRosenQueue.cpp</a>.</p>

<p>References <a class="el" href="SmallClasses_8hpp_source.shtml#l00238">RSSample::EnvelopeIntegral</a>, <a class="el" href="classFobj.shtml#a541c0edbb08855d1e3cdbb45b0aa26af">Fobj::get_interval_calls()</a>, <a class="el" href="classFobj.shtml#a63df2521571faeb43663613a9a4611e7">Fobj::get_real_calls()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00245">RSSample::IntegralEstimate()</a>, <a class="el" href="SmallClasses_8hpp_source.shtml#l00260">RSSample::Mean()</a>, <a class="el" href="MRSampler_8cpp_source.shtml#l00354">MRSampler::RejectionSampleMany()</a>, and <a class="el" href="SmallClasses_8hpp_source.shtml#l00241">RSSample::Samples</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//ofstream out (&quot;MRS_Rosenbrock.samples&quot;);//file to store the i.i.d samples</span>
  clock_t T1 = clock (), T2, T3;
  <span class="comment">// Construct theSampler with the chosen target shape object FTG</span>
  <a class="code" href="classMRSampler.shtml" title="The Moore rejection sampler class for trans-dimensional targets over labeled metric spaces...">MRSampler</a> theSampler (f, n_boxes, Alb, seed, (use_f_scale == 1));
  
        <span class="comment">//--comment this printing block if not needed</span>
        <span class="comment">// To print out the partition of the domain</span>
        <span class="comment">//cout &lt;&lt; &quot;Domain Partition: \n&quot; ;</span>
        <span class="comment">//ofstream Partout (&quot;MRS_RosenbrockDomain.txt&quot;); //Filename</span>
        <span class="comment">//theSampler.Print_Domain_Partition(Partout);</span>
        <span class="comment">//cout &lt;&lt; &quot;The output has been written to MRS_IsIt1or2CoinsDomain.txt&quot; </span>
        <span class="comment">//     &lt;&lt; endl &lt;&lt; endl;</span>
 
        <span class="comment">// To realize a file output of the RangeDomainSet</span>
   <span class="comment">//     ofstream os(&quot;MRS_RosenbrockRangeDomainSet.txt&quot;);         // Filename</span>
   <span class="comment">//     os &lt;&lt; theSampler &lt;&lt; endl;                   </span>
   <span class="comment">//     cout &lt;&lt; &quot;output has been written to MRS_IsIt1or2CoinsRangeDomainSet.txt&quot; </span>
   <span class="comment">//          &lt;&lt; endl &lt;&lt; endl;</span>
        <span class="comment">//--end of printing block</span>
<span class="comment"></span>  <span class="comment">// To print out the partition of the domain</span>
  
  T2 = clock ();
  <span class="keywordtype">double</span> Ptime = (double) (T2 - T1) / CLOCKS_PER_SEC;
  
  <span class="comment">//RSSample rs_sample;</span>
  cout &lt;&lt; <span class="stringliteral">&quot;before Rej..SampleMany \n&quot;</span>;
  cout &lt;&lt; <span class="stringliteral">&quot;n_samples: &quot;</span> &lt;&lt; n_samples &lt;&lt; endl;
  theSampler.RejectionSampleMany (n_samples, rs_sample);
  cout &lt;&lt; <span class="stringliteral">&quot;after Rej..SampleMany \n&quot;</span>;
  <span class="keywordtype">double</span> IntegralEstimate = _double (rs_sample.<a class="code" href="classRSSample.shtml#a9537562ed9b4bc945e4c92b2237732a8" title="A real estimate of the integral of the function over the domain.">IntegralEstimate</a> ());
  cout &lt;&lt; <span class="stringliteral">&quot;rs_sample IU, N, Nrs: &quot;</span> &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#aa3f52ce941256fc7d6cf71347fdfa67c" title="The envelope integral as a cxsc::real.">EnvelopeIntegral</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> 
       &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; rs_sample.<a class="code" href="classRSSample.shtml#a16622505cb282b5ebe608479fc026c12" title="An STL vector container to store accepted samples of labeled points.">Samples</a>.size() &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;RSSampleMany, integral est: &quot;</span> &lt;&lt; IntegralEstimate &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;RSSampleMany mean: \n&quot;</span>; rs_sample.<a class="code" href="classRSSample.shtml#a6e553a95e36dbecd6f0491bf71c6a761" title="Arithmetic mean of the sampled labeled points in a label-specific way.">Mean</a> ();
  <span class="comment">//rs_sample.Print(out);</span>
  
  cout &lt;&lt; <span class="stringliteral">&quot;n interval function calls: &quot;</span> &lt;&lt; f.<a class="code" href="classFobj.shtml#a541c0edbb08855d1e3cdbb45b0aa26af" title="Get number of interval function calls.">get_interval_calls</a> () &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;n real function calls: &quot;</span> &lt;&lt; f.<a class="code" href="classFobj.shtml#a63df2521571faeb43663613a9a4611e7" title="Get number of real function calls.">get_real_calls</a> () &lt;&lt; endl;
  
  <span class="comment">//----------------------------------------------------------------------------</span>
  T3 = clock ();
  <span class="keywordtype">double</span> Stime = (double) (T3 - T2) / CLOCKS_PER_SEC;
  cout &lt;&lt; <span class="stringliteral">&quot;# CPU Time (seconds). Partitioning: &quot;</span> &lt;&lt; Ptime &lt;&lt; <span class="stringliteral">&quot;  Sampling: &quot;</span> 
       &lt;&lt; Stime &lt;&lt; <span class="stringliteral">&quot;  Total: &quot;</span> &lt;&lt; (Ptime + Stime) &lt;&lt; endl;
  cout &lt;&lt; <span class="stringliteral">&quot;# CPU time (secods) per estimate: &quot;</span> 
       &lt;&lt; (Ptime + Stime) / (<span class="keywordtype">double</span>) (n_samples) &lt;&lt; endl;
}
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="MCMCFunctionSimRosenQueue_8cpp.shtml">MCMCFunctionSimRosenQueue.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:22 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
