<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::SPSnode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1SPSnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::SPSnode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::SPSnode" --><!-- doxytag: inherits="subpavings::SPnode" -->
<p>A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for processing sample data.  
 <a href="classsubpavings_1_1SPSnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for subpavings::SPSnode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1SPSnode__inherit__graph.png" border="0" usemap="#subpavings_1_1SPSnode_inherit__map" alt="Inheritance graph"/></div>
<map name="subpavings_1_1SPSnode_inherit__map" id="subpavings_1_1SPSnode_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::SPSnode:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1SPSnode__coll__graph.png" border="0" usemap="#subpavings_1_1SPSnode_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1SPSnode_coll__map" id="subpavings_1_1SPSnode_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1SPSnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ae8fb89ca868b4ec2b47d0273cd32f5f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#abcddd86c703c7263435686a5f7ad42f5">SPSnode</a> (ivector &amp;v, bool cntOnly, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#abcddd86c703c7263435686a5f7ad42f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a51f7f0ed3dd43f8851556ea4a3cb4209">SPSnode</a> (ivector &amp;v, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a51f7f0ed3dd43f8851556ea4a3cb4209"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a775af2d808a8a9a59f29e6c25b6f0e4f">SPSnode</a> (ivector &amp;v, size_t max, bool cntOnly, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a775af2d808a8a9a59f29e6c25b6f0e4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ad8f8a441fe2406ef50dc3d1fb06cb5b9">SPSnode</a> (ivector &amp;v, size_t max, int lab=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#ad8f8a441fe2406ef50dc3d1fb06cb5b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#af4aa97973f8fac14503ec22574675a99">SPSnode</a> (<a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb, bool cntOnly=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#af4aa97973f8fac14503ec22574675a99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a86d9a45e0f5a59b94d556279dafd92f9">SPSnode</a> (<a class="el" href="classLabBox.shtml">LabBox</a> &amp;lb, size_t max, bool cntOnly=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a86d9a45e0f5a59b94d556279dafd92f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a56a33f7824a42568a7c9535e2ed10c88">SPSnode</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a56a33f7824a42568a7c9535e2ed10c88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a65971d98a726cba6cf111882f984de06">operator=</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a65971d98a726cba6cf111882f984de06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3">getCounter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the counter.  <a href="#ab4bee06d1b314b064d88842ba720d4a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#afe262ee997e6ac57a15193a7d585f0ac">getSplitDim</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the split dimension.  <a href="#afe262ee997e6ac57a15193a7d585f0ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aeaa3e348d84106def631d3cd742a1420">getSplitValue</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the split value.  <a href="#aeaa3e348d84106def631d3cd742a1420"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a4285801767cd577432a0b13cdbdaba43">getCountsOnly</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the countsOnly value.  <a href="#a4285801767cd577432a0b13cdbdaba43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a8906934b09d85e67c49d38548e0cd38a">getData</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the node's data collection.  <a href="#a8906934b09d85e67c49d38548e0cd38a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aa4b207c66d28113dc641d7cddf691547">clearData</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the node's data collection.  <a href="#aa4b207c66d28113dc641d7cddf691547"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a69cbe84e4c59cd1369d3900d3ff05a01">makeEmptyNode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the node's data collection and counter.  <a href="#a69cbe84e4c59cd1369d3900d3ff05a01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678">checkTreeStateLegal</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check tree rooted at this is legal with respect to <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode()</a>.  <a href="#a7cf5893a0c2bcfe03caf2865203e6678"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a48e85710afe1e6b7f4d63afa891d4e38">checkTreeStateLegal</a> (size_t minChildPoints, double minVol) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check tree rooted at this is legal with respect to isSplittableNode(size_t minChildPoints, double minVol).  <a href="#a48e85710afe1e6b7f4d63afa891d4e38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae6a71f8266d023f98489dafcc56d3819">checkTreeStateLegal</a> (size_t minChildPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check tree rooted at this is legal with respect to isSplittableNode(size_t minChildPoints).  <a href="#ae6a71f8266d023f98489dafcc56d3819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#af8f9559a17318b187769c20e85316135">isSplittableNode</a> (size_t minChildPoints, double minVol) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check whether a node is splittable.  <a href="#af8f9559a17318b187769c20e85316135"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#acba45b1fe208f6218a87400eb454b28d">isSplittableNode</a> (size_t minChildPoints) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check whether a node is splittable.  <a href="#acba45b1fe208f6218a87400eb454b28d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ad077233e00a7093d66e35cca6fc6db6b">getLeftCountIfSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The count the left child would have if this node was split.  <a href="#ad077233e00a7093d66e35cca6fc6db6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aa10917d57d9a50cb2d393a422188a51f">getRightCountIfSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The count the right child would have if this node was split.  <a href="#aa10917d57d9a50cb2d393a422188a51f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08">getMinChildCountIfSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest number of points in either child if this was split.  <a href="#a1b3356a466432a282290af76df3adb08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a3df75e24c4a3a468b63f79667645c1dc">getMinChildCountIfSplitNEW</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#acbe47754c218f0c895a900330491cbb3">getChildrensLeftAndRightCountsIfSplit</a> (<a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;grandchildCounts) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return a container of counts for prospective grandchildren.  <a href="#acbe47754c218f0c895a900330491cbb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#abd4de519f005b145ef131f0c9d4331a0">getMinChildVolIfSplit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest volume of either child if this was split.  <a href="#abd4de519f005b145ef131f0c9d4331a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a2f8ce829fd9ba3ef3838d640ae201e9e">getLeafNodeCounts</a> (<a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;counts) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954">getLeaves</a> (<a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;leaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to all descendent leaf nodes.  <a href="#a6a833240b503da0e2b640782e8671954"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a8683fb9b17016cbe615408b51e791b9c">getAllNodes</a> (<a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;allNodes) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to all nodes.  <a href="#a8683fb9b17016cbe615408b51e791b9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70">getSubLeaves</a> (<a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;subleaves) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to all sub-leaf descendent nodes.  <a href="#af5ff16174902743a78b2d3db3e0a1c70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aeac2247b4626b1adfa609d3ff109ceb2">getRootCounter</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The count in the node's ultimate ancestor root.  <a href="#aeac2247b4626b1adfa609d3ff109ceb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aa5ae31017fb2fdee8b9168009d8d08a6">getMean</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample mean.  <a href="#aa5ae31017fb2fdee8b9168009d8d08a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">rvector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a4369d3887385551e053d3873b600f8a1">getUniformMean</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the uniform mean vector where each element is the midpoint of the coordinate.  <a href="#a4369d3887385551e053d3873b600f8a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aa3a4a9df979f04453e82d76866b52850">getChebDistMean</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Chebyshev distance for the mean.  <a href="#aa3a4a9df979f04453e82d76866b52850"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a31ee93bb53be29fd0e50ff7fcd189c98">getEmpMass</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the empirical mass of the node  <a href="#a31ee93bb53be29fd0e50ff7fcd189c98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a7713822499beb30a3d30f43b79c608b8">getChebDistCovar</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Chebyshev distance for the var-covar.  <a href="#a7713822499beb30a3d30f43b79c608b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aa0ea6455e40f7f2bdb1e972ab080f5a5">getHellingerDist</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Bhattarchaya coefficient.  <a href="#aa0ea6455e40f7f2bdb1e972ab080f5a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#afe386393d18f1e251972e959e79c3847">getHellingerDist1D</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#adf589d16a3e20b4285f428c8dc42d75d">getSumLeafCountOverVol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sum of the count over volume in the leaf nodes.  <a href="#adf589d16a3e20b4285f428c8dc42d75d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a6a75d9675312fb76aaf98bbeb084f9d6">getSmallestLeafCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of the leaf with the smallest count.  <a href="#a6a75d9675312fb76aaf98bbeb084f9d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae094573d2988d458e00a549039a6ad56">getLargestLeafCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count in the leaf with the smallest count.  <a href="#ae094573d2988d458e00a549039a6ad56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a45f10ce1371120a0c1be29fa0ad8bac5">getLogLik</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this leaf node's contribution to loglikelihood.  <a href="#a45f10ce1371120a0c1be29fa0ad8bac5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ab28c35298b721467721228a33a194433">getSplitChangeLogLik</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get change in log likelihood on split of this node.  <a href="#ab28c35298b721467721228a33a194433"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a9fd3a2a06ee14b5d5c307a2c7d795cef">getMergeChangeLogLik</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get change in log likelihood on merge of this' leaf chidren.  <a href="#a9fd3a2a06ee14b5d5c307a2c7d795cef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a3b5e815e94d8a276d7b13c0dc25a8dc4">getBestSplitChangeEMPCOPERR</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get best change in EMP under COPERR from splitting any leaf.  <a href="#a3b5e815e94d8a276d7b13c0dc25a8dc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a53b9e7117d36f7730d458f26d74e0d28">getBestSplitChangeEMPAIC</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get best change in EMP under AIC from splitting any leaf.  <a href="#a53b9e7117d36f7730d458f26d74e0d28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf8fbd3c03d1edeedbd5a793c9b822d">getBestMergeChangeEMPCOPERR</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get best change in EMP under COPERR from merging any subleaf.  <a href="#a7cf8fbd3c03d1edeedbd5a793c9b822d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a0e8b9126a14255276600bf5293d33e24">getBestMergeChangeEMPAIC</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get best change in EMP under AIC from merging any subleaf.  <a href="#a0e8b9126a14255276600bf5293d33e24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a483f3b91707cda0deaee7a05d0523f3b">getEMPContributionCOPERR</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this node's scaled contribution to EMP under COPERR.  <a href="#a483f3b91707cda0deaee7a05d0523f3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aa939623d58172bc7f24ddf5dd249b5c2">getEMPContributionAIC</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get this node's scaled contribution to EMP under AIC.  <a href="#aa939623d58172bc7f24ddf5dd249b5c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a33925f531930c000200f452209b0128c">getSplitChangeEMPCOPERR</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scaled change in sum term in EMP under COPERR on split.  <a href="#a33925f531930c000200f452209b0128c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#af75b1acec69e86469838524097fab408">getSplitChangeEMPAIC</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get change in sum term in EMP under AIC on split.  <a href="#af75b1acec69e86469838524097fab408"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a2c8cc31ffdb9c74b82cce176c8d14585">getMergeChangeEMPCOPERR</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scaled change in sum term in EMP under COPERR on merge.  <a href="#a2c8cc31ffdb9c74b82cce176c8d14585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a42114089fcad779bec855496154ded19">getMergeChangeEMPAIC</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get change in sum term in EMP under AIC on merge.  <a href="#a42114089fcad779bec855496154ded19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ad128b1715d294a65c905579ab43890d2">reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of another tree.  <a href="#ad128b1715d294a65c905579ab43890d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#afe32d323547d5169b03ed9058922ac9d">reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;other, size_t minChildPoints)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape so that the tree rooted at this has shape that is as close as possible to the union of this shape and the shape of another tree.  <a href="#afe32d323547d5169b03ed9058922ac9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aba02715cb75f803df7c3ffd1eaf027e8">nodePrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output details of a specific node.  <a href="#aba02715cb75f803df7c3ffd1eaf027e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a3cc0c8bb64c854ef16ba03891f5945d6">leafOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a3cc0c8bb64c854ef16ba03891f5945d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1">leavesOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#abe732a753f432c2239c9f82a47d089b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a817a8a29925937c189cc009366fe6bfb">leavesOutputTabsWithEMPs</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a817a8a29925937c189cc009366fe6bfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a11c1e7c0e652b891c08dfefebd285904">leavesOutputTabsWithHistHeight</a> (std::ostream &amp;os, const int prec) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a11c1e7c0e652b891c08dfefebd285904"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a7f8027e04d883efdf7b627208775b989">leavesOutputTabsWithHistHeight</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a7f8027e04d883efdf7b627208775b989"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a24b8bd122c6509dd0bdb1d11b52edb7a">leavesOutputTabsWithHistHeightAndEMPs</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a24b8bd122c6509dd0bdb1d11b52edb7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ad8b17faf69caa46fcfa021b61d09e278">getEMPSumCOPERR</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scaled EMP sum under COPERR for tree rooted at this.  <a href="#ad8b17faf69caa46fcfa021b61d09e278"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a26329c8ddf55f351a673fe258e5abd15">getEMPSumAIC</a> (const size_t n) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unscaled EMP sum under AIC for tree rooted at this.  <a href="#a26329c8ddf55f351a673fe258e5abd15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a918067afb150c053f7450fd18c6ecd22">nodeContains</a> (const rvector &amp;p, <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a> childInd=<a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the box a node represents contains a datapoint p.  <a href="#a918067afb150c053f7450fd18c6ecd22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a1ac36ca4768f69aab39ae45aaace5988">spsContains</a> (ivector &amp;z, int countBox, int countInBox) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of points in any box.  <a href="#a1ac36ca4768f69aab39ae45aaace5988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#adf0575b58b84a0910a8d5b67b6ec0f48">nodeExpand</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#adf0575b58b84a0910a8d5b67b6ec0f48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a0728b0ec4deee17f6a729a97c8b5a560">nodeExpand</a> (const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest, int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#a0728b0ec4deee17f6a729a97c8b5a560"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae432186483a5ec950dab0eb00b08a9bc">nodeExpand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#ae432186483a5ec950dab0eb00b08a9bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a19a54cd8f89112dbed3f43c2f405921f">nodeExpand</a> (const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a leaf node.  <a href="#a19a54cd8f89112dbed3f43c2f405921f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2">nodeReabsorbChildren</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reabsorbs both children of the node.  <a href="#a68cc1a1722c627a99dcefc3491847fb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a61c584952df4fa77109cb4bb9b46f657">nodeReunite</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *lChild, <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reunite nodes to form one leaf.  <a href="#a61c584952df4fa77109cb4bb9b46f657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae1d11e62b133e13be6c14f7ff759f152">nodeAdoptLeft</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *lChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#ae1d11e62b133e13be6c14f7ff759f152"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a4049a0078541b24d5451957f6f7dcd68">nodeAdoptRight</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#a4049a0078541b24d5451957f6f7dcd68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18">insertOneFind</a> (<a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">BigDataItr</a> newItr, <a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a> childInd, const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data into this node.  <a href="#af0d351af2a515188522e13e0c6502a18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a8ce80cd650645f34e79fbc1d4beb2326">swapSPS</a> (<a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this and another node. Swaps all the data members of this with the other node.  <a href="#a8ce80cd650645f34e79fbc1d4beb2326"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors for links between the nodes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These accessor methods shadow equivalent methods in the base class. Thus the method used is determined at compile time, not run time as would be the case if virtual methods were used. Because the pointers to parents and children are part of the base class definition, the methods have to cast the base class form to the derived class form in order for the pointer returned to be able to be used with derived class members.</p>
<p>Note that pointers for parent, leftChild, and rightChild are not reference counted so there could potentially be problems with the use of returned pointers (for instance, being used to delete nodes). These pointers might be better implemented with boost::shared_ptr . </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the parent of a node.  <a href="#a88c1d25d8e0b9738f5199cc4435c08b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc">getLeftChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the left child of a node.  <a href="#af7588b657e2819dd5dda525e08143ffc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7">getRightChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the right child of a node.  <a href="#acc7d3e22be28d76da5c8c228aaaa95c7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Get the sample variance-covariance matrix.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>This calculates the sample variance-covariance matrix from the accumulators for the sumproducts and sums of data point elements.</p>
<p>cov(i,j) = [sumproduct(i,j)-sum(i)xsum(j)/counter]/(counter-1)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a RealVec or reference to a RealVec representing the sample variance-covariance matrix in row-major order. </dd></dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">getVarCovar</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a1bc0843e834ae4d09db3bc148b64761b">getVarCovar</a> (<a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;varCovar) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">getUniformVarCovar</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a8ca1683e838159d5a33048344bec9b49">getUniformVarCovar</a> (<a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;varCovar) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">strippedConstructor</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a2dfb3087cff36fdf558bf75d5ee039c9">unionTreeStructure</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const rhs)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e">_reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to reshape this to a union.  <a href="#add75213a0cf94b42aa82aca57b02da3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#acae5407bbd325c9c4852c5a77304cee9">_reshapeToUnion</a> (const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const other, size_t minChildPoints, const std::string &amp;errorFilename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to reshape this to a union with a restriction of minChildPoints.  <a href="#acae5407bbd325c9c4852c5a77304cee9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95">spaceIndication</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An indication of the maximum number of data points a node needs to carry.  <a href="#a4d836fd2b3cd074343475de6f9511c95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154">splitDim</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension the node's box has been split along.  <a href="#afbda0af3b68cf12874faa64aa8a9b154"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6">splitValue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The value, on split dimension, where node's box was split.  <a href="#a60ef987525bfd22dd0a5adadc141f0b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02">countsOnly</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the amount of statistical summary data in node.  <a href="#a99af67614faaf93216ec0991e96ddb02"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">mutable data members.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These data members are mutable to allow them to be modified by const functions as data passed to or through the node.</p>
<p>Only leaf nodes have data associated with them but the recursively computable statistics, such as counter and sum, are maintained for all nodes. Thus when a data point is sent to the root node and progresses down the tree to find which leaf node it should be associated with, the counter is incremented and the data sum increased for each non-leaf node it passes through (ie, where it is contained in the box of that node but that node is not a leaf node so the box has been sub- divided and the datapoint continues on to one of the children). </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5">counter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter for how many data points are covered by theBox.  <a href="#a890b23bcab9091b420d88b99d16badc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643">dpSums</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container representing the sum of the data points covered by theBox.  <a href="#a1e5698e870376a507cd4a09bddc01643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78">dpSumProducts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container representing the sumproduct matrix of the data points covered by theBox.  <a href="#a7ff8f1c83a231af97c32808e0851dc78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8">dataItrs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for the association of data with a node.  <a href="#a2d45b1e3b34a39d128143a0829f051f8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classsubpavings_1_1SPSnode.shtml#a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367">defaultMaxPts</a> =  1000
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">To define the default maximum number of datapoints the node is expected to have associated with it.  <a href="classsubpavings_1_1SPSnode.shtml#a208ab19f2444e75f9602f8fd136fc03d">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a8011280b8a3a0729c581a00f3bb031ff">recalculateStats</a> (rvector &amp;newdata) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate summary statistics associated with node.  <a href="#a8011280b8a3a0729c581a00f3bb031ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aa70c978a273b7266c75e7d617ae4d100">recalculateSums</a> (rvector &amp;newdata) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate summary statistics associated with node.  <a href="#aa70c978a273b7266c75e7d617ae4d100"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ab49e57afe0939b41930e0cbb22c9ba8a">recalculateSumProducts</a> (rvector &amp;newdata) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate summary statistics associated with node.  <a href="#ab49e57afe0939b41930e0cbb22c9ba8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ac549870ef3b7994d9e87b952a012a7e9">nodeExpansionOnly</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the node with no reallocation of data.  <a href="#ac549870ef3b7994d9e87b952a012a7e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#adf3d76ca267b87c46d1fcb1ca3cecd84">splitData</a> (const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;boolTest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data associated with this down to children.  <a href="#adf3d76ca267b87c46d1fcb1ca3cecd84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a799dd8e194518c3dd525ecba26072585">nodeDataPrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the data in a specified format.  <a href="#a799dd8e194518c3dd525ecba26072585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a5f5cc02f707a2b98f7a93543c71298b2">nodeMeanPrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the mean in a specified format.  <a href="#a5f5cc02f707a2b98f7a93543c71298b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a03042a5084349960b1fd35396dc509a5">nodeVarCovarPrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the variance-covariance in a specified format.  <a href="#a03042a5084349960b1fd35396dc509a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ac273545c33e3abb0114811e7a1b06f98">leafOutputTabsWithEMPs</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#ac273545c33e3abb0114811e7a1b06f98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#aaf9ac8d98bda6e99c74b946d85c6bc61">leafOutputTabsWithHistHeight</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#aaf9ac8d98bda6e99c74b946d85c6bc61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ad64bd4af47589b21d9c8dde5135c3d0a">leafOutputTabsWithHistHeightAndEMPs</a> (const size_t bigN, std::ostream &amp;os, const int prec=5) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#ad64bd4af47589b21d9c8dde5135c3d0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a785e03fc466a6a1ea851f08338f8103d">setSplits</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the splitDimension and SplitValue when children grafted.  <a href="#a785e03fc466a6a1ea851f08338f8103d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959">gatherData</a> (<a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp;container, <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the node data.  <a href="#ac16a08aea6f8316526c46382e3252959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1SPSnode.shtml#a6c28eccf9962c4b9010f2f04b0231d30">unionNoData</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const rhs)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for processing sample data. </p>
<p>The base class <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is a node in the representation of a regular subpaving as a binary tree. A node represents a box (interval vector). SPnodes are linked together to form the tree. The initial box of the subpaving is the box represented by the root node of the tree. A box which has been split will be represented as node with 1 or 2 children.</p>
<p>A subpaving of [<b>x</b>] (union of non-overlapping subboxes of [<b>x</b>]) is represented by the leaves (degenerate/child-less) nodes in the tree.</p>
<p>The <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> class has additional data members for statistical data analysis. The <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> class is used to form a regular subpaving representing containers of sample data where some data-related criteria is used to determine when the subpaving should be bisected. For example, keeping the number of data points associated with a node below a specified maximum -- "a maximally statistically equivalent
    blocks" criterion.</p>
<p>Data points are of type csxc::rvector.</p>
<p>Leaves of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> class have data associated with them in the form of pointers to some big collection of sample data. If an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> is bisected the data associated with it descends to its children, so that only leaf SPSnodes have data associated with them. However, "recursively-computable statistical summaries", such as, count, sum, etc, of the data which would be contained in the box an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> represents are kept for all SPSnodes and continue to be updated when the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> has children and data reaching the node is passed on to be finally associated with a leaf.</p>
<p>For an algebraic statistical formalisation of Fisher's ideas on recursively computable statistics see "Notions of Sufficiency" by S.L. Lauritzen, Contributed Paper, 44th Session of the International Statistical Institute, Madrid, Spain, September 12th--22nd, 1983.</p>
<p>By default, all recursively computable statistics provided are maintained in each <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>. However, since this uses memory and is not always needed, an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> can be constructed to only maintain count statistics.</p>
<p>When a box is split along some dimension d, only the right (upper) subbox is closed on the actual split value (the midpoint of the interval which is the dth element in the interval vector/box to be bisected) whereas the left (lower) box has an open interval on this value. Thus [1 5] is subdivided to [1 3) and [3 5]. The parent <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> class can ignore this point but it must be addressed if we are to be able to decide which subbox (left or right) a datapoint sitting exactly on the split value in the split dimension should descend to. This is an extension of the empirical distribution to a partition of the root box with the leaves of the subpaving.</p>
<p>The class also needs to know which dimension the box represented by a node was split on and what the split value was, so that data reaching the node can be correctly (ie, in cognisance of the open and closed intervals described above) associated with either the right or left child. These values therefore become data members of the class, with default values for leaf nodes. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00109">109</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a208ab19f2444e75f9602f8fd136fc03d"></a><!-- doxytag: member="subpavings::SPSnode::@0" ref="a208ab19f2444e75f9602f8fd136fc03d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To define the default maximum number of datapoints the node is expected to have associated with it. </p>
<p>This is used for efficiency only to reserve vector space and a node can have more than this default maximum number of data points associated with it. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367"></a><!-- doxytag: member="defaultMaxPts" ref="a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367" args="" -->defaultMaxPts</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00121">121</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{<a class="code" href="classsubpavings_1_1SPSnode.shtml#a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367">defaultMaxPts</a> = 1000};
</pre></div>
</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae8fb89ca868b4ec2b47d0273cd32f5f5"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="ae8fb89ca868b4ec2b47d0273cd32f5f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00679">679</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00121">defaultMaxPts</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">SPSnode()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00960">strippedConstructor()</a>.</p>
<div class="fragment"><pre class="fragment">                     :  <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(-1), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(0.0),
                                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(<span class="keyword">true</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class default constructor</span>
            <span class="comment">// then does additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">// reserve space</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367">defaultMaxPts</a>);
            <span class="comment">// not sure whether to do this or not - leave for the moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="abcddd86c703c7263435686a5f7ad42f5"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="abcddd86c703c7263435686a5f7ad42f5" args="(ivector &amp;v, bool cntOnly, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents and a value for countsOnly which controls whether all available stats are maintained (false) or just counts (true), and optionally initialised with a label which defaults to 0 if not provided. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00732">732</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00121">defaultMaxPts</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>.</p>
<div class="fragment"><pre class="fragment">                                                      : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v, lab),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(-1), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(0.0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(cntOnly)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with ivector &amp; label</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367">defaultMaxPts</a>);
            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a51f7f0ed3dd43f8851556ea4a3cb4209"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="a51f7f0ed3dd43f8851556ea4a3cb4209" args="(ivector &amp;v, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents and optionally initialised with a label which defaults to 0 if not provided. The value for countsOnly will default to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00707">707</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00121">defaultMaxPts</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>.</p>
<div class="fragment"><pre class="fragment">                                        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v, lab),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(-1), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(0.0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(<span class="keyword">true</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with ivector &amp; label</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367">defaultMaxPts</a>);
            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a775af2d808a8a9a59f29e6c25b6f0e4f"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="a775af2d808a8a9a59f29e6c25b6f0e4f" args="(ivector &amp;v, size_t max, bool cntOnly, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents, a space indication, and a value for countsOnly which controls wether all available stats are maintained (false) or just counts (true), and optionally initialised with a label for the model which defaults to 0 if not provided. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00785">785</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>.</p>
<div class="fragment"><pre class="fragment">                                                                  :
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v, lab),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>(max), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(-1), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(0.0),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(cntOnly)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//cout &lt;&lt; &quot;node constructor&quot; &lt;&lt; &quot;\t&quot; &lt;&lt; cntOnly &lt;&lt; endl;</span>
            <span class="comment">//invokes the base class constructor with ivector argument</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>+1);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad8f8a441fe2406ef50dc3d1fb06cb5b9"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="ad8f8a441fe2406ef50dc3d1fb06cb5b9" args="(ivector &amp;v, size_t max, int lab=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with an interval vector for the box it represents, a space indication, and optionally initialised with a label for the model which defaults to 0 if not provided. The value for countsOnly will default to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00758">758</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>.</p>
<div class="fragment"><pre class="fragment">                                                    :
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v, lab),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>(max), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(-1), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(0.0),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(<span class="keyword">true</span>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with ivector argument</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>+1);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af4aa97973f8fac14503ec22574675a99"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="af4aa97973f8fac14503ec22574675a99" args="(LabBox &amp;lb, bool cntOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> for the labeled box it represents. Also optionally initialised with a value for countsOnly, defaults to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00837">837</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00121">defaultMaxPts</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>.</p>
<div class="fragment"><pre class="fragment">                                             : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(lb), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(0),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(-1), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(0.0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(cntOnly)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//invokes the base class constructor with LabBox argument</span>
            <span class="comment">// and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a208ab19f2444e75f9602f8fd136fc03da54168a18fc82748182314929de5e3367">defaultMaxPts</a>);
            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a86d9a45e0f5a59b94d556279dafd92f9"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="a86d9a45e0f5a59b94d556279dafd92f9" args="(LabBox &amp;lb, size_t max, bool cntOnly=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLabBox.shtml">LabBox</a> &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cntOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a <a class="el" href="classLabBox.shtml" title="A labeled box class.">LabBox</a> for the labeled box it represents, and a space indication. Also optionally initialised with a value for countsOnly, defaults to false (i.e., all stats maintained by default). </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00812">812</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>.</p>
<div class="fragment"><pre class="fragment">                                                         : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(lb),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>(max), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(0), <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(-1), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(0.0),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(cntOnly)
    {
        <span class="keywordflow">try</span> {

            <span class="comment">//invokes the base class constructor with LabBox argument</span>
            <span class="comment">//and then initialises additional data members</span>

            <span class="comment">//dpSums, a vector of dotprecision terms, is not initialised</span>
            <span class="comment">//dpSumProducts, similarly not initialised</span>

            <span class="comment">//reserve space - not sure if important - leave for moment</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>+1);
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a56a33f7824a42568a7c9535e2ed10c88"></a><!-- doxytag: member="subpavings::SPSnode::SPSnode" ref="a56a33f7824a42568a7c9535e2ed10c88" args="(const SPSnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5">SPSnode::SPSnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00861">861</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00679">SPSnode()</a>.</p>
<div class="fragment"><pre class="fragment">                                         : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*(other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>),
        other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>),
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>), <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>),
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>), <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">//reserve space</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve((other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>).size());
            <span class="comment">//copy dataItrs from other to this</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a> = other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(*(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(*(other.<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="add75213a0cf94b42aa82aca57b02da3e"></a><!-- doxytag: member="subpavings::SPSnode::_reshapeToUnion" ref="add75213a0cf94b42aa82aca57b02da3e" args="(const SPnode *const other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e">SPSnode::_reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method to reshape this to a union. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a7ac37cce7f65b0f4c71d37b06d581d17">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00621">621</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00157">subpavings::SPnode::_reshapeToUnion()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02372">reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e" title="Internal method to reshape this to a union.">SPnode::_reshapeToUnion</a>(other);
}
</pre></div>
</div>
</div>
<a class="anchor" id="acae5407bbd325c9c4852c5a77304cee9"></a><!-- doxytag: member="subpavings::SPSnode::_reshapeToUnion" ref="acae5407bbd325c9c4852c5a77304cee9" args="(const SPnode *const other, size_t minChildPoints, const std::string &amp;errorFilename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e">SPSnode::_reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> *const&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>errorFilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal method to reshape this to a union with a restriction of minChildPoints. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minChildPoints</td><td>is the minimum child points to allow for a split (as usual, if one child gets all the points and the number of points in this is &gt;= minChildPoints, the split is allowed). </td></tr>
    <tr><td class="paramname">errorFileName</td><td>is a file to which to log messages about nodes which could not be split because of <em>minChildPoints</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if this was able to reshape to exactly the union of this and <em>other</em>, false if the extent to which descendents of this could split to mimic other was limted by <em>minChildPoints</em>. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00629">629</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00401">subpavings::SPnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00406">subpavings::SPnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02192">subpavings::isLeaf()</a>, and <a class="el" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7">subpavings::outputFile()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// indictator for being able to do union exactly</span>
  <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;
  
  <span class="keywordflow">if</span> ( other != NULL &amp;&amp; !(other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) ) {

    <span class="comment">// this is not a leaf, other is a leaf</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {

      <span class="comment">// no need to do anything</span>
    }

    <span class="comment">// this is a leaf, other is not a leaf</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {

      <span class="comment">//we need to expand this</span>
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode</a>(minChildPoints)) <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae432186483a5ec950dab0eb00b08a9bc" title="Expand a leaf node.">nodeExpand</a>();
      <span class="keywordflow">else</span> {
        success = <span class="keyword">false</span>;
        <span class="comment">// log file</span>
        std::string line = <span class="stringliteral">&quot;Could not split &quot;</span> + <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() 
         + <span class="stringliteral">&quot; because of minChildPoints&quot;</span>;
        
        <a class="code" href="namespacesubpavings.shtml#aa5b5b66715568bc59cafea064eb8b1a7" title="Append a line to a txt file.">outputFile</a>(errorFilename, line); 
        
      }
      
    }

    <span class="comment">// now recurse on the children if both have children</span>
    <span class="comment">// note - it won&#39;t go here is !success because still isLeaf()</span>
    <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
      success = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e" title="Internal method to reshape this to a union.">_reshapeToUnion</a>(
          other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3" title="Accessor for the left child of a node.">getLeftChild</a>(), minChildPoints, errorFilename);
      success = <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e" title="Internal method to reshape this to a union.">_reshapeToUnion</a>(
          other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689" title="Accessor for the right child of a node.">getRightChild</a>(), minChildPoints, errorFilename)
          &amp;&amp; success;
    }
    
    <span class="keywordflow">return</span> success;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7cf5893a0c2bcfe03caf2865203e6678"></a><!-- doxytag: member="subpavings::SPSnode::checkTreeStateLegal" ref="a7cf5893a0c2bcfe03caf2865203e6678" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678">SPSnode::checkTreeStateLegal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check tree rooted at this is legal with respect to <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode()</a>. </p>
<p>'Legal' means that all non-leaf nodes in the tree are splittable, ie return <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode()</a> = true;</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all non-leaf nodes in the tree rooted at this are splittable, false if any non-leaf node in the tree rooted at this is not splittable. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#afde5e15be5259cf61821f175452d165f">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01043">1043</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01048">checkTreeStateLegal()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678" title="Check tree rooted at this is legal with respect to isSplittableNode().">SPnode::checkTreeStateLegal</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a48e85710afe1e6b7f4d63afa891d4e38"></a><!-- doxytag: member="subpavings::SPSnode::checkTreeStateLegal" ref="a48e85710afe1e6b7f4d63afa891d4e38" args="(size_t minChildPoints, double minVol) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678">SPSnode::checkTreeStateLegal</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check tree rooted at this is legal with respect to isSplittableNode(size_t minChildPoints, double minVol). </p>
<p>'Legal' means that all non-leaf nodes in the tree are splittable, ie return isSplittableNode(size_t minChildPoints, double minVol) = true;</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points that there would be in the children if the node were to be split. </td></tr>
    <tr><td class="paramname">minVol</td><td>is the minimum node volume to be tested for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all non-leaf nodes in the tree rooted at this are splittable with respect to <em>minChildPoints</em> and <em>minVol</em>, false if any non-leaf node in the tree rooted at this is not splittable according to these criteria. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01048">1048</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01043">checkTreeStateLegal()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01093">isSplittableNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// check current state is legal by looking at everything not a leaf</span>
  <span class="keywordtype">bool</span> legal = <span class="keyword">true</span>;
  <span class="keywordflow">if</span> ( !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
    legal = <a class="code" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode</a>(minChildPoints, minVol);
    <span class="keywordflow">if</span> (legal &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() ) {
        legal = 
          <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal</a>(minChildPoints,
                            minVol);
    }
    <span class="keywordflow">if</span> (legal &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() ) {
        legal = 
          <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal</a>(minChildPoints,
                            minVol);
    }
  }
  
  <span class="keywordflow">return</span> legal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae6a71f8266d023f98489dafcc56d3819"></a><!-- doxytag: member="subpavings::SPSnode::checkTreeStateLegal" ref="ae6a71f8266d023f98489dafcc56d3819" args="(size_t minChildPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678">SPSnode::checkTreeStateLegal</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check tree rooted at this is legal with respect to isSplittableNode(size_t minChildPoints). </p>
<p>'Legal' means that all non-leaf nodes in the tree are splittable, ie return isSplittableNode(size_T minChildPoints) = true;</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points that there would be in the children if the node were to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if all non-leaf nodes in the tree rooted at this are splittable with respect to <em>minChildPoints</em>, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01070">1070</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01043">checkTreeStateLegal()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01093">isSplittableNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// check current state is legal by looking at everything not a leaf</span>
  <span class="keywordtype">bool</span> legal = <span class="keyword">true</span>;
  <span class="keywordflow">if</span> ( !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
    legal = <a class="code" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode</a>(minChildPoints);
    <span class="keywordflow">if</span> (legal &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() ) {
        legal = 
          <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal</a>(minChildPoints);
    }
    <span class="keywordflow">if</span> (legal &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() ) {
        legal = 
          <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal</a>(minChildPoints);
    }
  }
  
  <span class="keywordflow">return</span> legal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa4b207c66d28113dc641d7cddf691547"></a><!-- doxytag: member="subpavings::SPSnode::clearData" ref="aa4b207c66d28113dc641d7cddf691547" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa4b207c66d28113dc641d7cddf691547">SPSnode::clearData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the node's data collection. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#af7739cf5333fccbe27610cbbd1138719">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01018">1018</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>.</p>
<div class="fragment"><pre class="fragment">    { <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.clear(); }
</pre></div>
</div>
</div>
<a class="anchor" id="ac16a08aea6f8316526c46382e3252959"></a><!-- doxytag: member="subpavings::SPSnode::gatherData" ref="ac16a08aea6f8316526c46382e3252959" args="(NodeData &amp;container, SPSnode *spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959">SPSnode::gatherData</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to the node data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of data associated with the node <b> and its descendents </b>. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00482">482</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l03000">nodeAdoptLeft()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03048">nodeAdoptRight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02925">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="keywordflow">if</span> (spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
                container =
                    <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(container,
                            spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());
            }
            <span class="keywordflow">if</span> (spn-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
                container =
                    <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(container,
                            spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// is a leaf</span>
            <span class="comment">// copy data from spn&#39;s dataItrs into temp container</span>
            container.insert(container.end(),
                            (spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>).begin(),
                            (spn-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>).end());
        }

        <span class="keywordflow">return</span> container;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8683fb9b17016cbe615408b51e791b9c"></a><!-- doxytag: member="subpavings::SPSnode::getAllNodes" ref="a8683fb9b17016cbe615408b51e791b9c" args="(SPSnodePtrs &amp;allNodes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a8683fb9b17016cbe615408b51e791b9c">SPSnode::getAllNodes</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>allNodes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to all nodes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of node pointers. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ac637655f207bc9bc049145a2bd904fdf">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01348">1348</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01348">getAllNodes()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01348">getAllNodes()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) { <span class="comment">// this is not empty</span>
      <span class="comment">//if (!hasLCwithBox() &amp;&amp; !hasRCwithBox()) { // this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
        <span class="comment">//cout &lt;&lt; nodeName &lt;&lt; endl;</span>
            allNodes.push_back(const_cast&lt;SPSnode*&gt;(<span class="keyword">this</span>));
        }
      
      <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a8683fb9b17016cbe615408b51e791b9c" title="Return a reference to all nodes.">getAllNodes</a>(allNodes);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a8683fb9b17016cbe615408b51e791b9c" title="Return a reference to all nodes.">getAllNodes</a>(allNodes);
        }       
        <span class="keywordflow">return</span> allNodes;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a0e8b9126a14255276600bf5293d33e24"></a><!-- doxytag: member="subpavings::SPSnode::getBestMergeChangeEMPAIC" ref="a0e8b9126a14255276600bf5293d33e24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a0e8b9126a14255276600bf5293d33e24">SPSnode::getBestMergeChangeEMPAIC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get best change in EMP under AIC from merging any subleaf. </p>
<p>n, the value to use for scaling, cancels out of change.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>best (lowest or most negative) scaled change in AIC from merging any of the subleaves. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02239">2239</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l02360">getMergeChangeEMPAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">getSubLeaves()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00443">subpavings::SPnode::isSubLeaf()</a>.</p>

<p>Referenced by <a class="el" href="histevalobj_8hpp_source.shtml#l00395">subpavings::CritAICMergeChange_GTE::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc" title="find if this node is a subleaf node.">isSubLeaf</a>()) {  <span class="comment">// this is a subleaf</span>
            bestEMPChange = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a42114089fcad779bec855496154ded19" title="Get change in sum term in EMP under AIC on merge.">getMergeChangeEMPAIC</a>();
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a sub leaf</span>
            <span class="comment">// set up a container for the subleaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> subleaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves);

            <span class="comment">// find the best child for splitting</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* best = *(subleaves.begin());

            bestEMPChange = best-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a42114089fcad779bec855496154ded19" title="Get change in sum term in EMP under AIC on merge.">getMergeChangeEMPAIC</a>();

            <span class="keywordflow">for</span>(it = subleaves.begin(); it &lt; subleaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;getMergeChangeEMPAIC() &lt; bestEMPChange) {

                    bestEMPChange = (*it)-&gt;getMergeChangeEMPAIC();
                }
            }
        } <span class="comment">// end else not a subleaf</span>

        <span class="keywordflow">return</span> bestEMPChange;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7cf8fbd3c03d1edeedbd5a793c9b822d"></a><!-- doxytag: member="subpavings::SPSnode::getBestMergeChangeEMPCOPERR" ref="a7cf8fbd3c03d1edeedbd5a793c9b822d" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf8fbd3c03d1edeedbd5a793c9b822d">SPSnode::getBestMergeChangeEMPCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get best change in EMP under COPERR from merging any subleaf. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to use for scaling, the total number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>best (lowest or most negative) scaled change in COPERR from merging any of the subleaves. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02204">2204</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l02331">getMergeChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">getSubLeaves()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00443">subpavings::SPnode::isSubLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc" title="find if this node is a subleaf node.">isSubLeaf</a>()) {  <span class="comment">// this is a subleaf</span>
            bestEMPChange = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2c8cc31ffdb9c74b82cce176c8d14585" title="Get scaled change in sum term in EMP under COPERR on merge.">getMergeChangeEMPCOPERR</a>(n);
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a subleaf</span>
            <span class="comment">// set up a container for the subleaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> subleaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves);

            <span class="comment">// find the best child for splitting</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* best = *(subleaves.begin());

            bestEMPChange = best-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2c8cc31ffdb9c74b82cce176c8d14585" title="Get scaled change in sum term in EMP under COPERR on merge.">getMergeChangeEMPCOPERR</a>(n);

            <span class="keywordflow">for</span>(it = subleaves.begin(); it &lt; subleaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;getMergeChangeEMPCOPERR(n) &lt; bestEMPChange) {

                    bestEMPChange = (*it)-&gt;getMergeChangeEMPCOPERR(n);
                }
            }
        } <span class="comment">// end else not a subleaf</span>

        <span class="keywordflow">return</span> bestEMPChange;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a53b9e7117d36f7730d458f26d74e0d28"></a><!-- doxytag: member="subpavings::SPSnode::getBestSplitChangeEMPAIC" ref="a53b9e7117d36f7730d458f26d74e0d28" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a53b9e7117d36f7730d458f26d74e0d28">SPSnode::getBestSplitChangeEMPAIC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get best change in EMP under AIC from splitting any leaf. </p>
<p>n, the value to use for scaling, cancels out of change.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>best (lowest or most negative) scaled change in AIC from splitting any of the leaves. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02169">2169</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02324">getSplitChangeEMPAIC()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="histevalobj_8hpp_source.shtml#l00227">subpavings::CritAICChange_GTE::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            bestEMPChange = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af75b1acec69e86469838524097fab408" title="Get change in sum term in EMP under AIC on split.">getSplitChangeEMPAIC</a>();
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>
            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <span class="comment">// find the best child for splitting</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* best = *(leaves.begin());

            bestEMPChange = best-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af75b1acec69e86469838524097fab408" title="Get change in sum term in EMP under AIC on split.">getSplitChangeEMPAIC</a>();

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;getSplitChangeEMPAIC() &lt; bestEMPChange) {

                    bestEMPChange = (*it)-&gt;getSplitChangeEMPAIC();
                }
            }
        } <span class="comment">// end else not a leaf</span>

        <span class="keywordflow">return</span> bestEMPChange;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3b5e815e94d8a276d7b13c0dc25a8dc4"></a><!-- doxytag: member="subpavings::SPSnode::getBestSplitChangeEMPCOPERR" ref="a3b5e815e94d8a276d7b13c0dc25a8dc4" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a3b5e815e94d8a276d7b13c0dc25a8dc4">SPSnode::getBestSplitChangeEMPCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get best change in EMP under COPERR from splitting any leaf. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to use for scaling, the total number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>best (lowest or most negative) scaled change in COPERR from splitting any of the leaves. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02134">2134</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02297">getSplitChangeEMPCOPERR()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="histevalobj_8hpp_source.shtml#l00197">subpavings::CritCOPERRChange_GTE::operator()()</a>, and <a class="el" href="histevalobj_8hpp_source.shtml#l00367">subpavings::CritCOPERRMergeChange_GTE::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision bestEMPChange;
        bestEMPChange = 0.0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            bestEMPChange = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a33925f531930c000200f452209b0128c" title="Get scaled change in sum term in EMP under COPERR on split.">getSplitChangeEMPCOPERR</a>(n);
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>
            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <span class="comment">// find the best child for splitting</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* best = *(leaves.begin());

            bestEMPChange = best-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a33925f531930c000200f452209b0128c" title="Get scaled change in sum term in EMP under COPERR on split.">getSplitChangeEMPCOPERR</a>(n);

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;getSplitChangeEMPCOPERR(n) &lt; bestEMPChange) {

                    bestEMPChange = (*it)-&gt;getSplitChangeEMPCOPERR(n);
                }
            }
        } <span class="comment">// end else not a leaf</span>

        <span class="keywordflow">return</span> bestEMPChange;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7713822499beb30a3d30f43b79c608b8"></a><!-- doxytag: member="subpavings::SPSnode::getChebDistCovar" ref="a7713822499beb30a3d30f43b79c608b8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7713822499beb30a3d30f43b79c608b8">SPSnode::getChebDistCovar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Chebyshev distance for the var-covar. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a63ea0f67b354888a8a12c0ffc81b0e5e">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01561">1561</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01960">getUniformVarCovar()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01953">getVarCovar()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobj_8hpp_source.shtml#l00312">subpavings::CompCovar::operator()()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00330">subpavings::CompCovarMass::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> Covar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">getVarCovar</a>();
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> unifCovar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">getUniformVarCovar</a>();

    real ChebDist = 0;
    <span class="comment">//loop through the real vector and get the Chebyshev distances</span>
    
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        real temp = abs(Covar[i] - unifCovar[i]);
        <span class="comment">//std::cout &lt;&lt; temp &lt;&lt; &quot;\t&quot; &lt;&lt; ChebDist &lt;&lt; std::endl;</span>
        ChebDist  = ( temp &gt; ChebDist) ? temp : ChebDist;
      }
      
      <span class="comment">//cout &lt;&lt; &quot;getChebDist: &quot; &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> ChebDist;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="aa3a4a9df979f04453e82d76866b52850"></a><!-- doxytag: member="subpavings::SPSnode::getChebDistMean" ref="aa3a4a9df979f04453e82d76866b52850" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa3a4a9df979f04453e82d76866b52850">SPSnode::getChebDistMean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Chebyshev distance for the mean. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a24fc7b09a8293edce2e3b602763a45e3">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01542">1542</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01499">getMean()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01528">getUniformMean()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobj_8hpp_source.shtml#l00276">subpavings::CompMean::operator()()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00294">subpavings::CompMeanMass::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    rvector Mean = <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa5ae31017fb2fdee8b9168009d8d08a6" title="Get the sample mean.">getMean</a>();
    rvector MeanUnif = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4369d3887385551e053d3873b600f8a1" title="Get the uniform mean vector where each element is the midpoint of the coordinate.">getUniformMean</a>();
    real ChebDist = 0;
    <span class="comment">//loop through the means and get the Chebyshev distances</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        real temp = abs(Mean[i] - MeanUnif[i]);
        <span class="comment">//std::cout &lt;&lt; temp &lt;&lt; &quot;\t&quot; &lt;&lt; ChebDist &lt;&lt; std::endl;</span>
        ChebDist  = ( temp &gt; ChebDist) ? temp : ChebDist;
      }
      
      <span class="comment">//cout &lt;&lt; &quot;getChebDist: &quot; &lt;&lt; endl;</span>
      <span class="comment">//std::cout &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; getMean() &lt;&lt; &quot;\t&quot; &lt;&lt; getUniformMean() &lt;&lt; std::endl;</span>
    <span class="keywordflow">return</span> ChebDist;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="acbe47754c218f0c895a900330491cbb3"></a><!-- doxytag: member="subpavings::SPSnode::getChildrensLeftAndRightCountsIfSplit" ref="acbe47754c218f0c895a900330491cbb3" args="(Size_tVec &amp;grandchildCounts) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#acbe47754c218f0c895a900330491cbb3">SPSnode::getChildrensLeftAndRightCountsIfSplit</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td>
          <td class="paramname"><em>grandchildCounts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return a container of counts for prospective grandchildren. </p>
<p>Should be called only on leaf nodes.</p>
<p>returns an indexable container of the number of points the prospective children of each prospective child (ie all four prospective grandchildren) would be associated with, indexed like this [0] = left child's left child count, [1] = left child's rght child count, [2] = rght child's left child count, [3] = rght child's rght child count, </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">grandchildCounts</td><td>a reference to a container to be filled with the prospective grandchild counts </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>grandchildCounts filled with the prospective grandchild counts. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ad1e930cb7befb42cd1985e91f3ddd9b6">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01238">1238</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00159">MaxDiamComp()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">subpavings::AdaptiveHistogram::decisionMCMCSplit()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">try</span> {

      <span class="comment">// first find what the children&#39;s boxes would be would be</span>
      <span class="keywordtype">int</span> splitMe; <span class="comment">// variable to hold first longest dimension</span>
      ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
      <span class="keywordtype">double</span> temp1 = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(box, splitMe);

      <span class="comment">// ivectors to be new boxes for new children</span>
      ivector rCBox;
      ivector lCBox;
      
      <span class="comment">// Call Upper() to get what would be the right hand child box</span>
      <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(box, rCBox, splitMe);
      <span class="comment">// Call Lower() to get what would be the left hand child box</span>
      <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(box, lCBox, splitMe);
      
      <span class="comment">// mid point of my box on first longest dimension</span>
      cxsc::real midSplit = cxsc::mid(box[splitMe]);

      <span class="comment">// and if those children were split</span>
      <span class="comment">// left Child </span>
      <span class="keywordtype">int</span> splitChildren = <a class="code" href="toolz_8cpp.shtml#af7098b26cfe9466d751176b29c67342c" title="Return the first dimension with maximal diameter.">MaxDiamComp</a>(lCBox);
      
      cxsc::real midSplitLC = cxsc::mid(lCBox[splitChildren]);
      
      <span class="comment">// right child </span>
      <span class="comment">// will split on the same dimension as LC</span>
      
      cxsc::real midSplitRC = cxsc::mid(rCBox[splitChildren]);
      
      <span class="comment">// now find how many of this node&#39;s data points would go right</span>
      <span class="comment">// and left children of left and right children</span>
      <span class="keywordtype">size_t</span> rightRightCount = 0;
      <span class="keywordtype">size_t</span> rightLeftCount = 0;
      <span class="keywordtype">size_t</span> leftRightCount = 0;
      <span class="keywordtype">size_t</span> leftLeftCount = 0;
      <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

      <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin(); it &lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); it++) {
        <span class="comment">// DataItrs is a container of iterators to a BigDataCollection</span>
        rvector p = **it;
        <span class="comment">// increment left child?</span>
        <span class="keywordflow">if</span> ( p[splitMe] &lt; midSplit ) {
          <span class="keywordflow">if</span> ( p[splitChildren] &lt; midSplitLC ) leftLeftCount++;
          <span class="keywordflow">else</span> rightLeftCount++;
        }
        <span class="keywordflow">else</span> { <span class="comment">// on right of me</span>
          <span class="keywordflow">if</span> ( p[splitChildren] &lt; midSplitRC) leftRightCount++;
          <span class="keywordflow">else</span> rightRightCount++;
        }
      }

      grandchildCounts.push_back(leftLeftCount);
      grandchildCounts.push_back(rightLeftCount);
      grandchildCounts.push_back(leftRightCount);
      grandchildCounts.push_back(rightRightCount);


      <span class="keywordflow">return</span> grandchildCounts;
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
      <span class="keywordtype">string</span> msg = string(e.what());
      <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>(<span class="stringliteral">&quot;Error in getChildrensLeftAndRightCountsIfSplit:\n&quot;</span> + msg);
    }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ab4bee06d1b314b064d88842ba720d4a3"></a><!-- doxytag: member="subpavings::SPSnode::getCounter" ref="ab4bee06d1b314b064d88842ba720d4a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3">SPSnode::getCounter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the counter. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00997">997</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">subpavings::RealMappedSPnode::_getLogLikelihood()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="auto__tools_8cpp_source.shtml#l00035">subpavings::checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00378">subpavings::AdaptiveHistogramValidation::checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">subpavings::AdaptiveHistogram::checkNodeCountForSplit()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">subpavings::CollatorSPVnode::CollatorSPVnode()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03601">subpavings::AdaptiveHistogramValidation::get2DIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04597">subpavings::AdaptiveHistogram::get2DIAE()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01409">subpavings::SPSVnode::getEmpMass()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01581">getEmpMass()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03530">subpavings::AdaptiveHistogramValidation::getFinMixIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03895">subpavings::AdaptiveHistogram::getFinMixIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">subpavings::AdaptiveHistogramValidation::getFinMixIntervalIAE()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">subpavings::SPSVnode::getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">getHellingerDist()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01651">subpavings::SPSVnode::getHellingerDist1D()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01820">getHellingerDist1D()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00508">subpavings::RealMappedSPnode::getLogLikelihood()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02331">getMergeChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02090">getMergeChangeLogLik()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01212">getMinChildCountIfSplitNEW()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00560">subpavings::AdaptiveHistogramValidation::getMinVol()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01339">subpavings::AdaptiveHistogram::getMinVol()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01243">subpavings::AdaptiveHistogram::getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01311">subpavings::AdaptiveHistogram::getScoreAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01282">subpavings::AdaptiveHistogram::getScoreCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03854">subpavings::AdaptiveHistogram::getUnifIAE()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00060">subpavings::CompCountVal::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00061">subpavings::CompCount::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00091">subpavings::CompHeightVal::operator()()</a>, <a class="el" href="splitdecisionobj_8hpp_source.shtml#l00093">subpavings::SplitOnK::operator()()</a>, <a class="el" href="nodecompobjval_8hpp_source.shtml#l00103">subpavings::CompAreaVal::operator()()</a>, <a class="el" href="splitdecisionobj_8hpp_source.shtml#l00134">subpavings::SplitOnVolDivK::operator()()</a>, <a class="el" href="splitdecisionobj_8hpp_source.shtml#l00196">subpavings::SplitOnKandVol::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00197">subpavings::CritCOPERRChange_GTE::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00199">subpavings::CompHeight::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00210">subpavings::CompArea::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00247">subpavings::CompExtArea::operator()()</a>, <a class="el" href="histevalobj_8hpp_source.shtml#l00367">subpavings::CritCOPERRMergeChange_GTE::operator()()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">subpavings::AdaptiveHistogram::outputLog()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03571">subpavings::AdaptiveHistogram::outputToTxtTabsWithEMPs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00108">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">subpavings::AdaptiveHistogram::recalcScaledEMPSumAIC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">subpavings::AdaptiveHistogram::recalcScaledEMPSumCOPERR()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02613">spsContains()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a4285801767cd577432a0b13cdbdaba43"></a><!-- doxytag: member="subpavings::SPSnode::getCountsOnly" ref="a4285801767cd577432a0b13cdbdaba43" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#a4285801767cd577432a0b13cdbdaba43">SPSnode::getCountsOnly</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the countsOnly value. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01009">1009</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00418">countsOnly</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a8906934b09d85e67c49d38548e0cd38a"></a><!-- doxytag: member="subpavings::SPSnode::getData" ref="a8906934b09d85e67c49d38548e0cd38a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> <a class="el" href="classsubpavings_1_1SPSnode.shtml#a8906934b09d85e67c49d38548e0cd38a">SPSnode::getData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the node's data collection. </p>
<p>Returns a copy of the node's collection of iterators to the big data set. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01014">1014</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02613">spsContains()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="aa939623d58172bc7f24ddf5dd249b5c2"></a><!-- doxytag: member="subpavings::SPSnode::getEMPContributionAIC" ref="aa939623d58172bc7f24ddf5dd249b5c2" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa939623d58172bc7f24ddf5dd249b5c2">SPSnode::getEMPContributionAIC</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get this node's scaled contribution to EMP under AIC. </p>
<p>Under AIC, EMP is -1 x sum over leaves of (counts in leaf x ln(count in leaf / (n * vol of leaf))) where n is the total number of data points in the histogram. And this is -1 * the node's contribution to the loglikelihood of the data given the current state.</p>
<p>Should only be called on leaf nodes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to use for scaling, the total number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>counter * (-ln(counter/(n*volume))) for this node. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02291">2291</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l02028">getLogLik()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02543">getEMPSumAIC()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> -<a class="code" href="classsubpavings_1_1SPSnode.shtml#a45f10ce1371120a0c1be29fa0ad8bac5" title="Get this leaf node&#39;s contribution to loglikelihood.">getLogLik</a>(n);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a483f3b91707cda0deaee7a05d0523f3b"></a><!-- doxytag: member="subpavings::SPSnode::getEMPContributionCOPERR" ref="a483f3b91707cda0deaee7a05d0523f3b" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#a483f3b91707cda0deaee7a05d0523f3b">SPSnode::getEMPContributionCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get this node's scaled contribution to EMP under COPERR. </p>
<p>Under COPERR, EMP is -1/n^2 x sum over leaves of (counts in leaf squared / volume of leaf) where n is the total number of data points in the histogram Should only be called on leaf nodes </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to use for scaling, the total number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-counter^2/(n*volume) for this node. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02272">2272</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02519">getEMPSumCOPERR()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// current number of data points associated to node is counter</span>
        <span class="comment">// current node volume from nodeVolume, and each child will have half</span>

        dotprecision contribution(0.0);
        <span class="keywordflow">if</span> ((n &gt; 0) &amp;&amp; (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0)) {
            accumulate(contribution, -(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>)/(1.0*n),
                    (1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>)/(n*<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
        }

        <span class="comment">// contribution is -counter^2/(n^2 * vol)</span>
        <span class="comment">// default cxsc rounding to nearest</span>

        <span class="comment">//return contribution;</span>
        <span class="keywordflow">return</span> rnd(contribution);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a31ee93bb53be29fd0e50ff7fcd189c98"></a><!-- doxytag: member="subpavings::SPSnode::getEmpMass" ref="a31ee93bb53be29fd0e50ff7fcd189c98" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPSnode.shtml#a31ee93bb53be29fd0e50ff7fcd189c98">SPSnode::getEmpMass</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the empirical mass of the node </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#afb9e32e6d78db527309d95ccc8c0049f">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01581">1581</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01485">getRootCounter()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobj_8hpp_source.shtml#l00294">subpavings::CompMeanMass::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00330">subpavings::CompCovarMass::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00366">subpavings::CompHellingerDist1DMass::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00385">subpavings::CompHellingerDist1DMassDiam::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00409">subpavings::CompHellingerDistMass::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00428">subpavings::CompHellingerDistMassDiam::operator()()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00451">subpavings::CompVolInv::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1SPSnode.shtml#aeac2247b4626b1adfa609d3ff109ceb2" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
    <span class="keywordtype">double</span> empMass = (<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>()*1.0)/(1.0*n);
    <span class="comment">//cout &lt;&lt; nodeName &lt;&lt; &quot;\t&quot; &lt;&lt; empMass &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> empMass;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a26329c8ddf55f351a673fe258e5abd15"></a><!-- doxytag: member="subpavings::SPSnode::getEMPSumAIC" ref="a26329c8ddf55f351a673fe258e5abd15" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a26329c8ddf55f351a673fe258e5abd15">SPSnode::getEMPSumAIC</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the unscaled EMP sum under AIC for tree rooted at this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the total number of points in the histogram, for scaling </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02543">2543</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l02291">getEMPContributionAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02543">getEMPSumAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02543">getEMPSumAIC()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00358">subpavings::AdaptiveHistogram::recalcScaledEMPSumAIC()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision retValue;
        retValue = 0.0;

        <span class="comment">// uses  member function getEMPContributionAIC for leaf result</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa939623d58172bc7f24ddf5dd249b5c2" title="Get this node&#39;s scaled contribution to EMP under AIC.">getEMPContributionAIC</a>(n);
        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            retValue+=<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a26329c8ddf55f351a673fe258e5abd15" title="Get the unscaled EMP sum under AIC for tree rooted at this.">getEMPSumAIC</a>(n);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            retValue+=<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a26329c8ddf55f351a673fe258e5abd15" title="Get the unscaled EMP sum under AIC for tree rooted at this.">getEMPSumAIC</a>(n);
        }
        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad8b17faf69caa46fcfa021b61d09e278"></a><!-- doxytag: member="subpavings::SPSnode::getEMPSumCOPERR" ref="ad8b17faf69caa46fcfa021b61d09e278" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad8b17faf69caa46fcfa021b61d09e278">SPSnode::getEMPSumCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get scaled EMP sum under COPERR for tree rooted at this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the total number of points in the histogram, for scaling </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02519">2519</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l02272">getEMPContributionCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02519">getEMPSumCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02519">getEMPSumCOPERR()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00350">subpavings::AdaptiveHistogram::recalcScaledEMPSumCOPERR()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision retValue;
        retValue = 0.0;

        <span class="comment">// uses  member function getEMPContributionCOPERR for leaf value</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a483f3b91707cda0deaee7a05d0523f3b" title="Get this node&#39;s scaled contribution to EMP under COPERR.">getEMPContributionCOPERR</a>(n);
        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            retValue = retValue + <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ad8b17faf69caa46fcfa021b61d09e278" title="Get scaled EMP sum under COPERR for tree rooted at this.">getEMPSumCOPERR</a>(n);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            retValue = retValue + <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ad8b17faf69caa46fcfa021b61d09e278" title="Get scaled EMP sum under COPERR for tree rooted at this.">getEMPSumCOPERR</a>(n);
        }

        <span class="keywordflow">return</span> retValue;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa0ea6455e40f7f2bdb1e972ab080f5a5"></a><!-- doxytag: member="subpavings::SPSnode::getHellingerDist" ref="aa0ea6455e40f7f2bdb1e972ab080f5a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa0ea6455e40f7f2bdb1e972ab080f5a5">SPSnode::getHellingerDist</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Bhattarchaya coefficient. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2e0a1a393daed9e3f5887162b68b0e6e">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01591">1591</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01499">getMean()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">getRootCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01528">getUniformMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01960">getUniformVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01953">getVarCovar()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobj_8hpp_source.shtml#l00409">subpavings::CompHellingerDistMass::operator()()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00428">subpavings::CompHellingerDistMassDiam::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">   {
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> Covar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">getVarCovar</a>(); <span class="comment">//get the covariance matrix/</span>
    real HD = 0.0; <span class="comment">//initialize hellinger distance to 0.</span>

    <span class="comment">// if there are no points, cov should be undefined. But since we want to push</span>
    <span class="comment">// this node to the bottom of the queue, hence let HD = 0.</span>
    <span class="comment">// if there is one point, the variance is 0. At the moment, we do not </span>
    <span class="comment">// want to split boxes with only one point and so also let HD = 0.</span>
    <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() == 0 || <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() == 1 ) { <span class="keywordflow">return</span> HD = 0.0; } 

    <span class="keywordflow">else</span> {
  <span class="comment">//    cout &lt;&lt; &quot;===========================&quot; &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; getCounter() &lt;&lt; endl;</span>
      <span class="comment">//get the differences of the mean vectors</span>
      rvector diffMean = <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa5ae31017fb2fdee8b9168009d8d08a6" title="Get the sample mean.">getMean</a>() - <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4369d3887385551e053d3873b600f8a1" title="Get the uniform mean vector where each element is the midpoint of the coordinate.">getUniformMean</a>();
      <span class="comment">//cout &lt;&lt; &quot;mean differences: &quot; &lt;&lt; diffMean &lt;&lt; endl;</span>

      <span class="comment">//make a gsl matrix for the mean difference</span>
      gsl_matrix * diffMeanMat = gsl_matrix_alloc(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>, 1);
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 1; j++) {
          gsl_matrix_set (diffMeanMat, i, j, _double(diffMean[i+1]));
        }
      }

      <span class="comment">// get the variances</span>
      <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> unifCovar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">getUniformVarCovar</a>();

      <span class="comment">// initialize matrix objects</span>
      gsl_matrix * CovarMat = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * CovarMatMult = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * UnifCovarMat = gsl_matrix_alloc(dimension, dimension);
      gsl_matrix * PMat = gsl_matrix_alloc(dimension, dimension); <span class="comment">//make this same as</span>
                                              <span class="comment">//CovarMat first</span>
      <span class="keywordtype">int</span> n = <a class="code" href="classsubpavings_1_1SPSnode.shtml#aeac2247b4626b1adfa609d3ff109ceb2" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
    
      <span class="comment">// problem with stably inverting the covariance matrix - if determinant is wrong, will get -DB</span>
      <span class="comment">// fill up the matrics for the var-covar</span>
      <span class="keywordtype">int</span> k = 0; <span class="comment">//counter for RealVec</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {

          <span class="keywordflow">if</span> ( i == j ) {
            gsl_matrix_set(CovarMat, i, j, _double(Covar[k]) + 0.00000001); <span class="comment">//cast to double</span>
            gsl_matrix_set(CovarMatMult, i, j, 100*(_double(Covar[k]))+0.00000001);
          }
          <span class="keywordflow">else</span> {
            gsl_matrix_set(CovarMat, i, j, _double(Covar[k])); <span class="comment">//cast to double</span>
            gsl_matrix_set(CovarMatMult, i, j, 100*(_double(Covar[k])));
          }
          
          gsl_matrix_set(PMat, i, j, _double(Covar[k])); <span class="comment">//cast to double</span>
          gsl_matrix_set(UnifCovarMat, i, j, _double(unifCovar[k])); <span class="comment">//cast to double</span>
          k++;
        }
      }

      <span class="comment">// if variance is -ve, atomic data points? treat as only one point (not</span>
      <span class="comment">// a very good assumption at the moment) and let HD = 0. </span>
      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
          <span class="keywordflow">if</span> ( (i == j) &amp;&amp; (gsl_matrix_get(CovarMat, i, j) &lt; 0) ) {
            cerr &lt;&lt; <span class="stringliteral">&quot;Negative variance!&quot;</span> &lt;&lt; endl;
            cout.precision(20);
            cout &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &lt;&lt; endl;
            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr;
            cout &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; endl;
            cout.precision(20);
            cout &lt;&lt; <span class="stringliteral">&quot;Data is&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin();
              dataItr!= <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); dataItr++) {
              <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *dataItr;
              rvector theData = *bigIt;
              cout &lt;&lt; theData &lt;&lt; endl; 
            } <span class="comment">// end loop through data container</span>
        
            <span class="comment">//cerr &lt;&lt; &quot;Variance cannot be negative.&quot; &lt;&lt; endl; </span>
            <span class="comment">//exit(1); </span>
            
            
            <span class="comment">//gsl_matrix_free(CovarMat);</span>
            <span class="comment">//gsl_matrix_free(UnifCovarMat);</span>
            <span class="comment">//gsl_matrix_free(PMat);</span>
            <span class="keywordflow">return</span> HD = 0.0;
             
          }
        }
      }
  
      <span class="comment">//else {</span>
        <span class="comment">/*cout &lt;&lt; &quot;CovarMat: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(CovarMat, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }</span>
<span class="comment">        cout &lt;&lt; &quot;CovarMatMult: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(CovarMatMult, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }</span>
<span class="comment">        cout &lt;&lt; &quot;UnifCovarMat: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(UnifCovarMat, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }   </span>
<span class="comment">          */</span>
        <span class="comment">//add the two matrices</span>
        gsl_matrix_add(PMat, UnifCovarMat);
        gsl_matrix_scale(PMat, 0.5);
        
        gsl_matrix * PMatForInv = gsl_matrix_alloc(dimension, dimension);
        PMatForInv = PMat; 
        <span class="comment">/*cout &lt;&lt; &quot;PMat: &quot; &lt;&lt; endl;</span>
<span class="comment">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="comment">          for (int j=0; j &lt; dimension; j++) {</span>
<span class="comment">            cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(PMat, i, j) &lt;&lt; endl; </span>
<span class="comment">          }</span>
<span class="comment">        }*/</span>

        <span class="comment">// get the determinants of CovarMat, UnifCovarMat, PMat</span>
        <span class="keywordtype">int</span> s;
        gsl_permutation * p = gsl_permutation_alloc(dimension);
        gsl_linalg_LU_decomp(CovarMatMult, p, &amp;s);
        <span class="comment">//cout &lt;&lt; &quot;CovarMat LU decomp: &quot; &lt;&lt; endl;</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
            <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(CovarMat, i, j) &lt;&lt; endl; </span>
          }
        }
        <span class="keywordtype">double</span> detCovarMat = gsl_linalg_LU_det(CovarMatMult, s)/(<a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(100,dimension));
        <span class="comment">//cout &lt;&lt; &quot;det covar mat: &quot; &lt;&lt; detCovarMat &lt;&lt; &quot;\t&quot; &lt;&lt; endl;</span>
        gsl_permutation_free(p);
        <span class="comment">// it is possible to get negative determinants, and negative DB, temporarily sweeping this under the rug </span>
        <span class="keywordflow">if</span> (detCovarMat &lt; 0) { cout &lt;&lt; <span class="stringliteral">&quot;Negative determinant.&quot;</span> &lt;&lt; endl; exit(1); }<span class="comment">//return HD = 0.0; }</span>
        <span class="keywordflow">else</span> {
          
          <span class="keywordtype">int</span> s1;
          gsl_permutation * p1 = gsl_permutation_alloc(dimension);
          gsl_linalg_LU_decomp(UnifCovarMat, p1, &amp;s1);
          <span class="comment">//cout &lt;&lt; &quot;UnifCovarMat decomp: &quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(UnifCovarMat, i, j) &lt;&lt; endl; </span>
            }
          }
          <span class="keywordtype">double</span> detUnifCovarMat = gsl_linalg_LU_det(UnifCovarMat, s1);
          <span class="comment">//cout &lt;&lt; &quot;det unif covar mat: &quot; &lt;&lt; detUnifCovarMat &lt;&lt; endl;</span>
          gsl_permutation_free(p1);

          <span class="keywordtype">int</span> s2;
          gsl_permutation * p2 = gsl_permutation_alloc(dimension);
          gsl_linalg_LU_decomp(PMat, p2, &amp;s2);
          <span class="keywordtype">double</span> detPMat = gsl_linalg_LU_det(PMat, s2);
          <span class="comment">//cout &lt;&lt; &quot;det p mat: &quot; &lt;&lt; detPMat &lt;&lt; endl;</span>
  
          <span class="comment">//now get the inverse of P</span>
          gsl_matrix * Pinverse = gsl_matrix_alloc(dimension, dimension); 
          gsl_linalg_LU_invert(PMat, p2, Pinverse);
          gsl_permutation_free(p2);
          <span class="comment">//cout &lt;&lt; &quot;p inverse &quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_matrix_get(Pinverse, i, j) &lt;&lt; endl; </span>
            }
          }
      
          <span class="comment">//now get the Bhattacharya coefficient</span>
          <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
          gsl_matrix * diffMeanMatTranspose = gsl_matrix_alloc(1, dimension);
          gsl_matrix_transpose_memcpy(diffMeanMatTranspose, diffMeanMat);
        
          <span class="comment">// now convert all to rmatrix for easier computations</span>
          rmatrix diffMeanR(0, dimension-1, 0, 0);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 1; j++) {
              diffMeanR[i][j] = gsl_matrix_get(diffMeanMat, i, j); 
            }
          }
        
          rmatrix diffMeanTransR(0, 0, 0, dimension-1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              diffMeanTransR[i][j] = gsl_matrix_get(diffMeanMatTranspose, i, j); 
            }
          }
        
          rmatrix PinvR(0, dimension-1, 0, dimension-1);
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
              PinvR[i][j] = gsl_matrix_get(Pinverse, i, j); 
            }
          }
        
          <span class="comment">//free the gsl_matrices</span>
          gsl_matrix_free(CovarMat);
          gsl_matrix_free(UnifCovarMat);
          gsl_matrix_free(PMat);
        
          <span class="comment">//cout &lt;&lt; diffMeanR &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; diffMeanTransR &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; PinvR &lt;&lt; endl;</span>
        
          <span class="comment">//now get the Bhattacharya coefficient</span>
          <span class="comment">//DB = 1.0/8.0 * diffMeanMat1 * invP * diffMeanMat2 + 0.5*log(detP/sqrt{detP1}{detP2});</span>
          <span class="comment">//cout &lt;&lt; (diffMeanTransR*PinvR)*diffMeanR &lt;&lt; endl;</span>
          rmatrix MatOp = (diffMeanTransR*PinvR)*diffMeanR;
          <span class="comment">//cout &lt;&lt; MatOp &lt;&lt; &quot;\t&quot; &lt;&lt; MatOp[0][0] &lt;&lt; endl;</span>
          assert(MatOp &gt;= 0);
          real DB = 1.0/8.0 * MatOp[0][0] + 0.5*log(detPMat/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(detCovarMat*detUnifCovarMat));
          <span class="comment">//cout &lt;&lt; &quot;DB: &quot; &lt;&lt; DB &lt;&lt; endl;</span>
          <span class="keywordflow">if</span> (DB &lt; 0) { <span class="keywordflow">return</span> HD = 0.0; }
          <span class="keywordflow">else</span> {
            real BC = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-DB);
            assert(BC &gt;= 0);
          <span class="comment">//cout &lt;&lt; &quot;BC: &quot; &lt;&lt; BC &lt;&lt; endl;</span>
            real HD = <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1-BC);
          <span class="comment">//cout &lt;&lt; &quot;HD: &quot; &lt;&lt; HD &lt;&lt; endl;</span>
            assert(HD &gt;=0);
            <span class="keywordflow">return</span> HD;
          }
        } <span class="comment">// end of determinant is not zero</span>
      }
  }   
</pre></div>
</div>
</div>
<a class="anchor" id="afe386393d18f1e251972e959e79c3847"></a><!-- doxytag: member="subpavings::SPSnode::getHellingerDist1D" ref="afe386393d18f1e251972e959e79c3847" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#afe386393d18f1e251972e959e79c3847">SPSnode::getHellingerDist1D</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3b56f3b8a024ab6929087e803e7af765">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01820">1820</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01499">getMean()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01528">getUniformMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01960">getUniformVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01953">getVarCovar()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="nodecompobj_8hpp_source.shtml#l00348">subpavings::CompHellingerDist1D::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00366">subpavings::CompHellingerDist1DMass::operator()()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00385">subpavings::CompHellingerDist1DMassDiam::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">   {
    real HD = 0.0; 
    <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> Covar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">getVarCovar</a>();

    <span class="comment">// if the variance is negative - need to investiage this more</span>
    
    <span class="keywordflow">if</span> (Covar[0] &lt; 0) {
      cout &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() &lt;&lt; endl;
      cout &lt;&lt; Covar[0] &lt;&lt; endl;
      <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr;
      cout &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a930afc65b88ca963bb94d849a0e8c3db" title="Get the node name.">getNodeName</a>() &lt;&lt; endl;
      cout.precision(20);
      cout &lt;&lt; <span class="stringliteral">&quot;Data is&quot;</span> &lt;&lt; std::endl;
          <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin();
                dataItr!= <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); dataItr++) {

                <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *dataItr;
                rvector theData = *bigIt;

                cout &lt;&lt; theData &lt;&lt; endl; 
      } <span class="comment">// end loop through data container</span>
      
      cerr &lt;&lt; <span class="stringliteral">&quot;Variance cannot be negative.&quot;</span> &lt;&lt; endl; 
    <span class="comment">//  exit(1);</span>
      <span class="keywordflow">return</span> HD = 0.0; 
    }

    <span class="comment">// can continue if variance is not negative</span>

      <span class="comment">// if there are no points, should be undefined. But since we want to push</span>
      <span class="comment">// this node to the bottom of the queue, hence let HD = 0.</span>
      <span class="comment">// if there is one point, the variance is 0. At the moment, we do not </span>
      <span class="comment">//want to split boxes with only one point and so also let HD = 0.</span>
      <span class="comment">// if variance is -ve, atomic data points? treat as only one point (not</span>
      <span class="comment">// a very good assumption at the moment) and let HD = 0. </span>
      <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>() == 0  || Covar[0] &lt;= 0 ) { <span class="keywordflow">return</span> HD = 0.0; } 
      <span class="comment">/*else if ( Covar[0] == 0 ) { </span>
<span class="comment">        cout &lt;&lt; getCounter() &lt;&lt; endl;</span>
<span class="comment">        cout &lt;&lt; getEmpMass() &lt;&lt; endl;</span>
<span class="comment">        cout &lt;&lt; nodeVolume() &lt;&lt; endl;</span>
<span class="comment">        cout &lt;&lt; getMean() &lt;&lt; endl;</span>
<span class="comment">        //cerr &lt;&lt; &quot;no variance. check!&quot; &lt;&lt; endl;</span>
<span class="comment">        //exit(1);</span>
<span class="comment">      }*/</span>

      <span class="keywordflow">else</span> {
        <span class="comment">//get the differences of the mean vectors</span>
        rvector diffMean = <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa5ae31017fb2fdee8b9168009d8d08a6" title="Get the sample mean.">getMean</a>() - <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4369d3887385551e053d3873b600f8a1" title="Get the uniform mean vector where each element is the midpoint of the coordinate.">getUniformMean</a>();
        <span class="comment">//cout &lt;&lt; &quot;mean differences: &quot; &lt;&lt; diffMean[1] &lt;&lt; endl;</span>
        
        <span class="comment">// get the variances</span>
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> unifCovar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">getUniformVarCovar</a>();
        <span class="comment">//cout &lt;&lt; &quot;Covar: &quot; &lt;&lt; Covar[0] &lt;&lt;  endl;</span>
        <span class="comment">//cout &lt;&lt; &quot;unifCovar: &quot; &lt;&lt; unifCovar[0] &lt;&lt; endl;</span>
        <span class="comment">//if all the elements for CovarMat are all zero, we do not have any points in </span>
        <span class="comment">//this leaf node - so return hellinger distance as 0</span>
  
        <span class="comment">// use the sqrt of the squared hellinger distance for two normal distributions</span>
        <span class="comment">// 1 - sqrt(2*sigma1*sigma2/(sigma1^2 + sigma2^2))*exp(-0.25*(mu1-mu2)^2/(sigma1^2+sigma2^2))</span>
        <span class="comment">//cout &lt;&lt; diffMean &lt;&lt; &quot;\t&quot;;</span>
        interval covarI = interval(Covar[0]);
        interval unifCovarI = interval(unifCovar[0]);
        interval sumVar = covarI + unifCovarI;
        <span class="comment">//cout &lt;&lt; sumVar &lt;&lt; &quot;\t&quot;;</span>
        interval insqrt = 2*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(covarI)*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(unifCovarI)/sumVar;
        <span class="comment">//cout &lt;&lt; insqrt &lt;&lt; &quot;\t&quot;;</span>
        interval H2 = interval(1,1) - <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(insqrt) *<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>((-0.25*diffMean[1]*diffMean[1])/sumVar);
        <span class="comment">//cout &lt;&lt; &quot;H2: &quot; &lt;&lt; H2 &lt;&lt; endl;</span>
        HD = mid(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(H2));
        <span class="comment">//cout &lt;&lt; HD &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( HD &gt; 1 || HD &lt; 0) { 
          cerr &lt;&lt; <span class="stringliteral">&quot;HD should be between 0 and 1.&quot;</span> &lt;&lt; endl;
          exit(0);
        }
        <span class="keywordflow">return</span> HD;
      }

  }
</pre></div>
</div>
</div>
<a class="anchor" id="ae094573d2988d458e00a549039a6ad56"></a><!-- doxytag: member="subpavings::SPSnode::getLargestLeafCount" ref="ae094573d2988d458e00a549039a6ad56" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#ae094573d2988d458e00a549039a6ad56">SPSnode::getLargestLeafCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the count in the leaf with the smallest count. </p>
<p>Returns the count of the largest (by count) leaf node. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#adfb30c9946f868e143c81e6bf35a7a6f">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01454">1454</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> largestCount = 0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            largestCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>

            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <span class="comment">// could be just this if no children</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <span class="comment">// find the largest child by volume</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;
            largestCount = (*(leaves.begin()))-&gt;counter;

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;counter &gt; largestCount) {
                    largestCount = (*it)-&gt;counter;
                }
            }
        } <span class="comment">// end else not a leaf</span>

        <span class="keywordflow">return</span> largestCount;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2f8ce829fd9ba3ef3838d640ae201e9e"></a><!-- doxytag: member="subpavings::SPSnode::getLeafNodeCounts" ref="a2f8ce829fd9ba3ef3838d640ae201e9e" args="(Size_tVec &amp;counts) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a2f8ce829fd9ba3ef3838d640ae201e9e">SPSnode::getLeafNodeCounts</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a612fc5639b45583b9fd33bd304354f81">Size_tVec</a> &amp;&#160;</td>
          <td class="paramname"><em>counts</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fills in container of leaf counts, left to right.</p>
<p>Traverses the leaves left to right, puts the leaf counts into container.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">counts</td><td>is reference to the container to fill in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the container filled in with leaf counts. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0d6df4752e05170510e43b67d8eb3110">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01308">1308</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01308">getLeafNodeCounts()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03516">subpavings::AdaptiveHistogram::getLeafCounts()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01308">getLeafNodeCounts()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2f8ce829fd9ba3ef3838d640ae201e9e">getLeafNodeCounts</a>(counts);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2f8ce829fd9ba3ef3838d640ae201e9e">getLeafNodeCounts</a>(counts);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

            counts.push_back(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>);
        }
        <span class="keywordflow">return</span> counts;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6a833240b503da0e2b640782e8671954"></a><!-- doxytag: member="subpavings::SPSnode::getLeaves" ref="a6a833240b503da0e2b640782e8671954" args="(SPSnodePtrs &amp;leaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954">SPSnode::getLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to all descendent leaf nodes. </p>
<p>Will be just this if this is a leaf.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of node pointers. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6f3850e716947e051a9e9af16c2b4508">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01328">1328</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>.</p>

<p>Referenced by <a class="el" href="multitreemanager_8cpp_source.shtml#l00114">MultiTreeManager::addToOutcomeSpace()</a>, <a class="el" href="multitreemanager_8cpp_source.shtml#l00058">MultiTreeManager::addToOutcomeSpaceAndGraph()</a>, <a class="el" href="MCMCGR_8cpp_source.shtml#l00140">doMCMCGRAuto()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04629">subpavings::AdaptiveHistogram::findDensityRegion()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02169">getBestSplitChangeEMPAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02134">getBestSplitChangeEMPCOPERR()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03650">subpavings::AdaptiveHistogram::getEstLogLikelihoodFromRSSample()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03970">subpavings::AdaptiveHistogram::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04206">subpavings::AdaptiveHistogram::getLaplaceIntervalIAE()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01454">getLargestLeafCount()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04402">subpavings::AdaptiveHistogram::getLognormalIntervalIAE()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01422">getSmallestLeafCount()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01394">getSumLeafCountOverVol()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03774">subpavings::AdaptiveHistogram::getUnifIAE()</a>, <a class="el" href="Coverage_8cpp_source.shtml#l00051">main()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03638">subpavings::AdaptiveHistogram::makeEmpty()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">subpavings::AdaptiveHistogram::MCMCsamples()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
            leaves.push_back(const_cast&lt;SPSnode*&gt;(<span class="keyword">this</span>));
        }
        <span class="keywordflow">return</span> leaves;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af7588b657e2819dd5dda525e08143ffc"></a><!-- doxytag: member="subpavings::SPSnode::getLeftChild" ref="af7588b657e2819dd5dda525e08143ffc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc">SPSnode::getLeftChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the left child of a node. </p>
<p>Hides the base class version of this method.</p>
<p>Returns a copy of the pointer to leftChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3ef0b662df21eb88689644cb5d1279d2">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01034">1034</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">subpavings::RealMappedSPnode::_getLogLikelihood()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="auto__tools_8cpp_source.shtml#l00035">subpavings::checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">subpavings::AdaptiveHistogram::checkNodeCountForSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01048">checkTreeStateLegal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01348">getAllNodes()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02543">getEMPSumAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02519">getEMPSumCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01308">getLeafNodeCounts()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02331">getMergeChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02090">getMergeChangeLogLik()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01212">getMinChildCountIfSplitNEW()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">getSubLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02403">leavesOutputTabs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">leavesOutputTabsWithEMPs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02466">leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02488">leavesOutputTabsWithHistHeightAndEMPs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00108">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02613">spsContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">SPSnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00554">unionNoData()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="ad077233e00a7093d66e35cca6fc6db6b"></a><!-- doxytag: member="subpavings::SPSnode::getLeftCountIfSplit" ref="ad077233e00a7093d66e35cca6fc6db6b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad077233e00a7093d66e35cca6fc6db6b">SPSnode::getLeftCountIfSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The count the left child would have if this node was split. </p>
<p>Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the left child if the node were to be split.</p>
<p>Note that the left child's interval on the split dimension would be an open interval. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a64b5d63790c02a454aa0e86222b1a3d3">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01170">1170</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00159">MaxDiamComp()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01198">getMinChildCountIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01212">getMinChildCountIfSplitNEW()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02297">getSplitChangeEMPCOPERR()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02044">getSplitChangeLogLik()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  <span class="comment">// first find what the dimension for the split would be </span>
  <span class="comment">// if the split were made</span>
  <span class="comment">// right hand child&#39;s box would be if that child</span>
  <span class="comment">// were to be created</span>
  cxsc::ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
  
  <span class="keywordtype">int</span> split = <a class="code" href="toolz_8cpp.shtml#af7098b26cfe9466d751176b29c67342c" title="Return the first dimension with maximal diameter.">MaxDiamComp</a>(box);
  
  cxsc::real midSplit = cxsc::mid(box[split]);

  <span class="comment">// left child would have everything up to but not including</span>
  <span class="comment">// midSplit, on the split dimension</span>
  <span class="keywordtype">size_t</span> leftCount = 0;
  <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

  <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin(); it &lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); it++) {
    <span class="comment">// DataItrs is a container of iterators to a BigDataCollection</span>
    <span class="comment">// increment rightCount if the point is in rC</span>
    <span class="keywordflow">if</span>(  (**it)[split] &lt; midSplit ) leftCount++;
  }

  <span class="keywordflow">return</span> leftCount;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a45f10ce1371120a0c1be29fa0ad8bac5"></a><!-- doxytag: member="subpavings::SPSnode::getLogLik" ref="a45f10ce1371120a0c1be29fa0ad8bac5" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#a45f10ce1371120a0c1be29fa0ad8bac5">SPSnode::getLogLik</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get this leaf node's contribution to loglikelihood. </p>
<p>A leaf node's contribution to the log likelihood of overall state given the data is (count in leaf x ln(count in leaf / (n * vol of leaf))) where n is the total number of data points in the histogram.</p>
<p>Should only be called on leaf nodes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to use for scaling, the total number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>counter * (ln(counter/(n*volume))) for this node. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02028">2028</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02291">getEMPContributionAIC()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// contribution to loglikelihood is counter*log(counter/(n * vol))</span>

        dotprecision contribution(0.0);
        <span class="keywordflow">if</span> ((n &gt; 0) &amp;&amp; (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0)) {

            accumulate(contribution, 1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, log(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>));
            accumulate(contribution, -1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, log(1.0*n));
            accumulate(contribution, -1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, log(<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
        }
        <span class="comment">// default cxsc rounding to nearest</span>
        <span class="keywordflow">return</span> rnd(contribution);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa5ae31017fb2fdee8b9168009d8d08a6"></a><!-- doxytag: member="subpavings::SPSnode::getMean" ref="aa5ae31017fb2fdee8b9168009d8d08a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa5ae31017fb2fdee8b9168009d8d08a6">SPSnode::getMean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sample mean. </p>
<p>This calculates the sample mean from the accumulators for the sums of data point elements. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2d2b97cb6916b19ad2affc4907265b6f">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01499">1499</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">countsOnly</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00344">dpSums</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01542">getChebDistMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01820">getHellingerDist1D()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01227">subpavings::AdaptiveHistogram::getRootPavingMean()</a>.</p>
<div class="fragment"><pre class="fragment">    {
       <span class="comment">// cout &lt;&lt; &quot;Get Mean for &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
    <span class="comment">//  cout &lt;&lt; getCountsOnly() &lt;&lt; &quot;\t&quot; &lt;&lt; getCounter() &lt;&lt; endl;</span>
      
        <span class="comment">// set up an rvector retMean of the correct dimensions</span>
        rvector retMean(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);
        <span class="comment">// loop through the elements in the dpSums vector</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {

            <span class="comment">// if no data elements each element or if only counts are held,</span>
            <span class="comment">// that element of the mean is 0.0</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> || (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> == 0)) {
                <span class="comment">// cxsc::rvector is indexed 1 to n</span>
                retMean[i+1] = 0.0;
            }
            <span class="comment">// if data elements, find the element-by-element mean</span>
            <span class="keywordflow">else</span> {
                <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
                retMean[i+1] = rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i])/(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>);
            }
        }<span class="comment">// end loop through the elements in dpSums</span>

        <span class="keywordflow">return</span> retMean;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a42114089fcad779bec855496154ded19"></a><!-- doxytag: member="subpavings::SPSnode::getMergeChangeEMPAIC" ref="a42114089fcad779bec855496154ded19" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a42114089fcad779bec855496154ded19">SPSnode::getMergeChangeEMPAIC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get change in sum term in EMP under AIC on merge. </p>
<p>Under AIC, EMP is -1 x sum over leaves of (counts in leaf x ln(count in leaf / (n * volume of leaf))) where n is the total number of data points in the histogram.</p>
<p>Should only be called on subleaf nodes (two leaf children)</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node were merged. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02360">2360</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l02090">getMergeChangeLogLik()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02239">getBestMergeChangeEMPAIC()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00175">subpavings::CompEMPSumChangeMergeAIC::operator()()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> -<a class="code" href="classsubpavings_1_1SPSnode.shtml#a9fd3a2a06ee14b5d5c307a2c7d795cef" title="Get change in log likelihood on merge of this&#39; leaf chidren.">getMergeChangeLogLik</a>();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2c8cc31ffdb9c74b82cce176c8d14585"></a><!-- doxytag: member="subpavings::SPSnode::getMergeChangeEMPCOPERR" ref="a2c8cc31ffdb9c74b82cce176c8d14585" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a2c8cc31ffdb9c74b82cce176c8d14585">SPSnode::getMergeChangeEMPCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get scaled change in sum term in EMP under COPERR on merge. </p>
<p>Under COPERR, EMP is -1/n^2 x sum over leaves of (counts in leaf squared / (n * volume of leaf)) where n is the total number of data points in the histogram.</p>
<p>Should only be called on subleaf nodes (two leaf children).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to use for scaling, the total number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the change in the sum over leaves of (counts in leaf squared over (n * volume of leaf) which would result if this node were merged. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02331">2331</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02204">getBestMergeChangeEMPCOPERR()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00145">subpavings::CompEMPSumChangeMergeCOPERR::operator()()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// first find what the left hand child&#39;s counter is</span>
        <span class="keywordtype">size_t</span> leftCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();

        <span class="comment">// and right child</span>
        <span class="keywordtype">size_t</span> rightCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();

        <span class="comment">// current number of data points associated to node is counter</span>
        <span class="comment">// current node volume from nodeVolume, and each child will have half</span>

        <span class="comment">// change is 1/(n^2 * vol) x (2(lc_count^2 + rc_count^2) - counter^2)</span>
        <span class="comment">// Change is scaled by n, total points in histogram</span>
        dotprecision change;
        change = 0.0;
        <span class="keywordflow">if</span> (n &gt; 0) {
            accumulate(change, (1.0*leftCount)/(1.0*n),
                                (2.0*leftCount)/(n*<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
            accumulate(change, (1.0*(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - leftCount))/(1.0*n),
                                (2.0*(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - leftCount))/(n*<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
            accumulate(change, -(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>)/(n*<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()),
                                    (1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>)/(1.0*n));
        }
        <span class="keywordflow">return</span> change;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a9fd3a2a06ee14b5d5c307a2c7d795cef"></a><!-- doxytag: member="subpavings::SPSnode::getMergeChangeLogLik" ref="a9fd3a2a06ee14b5d5c307a2c7d795cef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a9fd3a2a06ee14b5d5c307a2c7d795cef">SPSnode::getMergeChangeLogLik</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get change in log likelihood on merge of this' leaf chidren. </p>
<p>log likelihood is sum over leaves of (counts in leaf x ln(count in leaf / (n * volume of leaf))) where n is the total number of data points in the histogram.</p>
<p>Should only be called on cherry leaf nodes (two leaf children).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node's leaf chilren were merged back into this. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02090">2090</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02360">getMergeChangeEMPAIC()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision change;
        change = 0.0;

        <span class="comment">// if counter is 0 there can be no change on merging</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0) {

            <span class="comment">// first find what the left hand child&#39;s counter is</span>
            <span class="keywordtype">size_t</span> leftCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();

            <span class="comment">// and right child</span>
            <span class="keywordtype">size_t</span> rightCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();

            <span class="comment">// change is (count*ln(count)</span>
            <span class="comment">//      - (lc_count*ln(lc_count) + rc_count*ln(rc_count) +</span>
            <span class="comment">//          count*ln(2))</span>
            <span class="comment">// note that the terms involving the total count in the histogram</span>
            <span class="comment">// and the volume of this node cancel so this change</span>
            <span class="comment">// is effectively scaled and does not need to use n</span>

            dotprecision currentEMP(0.0);
            dotprecision childEMP(0.0);
            <span class="keywordflow">if</span> (leftCount &gt; 0) accumulate(childEMP, 1.0*leftCount,
                             log(1.0*leftCount));

            <span class="keywordflow">if</span> (rightCount &gt; 0) accumulate(childEMP, 1.0*rightCount,
                             log(1.0*rightCount));

            accumulate(childEMP, 1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, log(2.0));

            accumulate(currentEMP, 1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, log(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>));

            change = currentEMP - childEMP;
        }

        <span class="keywordflow">return</span> change;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a1b3356a466432a282290af76df3adb08"></a><!-- doxytag: member="subpavings::SPSnode::getMinChildCountIfSplit" ref="a1b3356a466432a282290af76df3adb08" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#a1b3356a466432a282290af76df3adb08">SPSnode::getMinChildCountIfSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Smallest number of points in either child if this was split. </p>
<p>Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the left and right child if the node were to be split. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a43024ae81075f8a822ccccad013b3ef7">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01198">1198</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01170">getLeftCountIfSplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="auto__tools_8cpp_source.shtml#l00035">subpavings::checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00986">subpavings::AdaptiveHistogram::checkNodeCountForSplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, <a class="el" href="splitdecisionobj_8hpp_source.shtml#l00093">subpavings::SplitOnK::operator()()</a>, and <a class="el" href="splitdecisionobj_8hpp_source.shtml#l00134">subpavings::SplitOnVolDivK::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordflow">try</span> {
      <span class="keywordtype">size_t</span> min = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ad077233e00a7093d66e35cca6fc6db6b" title="The count the left child would have if this node was split.">getLeftCountIfSplit</a>();
      <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - min) &lt; min) min = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - min;
      <span class="keywordflow">return</span> min;
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
      <span class="keywordtype">string</span> msg = string(e.what());
      <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>(<span class="stringliteral">&quot;Error in getMinChildCountIfSplit:\n&quot;</span> + msg);
    }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a3df75e24c4a3a468b63f79667645c1dc"></a><!-- doxytag: member="subpavings::SPSnode::getMinChildCountIfSplitNEW" ref="a3df75e24c4a3a468b63f79667645c1dc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#a3df75e24c4a3a468b63f79667645c1dc">SPSnode::getMinChildCountIfSplitNEW</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01212">1212</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01170">getLeftCountIfSplit()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01122">isSplittableNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">size_t</span> min = 0;
  
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
    min = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ad077233e00a7093d66e35cca6fc6db6b" title="The count the left child would have if this node was split.">getLeftCountIfSplit</a>();
  }
  <span class="keywordflow">else</span> {
    min = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
  }
  
  <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - min) &lt; min) min = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - min;
  
  <span class="keywordflow">return</span> min;
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="abd4de519f005b145ef131f0c9d4331a0"></a><!-- doxytag: member="subpavings::SPSnode::getMinChildVolIfSplit" ref="abd4de519f005b145ef131f0c9d4331a0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1SPSnode.shtml#abd4de519f005b145ef131f0c9d4331a0">subpavings::SPSnode::getMinChildVolIfSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Smallest volume of either child if this was split. </p>
<p>Does not split the nodes, just returns the volume of the left and right child if the node were to be split. </p>

</div>
</div>
<a class="anchor" id="a88c1d25d8e0b9738f5199cc4435c08b4"></a><!-- doxytag: member="subpavings::SPSnode::getParent" ref="a88c1d25d8e0b9738f5199cc4435c08b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4">SPSnode::getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the parent of a node. </p>
<p>Hides the base class version of this method.</p>
<p>Returns a copy of the pointer to parent node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae42cbf85bd00caf12e6acac68ae1fcd3">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01029">1029</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">subpavings::AdaptiveHistogram::mergeUp()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02568">nodeContains()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="acc7d3e22be28d76da5c8c228aaaa95c7"></a><!-- doxytag: member="subpavings::SPSnode::getRightChild" ref="acc7d3e22be28d76da5c8c228aaaa95c7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7">SPSnode::getRightChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the right child of a node. </p>
<p>Hides the base class version of this method.</p>
<p>Returns a copy of the pointer to rightChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#af681e178575b285f123c1c01bac9ac42">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01039">1039</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="realmappedspnode_8cpp_source.shtml#l01065">subpavings::RealMappedSPnode::_getLogLikelihood()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00804">subpavings::AdaptiveHistogram::changeStateForSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01048">checkTreeStateLegal()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00725">subpavings::AdaptiveHistogram::decisionMCMCMerge()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01348">getAllNodes()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02543">getEMPSumAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02519">getEMPSumCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01308">getLeafNodeCounts()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02331">getMergeChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02090">getMergeChangeLogLik()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">getSubLeaves()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02403">leavesOutputTabs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">leavesOutputTabsWithEMPs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02466">leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02488">leavesOutputTabsWithHistHeightAndEMPs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02127">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05519">subpavings::AdaptiveHistogram::prioritySplitGet()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05181">subpavings::AdaptiveHistogram::prioritySplitMCMC()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02435">subpavings::AdaptiveHistogram::prioritySplitWithSwitches()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04828">subpavings::AdaptiveHistogram::prioritySplitWithTotalVar()</a>, <a class="el" href="realmappedspnode_8cpp_source.shtml#l00108">subpavings::RealMappedSPnode::RealMappedSPnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02613">spsContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00861">SPSnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00554">unionNoData()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="aa10917d57d9a50cb2d393a422188a51f"></a><!-- doxytag: member="subpavings::SPSnode::getRightCountIfSplit" ref="aa10917d57d9a50cb2d393a422188a51f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa10917d57d9a50cb2d393a422188a51f">subpavings::SPSnode::getRightCountIfSplit</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The count the right child would have if this node was split. </p>
<p>Does not split the nodes, just calculates how many of the data points currently associated with this node would go to the right child if the node were to be split.</p>
<p>Note that the left child's interval on the split dimension would be a closed interval. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a9a51fbde60e061846a93981688cc67af">subpavings::SPSVnode</a>.</p>

</div>
</div>
<a class="anchor" id="aeac2247b4626b1adfa609d3ff109ceb2"></a><!-- doxytag: member="subpavings::SPSnode::getRootCounter" ref="aeac2247b4626b1adfa609d3ff109ceb2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#aeac2247b4626b1adfa609d3ff109ceb2">SPSnode::getRootCounter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The count in the node's ultimate ancestor root. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a346a5ff0d8177212b23342cada4b5c18">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01485">1485</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01029">getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">getRootCounter()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00362">subpavings::CollatorSPnode::CollatorSPnode()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01581">getEmpMass()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">getRootCounter()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03774">subpavings::AdaptiveHistogram::getUnifIAE()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00091">subpavings::CompEMPSumChangeCOPERR::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00145">subpavings::CompEMPSumChangeMergeCOPERR::operator()()</a>, <a class="el" href="nodecompobj_8hpp_source.shtml#l00210">subpavings::CompArea::operator()()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00247">subpavings::CompExtArea::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> retValue = 0;
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) { <span class="comment">// this is root</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
        }
        <span class="keywordflow">else</span> {
            <span class="comment">// recurse upwards</span>
            retValue = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4" title="Accessor for the parent of a node.">getParent</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#aeac2247b4626b1adfa609d3ff109ceb2" title="The count in the node&#39;s ultimate ancestor root.">getRootCounter</a>();
        }
        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6a75d9675312fb76aaf98bbeb084f9d6"></a><!-- doxytag: member="subpavings::SPSnode::getSmallestLeafCount" ref="a6a75d9675312fb76aaf98bbeb084f9d6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#a6a75d9675312fb76aaf98bbeb084f9d6">SPSnode::getSmallestLeafCount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the count of the leaf with the smallest count. </p>
<p>Returns the count in the smallest (by count) leaf node. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d355f8da3eb609f5c81ce63b437fcf9">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01422">1422</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> smallestCount = 0;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            smallestCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>
            <span class="comment">// set up a container for the leaf children</span>
            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <span class="comment">// find the smallest child by count</span>
            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* smallest = *(leaves.begin());

            smallestCount = smallest-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                <span class="keywordflow">if</span> ((*it)-&gt;counter &lt; smallestCount) {

                    smallestCount = (*it)-&gt;counter;
                }
            }
        } <span class="comment">// end else not a leaf</span>

        <span class="keywordflow">return</span> smallestCount;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af75b1acec69e86469838524097fab408"></a><!-- doxytag: member="subpavings::SPSnode::getSplitChangeEMPAIC" ref="af75b1acec69e86469838524097fab408" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#af75b1acec69e86469838524097fab408">SPSnode::getSplitChangeEMPAIC</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get change in sum term in EMP under AIC on split. </p>
<p>Under AIC, EMP is -1 x sum over leaves of (counts in leaf x ln(count in leaf / (n * volume of leaf))) where n is the total number of data points in the histogram.</p>
<p>Should only be called on leaf nodes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node were split. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02324">2324</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l02044">getSplitChangeLogLik()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02169">getBestSplitChangeEMPAIC()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00119">subpavings::CompEMPSumChangeAIC::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">return</span> -<a class="code" href="classsubpavings_1_1SPSnode.shtml#ab28c35298b721467721228a33a194433" title="Get change in log likelihood on split of this node.">getSplitChangeLogLik</a>();

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a33925f531930c000200f452209b0128c"></a><!-- doxytag: member="subpavings::SPSnode::getSplitChangeEMPCOPERR" ref="a33925f531930c000200f452209b0128c" args="(const size_t n) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#a33925f531930c000200f452209b0128c">SPSnode::getSplitChangeEMPCOPERR</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get scaled change in sum term in EMP under COPERR on split. </p>
<p>Under COPERR, EMP is -1/n^2 x sum over leaves of (counts in leaf squared / (n * volume of leaf)) where n is the total number of data points in the histogram.</p>
<p>Should only be called on leaf nodes.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the value to use for scaling, the total number of points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the change in the sum over leaves of (counts in leaf squared over (n * volume of leaf) which would result if this node were split. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02297">2297</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01170">getLeftCountIfSplit()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02134">getBestSplitChangeEMPCOPERR()</a>, and <a class="el" href="nodecompobj_8hpp_source.shtml#l00091">subpavings::CompEMPSumChangeCOPERR::operator()()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// first find what the left hand child&#39;s counter would be if that child</span>
        <span class="comment">// were to be created</span>
        <span class="keywordtype">size_t</span> leftCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ad077233e00a7093d66e35cca6fc6db6b" title="The count the left child would have if this node was split.">getLeftCountIfSplit</a>();

        <span class="comment">// current number of data points associated to node is counter</span>
        <span class="comment">// current node volume from nodeVolume, and each child will have half</span>

        <span class="comment">// change is 1/(n^2 * vol) x (counter^2 - 2(lc_count^2 + rc_count^2))</span>
        <span class="comment">// if we split and lc_count, rc_count were the new counts in</span>
        <span class="comment">// left and right children respectively</span>
        <span class="comment">// Change is scaled by n, total points in histogram</span>
        dotprecision change;
        change = 0.0;
        <span class="keywordflow">if</span> (n &gt; 0) {
            accumulate(change, (1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>)/(n*<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()),
                                (1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>)/(1.0*n));
            accumulate(change, (1.0*leftCount)/(1.0*n),
                                -(2.0*leftCount)/(n*<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
            accumulate(change, (1.0*(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - leftCount))/(1.0*n),
                                -(2.0*(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> - leftCount))/(n*<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
        }
        <span class="keywordflow">return</span> change;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab28c35298b721467721228a33a194433"></a><!-- doxytag: member="subpavings::SPSnode::getSplitChangeLogLik" ref="ab28c35298b721467721228a33a194433" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="classsubpavings_1_1SPSnode.shtml#ab28c35298b721467721228a33a194433">SPSnode::getSplitChangeLogLik</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get change in log likelihood on split of this node. </p>
<p>log likelihood is sum over leaves of (counts in leaf x ln(count in leaf / (n * volume of leaf))) where n is the total number of data points in the histogram.</p>
<p>Should only be called on leaf nodes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the change in the sum over leaves of (counts in leaf squared over volume of leaf) which would result if this node were split. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02044">2044</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01170">getLeftCountIfSplit()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00630">subpavings::AdaptiveHistogram::decisionMCMCSplit()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02324">getSplitChangeEMPAIC()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        
       <span class="comment">// cout &lt;&lt; &quot;caling get split change llk&quot; &lt;&lt; endl;</span>
        
        dotprecision change;
        change = 0.0;

        <span class="comment">// if counter is 0 there can be no change on splitting</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0) {

            <span class="comment">// first find what the left hand child&#39;s counter would be if</span>
            <span class="comment">// that child were to be created</span>
            <span class="keywordtype">size_t</span> leftCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ad077233e00a7093d66e35cca6fc6db6b" title="The count the left child would have if this node was split.">getLeftCountIfSplit</a>();
            <span class="comment">// current number of data points associated to node is counter</span>
            <span class="keywordtype">size_t</span> rightCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>-leftCount;
    
            <span class="comment">// current node volume from nodeVolume; each child will have half</span>
            <span class="comment">// change is</span>
            <span class="comment">//      (lc_count*ln(lc_count) + rc_count*ln(rc_count) +</span>
            <span class="comment">//          count*ln(2)) - (count*ln(count)</span>
            <span class="comment">// if we split and lc_count, rc_count were the new counts in</span>
            <span class="comment">// left and right children respectively</span>
            <span class="comment">// note that the terms involving the total count in the histogram</span>
            <span class="comment">// and the volume of this node cancel so this change</span>
            <span class="comment">// is effectively scaled and does not need to use n</span>

            dotprecision currentEMP(0.0);
            dotprecision childEMP(0.0);

            <span class="keywordflow">if</span> (leftCount &gt; 0) accumulate(childEMP, 1.0*leftCount,
                             log(1.0*leftCount));

            <span class="keywordflow">if</span> (rightCount &gt; 0) accumulate(childEMP, 1.0*rightCount,
                             log(1.0*rightCount));

            accumulate(childEMP, 1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, log(2.0));

            accumulate(currentEMP, 1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, log(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>));

            change = childEMP - currentEMP;
        }
        <span class="keywordflow">return</span> change;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="afe262ee997e6ac57a15193a7d585f0ac"></a><!-- doxytag: member="subpavings::SPSnode::getSplitDim" ref="afe262ee997e6ac57a15193a7d585f0ac" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPSnode.shtml#afe262ee997e6ac57a15193a7d585f0ac">SPSnode::getSplitDim</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the split dimension. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01001">1001</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00401">splitDim</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02184">subpavings::SPSVnode::nodeContains()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02568">nodeContains()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="aeaa3e348d84106def631d3cd742a1420"></a><!-- doxytag: member="subpavings::SPSnode::getSplitValue" ref="aeaa3e348d84106def631d3cd742a1420" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#aeaa3e348d84106def631d3cd742a1420">SPSnode::getSplitValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the split value. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01005">1005</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00408">splitValue</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l02184">subpavings::SPSVnode::nodeContains()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02568">nodeContains()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="af5ff16174902743a78b2d3db3e0a1c70"></a><!-- doxytag: member="subpavings::SPSnode::getSubLeaves" ref="af5ff16174902743a78b2d3db3e0a1c70" args="(SPSnodePtrs &amp;subleaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70">SPSnode::getSubLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923">SPSnodePtrs</a> &amp;&#160;</td>
          <td class="paramname"><em>subleaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a reference to all sub-leaf descendent nodes. </p>
<p>Sub-leaf nodes have at least one child but any child must be a leaf, ie sub-leaves are the parents of leaf nodes.</p>
<p>Will be just this if this is a subleaf.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to a container of node pointers. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#aa5408d2d74de8b95325c5973cf43f7fb">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01373">1373</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">getSubLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00443">subpavings::SPnode::isSubLeaf()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02239">getBestMergeChangeEMPAIC()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02204">getBestMergeChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01373">getSubLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03102">subpavings::AdaptiveHistogram::MCMCsamples()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">subpavings::AdaptiveHistogram::mergeUp()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af5ff16174902743a78b2d3db3e0a1c70" title="Return a reference to all sub-leaf descendent nodes.">getSubLeaves</a>(subleaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a079c914f2e19278844d934baad47fbfc" title="find if this node is a subleaf node.">isSubLeaf</a>()) { <span class="comment">// this is a subleaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a subleaf</span>
            subleaves.push_back(const_cast&lt;SPSnode*&gt;(<span class="keyword">this</span>));
        }
        <span class="keywordflow">return</span> subleaves;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="adf589d16a3e20b4285f428c8dc42d75d"></a><!-- doxytag: member="subpavings::SPSnode::getSumLeafCountOverVol" ref="adf589d16a3e20b4285f428c8dc42d75d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf589d16a3e20b4285f428c8dc42d75d">SPSnode::getSumLeafCountOverVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the sum of the count over volume in the leaf nodes. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ac741a9772d992ba74911cf692e1ed772">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01394">1394</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">getLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01251">subpavings::AdaptiveHistogram::getRootSumLeafCountOverVol()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        dotprecision sum(0.0);

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {  <span class="comment">// this is a leaf</span>
            accumulate(sum, 1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, (1.0/<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>()));
        }

        <span class="keywordflow">else</span> { <span class="comment">// this is not a leaf</span>

            <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves;
            <span class="comment">// fill the container with the leaf children</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a6a833240b503da0e2b640782e8671954" title="Return a reference to all descendent leaf nodes.">getLeaves</a>(leaves);

            <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it;

            <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
                accumulate(sum, 1.0*((*it)-&gt;getCounter()),
                            (1.0/(*it)-&gt;nodeVolume()));
            }
        }
        <span class="keywordflow">return</span> rnd(sum);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4369d3887385551e053d3873b600f8a1"></a><!-- doxytag: member="subpavings::SPSnode::getUniformMean" ref="a4369d3887385551e053d3873b600f8a1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rvector <a class="el" href="classsubpavings_1_1SPSnode.shtml#a4369d3887385551e053d3873b600f8a1">SPSnode::getUniformMean</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the uniform mean vector where each element is the midpoint of the coordinate. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ae2cfb09a96d3c6b0d716236cbfccebd3">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01528">1528</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01542">getChebDistMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">getHellingerDist()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01820">getHellingerDist1D()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    rvector unifMean(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);
    
    <span class="comment">// loop through the coordinates of this box to get the midpoint at each</span>
    <span class="comment">// coordinate</span>
    ivector thisBox = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
      unifMean[i] = mid(thisBox[i]);
    }
    <span class="keywordflow">return</span> unifMean;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a83c7f66b07ab9afd1934b080fd4af8c4"></a><!-- doxytag: member="subpavings::SPSnode::getUniformVarCovar" ref="a83c7f66b07ab9afd1934b080fd4af8c4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> <a class="el" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">SPSnode::getUniformVarCovar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0a9c9ba4802d37fdb0ee1fff25908fbb">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01960">1960</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01561">getChebDistCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">getHellingerDist()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01820">getHellingerDist1D()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> retVarCovar;
        retVarCovar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">getUniformVarCovar</a>(retVarCovar);
        <span class="keywordflow">return</span> retVarCovar;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8ca1683e838159d5a33048344bec9b49"></a><!-- doxytag: member="subpavings::SPSnode::getUniformVarCovar" ref="a8ca1683e838159d5a33048344bec9b49" args="(RealVec &amp;varCovar) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a83c7f66b07ab9afd1934b080fd4af8c4">SPSnode::getUniformVarCovar</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td>
          <td class="paramname"><em>varCovar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#ab1f050670fdcdc6f68e009a0cba0ed35">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01969">1969</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>.</p>
<div class="fragment"><pre class="fragment">    {
      unifVarCovar.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);
      ivector thisBox = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
      
      <span class="comment">// fill in the matrix where the diag are (1/12)*(b-a)^2 and off-diag </span>
      <span class="comment">// are 0.</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; dimension*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
          unifVarCovar.push_back(0.0); <span class="comment">//first fill up the container with 0</span>
      }
      <span class="comment">// then fill up the diags</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
        <span class="keywordtype">int</span> pos = i*dimension + i;
        unifVarCovar[pos] = 1.0/12.0 * (Sup(thisBox[i+1]) - Inf(thisBox[i+1])) 
                      * (Sup(thisBox[i+1]) - Inf(thisBox[i+1]));
      }
      
      <span class="comment">//for (size_t i = 0; i &lt; dimension*dimension; i++) {cout &lt;&lt; unifVarCovar[i] &lt;&lt; endl;}</span>

        <span class="keywordflow">return</span> unifVarCovar;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7637c85b772a280a9769b97f7bace3c3"></a><!-- doxytag: member="subpavings::SPSnode::getVarCovar" ref="a7637c85b772a280a9769b97f7bace3c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">SPSnode::getVarCovar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#abdef36aad99bfe53f78d4e8304ac59d6">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01953">1953</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01561">getChebDistCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01820">getHellingerDist1D()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01235">subpavings::AdaptiveHistogram::getRootPavingVarCovar()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> retVarCovar;
        retVarCovar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">getVarCovar</a>(retVarCovar);
        <span class="keywordflow">return</span> retVarCovar;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a1bc0843e834ae4d09db3bc148b64761b"></a><!-- doxytag: member="subpavings::SPSnode::getVarCovar" ref="a1bc0843e834ae4d09db3bc148b64761b" args="(RealVec &amp;varCovar) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">SPSnode::getVarCovar</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td>
          <td class="paramname"><em>varCovar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a61adf71c4652c4ec29a9dc323174d1a3">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01903">1903</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">countsOnly</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00381">dpSumProducts</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00344">dpSums</a>.</p>
<div class="fragment"><pre class="fragment">    {
        varCovar.clear();
        varCovar.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);

        <span class="comment">// loop through the elements in the dpSumProducts vector</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k = 0; k &lt; dimension*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; k++) {

            <span class="comment">// counts only held or if 0 or 1 data points</span>
            <span class="comment">// each element of the var-covar is 0.0</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> || (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &lt;= 1)) {
                varCovar.push_back(0.0);
            }
            <span class="comment">// if &gt;1 data points find element-by-element var-covar</span>

            <span class="comment">/*the var-covar is the sample var-covar</span>
<span class="comment">            which is</span>
<span class="comment">            [sumproduct(i,j)-sum(i)sum(j)/counter]/(counter-1)</span>
<span class="comment"></span>
<span class="comment">            element k in the vector of dotprecison sumproducts</span>
<span class="comment">            corresponds to row k/n, (row 0 to n-1)</span>
<span class="comment">            and column k-row*n (col 0 to n-1)</span>
<span class="comment">            in a matrix view of the sumproducts */</span>

            <span class="keywordflow">else</span> {
                <span class="keywordtype">size_t</span> i = k/<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; <span class="comment">// row  (int/int = int)</span>
                <span class="keywordtype">size_t</span> j = k - i*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; <span class="comment">// column</span>

                <span class="comment">// make another dotprecision variable</span>
                dotprecision temp1 = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[k];

                dotprecision temp2(0.0);
                <span class="comment">// sum(i) x sum(j)</span>
                <span class="comment">// default cxsc rounding dotprecision rnd_next</span>
                accumulate(temp2,  rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i]),
                        rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[j]));

                real div = -1.0/<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;

                <span class="comment">// sumproduct(i,j) - sum(i)(sum(j)/counter</span>
                <span class="comment">// default cxsc rounding</span>
                accumulate(temp1, rnd(temp2), div);
                <span class="comment">// calculate the variance covariance element</span>
                varCovar.push_back(rnd(temp1)/(1.0*(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>-1)));
            }
        }<span class="comment">// end loop through the elements in dpSumProducts</span>

        <span class="keywordflow">return</span> varCovar;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af0d351af2a515188522e13e0c6502a18"></a><!-- doxytag: member="subpavings::SPSnode::insertOneFind" ref="af0d351af2a515188522e13e0c6502a18" args="(BigDataItr newItr, OPERATIONS_ON childInd, const SplitDecisionObj &amp;boolTest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18">SPSnode::insertOneFind</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a">BigDataItr</a>&#160;</td>
          <td class="paramname"><em>newItr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a>&#160;</td>
          <td class="paramname"><em>childInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts data into this node. </p>
<p>Called recursively from the root and through the tree, seeking leaf node whose box contains the data point. If data is inserted, this method also tests whether the node should be expanded following the addition of the data. Following an expansion, insertOneFind is used again to pass the the node's data down to its new children.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newItr</td><td>an iterator to the data in big data collection. </td></tr>
    <tr><td class="paramname">childInd</td><td>an indicator for whether the current node is a treated as a left or right child or a root. This is passed to <a class="el" href="classsubpavings_1_1SPSnode.shtml#a918067afb150c053f7450fd18c6ecd22" title="Check if the box a node represents contains a datapoint p.">nodeContains()</a> when testing whether the node contains the data. </td></tr>
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. This object can a dummy which never splits the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the node the data is 'inserted' into, before it is split, or NULL if no insert. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l03094">3094</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02568">nodeContains()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02853">nodeExpand()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_RIGHT</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00074">recalculateStats()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00271">subpavings::AdaptiveHistogram::insertDataFromContainer()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogram::insertOne()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03000">nodeAdoptLeft()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03048">nodeAdoptRight()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02925">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        rvector newData = *newItr;

        <span class="comment">// start at the top</span>

        <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* retObj = NULL;

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a918067afb150c053f7450fd18c6ecd22" title="Check if the box a node represents contains a datapoint p.">nodeContains</a>(newData, childInd)) {

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a8011280b8a3a0729c581a00f3bb031ff" title="Recalculate summary statistics associated with node.">recalculateStats</a>(newData);

            <span class="keywordtype">bool</span> wasLeaf = (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>());

            <span class="comment">// if it is a leaf, add the data and return this object</span>
            <span class="keywordflow">if</span>(wasLeaf) {

                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.push_back(newItr);

                <span class="comment">// give this node as return value</span>
                retObj = <span class="keyword">this</span>;

                <span class="comment">// split if we need to</span>
                <span class="keywordflow">if</span> (boolTest(<span class="keyword">this</span>)) {
                    <span class="comment">// expand and split data to children</span>

                    <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae432186483a5ec950dab0eb00b08a9bc" title="Expand a leaf node.">nodeExpand</a>(boolTest);

                } <span class="comment">// end if we need to split</span>

            } <span class="comment">// end of isLeaf</span>

            <span class="comment">// if not a leaf before we had split, and contains data</span>
            <span class="comment">// recurse on the children if any</span>
            <span class="keywordflow">if</span> (!wasLeaf) {

                <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>!=NULL &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()){

                    retObj =
                    (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(
                        newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>, boolTest);
                }
                <span class="comment">// only try left if we did not find on the right</span>
                <span class="keywordflow">if</span>(retObj == NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>!=NULL &amp;&amp;
                                    !<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {

                    retObj =
                    (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(newItr,
                    <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>, boolTest);
                }
            }

        } <span class="comment">// end if node contains</span>

        <span class="comment">// will return null if does not contain the data</span>

        <span class="keywordflow">return</span> retObj;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="afcaf3b298a975017982e88a068bab8af"></a><!-- doxytag: member="subpavings::SPSnode::isSplittableNode" ref="afcaf3b298a975017982e88a068bab8af" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">SPSnode::isSplittableNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return boolean to indicate if node is splittable.</p>
<p>A node is splittable if the node volume is &gt;= 2 * cxsc::MinReal (the smallest representable real number). </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ac3e8e3499bcb0acb42181b781d7796b3">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01093">1093</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01048">checkTreeStateLegal()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l01100">isSplittableNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">SPnode::isSplittableNode</a>();
} 
</pre></div>
</div>
</div>
<a class="anchor" id="af8f9559a17318b187769c20e85316135"></a><!-- doxytag: member="subpavings::SPSnode::isSplittableNode" ref="af8f9559a17318b187769c20e85316135" args="(size_t minChildPoints, double minVol) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">SPSnode::isSplittableNode</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minVol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to check whether a node is splittable. </p>
<p>Decides whether a node is splittable based on checking volume and number of points that would result in child nodes on split.</p>
<p>Node must satisfy the basic <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode()</a> test <b>and</b> volume must be &gt;=minVol to split <b>and</b> if <em>minChildPoints</em> &gt; 0, then </p>
<ul>
<li>
either the node must have at least minChildPoints and all the points go to one of the children (the other getting none) </li>
<li>
or the smallest number of points which would go to the either of the prospective new children must be &gt;= minChildPoints </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>if <em>minVol</em> is &lt; minimum for passing <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode()</a> then node will fail test even if node volume &gt; minVol, ie <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode()</a> overrides all other criteria.</dd></dl>
<p>Thus in general the method will only return true if the given node satisfies both the minVol test and, if it were to be split, both children would have at least minChildPoints data points, <b>but</b> if all the data points would go to <b>one</b> child (none to the other), this will also satisfy the minChildPoints test.</p>
<p>If the node has already been split, the test will use the actual numbers of points in the children; if the node is a leaf (ie not split) then the test will consider the number of points that would go to the each child if it were to be split.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points that there would be in the children if the node were to be split. </td></tr>
    <tr><td class="paramname">minVol</td><td>is the minimum node volume to be tested for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if has been a test conditions satisfied, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01100">1100</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01093">isSplittableNode()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>
<div class="fragment"><pre class="fragment">{
    
  <span class="keywordtype">bool</span> retValue = (<a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>() &gt;= minVol);
<span class="comment">//  cout &lt;&lt; nodeVolume() &lt;&lt; &quot;\t&quot; &lt;&lt; minVol &lt;&lt; endl;</span>
  
  <span class="comment">//cout &lt;&lt; nodeVolume() &lt;&lt; &quot;\t&quot; &lt;&lt; minVol &lt;&lt; endl;</span>
  
  <span class="keywordflow">if</span> (retValue) {
    retValue = <a class="code" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode</a>(minChildPoints);
  }
  <span class="keywordflow">else</span> {
<span class="preprocessor">    #ifdef DEBUG_CHECK_NODE_COUNT</span>
<span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">&quot;isSplittableNode: node failed vol test&quot;</span> &lt;&lt; endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>  }
  <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acba45b1fe208f6218a87400eb454b28d"></a><!-- doxytag: member="subpavings::SPSnode::isSplittableNode" ref="acba45b1fe208f6218a87400eb454b28d" args="(size_t minChildPoints) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">SPSnode::isSplittableNode</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to check whether a node is splittable. </p>
<p>Decides whether a node is splittable based number of points that would result in child nodes on split.</p>
<p>Node must satisfy the basic <a class="el" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode()</a> test <b>and</b> if <em>minChildPoints</em> &gt; 0, then </p>
<ul>
<li>
either the node must have at least minChildPoints and all the points go to one of the children (the other getting none) </li>
<li>
or the smallest number of points which would go to the either of the prospective new children must be &gt;= minChildPoints </li>
</ul>
<p>Thus in general the method will only return true if, if it were to be split, both children would have at least minChildPoints data points, <b>but</b> if all the data points would go to <b>one</b> child (none to the other), this will also satisfy the minChildPoints test.</p>
<p>If the node has already been split, the test will use the actual numbers of points in the children; if the node is a leaf (ie not split) then the test will consider the number of points that would go to the each child if it were to be split.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minChildPoints</td><td>is the minimum number of points that there would be in the children if the node were to be split. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if has been a test conditions satisfied, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01122">1122</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01212">getMinChildCountIfSplitNEW()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01093">isSplittableNode()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00159">MaxDiamComp()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">bool</span> retValue = <a class="code" href="classsubpavings_1_1SPSnode.shtml#afcaf3b298a975017982e88a068bab8af">isSplittableNode</a>();  <span class="comment">//basic check</span>
  <span class="keywordflow">if</span> (!retValue) {
<span class="preprocessor">    #ifdef DEBUG_CHECK_NODE_COUNT</span>
<span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">&quot;isSplittableNode: node failed basic is splittable test&quot;</span> &lt;&lt; endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span><span class="preprocessor">    #ifdef DEBUG_MCMC_SPLIT_FAIL</span>
<span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">&quot;Failed isSplittableNode: I am &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> &lt;&lt; endl;
      {
        ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
        interval maxD = box[<a class="code" href="toolz_8cpp.shtml#af7098b26cfe9466d751176b29c67342c" title="Return the first dimension with maximal diameter.">MaxDiamComp</a>(box)];
  
        cout &lt;&lt; cxsc::SaveOpt;
        cout &lt;&lt; Scientific &lt;&lt; SetPrecision(35,30);
        cout &lt;&lt; <span class="stringliteral">&quot;interval to be split is &quot;</span> &lt;&lt; maxD &lt;&lt; endl;
        cout &lt;&lt; cxsc::RestoreOpt;
      }
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>  }
<span class="preprocessor">  #ifdef DEBUG_CHECK_NODE_COUNT</span>
<span class="preprocessor"></span>    cout &lt;&lt; <span class="stringliteral">&quot;isSplittableNode minChildPoints = &quot;</span> &lt;&lt; minChildPoints &lt;&lt; endl;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  <span class="keywordflow">if</span> (retValue &amp;&amp; minChildPoints &gt; 0) {
    retValue = <span class="keyword">false</span>; <span class="comment">// need to retest</span>
  
    <span class="keywordtype">size_t</span>  minChildCount = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a3df75e24c4a3a468b63f79667645c1dc">getMinChildCountIfSplitNEW</a>();
    
        
    <span class="keywordflow">if</span> ( (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt;= minChildPoints) &amp;&amp;
      ((minChildCount == 0) || (minChildCount &gt;= minChildPoints)) ) {
        retValue = <span class="keyword">true</span>;
      }
<span class="preprocessor">    #ifdef DEBUG_CHECK_NODE_COUNT</span>
<span class="preprocessor"></span>      cout &lt;&lt; <span class="stringliteral">&quot;isSplittableNode minChildCount = &quot;</span> &lt;&lt; minChildCount &lt;&lt; endl;
      cout &lt;&lt; <span class="stringliteral">&quot;(minChildCount &gt;= minChildPoints) = &quot;</span> &lt;&lt; (minChildCount &gt;= minChildPoints) &lt;&lt; endl;
  
      cout &lt;&lt; <span class="stringliteral">&quot;isSplittable = &quot;</span> &lt;&lt; retValue &lt;&lt; endl;
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>  }
    <span class="keywordflow">return</span> retValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3cc0c8bb64c854ef16ba03891f5945d6"></a><!-- doxytag: member="subpavings::SPSnode::leafOutputTabs" ref="a3cc0c8bb64c854ef16ba03891f5945d6" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a3cc0c8bb64c854ef16ba03891f5945d6">SPSnode::leafOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector is:</p>
<p>label [tab] counter [tab] volume [tabl] Inf(ivector[1]) [tab] Sup(ivector[1]) [tab] ... [tab] Inf(ivector[n]) [tab] Sup(ivector[n]) </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a01b35db8ce4b99460ff352f6d25a529c">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00348">348</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02403">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> prec = 5; <span class="comment">// precision for output</span>

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy of theBox</span>

            <span class="comment">// output the node name, nodeVolume, counter</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
            <span class="comment">// followed by the intervals of box using Inf and Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>

            streamsize oldPrec = os.precision();
            os &lt;&lt; setprecision(prec);

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
            os &lt;&lt; setprecision(oldPrec);

        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac273545c33e3abb0114811e7a1b06f98"></a><!-- doxytag: member="subpavings::SPSnode::leafOutputTabsWithEMPs" ref="ac273545c33e3abb0114811e7a1b06f98" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#ac273545c33e3abb0114811e7a1b06f98">SPSnode::leafOutputTabsWithEMPs</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data.</p>
<p>The format for a d-dimensional interval vector is</p>
<p>nodeName [tab] counter [tab] volume [tab] scaled EMP contribution COPERR [tab] change in scaled EMP contribution COPERR if split [tab] scaled EMP contribution AIC [tab] change in scaled EMP contribution AIC if split [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[d]) [tab] Sup(ivector[d] </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total datapoints, used by the emps calculation </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a2ab7acc0aff92694976546f1555f67ed">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00378">378</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02425">leavesOutputTabsWithEMPs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy of theBox</span>

            <span class="comment">// output the name, (not label), nodeVolume, counter</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            <span class="comment">//os &lt;&lt; label;</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
            <span class="comment">// EMP contributions and changes if split</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a483f3b91707cda0deaee7a05d0523f3b" title="Get this node&#39;s scaled contribution to EMP under COPERR.">getEMPContributionCOPERR</a>(bigN);
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a33925f531930c000200f452209b0128c" title="Get scaled change in sum term in EMP under COPERR on split.">getSplitChangeEMPCOPERR</a>(bigN));
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa939623d58172bc7f24ddf5dd249b5c2" title="Get this node&#39;s scaled contribution to EMP under AIC.">getEMPContributionAIC</a>(bigN);
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#af75b1acec69e86469838524097fab408" title="Get change in sum term in EMP under AIC on split.">getSplitChangeEMPAIC</a>());

            <span class="comment">// followed by the intervals of box using Inf and Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            streamsize oldPrec = os.precision();
            os &lt;&lt; setprecision(prec);

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
            os &lt;&lt; setprecision(oldPrec);

        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aaf9ac8d98bda6e99c74b946d85c6bc61"></a><!-- doxytag: member="subpavings::SPSnode::leafOutputTabsWithHistHeight" ref="aaf9ac8d98bda6e99c74b946d85c6bc61" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#aaf9ac8d98bda6e99c74b946d85c6bc61">SPSnode::leafOutputTabsWithHistHeight</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Includes the height of a bin represented by this leaf node for a normalised histogram, ie counter/(node volume * total count in tree)</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for a d-dimensional interval vector is:</p>
<p>nodeName [tab] counter [tab] volume [tabl] counter/(volume*total count) [tab] Inf(ivector[1]) [tab] Sup(ivector[1]) [tab] ... [tab] Inf(ivector[d]) [tab] Sup(ivector[d]) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by the height calculation </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a6eff83d7095798158c0bc17ee70e54c0">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00414">414</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02466">leavesOutputTabsWithHistHeight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy of theBox</span>
            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();

            <span class="comment">// output the node name, nodeVolume, counter, counter/(bigN * vol)</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; counter/(vol * bigN);
            <span class="comment">// followed by the intervals of box using Inf and Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            streamsize oldPrec = os.precision();
            os &lt;&lt; setprecision(prec);

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
            os &lt;&lt; setprecision(oldPrec);

        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad64bd4af47589b21d9c8dde5135c3d0a"></a><!-- doxytag: member="subpavings::SPSnode::leafOutputTabsWithHistHeightAndEMPs" ref="ad64bd4af47589b21d9c8dde5135c3d0a" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad64bd4af47589b21d9c8dde5135c3d0a">SPSnode::leafOutputTabsWithHistHeightAndEMPs</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data.</p>
<p>Includes the height of a bin represented by this leaf node for a normalised histogram, ie counter/(node volume * total count in tree)</p>
<p>The format for a d-dimensional interval vector is</p>
<p>nodeName [tab] counter [tab] volume [tabl] counter/(volume*total count) scaled EMP contribution COPERR [tab] change in scaled EMP contribution COPERR if split [tab] scaled EMP contribution AIC [tab] change in scaled EMP contribution AIC if split [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[d]) [tab] Sup(ivector[d] </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by emps and height calculations </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a4ed4d26826f77814558a0ad3770582f4">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00444">444</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02488">leavesOutputTabsWithHistHeightAndEMPs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy of theBox</span>
            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();

            <span class="comment">// output the node name, nodeVolume, counter, counter/(n * vol)</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            <span class="comment">//os &lt;&lt; label;</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; counter/(vol * bigN);
            <span class="comment">// EMP contributions and changes if split</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a483f3b91707cda0deaee7a05d0523f3b" title="Get this node&#39;s scaled contribution to EMP under COPERR.">getEMPContributionCOPERR</a>(bigN);
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a33925f531930c000200f452209b0128c" title="Get scaled change in sum term in EMP under COPERR on split.">getSplitChangeEMPCOPERR</a>(bigN));
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa939623d58172bc7f24ddf5dd249b5c2" title="Get this node&#39;s scaled contribution to EMP under AIC.">getEMPContributionAIC</a>(bigN);
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#af75b1acec69e86469838524097fab408" title="Get change in sum term in EMP under AIC on split.">getSplitChangeEMPAIC</a>());

            <span class="comment">// followed by the intervals of box using Inf and Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            streamsize oldPrec = os.precision();
            os &lt;&lt; setprecision(prec);

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
            os &lt;&lt; setprecision(oldPrec);

        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="abe732a753f432c2239c9f82a47d089b1"></a><!-- doxytag: member="subpavings::SPSnode::leavesOutputTabs" ref="abe732a753f432c2239c9f82a47d089b1" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1">SPSnode::leavesOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSnode.shtml#a3cc0c8bb64c854ef16ba03891f5945d6" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs()</a> to output information for each leaf node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#abcac815b9e5e60a3d18fa3534a12c518">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02403">2403</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00348">leafOutputTabs()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02403">leavesOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02403">leavesOutputTabs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04703">subpavings::AdaptiveHistogram::outputLogPlain()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03546">subpavings::AdaptiveHistogram::outputToTxtTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// uses  member function leafOutputTabs to generate node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a3cc0c8bb64c854ef16ba03891f5945d6" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs</a>(os);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#abe732a753f432c2239c9f82a47d089b1" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a817a8a29925937c189cc009366fe6bfb"></a><!-- doxytag: member="subpavings::SPSnode::leavesOutputTabsWithEMPs" ref="a817a8a29925937c189cc009366fe6bfb" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a817a8a29925937c189cc009366fe6bfb">SPSnode::leavesOutputTabsWithEMPs</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSnode.shtml#a3cc0c8bb64c854ef16ba03891f5945d6" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs()</a> to output information for each leaf node. Includes scaled COPERR and AIC contributions and changes if split. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by emps and height calculations </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02425">2425</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00378">leafOutputTabsWithEMPs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02425">leavesOutputTabsWithEMPs()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02425">leavesOutputTabsWithEMPs()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00383">subpavings::AdaptiveHistogram::outputLog()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03571">subpavings::AdaptiveHistogram::outputToTxtTabsWithEMPs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) { <span class="comment">// root</span>
            std::string headers = <span class="stringliteral">&quot;node \t vol \t count \t EMP COPERR &quot;</span>;
            headers += <span class="stringliteral">&quot;\t &amp;change \t EMP AIC \t &amp;change \t dimensions \n&quot;</span>;
            os &lt;&lt; headers;
        }

        <span class="comment">// uses  member function leafOutputTabsWithEMPs to generate node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac273545c33e3abb0114811e7a1b06f98" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithEMPs</a>(bigN, os, prec);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a817a8a29925937c189cc009366fe6bfb" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithEMPs</a>(bigN, os, prec);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a817a8a29925937c189cc009366fe6bfb" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithEMPs</a>(bigN, os, prec);
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a11c1e7c0e652b891c08dfefebd285904"></a><!-- doxytag: member="subpavings::SPSnode::leavesOutputTabsWithHistHeight" ref="a11c1e7c0e652b891c08dfefebd285904" args="(std::ostream &amp;os, const int prec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a11c1e7c0e652b891c08dfefebd285904">SPSnode::leavesOutputTabsWithHistHeight</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSnode.shtml#aaf9ac8d98bda6e99c74b946d85c6bc61" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeight()</a> to output information for each leaf node. Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points of this root. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#adc55cda7856cfdd854051b891263d3bf">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02456">2456</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02466">leavesOutputTabsWithHistHeight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a11c1e7c0e652b891c08dfefebd285904" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeight</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, os, prec);
        <span class="keywordflow">return</span> (os);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7f8027e04d883efdf7b627208775b989"></a><!-- doxytag: member="subpavings::SPSnode::leavesOutputTabsWithHistHeight" ref="a7f8027e04d883efdf7b627208775b989" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a11c1e7c0e652b891c08dfefebd285904">SPSnode::leavesOutputTabsWithHistHeight</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSnode.shtml#aaf9ac8d98bda6e99c74b946d85c6bc61" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeight()</a> to output information for each leaf node. Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points of this root. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by emps and height calculations </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a8419f16a2f0667bc190a4a9ed41121c1">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02466">2466</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00414">leafOutputTabsWithHistHeight()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02456">leavesOutputTabsWithHistHeight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// uses  member function leafOutputTabs to generate node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#aaf9ac8d98bda6e99c74b946d85c6bc61" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeight</a>(bigN, os, prec);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a11c1e7c0e652b891c08dfefebd285904" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeight</a>(bigN, os, prec);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a11c1e7c0e652b891c08dfefebd285904" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeight</a>(bigN, os, prec);
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a24b8bd122c6509dd0bdb1d11b52edb7a"></a><!-- doxytag: member="subpavings::SPSnode::leavesOutputTabsWithHistHeightAndEMPs" ref="a24b8bd122c6509dd0bdb1d11b52edb7a" args="(const size_t bigN, std::ostream &amp;os, const int prec=5) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a24b8bd122c6509dd0bdb1d11b52edb7a">SPSnode::leavesOutputTabsWithHistHeightAndEMPs</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>prec</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad64bd4af47589b21d9c8dde5135c3d0a" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeightAndEMPs()</a> to output information for each leaf node. Includes output for the height of histogram bins for a normalised histogram based on tree with total number of data points n. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>is total data points, used by emps and height calculations </td></tr>
    <tr><td class="paramname">os</td><td>is the stream to send to </td></tr>
    <tr><td class="paramname">prec</td><td>is the precision used for printing, defaulting to 5 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02488">2488</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00444">leafOutputTabsWithHistHeightAndEMPs()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02488">leavesOutputTabsWithHistHeightAndEMPs()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02488">leavesOutputTabsWithHistHeightAndEMPs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) { <span class="comment">// root</span>
            std::string headers = <span class="stringliteral">&quot;node \t vol \t count \t height &quot;</span>;
            headers += <span class="stringliteral">&quot;\t EMP COPERR \t &amp;change \t EMP AIC \t &amp;change &quot;</span>;
            headers += <span class="stringliteral">&quot;\t dimensions \n&quot;</span>;
            os &lt;&lt; headers;
        }

        <span class="comment">// uses  member function leafOutputTabsWithEMPs to generate node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ad64bd4af47589b21d9c8dde5135c3d0a" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabsWithHistHeightAndEMPs</a>(bigN, os, prec);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

        <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a24b8bd122c6509dd0bdb1d11b52edb7a" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeightAndEMPs</a>(bigN,
                                                                    os, prec);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a24b8bd122c6509dd0bdb1d11b52edb7a" title="Output for for all leaves of a binary tree.">leavesOutputTabsWithHistHeightAndEMPs</a>(bigN,
                                                                    os, prec);
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a69cbe84e4c59cd1369d3900d3ff05a01"></a><!-- doxytag: member="subpavings::SPSnode::makeEmptyNode" ref="a69cbe84e4c59cd1369d3900d3ff05a01" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#a69cbe84e4c59cd1369d3900d3ff05a01">SPSnode::makeEmptyNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the node's data collection and counter. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01022">1022</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>.</p>
<div class="fragment"><pre class="fragment">   { <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.clear();
     <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> = 0;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="ae1d11e62b133e13be6c14f7ff759f152"></a><!-- doxytag: member="subpavings::SPSnode::nodeAdoptLeft" ref="ae1d11e62b133e13be6c14f7ff759f152" args="(SPSnode *lChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#ae1d11e62b133e13be6c14f7ff759f152">SPSnode::nodeAdoptLeft</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a left child rather than attempting to reunite two children into this. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>not thoroughly tested </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l03000">3000</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00507">setSplits()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02925">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// we have to collect all the data from the child,</span>
        <span class="comment">// and fire it into this to make sure that the stats</span>
        <span class="comment">// for this (this node) are correct</span>

        <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> tempContainer;
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(tempContainer, lChild);

        <span class="comment">// reserve capacity in this</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(tempContainer.size());

        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

        <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* insertedInto = NULL;

        <span class="keywordflow">for</span> (it = tempContainer.begin();
            it &lt; tempContainer.end(); it++) {

            <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// dummy split decision maker</span>
            insertedInto = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(*it, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, sn);
            <span class="comment">// insert with no splitting</span>
            <span class="keywordflow">if</span> (insertedInto == NULL) {
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Check SPSnode::nodeAdoptLeft: &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;data &quot;</span> &lt;&lt; **it &lt;&lt; <span class="stringliteral">&quot; from node &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;to be adopted rejected by new &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;parent&quot;</span> &lt;&lt; std::endl;
            }
        }

        <span class="comment">// the stats for this should now be right</span>
        <span class="comment">// but the data is associated with its descendent nodes</span>
        <span class="comment">// so we need to clear the actual data</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.clear();

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddLeft() checks labels, hull size , present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(lChild);
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a785e03fc466a6a1ea851f08338f8103d" title="Set the splitDimension and SplitValue when children grafted.">setSplits</a>(); <span class="comment">// set the split dimension and split value</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4049a0078541b24d5451957f6f7dcd68"></a><!-- doxytag: member="subpavings::SPSnode::nodeAdoptRight" ref="a4049a0078541b24d5451957f6f7dcd68" args="(SPSnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#a4049a0078541b24d5451957f6f7dcd68">SPSnode::nodeAdoptRight</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a right child rather than attempting to reunite two children into this. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Not thoroughly tested </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l03048">3048</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00507">setSplits()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02925">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//* this is the node which will become the parent</span>

        <span class="comment">// we have to collect all the data from the child,</span>
        <span class="comment">// and fire it into this to make sure that the stats</span>
        <span class="comment">// for this (this node) are correct</span>
        <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> tempContainer;
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(tempContainer, rChild);

        <span class="comment">// reserve capacity in this</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(tempContainer.size());

        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

        <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* insertedInto = NULL;

        <span class="keywordflow">for</span> (it = tempContainer.begin();
            it &lt; tempContainer.end(); it++) {

            <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn; <span class="comment">// dummy split decision maker</span>
            insertedInto = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(*it, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, sn);
            <span class="comment">// insert with no splitting</span>
            <span class="keywordflow">if</span> (insertedInto == NULL) {
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Check SPSnode::nodeAdoptRight: &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;data &quot;</span> &lt;&lt; **it &lt;&lt; <span class="stringliteral">&quot; from node to &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;be adopted rejected by new parent&quot;</span>
                    &lt;&lt; std::endl;
            }
        }

        <span class="comment">// the stats for this should now be right</span>
        <span class="comment">// but the data is associated with its descendent nodes</span>
        <span class="comment">// so we need to clear the actual data</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.clear();

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddRight() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(rChild);
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a785e03fc466a6a1ea851f08338f8103d" title="Set the splitDimension and SplitValue when children grafted.">setSplits</a>(); <span class="comment">// set the split dimension and split value</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a918067afb150c053f7450fd18c6ecd22"></a><!-- doxytag: member="subpavings::SPSnode::nodeContains" ref="a918067afb150c053f7450fd18c6ecd22" args="(const rvector &amp;p, OPERATIONS_ON childInd=ON_PARENT) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#a918067afb150c053f7450fd18c6ecd22">SPSnode::nodeContains</a> </td>
          <td>(</td>
          <td class="paramtype">const rvector &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98">OPERATIONS_ON</a>&#160;</td>
          <td class="paramname"><em>childInd</em> = <code><a class="el" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the box a node represents contains a datapoint p. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>virtual BOOL_INTERVAL <a class="el" href="classsubpavings_1_1SPnode.shtml#aa90c047beb6a8b6a4beb74342ad593a3" title="Check if ivector z is contained in this or children.">spContains(const ivector&amp; z) const</a> is not redeclared so use base.</dd>
<dd>
virtual BOOL_INTERVAL <a class="el" href="classsubpavings_1_1SPnode.shtml#a56f98ed5bc26b9b11dfce51f3e667e2b" title="Check if rvector p is contained in this node or any of its children.">spContains(const rvector&amp; p) const</a> is not redeclared so use base.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the value of the data point being tested for containment in the box represented by this node. </td></tr>
    <tr><td class="paramname">childInd</td><td>indicates whether this should be considered to be a left child or a right child (ie where we need to take splitting dimension and value into account) or as a parent node (default).</td></tr>
  </table>
  </dd>
</dl>
<p>If a node is being considered as a child node (ie childInd is ON_RIGHT or ON_LEFT) and actaully has a parent node, then is is assumed that the data point would have been in the box associated with the parent node, and the question now is just whether it falls into the left or right child. Thus no test for full containment of the data point in the box is carried out, and this method just checks whether the data point would have fallen from the parent into the left or right child.</p>
<p>If childInd is ON_PARENT, or if the node has no parent node, then the method checks for full containment of the data point within the box associated with this node.</p>
<p>Note that the interval on the parent's split dimension of the right child's box is closed at the split value and the interval of the left child's box is open. A datapoint whose element in the split dimension is exactly the split value should be assessed to be in the right child's box but not the left child's box. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#aaefe6100d8c62dc84849cd2adb733ffb">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a803d11f31d86f0565dbe682a33099698">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02568">2568</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01029">getParent()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01001">getSplitDim()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01005">getSplitValue()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_RIGHT</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00904">subpavings::AdaptiveHistogramCollator::getEstLogLikelihoodFromRSSample()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02613">spsContains()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
    
    <span class="comment">// only check for total containment if this is a parent node</span>
    <span class="comment">// or to be treated as such</span>
    <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> == NULL) || (childInd == <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>)) {
    
      <span class="comment">// cast p to an ivector</span>
      ivector pvec = _ivector(p);
    
      <span class="comment">//find if p is in the box</span>
      <span class="keywordflow">if</span> (pvec &lt;= <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) {
        retValue = <span class="keyword">true</span>;
      }
    }
    <span class="comment">// if not to be treated as a whole box, we assume it was in the parent</span>
    <span class="comment">// and only check ourselves with respect to the split dimension</span>
    <span class="comment">// and if this is a right child it can be anywhere </span>
    <span class="comment">// but  this is a left child,</span>
    <span class="comment">// we need to check the split</span>
    <span class="comment">// find what dimension the parent was split on and what</span>
    <span class="comment">// the split value was</span>
    <span class="comment">// pvector must be strictly less than parentSplitValue</span>
    <span class="comment">// on the split dimension</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a> != NULL) { <span class="comment">// truly not a parent node</span>
    
      <span class="keywordtype">int</span> parentSplitDim = (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4" title="Accessor for the parent of a node.">getParent</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#afe262ee997e6ac57a15193a7d585f0ac" title="Accessor for the split dimension.">getSplitDim</a>();
      real parentSplitValue = (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a88c1d25d8e0b9738f5199cc4435c08b4" title="Accessor for the parent of a node.">getParent</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#aeaa3e348d84106def631d3cd742a1420" title="Accessor for the split value.">getSplitValue</a>();
      
      <span class="keywordtype">bool</span> strictlyLeft = (p[parentSplitDim] &lt; parentSplitValue);

      <span class="keywordflow">if</span> (childInd == <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>) { 
        retValue = strictlyLeft;
        }
      <span class="keywordflow">if</span> (childInd == <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>) { 
        retValue = !strictlyLeft; 
      }
    }
    
    <span class="keywordflow">return</span> retValue;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a799dd8e194518c3dd525ecba26072585"></a><!-- doxytag: member="subpavings::SPSnode::nodeDataPrint" ref="a799dd8e194518c3dd525ecba26072585" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a799dd8e194518c3dd525ecba26072585">SPSnode::nodeDataPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the data in a specified format. </p>
<p>Replaces the format that the cxsc::&lt;&lt; operator produces for vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional real vector data point is:</p>
<p>label [tab] rvector[1] [tab] . . . [tab] rvector[n] </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5868a7661363e2f3bd7d2e267c22ceb1">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00267">267</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01995">nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.empty()) {

            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr;

            os &lt;&lt; <span class="stringliteral">&quot;Data is&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin();
                dataItr!= <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); dataItr++) {

                <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *dataItr;
                rvector theData = *bigIt;

                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> + 1; i++) {
                    os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>; <span class="comment">// print the label</span>
                    os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; theData[i]; <span class="comment">// print data</span>
                }   <span class="comment">// end loop through data elements</span>

                os &lt;&lt; std::endl;

            } <span class="comment">// end loop through data container</span>
        } <span class="comment">// end if counter &gt; 0</span>
        <span class="comment">// if no data, ie counter = 0, then just return os unaltered</span>

        <span class="keywordflow">return</span> os;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="adf0575b58b84a0910a8d5b67b6ec0f48"></a><!-- doxytag: member="subpavings::SPSnode::nodeExpand" ref="adf0575b58b84a0910a8d5b67b6ec0f48" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf0575b58b84a0910a8d5b67b6ec0f48">SPSnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand a leaf node to have two children and pass data down to the children with no further splitting.</p>
<p>Uses nodeExpansion() and <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf3d76ca267b87c46d1fcb1ca3cecd84" title="Send the data associated with this down to children.">splitData()</a>.</p>
<p>Equivalent to bisecting a box in a regular subpaving. Makes two new sibling child nodes of this. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>is the dimension on which to to bisect theBox. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a94c33927011a8d2613d40ccf6ccfafc1">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02831">2831</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00171">nodeExpansionOnly()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00223">splitData()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac549870ef3b7994d9e87b952a012a7e9" title="Expand the node with no reallocation of data.">nodeExpansionOnly</a>(comp);    <span class="comment">// expand the node</span>
        <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn;              <span class="comment">// dummy split decision maker</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#adf3d76ca267b87c46d1fcb1ca3cecd84" title="Send the data associated with this down to children.">splitData</a>(sn);            <span class="comment">// split the data with no further splitting</span>


    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0728b0ec4deee17f6a729a97c8b5a560"></a><!-- doxytag: member="subpavings::SPSnode::nodeExpand" ref="a0728b0ec4deee17f6a729a97c8b5a560" args="(const SplitDecisionObj &amp;boolTest, int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf0575b58b84a0910a8d5b67b6ec0f48">SPSnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand a leaf node to have two children and pass data down to the children, allowing for further splitting.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
    <tr><td class="paramname">comp</td><td>is the dimension on which to to bisect theBox. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#acbad110f9ed41364774c9e2fea658594">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02842">2842</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00171">nodeExpansionOnly()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00223">splitData()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac549870ef3b7994d9e87b952a012a7e9" title="Expand the node with no reallocation of data.">nodeExpansionOnly</a>(comp);    <span class="comment">// expand the node</span>
        <span class="comment">// split the data, allowing for further splitting</span>

        <a class="code" href="classsubpavings_1_1SPSnode.shtml#adf3d76ca267b87c46d1fcb1ca3cecd84" title="Send the data associated with this down to children.">splitData</a>(boolTest);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ae432186483a5ec950dab0eb00b08a9bc"></a><!-- doxytag: member="subpavings::SPSnode::nodeExpand" ref="ae432186483a5ec950dab0eb00b08a9bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf0575b58b84a0910a8d5b67b6ec0f48">SPSnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand a leaf node to have two children and pass data down to the children with no further splitting.</p>
<p>Finds the splitting dimension. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a0eb85efd74fa770f3259d6ba948b65b8">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02853">2853</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02863">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae432186483a5ec950dab0eb00b08a9bc" title="Expand a leaf node.">nodeExpand</a>(maxdiamcomp); <span class="comment">// complete nodeExpand</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a19a54cd8f89112dbed3f43c2f405921f"></a><!-- doxytag: member="subpavings::SPSnode::nodeExpand" ref="a19a54cd8f89112dbed3f43c2f405921f" args="(const SplitDecisionObj &amp;boolTest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf0575b58b84a0910a8d5b67b6ec0f48">SPSnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand a leaf node. </p>
<p>Expand the leaf node to have two children and pass data down to the children, allowing for further splitting.</p>
<p>Finds the dimension to split on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">boolTest</td><td>is a reference to an object providing a function operator determining whether to split a node when a data point arrives. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02863">2863</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02853">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae432186483a5ec950dab0eb00b08a9bc" title="Expand a leaf node.">nodeExpand</a>(boolTest, maxdiamcomp); <span class="comment">// complete nodeExpand</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac549870ef3b7994d9e87b952a012a7e9"></a><!-- doxytag: member="subpavings::SPSnode::nodeExpansionOnly" ref="ac549870ef3b7994d9e87b952a012a7e9" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#ac549870ef3b7994d9e87b952a012a7e9">SPSnode::nodeExpansionOnly</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand the node with no reallocation of data. </p>
<p>Bisect box, make two new nodes (one for each half box) and graft onto this node provided that this node is a leaf. Equivalent to bisecting a box in a regular subpaving. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a747a3c135503cbf1f1b349a5898cebc4">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00171">171</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02192">subpavings::isLeaf()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02831">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span>
        {
            <span class="comment">// only do something if this SPSnode is a leaf</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                <span class="comment">// ivectors to become boxes for new children</span>
                ivector lC, rC;

                <span class="comment">// Call Lower() and Upper() to put the split</span>
                <span class="comment">// boxes into lC and rC respectively</span>
                <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lC, comp);
                <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rC, comp);

                <span class="comment">// when making new children, use constructor</span>
                <span class="comment">// that will give space indication (for data)</span>
                <span class="comment">// of the size of this node&#39;s dataItrs</span>
                <span class="keywordtype">size_t</span> space = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.size();

                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(lC,
                                        space, <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>));

                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(rC,
                                        space, <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>));

                <span class="comment">//name the new children</span>
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);

                <span class="comment">// store the split dimension in this</span>
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = comp;

                <span class="comment">// store the split value in this</span>
                <span class="comment">// the split value is the infinum of interval</span>
                <span class="comment">// of right child box for dimension split on</span>
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = _double(Inf(
                    ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())[comp]));
            }
        }

        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;SPSnode::nodeExpansionOnly()&quot;</span> &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5f5cc02f707a2b98f7a93543c71298b2"></a><!-- doxytag: member="subpavings::SPSnode::nodeMeanPrint" ref="a5f5cc02f707a2b98f7a93543c71298b2" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a5f5cc02f707a2b98f7a93543c71298b2">SPSnode::nodeMeanPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the mean in a specified format. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a768f9507517be618970d19874b1ff992">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00295">295</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01995">nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0) &amp;&amp; !<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>) {

            os &lt;&lt; <span class="stringliteral">&quot;Mean is &quot;</span>;

            <span class="comment">// loop through the elements in the dpSums vector</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
                <span class="comment">// default cxsc rounding of dotprecision</span>
                <span class="comment">// to rnd_next</span>
                os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; (rnd(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i])/(1.0*<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>));

            }<span class="comment">// end loop through the elements in dpSums</span>

            os &lt;&lt; std::endl;

        } <span class="comment">// end if</span>
        <span class="comment">// if no data, ie counter = 0, or if we are only keeping counts</span>
        <span class="comment">// then just return os unaltered</span>

        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="aba02715cb75f803df7c3ffd1eaf027e8"></a><!-- doxytag: member="subpavings::SPSnode::nodePrint" ref="aba02715cb75f803df7c3ffd1eaf027e8" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#aba02715cb75f803df7c3ffd1eaf027e8">SPSnode::nodePrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output details of a specific node. </p>
<p>This is intended for console output or output to a mixed alpha and numeric file. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#aaf14185437d50e955c5ea938dc6e7559">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a51715ef7b6e370006e914fee15061cfc">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l01995">1995</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00267">nodeDataPrint()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00295">nodeMeanPrint()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00321">nodeVarCovarPrint()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03595">subpavings::AdaptiveHistogram::outputRootToTxt()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// output for box in form:</span>
        <span class="comment">// box, volume, counter, mean, variance covariance, and data</span>

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            os &lt;&lt; <span class="stringliteral">&quot;Box is :&quot;</span>;

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
                <span class="comment">// c-xsc default output for intervals</span>
                os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; thisBox[i];
            }

            os &lt;&lt; std::endl;
            os &lt;&lt; <span class="stringliteral">&quot;Box volume is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>() &lt;&lt; std::endl;
            os &lt;&lt; <span class="stringliteral">&quot;Counter = &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &lt;&lt; std::endl;

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a5f5cc02f707a2b98f7a93543c71298b2" title="Print the mean in a specified format.">nodeMeanPrint</a>(os);
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a03042a5084349960b1fd35396dc509a5" title="Print the variance-covariance in a specified format.">nodeVarCovarPrint</a>(os);
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a799dd8e194518c3dd525ecba26072585" title="Print the data in a specified format.">nodeDataPrint</a>(os);


            os &lt;&lt; std::endl;
        }
        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a68cc1a1722c627a99dcefc3491847fb2"></a><!-- doxytag: member="subpavings::SPSnode::nodeReabsorbChildren" ref="a68cc1a1722c627a99dcefc3491847fb2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2">SPSnode::nodeReabsorbChildren</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reabsorbs both children of the node. </p>
<p>Effectively reverses any split of the node.</p>
<p>Data associated with the children is pushed back up to this and the splitDim and splitValue reset to leaf defaults.</p>
<p>Works even if the children are not leaves. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ab92c1accdfd155898e63e26a112b8e36">subpavings::SPnode</a>.</p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#aed19a06dc479c2edc865243d2c131c30">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02875">2875</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">splitDim</a>, and <a class="el" href="spsnode_8hpp_source.shtml#l00408">splitValue</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l00881">subpavings::AdaptiveHistogram::changeStateForMerge()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02875">subpavings::AdaptiveHistogram::mergeUp()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l02698">subpavings::AdaptiveHistogram::priorityMerge()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// first recursively deal with the children of the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>())
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2" title="Reabsorbs both children of the node.">nodeReabsorbChildren</a>();
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>())
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a68cc1a1722c627a99dcefc3491847fb2" title="Reabsorbs both children of the node.">nodeReabsorbChildren</a>();

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>, <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>());
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>, <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>());
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
        }

        <span class="comment">// reset splitDim and splitValue to their defaults</span>
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = -1;
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = 0.0;

        <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a61c584952df4fa77109cb4bb9b46f657"></a><!-- doxytag: member="subpavings::SPSnode::nodeReunite" ref="a61c584952df4fa77109cb4bb9b46f657" args="(SPSnode *lChild, SPSnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#a61c584952df4fa77109cb4bb9b46f657">SPSnode::nodeReunite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to reunite nodes to form one leaf. </p>
<p>Note that the nodes provided, lChild and rChild, are not the actual children of this, they are potential children which we are trying to either totally bring into this (if there are two of them) or to graft onto this if there is only one of them. This is typically a new, part-formed node whose formation can be completed by reuniting already two already-formed nodes into it or by adding on one child if only one is available. nodeReunite is used in building a tree upwards (rather than in pruning leaves of formed tree from the bottom up).</p>
<p>If two potential children are provided and they are both leaves, it combines the two leaf siblings into this. If the potential children are not leaves or if only one potential child is provided, it grafts the potential child/children onto this as its child/children.</p>
<p>Data associated with the children is moved to the new parent and statistics recalculated.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>nodeReunite would not normally be used with SPSnodes but is in the base class and is reimplemented to try do it appropriately for this derived class should it be needed. This function is untested. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02925">2925</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03000">nodeAdoptLeft()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03048">nodeAdoptRight()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">subpavings::SPnode::recursiveRename()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// redo the box, move the data up,</span>

        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// check that the labels match and exit if not</span>
        <span class="keywordflow">if</span> ((lChild-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> ) || (rChild-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>)) {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>(<span class="stringliteral">&quot;Labels do not match&quot;</span>);
        }

        <span class="comment">// if both subpavings are leaves and hull of boxes is x,</span>
        <span class="comment">// discard them: *this is a leaf</span>
        <span class="keywordflow">if</span> (lChild-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; rChild-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            <span class="keywordflow">if</span> (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> !=
                (*(lChild-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>) | *(rChild-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>))) {
                <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>(<span class="stringliteral">&quot;Boxes to be reunited do not fit&quot;</span>);
            }

            <span class="comment">// we have to collect all the data from the children,</span>
            <span class="comment">// and fire it into this to make sure that the</span>
            <span class="comment">// stats for this (this node) are correct</span>
            <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> tempContainer;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(tempContainer, lChild);
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac16a08aea6f8316526c46382e3252959" title="Return a reference to the node data.">gatherData</a>(tempContainer, rChild);

            <span class="comment">// reserve capacity in this</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve(tempContainer.size());

            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> it;

            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* insertedInto = NULL;

            <span class="keywordflow">for</span> (it = tempContainer.begin();
                it &lt; tempContainer.end(); it++) {
                <span class="comment">// insert with no splitting</span>
                <a class="code" href="classsubpavings_1_1SplitNever.shtml" title="Class for never splitting.">SplitNever</a> sn;
                insertedInto = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(*it, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>, sn);
                <span class="keywordflow">if</span> (insertedInto == NULL) {
                    std::cerr &lt;&lt; <span class="stringliteral">&quot;Check &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot;SPSnode::nodeReunite: &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot; data &quot;</span> &lt;&lt; **it
                        &lt;&lt; <span class="stringliteral">&quot; from nodes to be adopted &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot;rejected by new parent&quot;</span>
                        &lt;&lt; std::endl;
                }
            }

            <span class="comment">// the stats for this should now be right</span>
            <span class="comment">// and this will be a leaf so the data</span>
            <span class="comment">// should stay associated with it</span>

            <span class="comment">//discard the two subpavings given</span>
            <span class="keyword">delete</span> lChild;
            <span class="keyword">delete</span> rChild;

        }

        <span class="keywordflow">else</span> {  <span class="comment">// at least one of the children is not a leaf</span>
            <span class="comment">// this has to adopt them rather than reuniting them</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4049a0078541b24d5451957f6f7dcd68" title="Builds a higher level of a tree from existing nodes.">nodeAdoptRight</a>(rChild);
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae1d11e62b133e13be6c14f7ff759f152" title="Builds a higher level of a tree from existing nodes.">nodeAdoptLeft</a>(lChild);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>(); <span class="comment">// recursively rename child branches</span>
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a03042a5084349960b1fd35396dc509a5"></a><!-- doxytag: member="subpavings::SPSnode::nodeVarCovarPrint" ref="a03042a5084349960b1fd35396dc509a5" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1SPSnode.shtml#a03042a5084349960b1fd35396dc509a5">SPSnode::nodeVarCovarPrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print the variance-covariance in a specified format. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a096bff1081ceb308590aac8f2f3ee660">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00321">321</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01995">nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> &gt; 0) &amp;&amp; !<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>) {

            <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> varCovar;
            varCovar = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7637c85b772a280a9769b97f7bace3c3">getVarCovar</a>(varCovar);

            <span class="comment">/* element k in the vector representing the</span>
<span class="comment">            variance-covariance matrix corresponds to</span>
<span class="comment">            row k/n, (row 0 to n-1) and column k-row*n (col 0 to n-1)</span>
<span class="comment">            in a matrix view variance-covariance */</span>

            os &lt;&lt; <span class="stringliteral">&quot;Variance Covariance is &quot;</span> &lt;&lt; std::endl;

            <span class="comment">// loop through the elements and print as matrix</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; j++) {
                    os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; varCovar[(i*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>)+j];
                }
                os &lt;&lt; std::endl;
            }
        }
        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a65971d98a726cba6cf111882f984de06"></a><!-- doxytag: member="subpavings::SPSnode::operator=" ref="a65971d98a726cba6cf111882f984de06" args="(const SPSnode &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp; SPSnode::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00895">895</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">countsOnly</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00381">dpSumProducts</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00344">dpSums</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">splitDim</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00408">splitValue</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00679">SPSnode()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {

            <span class="comment">// delete the current children (deletes their children as well)</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>();
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
            }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>();
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
            }
            <span class="comment">// and delete the current box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = NULL;
            }

            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>=NULL;

            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(*rhs.<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = rhs.<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = rhs.<a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = rhs.<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>;

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>;

            <span class="comment">//reserve space</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.reserve((rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>).size());
            <span class="comment">//copy dataItrs from other to this</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a> = rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>;

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (rhs.<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(*(rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (rhs.<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(*(rhs.<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8011280b8a3a0729c581a00f3bb031ff"></a><!-- doxytag: member="subpavings::SPSnode::recalculateStats" ref="a8011280b8a3a0729c581a00f3bb031ff" args="(rvector &amp;newdata) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#a8011280b8a3a0729c581a00f3bb031ff">SPSnode::recalculateStats</a> </td>
          <td>(</td>
          <td class="paramtype">rvector &amp;&#160;</td>
          <td class="paramname"><em>newdata</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate summary statistics associated with node. </p>
<p>Recalculates counter and sums (used for mean) and sumproducts (used for variance-covariance). </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00074">74</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        
        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>++;  <span class="comment">// update the counter</span>

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>) {

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa70c978a273b7266c75e7d617ae4d100" title="Recalculate summary statistics associated with node.">recalculateSums</a>(newdata); <span class="comment">// update the sums</span>

            <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab49e57afe0939b41930e0cbb22c9ba8a" title="Recalculate summary statistics associated with node.">recalculateSumProducts</a>(newdata); <span class="comment">// update the sumproducts</span>
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab49e57afe0939b41930e0cbb22c9ba8a"></a><!-- doxytag: member="subpavings::SPSnode::recalculateSumProducts" ref="ab49e57afe0939b41930e0cbb22c9ba8a" args="(rvector &amp;newdata) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#ab49e57afe0939b41930e0cbb22c9ba8a">SPSnode::recalculateSumProducts</a> </td>
          <td>(</td>
          <td class="paramtype">rvector &amp;&#160;</td>
          <td class="paramname"><em>newdata</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate summary statistics associated with node. </p>
<p>Recalculates sumproducts (used for variance-covariance). </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a3df955b69f0e3d73efd0ccc3026fe0e7">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00113">113</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">/* the sumproducts can be thought of as an nxn matrix,</span>
<span class="comment">        which is implemented here as a nxn element vector of</span>
<span class="comment">        dotprecision variables, using row-major order.</span>
<span class="comment">        Ie the m-th element (m = 0, . . . nxn-1) is in row floor(m/n)</span>
<span class="comment">        and column m-rowxn in the matrix configuration.</span>
<span class="comment">        Or, the sumproduct of elements i and j in an rvector,</span>
<span class="comment">        i,j = 0,...,n-1, is element m=(ixn+j) of the sumproducts</span>
<span class="comment">        vector. */</span>

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>.empty()) {    <span class="comment">//nothing there yet</span>
            <span class="comment">// reserve space for all elements</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);

            <span class="comment">// for each dimnsn^2 of data, initialise element</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; (dimension*<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>); i++) {
                dotprecision dp;
                dp = 0.0;
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>.push_back(dp);
            }
        }

        <span class="comment">// make a dot precision variable out of the ith element</span>
        <span class="comment">// and jth element of the of the rvector of new data and</span>
        <span class="comment">// store in dpSumProducts.</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; dimension + 1; i++) {
            <span class="comment">// only need to do columns 1 to i because of symmetry</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j&lt; i + 1; j++) {

                <span class="keywordtype">size_t</span> index = (i-1)*dimension + (j-1);
                <span class="comment">// rvectors indexed 1 to n</span>
                accumulate(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[index],
                        newdata[i], newdata[j]);

                <span class="comment">//if not on the diagonal of the matrix,</span>
                <span class="comment">// we can also fill in the symmetric element</span>
                <span class="keywordflow">if</span> (i!=j) {
                    <span class="keywordtype">size_t</span> sym_index = (j-1)*dimension
                        + (i-1);
                    <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[sym_index] =
                        <a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>[index];
                } <span class="comment">// end if</span>
            }<span class="comment">// end j-loop</span>
        }<span class="comment">// end i-loop</span>

        <span class="comment">// sumproducts has been updated for new datapoint</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa70c978a273b7266c75e7d617ae4d100"></a><!-- doxytag: member="subpavings::SPSnode::recalculateSums" ref="aa70c978a273b7266c75e7d617ae4d100" args="(rvector &amp;newdata) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#aa70c978a273b7266c75e7d617ae4d100">SPSnode::recalculateSums</a> </td>
          <td>(</td>
          <td class="paramtype">rvector &amp;&#160;</td>
          <td class="paramname"><em>newdata</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculate summary statistics associated with node. </p>
<p>Recalculates sums (used for mean). </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a7590c8e3a8502b3b8a15bc2c4c494904">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00089">89</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.empty()) {   <span class="comment">//nothing in the sums yet</span>
            <span class="comment">// reserve space in dpSums for all elements of the mean</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.reserve(<a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>);

            <span class="comment">// for each dimnsn of data, initialise element</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a>; i++) {
                dotprecision dp;
                dp = 0.0;
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>.push_back(dp);
            }
        }

        <span class="comment">// make a dot precision variable out of the ith element</span>
        <span class="comment">// of the rvector of new data and store in dpSums</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i&lt; dimension + 1; i++) {
            <span class="comment">// rvectors indexed 1 to n, vectors indexed 0 to n-1</span>
            accumulate(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>[i-1], newdata[i], 1.0);
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad128b1715d294a65c905579ab43890d2"></a><!-- doxytag: member="subpavings::SPSnode::reshapeToUnion" ref="ad128b1715d294a65c905579ab43890d2" args="(const SPnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad128b1715d294a65c905579ab43890d2">SPSnode::reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of another tree. </p>
<p>Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if this has no box or if <em>other</em> has no box.</p>
<p>Throws an <a class="el" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a> if boxes of this and <em>other</em> are not the same.</p>
<p>Throws an std::runtime_error if <em>other</em> has an illegal state (see <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal()</a>).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is the tree to make the union against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This has a box and that box is identical to the box of <em>other</em>. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the tree rooted at this has shape that is the union of the shape of this before the operation and the shape of <em>other</em>. <em>other</em> is unchanged. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a1113235b4bedd4a2849cc8e6dae719dc">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02366">2366</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03611">subpavings::AdaptiveHistogram::reshapeToUnion()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classsubpavings_1_1SPSnode.shtml#ad128b1715d294a65c905579ab43890d2" title="Reshape so that the tree rooted at this has shape that is the union of this shape and the shape of an...">SPnode::reshapeToUnion</a>(other);
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="afe32d323547d5169b03ed9058922ac9d"></a><!-- doxytag: member="subpavings::SPSnode::reshapeToUnion" ref="afe32d323547d5169b03ed9058922ac9d" args="(const SPnode &amp;other, size_t minChildPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#ad128b1715d294a65c905579ab43890d2">SPSnode::reshapeToUnion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPnode.shtml">SPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>minChildPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reshape so that the tree rooted at this has shape that is as close as possible to the union of this shape and the shape of another tree. </p>
<p>If <em>other</em> is more split than this, this will not exactly follow the shape of <em>other</em> if the resulting nodes would not splittable according to isSplittableNode(size_t minChildPoints). If any node cannot be split to follow the shape of <em>other</em> due to <em>minChildPoints</em>, a message will be printed to std::cerr.</p>
<p>Throws a <a class="el" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a> if this has no box or if <em>other</em> has no box.</p>
<p>Throws an <a class="el" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a> if boxes of this and <em>other</em> are not the same.</p>
<p>Throws an std::runtime_error if <em>other</em> has an illegal state (see <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7cf5893a0c2bcfe03caf2865203e6678" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal()</a>).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>is the tree to make the union against. </td></tr>
    <tr><td class="paramname">minChildPoints</td><td>is the minumum child points to use to check if this can be split in order to follow <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This has a box and that box is identical to the box of <em>other</em>. </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>the tree rooted at this has shape that is the union of the shape of this before the operation and the shape of <em>other</em>. <em>other</em> is unchanged. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02372">2372</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8cpp_source.shtml#l00621">_reshapeToUnion()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00820">subpavings::SPnode::checkTreeStateLegal()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609">subpavings::getUniqueFilename()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() || other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1NoBox__Error.shtml">NoBox_Error</a>(
    <span class="stringliteral">&quot;SPnode::reshapeToUnion(const SPnode&amp;, size_t)&quot;</span>);
  }
  <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != other.<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() )  {
    <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1IncompatibleDimensions__Error.shtml">IncompatibleDimensions_Error</a>(
    <span class="stringliteral">&quot;SPnode::reshapeToUnion(const SPnode&amp;, size_t)&quot;</span>);
  }
  <span class="keywordflow">if</span> ( !other.<a class="code" href="classsubpavings_1_1SPnode.shtml#afde5e15be5259cf61821f175452d165f" title="Check tree rooted at this is legal with respect to isSplittableNode().">checkTreeStateLegal</a>() )
    <span class="keywordflow">throw</span> runtime_error(
    <span class="stringliteral">&quot;SPnode::reshapeToUnion(const SPnode&amp;, size_t) : other has illegal tree state&quot;</span>);
  
  std::string baseErrorFilename(<span class="stringliteral">&quot;ReshapeErrors&quot;</span>);
  std::string errorFilename = <a class="code" href="namespacesubpavings.shtml#ae23d4a36711d5b768cacab3fdb72b609" title="Construct a unique filename from base and timestamp number.">getUniqueFilename</a>(baseErrorFilename);
  
  <span class="keywordtype">bool</span> success = this-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#add75213a0cf94b42aa82aca57b02da3e" title="Internal method to reshape this to a union.">_reshapeToUnion</a>(
          &amp;other, minChildPoints, errorFilename);
  
  <span class="comment">// if we returned success there should be no file with that name</span>
  <span class="keywordflow">if</span>(!success) {
    std::cerr &lt;&lt; <span class="stringliteral">&quot;\nCould not exactly reshape this to the union:&quot;</span>
      &lt;&lt; <span class="stringliteral">&quot; check &quot;</span> &lt;&lt; errorFilename &lt;&lt; <span class="stringliteral">&quot; for errors\n&quot;</span> &lt;&lt; endl;
  }
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="a785e03fc466a6a1ea851f08338f8103d"></a><!-- doxytag: member="subpavings::SPSnode::setSplits" ref="a785e03fc466a6a1ea851f08338f8103d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#a785e03fc466a6a1ea851f08338f8103d">SPSnode::setSplits</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the splitDimension and SplitValue when children grafted. </p>
<p>Sets the splitDimension and SplitValue for this node when children are grafted on. Called by nodeAdoptLeft or nodeAdoptRight.</p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this has splitDimension and SplitValue corresponding to children. </dd></dl>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a5d6459ebf84a81b4759a3dd6524df4cf">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00507">507</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l03000">nodeAdoptLeft()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03048">nodeAdoptRight()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// set the split dimension and split value for this box</span>
        <span class="comment">// based on the children which have been added</span>
        ivector childBox;
        <span class="keywordtype">bool</span> alreadyDone = <span class="keyword">false</span>;

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            childBox = <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            childBox = <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
        }
        <span class="keywordtype">int</span> pLb = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>); <span class="comment">// parent box lower bound</span>
        <span class="keywordtype">int</span> dim = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>) + 1;
        <span class="keywordtype">int</span> cLb = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(childBox); <span class="comment">// child box lower bound (should be = pLb)</span>

        <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> != -1 &amp;&amp;
            (<a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> == Inf(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb])
            || <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> == Sup(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb])))
                alreadyDone = <span class="keyword">true</span>;

        <span class="keywordflow">if</span> (!alreadyDone) {
            <span class="keywordtype">int</span> d = 1;
            <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = -1;
            <span class="keywordflow">while</span> ((d &lt;= dim) &amp;&amp; (<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> == -1)) {
                <span class="keywordflow">if</span> (diam(childBox[d + cLb - 1]) &lt; diam((*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>)[d])) {
                    <a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> = d + pLb - 1; <span class="comment">// the split dimension</span>
                }
                d++;
            }
            <span class="comment">// split value is bottom of right child box on dth dim</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = Inf(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb]);
            }
            <span class="comment">// else split value is top of left child box on dth dim</span>
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
                <a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a> = Sup(childBox[<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a> - pLb + cLb]);
            }
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="adf3d76ca267b87c46d1fcb1ca3cecd84"></a><!-- doxytag: member="subpavings::SPSnode::splitData" ref="adf3d76ca267b87c46d1fcb1ca3cecd84" args="(const SplitDecisionObj &amp;boolTest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#adf3d76ca267b87c46d1fcb1ca3cecd84">SPSnode::splitData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SplitDecisionObj.shtml">SplitDecisionObj</a> &amp;&#160;</td>
          <td class="paramname"><em>boolTest</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send the data associated with this down to children. </p>
<p>Children may then be resplit using boolTest. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00223">223</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_LEFT</a>, and <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_RIGHT</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l02831">nodeExpand()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="comment">// check that both children exist</span>
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() || !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Cannot split data when there are not two &quot;</span>;
            msg += <span class="stringliteral">&quot; children&quot;</span>;
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>(msg);
        }

        <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr; <span class="comment">// iterator</span>

        <span class="comment">//divvie the data up amongst the children</span>
        <span class="keywordflow">for</span> (dataItr = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.begin();
            dataItr!= <a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>.end(); dataItr++) {
            <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> newItr = *dataItr;

            <span class="comment">//calls insertOneFind on the children of this node</span>
            <span class="comment">// so stats are not recalculated for this node itself</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* reinsertedInto = NULL;

            <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>!=NULL &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {

                reinsertedInto =
                    (<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(
                    newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98ad9000b1b4eb93fa2d8440f85df311107">ON_RIGHT</a>, boolTest);
            }

            <span class="comment">// only try the left if it&#39;s not on the right</span>
            <span class="keywordflow">if</span>(reinsertedInto==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>!=NULL
            &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) {

                reinsertedInto =
                    (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>())-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af0d351af2a515188522e13e0c6502a18" title="Inserts data into this node.">insertOneFind</a>(
                    newItr, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a5e4950af717b37685674f0a9fcae8abe">ON_LEFT</a>, boolTest);
            }

        }

        <a class="code" href="classsubpavings_1_1SPSnode.shtml#aa4b207c66d28113dc641d7cddf691547" title="Clears the node&#39;s data collection.">clearData</a>();         <span class="comment">//clear the data in this node</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a1ac36ca4768f69aab39ae45aaace5988"></a><!-- doxytag: member="subpavings::SPSnode::spsContains" ref="a1ac36ca4768f69aab39ae45aaace5988" args="(ivector &amp;z, int countBox, int countInBox) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPSnode.shtml#a1ac36ca4768f69aab39ae45aaace5988">SPSnode::spsContains</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countInBox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of points in any box. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>query box </td></tr>
    <tr><td class="paramname">countBox</td><td></td></tr>
    <tr><td class="paramname">countInBox</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Later. </p>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l02613">2613</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_FALSE</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_INDET</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00074">subpavings::BI_TRUE</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01014">getData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02568">nodeContains()</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00082">subpavings::ON_PARENT</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02613">spsContains()</a>.</p>

<p>Referenced by <a class="el" href="InsideBox_8cpp_source.shtml#l00057">main()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l02613">spsContains()</a>.</p>
<div class="fragment"><pre class="fragment">   {
      <span class="comment">// Query box is z and box to be compared is theBox accessed by getBox()</span>
      <span class="comment">// z is assumed not to be empty</span>
      <span class="comment">// nb Intersection() gives error if unequal index sets passed</span>
         
      <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>; <span class="comment">// for the return value</span>
        
      <span class="comment">// case of no intersection, i.e. the intersection of theBox and z is</span>
      <span class="comment">// empty </span>
        ivector r; <span class="comment">// temporary ivector</span>
         <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(r, z, <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())==0){
            retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
            <span class="keywordflow">return</span> countBox; 
         }        
  
         <span class="comment">// case of isEmpty() being true</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()){
         <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>; <span class="comment">// for the return value</span>
         }
 
         <span class="comment">// case of a non-empty leaf</span>
         <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {           
            ivector r; <span class="comment">// temporary, to be passed to Intersection                 </span>
            <span class="keywordflow">if</span> (z&lt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) {
            <span class="comment">// z is contained inside theBox but borders are not included</span>
             
               <span class="comment">// make z a SPSnode</span>
               <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> queryNode(z, 1);
  
               <span class="comment">// access data in theBox</span>
               <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> boxData = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a8906934b09d85e67c49d38548e0cd38a" title="Accessor for the node&#39;s data collection.">getData</a>();
               <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> boxDataItr;
                 
               <span class="comment">// check if queryNode contains data from theBox</span>
               <span class="keywordflow">for</span>(boxDataItr = boxData.begin(); boxDataItr != boxData.end(); boxDataItr++){
                  <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *boxDataItr; 
                  rvector theData = *bigIt;  <span class="comment">// convert NodeData to rvector</span>
                    
                  <span class="comment">// if nodeContains is true, increment countInBox</span>
                  <span class="keywordflow">if</span>(queryNode.nodeContains(theData, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>)){
                     countInBox += 1;
                  }
               }                             
                 
                <span class="comment">// final count;</span>
                countBox = countInBox;
                retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>;
            } 
          
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (z==<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) {
            <span class="comment">// z fully covers theBox, including the borders</span>
               countBox += <a class="code" href="classsubpavings_1_1SPSnode.shtml#ab4bee06d1b314b064d88842ba720d4a3" title="Accessor for the counter.">getCounter</a>();
               retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6a6dc46ce899440df44cb246c8673f77ce">BI_TRUE</a>;
            }
       
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(r, z, <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {
            <span class="comment">// result is indeterminate if there is an intersection but z is not             </span>
        <span class="comment">// wholly in theBox&quot;</span>
                
               <span class="keywordflow">if</span> (Inf(r) == Sup(r)){
                  retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
               }
 
               <span class="keywordflow">else</span>{
            <span class="comment">// make z a SPSnode</span>
            <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> queryNode(z, 1);
  
            <span class="comment">// access data in theBox</span>
            <a class="code" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30" title="Define type NodeData as a container for iterators a BigData.">NodeData</a> boxData = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a8906934b09d85e67c49d38548e0cd38a" title="Accessor for the node&#39;s data collection.">getData</a>();
            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> boxDataItr;
                 
            <span class="comment">// check if queryNode contains data from theBox</span>
            <span class="keywordflow">for</span>(boxDataItr = boxData.begin(); boxDataItr != boxData.end(); boxDataItr++){
              <a class="code" href="namespacesubpavings.shtml#a8792314c11b28ac2b8c4c85c47526f3a" title="Define type BigDataItr as an iterator BigData.">BigDataItr</a> bigIt = *boxDataItr; 
              rvector theData = *bigIt;  <span class="comment">// convert NodeData to rvector</span>
                     
              <span class="comment">// if nodeContains is true, increment countInBox</span>
              <span class="keywordflow">if</span>(queryNode.nodeContains(theData, <a class="code" href="namespacesubpavings.shtml#ae1ea349cda4812634df03761ebfc1c98a4863db89a4712e90bb113f9acf898781">ON_PARENT</a>)){
                countInBox += 1;
              }
            }                             
                
            <span class="comment">// final count;</span>
            countBox += countInBox;
            retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
               }
            }
 
            <span class="keywordflow">else</span> {
          <span class="comment">// Case that there is no intersection</span>
          retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
            }
            
           <span class="keywordflow">return</span> countBox;
         } <span class="comment">// end (!isEmpty() &amp;&amp; isLeaf())</span>
          
         <span class="comment">//case of an non-empty non-leaf</span>
         <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
            ivector Lz, Rz; <span class="comment">// ivectors passed to Intersection()</span>
            <span class="comment">// will contain intersection after Intersection() call</span>
 
            <span class="comment">// to hold results of tests on left and right children</span>
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> Ltest = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
            <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6" title="Define type &quot;Interval Booleans&quot;.">BOOL_INTERVAL</a> Rtest = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
 
            <span class="comment">// indicators for tested left and right sides</span>
            <span class="keywordtype">bool</span> LtestSuccess = <span class="keyword">false</span>;
            <span class="keywordtype">bool</span> RtestSuccess = <span class="keyword">false</span>;

 <span class="comment">//        cout &lt;&lt; &quot;    // Find if there is a leftChild with a box&quot; &lt;&lt; endl;</span>
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp;
               <a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Lz, z, <a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {
               <span class="comment">// Lz contains intersctn of z &amp; leftChild box</span>
               <span class="comment">// test Lz and left child node</span>
               <span class="comment">//Ltest = </span>
               countBox =  (<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1ac36ca4768f69aab39ae45aaace5988" title="Get the number of points in any box.">spsContains</a>(Lz, countBox, countInBox));
               LtestSuccess = <span class="keyword">true</span>;
            }
                  
   <span class="comment">//    cout &lt;&lt; &quot;   // Find if there is a rightChild with a box&quot; &lt;&lt; endl;</span>
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp;
               <a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz, z, <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>())) {
               <span class="comment">// Rz contains intersctn of z &amp; rightChild box </span>
               <span class="comment">// test Rz and right child node</span>
               <span class="comment">//Rtest = </span>
               countBox =  <a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1ac36ca4768f69aab39ae45aaace5988" title="Get the number of points in any box.">spsContains</a>(Rz, countBox, countInBox);
               RtestSuccess = <span class="keyword">true</span>;
            }
        
 <span class="comment">//          cout &lt;&lt; &quot;  // if both children tested &quot; &lt;&lt; endl;</span>
           <span class="keywordflow">if</span> (LtestSuccess &amp;&amp; RtestSuccess) {
               <span class="comment">//return value is the result of both tests</span>
               <span class="comment">// if the same or BI_INDET if diff</span>
               Ltest==Rtest ?
               retValue = Ltest : retValue=<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
            }
          
 <span class="comment">//           cout &lt;&lt; &quot; // if has two children but neither was tested&quot; &lt;&lt; endl;</span>
            <span class="comment">// ie neither Intersection() returned true</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
               &amp;&amp; !LtestSuccess &amp;&amp; !RtestSuccess) {
               retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
               <span class="comment">// note that the AIA book has BI_TRUE here</span>
               <span class="comment">// but this can&#39;t be correct</span>
            }
  
   <span class="comment">//       cout &lt;&lt; &quot;  // if has two children but only right was tested&quot; &lt;&lt; endl;</span>
             <span class="comment">// ie left Intersection() returned false</span>
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                &amp;&amp; !LtestSuccess &amp;&amp; RtestSuccess) {
                retValue = Rtest;
                <span class="comment">// return value result of test of right side</span>
             }
            
     <span class="comment">//   cout &lt;&lt; &quot;    // if has two children but only left was tested&quot; &lt;&lt; endl;</span>
             <span class="comment">// ie right Intersection() returned false</span>
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                 &amp;&amp; LtestSuccess &amp;&amp; !RtestSuccess) {
                 retValue = Ltest;
                 <span class="comment">// return value result of test of left side</span>
             }
           
 <span class="comment">//    cout &lt;&lt; &quot;   // if has right child only and that child was tested&quot; &lt;&lt; endl;</span>
             <span class="comment">// ie Intersection() returned true</span>
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()
                 &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; RtestSuccess) {
                 <span class="comment">// if all of z contained in right child&#39;s box</span>
                 <span class="keywordflow">if</span> (Rz==z) {
                     retValue = Rtest;
                 }
                 <span class="comment">// return false if Rtest false, else INDET</span>
                 <span class="keywordflow">else</span> {
                       Rtest==<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a> ? retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>
                       : retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
                 }
            }
            
 <span class="comment">//    cout &lt;&lt; &quot;  // if has right child only and that child not tested&quot; &lt;&lt; endl;</span>
             <span class="comment">// ie Intersection() returned false</span>
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()
                 &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !RtestSuccess) {
                 retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
             }
             
 <span class="comment">//    cout &lt;&lt; &quot;   // if has left child only and that child was tested&quot; &lt;&lt; endl;</span>
             <span class="comment">// ie Intersection() returned true</span>
             <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                 &amp;&amp; LtestSuccess) {
                 <span class="comment">// if whole of z contained in left child&#39;s box</span>
                 <span class="keywordflow">if</span> (Lz==z) {
                     retValue = Ltest;
                 }
                 <span class="comment">// return false if Ltest false, otherwise INDET</span>
                 <span class="keywordflow">else</span> {
                       Ltest==<a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a> ?
                       retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a> :
                       retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6ad05adf0e5db6a47d94c640a2cbe45eea">BI_INDET</a>;
                  }
             }
           
 <span class="comment">//   cout &lt;&lt; &quot;   // if has left child only &amp; that child was not tested&quot; &lt;&lt; endl;</span>
             <span class="comment">// ie Intersection() returned false</span>
             <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()
                 &amp;&amp; !LtestSuccess) {
                 retValue = <a class="code" href="namespacesubpavings.shtml#abf44b15764c504d6ffa87c62b45b01a6af416f80a49e36092e0ce20344f72a226">BI_FALSE</a>;
             }
 
           <span class="comment">//  case no children covered by isLeaf() block above</span>
         } <span class="comment">// end of (!isEmpty() &amp;&amp; !isLeaf())</span>
 
     <span class="keywordflow">return</span> countBox;
       
   } <span class="comment">// end of spsContains for ivector</span>
</pre></div>
</div>
</div>
<a class="anchor" id="ac6259d2964d38acbb759c9f212853ef7"></a><!-- doxytag: member="subpavings::SPSnode::strippedConstructor" ref="ac6259d2964d38acbb759c9f212853ef7" args="(const SPSnode *const other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">SPSnode::strippedConstructor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00960">960</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00418">countsOnly</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">splitDim</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00408">splitValue</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00679">SPSnode()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l00554">unionNoData()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* newNode = NULL;
        <span class="keywordflow">try</span> {
            <span class="keywordflow">if</span> (other != NULL) {
                <span class="keywordflow">if</span> (other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>())
                    newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>;
                <span class="keywordflow">else</span> {
                    ivector* newBox = <span class="keyword">new</span> ivector(other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>());
                    newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(*newBox);
                    newNode-&gt;splitDim = other-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>;
                    newNode-&gt;splitValue = other-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>;
                }

                newNode-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
                newNode-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = 0;
                newNode-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a> = <span class="keyword">true</span>;

                <span class="keywordflow">if</span> (other-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>() != NULL)
                    newNode-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">strippedConstructor</a>(other-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()));
                <span class="keywordflow">if</span> (other-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>() != NULL)
                    newNode-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">strippedConstructor</a>(other-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()));
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newNode;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8ce80cd650645f34e79fbc1d4beb2326"></a><!-- doxytag: member="subpavings::SPSnode::swapSPS" ref="a8ce80cd650645f34e79fbc1d4beb2326" args="(SPSnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1SPSnode.shtml#a8ce80cd650645f34e79fbc1d4beb2326">SPSnode::swapSPS</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this and another node. Swaps all the data members of this with the other node. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>a reference to the node to swap with </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is identical,in terms of its data members, to spn before the swap, and spn is identical to this after the swap. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l03191">3191</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spsnode_8hpp_source.shtml#l00316">counter</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00418">countsOnly</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00393">dataItrs</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00381">dpSumProducts</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00344">dpSums</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00297">spaceIndication</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00401">splitDim</a>, <a class="el" href="spsnode_8hpp_source.shtml#l00408">splitValue</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02125">subpavings::SPnode::swap()</a>.</p>
<div class="fragment"><pre class="fragment">  { 
    <span class="comment">/* theBox, parent, leftChild,</span>
<span class="comment">    rightChild and nodeName are inherited from base class */</span>
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">SPnode::swap</a>(spn); <span class="comment">// use the base version</span>
    
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95" title="An indication of the maximum number of data points a node needs to carry.">spaceIndication</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5" title="A counter for how many data points are covered by theBox.">counter</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643" title="A container representing the sum of the data points covered by theBox.">dpSums</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78" title="A container representing the sumproduct matrix of the data points covered by theBox.">dpSumProducts</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8" title="A container for the association of data with a node.">dataItrs</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154" title="Dimension the node&#39;s box has been split along.">splitDim</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6" title="The value, on split dimension, where node&#39;s box was split.">splitValue</a>);
    <a class="code" href="classsubpavings_1_1SPnode.shtml#a08eac7d3d3f57b9d6e56a84f14e9f4fb" title="Swap this and another node.">std::swap</a>(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>, spn.<a class="code" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02" title="Determines the amount of statistical summary data in node.">countsOnly</a>);
    
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a6c28eccf9962c4b9010f2f04b0231d30"></a><!-- doxytag: member="subpavings::SPSnode::unionNoData" ref="a6c28eccf9962c4b9010f2f04b0231d30" args="(const SPSnode *const lhs, const SPSnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1SPSnode.shtml#a6c28eccf9962c4b9010f2f04b0231d30">SPSnode::unionNoData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the non-minimal union of nodes with no data.</p>
<p>Calls itself recursively to adds two pavings together as the union of the two but discards the actual data.</p>
<p>Does not rename the nodes from root downwards.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to root of first <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>pointer to root of second <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to root of a new <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree whose leaves are the union of the leaves of lhs, rhs and which has no data. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l00554">554</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">getLeftChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l00960">strippedConstructor()</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l03160">unionTreeStructure()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* newNode = NULL;

        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;  <span class="comment">// indicator for done adding</span>

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (lhs == NULL &amp;&amp; rhs == NULL) done = <span class="keyword">true</span>; <span class="comment">// we will return NULL</span>

            <span class="comment">// if the lhs is null or has no box, return a tree or node based on rhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (lhs==NULL || ((lhs != NULL) &amp;&amp; (lhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>())))) {

                newNode = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">SPSnode::strippedConstructor</a>(rhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// if the rhs is null or has no box, return a tree or node based on lhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (rhs==NULL || ((rhs != NULL) &amp;&amp; (rhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>())))) {

                newNode = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">SPSnode::strippedConstructor</a>(lhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// by now, if we are not done, both pavings are not null and both have boxes</span>
            <span class="comment">// we assume that the boxes are the same</span>

            <span class="comment">// we have to check who has children</span>

            <span class="comment">// if both are leaves we can just return a node based on say lhs</span>
             <span class="comment">// if only rhs is leaf, lhs is not a leaf, return a node based on lhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; rhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                newNode = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">SPSnode::strippedConstructor</a>(lhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// if only lhs is leaf, rhs is not a leaf, return a node based on rhs</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !rhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                newNode = <a class="code" href="classsubpavings_1_1SPSnode.shtml#ac6259d2964d38acbb759c9f212853ef7">SPSnode::strippedConstructor</a>(rhs);
                done = <span class="keyword">true</span>;
            }

            <span class="comment">// if neither are leaves</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; !lhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; !rhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                <span class="comment">// make a node based on one of them, and add on the results of</span>
                <span class="comment">// recursing on the children</span>
                ivector* newPermBox = <span class="keyword">new</span> ivector(lhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>());
                newNode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1SPSnode.shtml#ae8fb89ca868b4ec2b47d0273cd32f5f5" title="Default constructor.">SPSnode</a>(*newPermBox);
                newNode-&gt;nodeAdoptRight(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6c28eccf9962c4b9010f2f04b0231d30">unionNoData</a>(lhs-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>(),
                                                            rhs-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#acc7d3e22be28d76da5c8c228aaaa95c7" title="Accessor for the right child of a node.">getRightChild</a>()));
                newNode-&gt;nodeAdoptLeft(<a class="code" href="classsubpavings_1_1SPSnode.shtml#a6c28eccf9962c4b9010f2f04b0231d30">unionNoData</a>(lhs-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>(),
                                                            rhs-&gt;<a class="code" href="classsubpavings_1_1SPSnode.shtml#af7588b657e2819dd5dda525e08143ffc" title="Accessor for the left child of a node.">getLeftChild</a>()));
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newNode;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a2dfb3087cff36fdf558bf75d5ee039c9"></a><!-- doxytag: member="subpavings::SPSnode::unionTreeStructure" ref="a2dfb3087cff36fdf558bf75d5ee039c9" args="(const SPSnode *const lhs, const SPSnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> * <a class="el" href="classsubpavings_1_1SPSnode.shtml#a2dfb3087cff36fdf558bf75d5ee039c9">SPSnode::unionTreeStructure</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the non-minimal union of two tree as a new tree with no data.</p>
<p>Adds two pavings together as the union of the two but discards the actual data. The tree manager should provide new data.</p>
<p>Renames nodes from new root downwards.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to root of first <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>pointer to root of second <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to root of a new <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> tree whose leaves are the union of the leaves of lhs, rhs and which has no data. </dd></dl>

<p>Definition at line <a class="el" href="spsnode_8cpp_source.shtml#l03160">3160</a> of file <a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">subpavings::SPnode::recursiveRename()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00554">unionNoData()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01166">subpavings::AdaptiveHistogram::operator+()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>* newNode = NULL;

        <span class="keywordflow">if</span> ((lhs != NULL) &amp;&amp; (rhs != NULL) &amp;&amp; (lhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() != rhs-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()))
        {
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>(<span class="stringliteral">&quot;Union unequal subpavings&quot;</span>);
        }
        <span class="keywordflow">else</span> {
            <span class="keywordflow">try</span> {

                newNode = <a class="code" href="classsubpavings_1_1SPSnode.shtml#a6c28eccf9962c4b9010f2f04b0231d30">unionNoData</a>(lhs, rhs);
                newNode-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>();
            }
            <span class="keywordflow">catch</span> (bad_alloc&amp; a) {
                cerr &lt;&lt; a.what() &lt;&lt; endl;
                cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
                <span class="keywordflow">throw</span>;
            }
            <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; e) {
                <span class="keywordtype">string</span> msg(e.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
                <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>(<span class="stringliteral">&quot;Error in union: original error &quot;</span> + msg);
            }
        }

        <span class="keywordflow">return</span> newNode;

    }
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a890b23bcab9091b420d88b99d16badc5"></a><!-- doxytag: member="subpavings::SPSnode::counter" ref="a890b23bcab9091b420d88b99d16badc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#a890b23bcab9091b420d88b99d16badc5">subpavings::SPSnode::counter</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A counter for how many data points are covered by theBox. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00316">316</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l00997">getCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02272">getEMPContributionCOPERR()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01207">subpavings::SPSVnode::getLargestLeafCount()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01454">getLargestLeafCount()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01060">subpavings::SPSVnode::getLeafNodeCounts()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01308">getLeafNodeCounts()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00964">subpavings::SPSVnode::getLeftCountIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02028">getLogLik()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01267">subpavings::SPSVnode::getMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01499">getMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02331">getMergeChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02090">getMergeChangeLogLik()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00970">subpavings::SPSVnode::getMinChildCountIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01198">getMinChildCountIfSplit()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01212">getMinChildCountIfSplitNEW()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01238">subpavings::SPSVnode::getRootCounter()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">getRootCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01175">subpavings::SPSVnode::getSmallestLeafCount()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01422">getSmallestLeafCount()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02297">getSplitChangeEMPCOPERR()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02044">getSplitChangeLogLik()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01147">subpavings::SPSVnode::getSumLeafCountOverVol()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01394">getSumLeafCountOverVol()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01294">subpavings::SPSVnode::getVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01903">getVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01122">isSplittableNode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01818">subpavings::SPSVnode::leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02456">leavesOutputTabsWithHistHeight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01022">makeEmptyNode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01765">subpavings::SPSVnode::nodePrint()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01995">nodePrint()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<a class="anchor" id="a99af67614faaf93216ec0991e96ddb02"></a><!-- doxytag: member="subpavings::SPSnode::countsOnly" ref="a99af67614faaf93216ec0991e96ddb02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1SPSnode.shtml#a99af67614faaf93216ec0991e96ddb02">subpavings::SPSnode::countsOnly</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the amount of statistical summary data in node. </p>
<p>If true, only counts are maintained in the node. If false, counts and other statistics (sums, sumproducts) are also maintained.</p>
<p>Setting countsOnly to false can help to conserve memory when means (from sums) and covariances (from sumproducts) will not be needed. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00418">418</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01009">getCountsOnly()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01267">subpavings::SPSVnode::getMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01499">getMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01294">subpavings::SPSVnode::getVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01903">getVarCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d45b1e3b34a39d128143a0829f051f8"></a><!-- doxytag: member="subpavings::SPSnode::dataItrs" ref="a2d45b1e3b34a39d128143a0829f051f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af005697b49cff9ea37fc3bc9ed19da30">NodeData</a> <a class="el" href="classsubpavings_1_1SPSnode.shtml#a2d45b1e3b34a39d128143a0829f051f8">subpavings::SPSnode::dataItrs</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container for the association of data with a node. </p>
<p>Data is associated with a node via this container of iterators. The iterators can, very loosely, in the sense in which they are used here, be thought of as pointers to a big data collection of all data points. Only leaf nodes can have anything in this container. However, not all leaf nodes will necessarily have something in this container: the container will be empty if no data points are covered by the box represented by a leaf node. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00393">393</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l00907">subpavings::SPSVnode::clearData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01018">clearData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00433">subpavings::SPSVnode::gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00482">gatherData()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01014">getData()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01419">subpavings::SPSVnode::getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01591">getHellingerDist()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01820">getHellingerDist1D()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01170">getLeftCountIfSplit()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00932">subpavings::SPSVnode::getRightCountIfSplit()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02132">subpavings::SPSVnode::insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03094">insertOneFind()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01022">makeEmptyNode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02036">subpavings::SPSVnode::nodeAdoptLeft()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03000">nodeAdoptLeft()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l02085">subpavings::SPSVnode::nodeAdoptRight()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l03048">nodeAdoptRight()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">subpavings::SPSVnode::nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01960">subpavings::SPSVnode::nodeReunite()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02925">nodeReunite()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00679">SPSnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00572">subpavings::SPSVnode::SPSVnode()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ff8f1c83a231af97c32808e0851dc78"></a><!-- doxytag: member="subpavings::SPSnode::dpSumProducts" ref="a7ff8f1c83a231af97c32808e0851dc78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> <a class="el" href="classsubpavings_1_1SPSnode.shtml#a7ff8f1c83a231af97c32808e0851dc78">subpavings::SPSnode::dpSumProducts</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container representing the sumproduct matrix of the data points covered by theBox. </p>
<p>The sumproducts matrix is used to obtain the sample variance-covariance matrix.</p>
<p>The for n-dimensional data the sample variance-covariance matrix is an nxn matrix where the element in row i, column j is the sample covariance between the ith-dimension and jth-dimension of the data, which is [sumproduct(i,j)-sum(i)sum(j)/counter]/(counter-1).</p>
<p>So by keeping the sum product and sums up to date, we can calculate a covariance on demand.</p>
<p>The sumproducts can be thought of as an nxn matrix where the element in row i, column j is the sum over all the datapoints associated with that box of the products of the ith element and jth element in the datapoints. ie for each datapoint, we take the product of the ith and jth elements and then sum the products over all the datapoints.</p>
<p>Data points are rvectors so each element is a real, and the the accumulation (sum) of products of reals is implemented here with a dotprecision accumulator.</p>
<p>The sumproduct matrix is stored here as a nxn element vector of dotprecision variables (where n is the dimensions of the rvectors or data points), using row-major order.</p>
<p>Ie the m-th element (m = 0, . . . nxn-1) is in row floor(m/n) and column m-rowxn in the matrix configuration.</p>
<p>Or, the sumproduct of elements i and j in an rvector, i,j = 0,...,n-1, is element m=(ixn+j) of the sumproducts vector. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00381">381</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01294">subpavings::SPSVnode::getVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01903">getVarCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e5698e870376a507cd4a09bddc01643"></a><!-- doxytag: member="subpavings::SPSnode::dpSums" ref="a1e5698e870376a507cd4a09bddc01643" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> <a class="el" href="classsubpavings_1_1SPSnode.shtml#a1e5698e870376a507cd4a09bddc01643">subpavings::SPSnode::dpSums</a><code> [mutable, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container representing the sum of the data points covered by theBox. </p>
<p>The sums are used for calculating the mean and also the sample variance-covariance matrix for the data associated with a node.</p>
<p>cxsc::dotprecision accumulators are used to maintain the sum of the data in each dimension of the data because floating point arithmetic can result in inaccuracies during summation, especially in large boxes.</p>
<p>We could use Kahan summation instead with a lot more work. Kahan summation relies on adding a number of points in a sequence and recovering data lost in one summation during the next one. When we simply add two numbers, Kahan summation has no chance to recover the lost part. We would have to implement this by keeping the lost part, say having a vector of pairs, and trying to re-add the lost part each time. See <a href="http://en.wikipedia.org/wiki/Kahan_summation_algorithm">http://en.wikipedia.org/wiki/Kahan_summation_algorithm</a> . The same may apply to arguments for using gsl_mean using a simpler reccurence relation. Speed comparisons have not been performed on the three alternative possible implementations of the recursively computable sample sum or sample mean. However we get most relable and accurate sums using cxsc::dotprecision accumulators. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00344">344</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsvnode_8cpp_source.shtml#l01267">subpavings::SPSVnode::getMean()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01499">getMean()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01294">subpavings::SPSVnode::getVarCovar()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01903">getVarCovar()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d836fd2b3cd074343475de6f9511c95"></a><!-- doxytag: member="subpavings::SPSnode::spaceIndication" ref="a4d836fd2b3cd074343475de6f9511c95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1SPSnode.shtml#a4d836fd2b3cd074343475de6f9511c95">subpavings::SPSnode::spaceIndication</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An indication of the maximum number of data points a node needs to carry. </p>
<p>This is used for efficiency only to reserve vector space and a node can have more than this maximum number of data points associated with it. Defaults to defaultMaxPts. </p>

<p>Reimplemented in <a class="el" href="classsubpavings_1_1SPSVnode.shtml#a98a73d1c8dafe1d9248aeec76c8f74ef">subpavings::SPSVnode</a>.</p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00297">297</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00679">SPSnode()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<a class="anchor" id="afbda0af3b68cf12874faa64aa8a9b154"></a><!-- doxytag: member="subpavings::SPSnode::splitDim" ref="afbda0af3b68cf12874faa64aa8a9b154" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1SPSnode.shtml#afbda0af3b68cf12874faa64aa8a9b154">subpavings::SPSnode::splitDim</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dimension the node's box has been split along. </p>
<p>This is needed to accurately divide data between a node's left and right children. Defaults to -1 if the node is a leaf. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00401">401</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01001">getSplitDim()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">subpavings::SPSVnode::nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<a class="anchor" id="a60ef987525bfd22dd0a5adadc141f0b6"></a><!-- doxytag: member="subpavings::SPSnode::splitValue" ref="a60ef987525bfd22dd0a5adadc141f0b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1SPSnode.shtml#a60ef987525bfd22dd0a5adadc141f0b6">subpavings::SPSnode::splitValue</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The value, on split dimension, where node's box was split. </p>
<p>This is needed to accurately divide data between a node's left and right children. Defaults to 0.0 if the node is a leaf. </p>

<p>Definition at line <a class="el" href="spsnode_8hpp_source.shtml#l00408">408</a> of file <a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="spsnode_8cpp_source.shtml#l01005">getSplitValue()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01909">subpavings::SPSVnode::nodeReabsorbChildren()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l02875">nodeReabsorbChildren()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00791">subpavings::SPSVnode::operator=()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00895">operator=()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00749">subpavings::SPSVnode::SPSVnode()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00859">subpavings::SPSVnode::strippedConstructor()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00960">strippedConstructor()</a>, and <a class="el" href="spsnode_8cpp_source.shtml#l03191">swapSPS()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a></li>
<li><a class="el" href="spsnode_8cpp_source.shtml">spsnode.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:42 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
