<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: adaptivehistogramvalidation.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('adaptivehistogramvalidation_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">adaptivehistogramvalidation.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="adaptivehistogramvalidation_8hpp_source.shtml">adaptivehistogramvalidation.hpp</a>&quot;</code><br/>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;string&gt;</code><br/>
<code>#include &lt;set&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;list&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;sstream&gt;</code><br/>
<code>#include &lt;exception&gt;</code><br/>
<code>#include &lt;gsl/gsl_randist.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_math.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
<code>#include &quot;<a class="el" href="toolz_8hpp_source.shtml">toolz.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="SmallClasses_8hpp_source.shtml">SmallClasses.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="sptools_8hpp_source.shtml">sptools.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spalgorithms_8hpp_source.shtml">spalgorithms.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="spsnode_8hpp_source.shtml">spsnode.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="collatorspvnode_8hpp_source.shtml">collatorspvnode.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml">adaptivehistogramvcollator.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="histmcmcobjs_8hpp_source.shtml">histmcmcobjs.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="histevalobjval_8hpp_source.shtml">histevalobjval.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="errorfunc_8hpp_source.shtml">errorfunc.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Int_8h_source.shtml">../examples/StatsSubPav/ExactInt/Int.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dim2taylor_8hpp_source.shtml">../examples/StatsSubPav/ExactInt/dim2taylor.hpp</a>&quot;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
</div>
<p><a href="adaptivehistogramvalidation_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMyCompare.shtml">MyCompare</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptivehistogramvalidation_8cpp.shtml#a931e209c5c58806a0f5713fd505043b9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;adh)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the contents of an AdaptiveHistogramValidation object.  <a href="#a931e209c5c58806a0f5713fd505043b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptivehistogramvalidation_8cpp.shtml#a5028384ac48cd67696b157d497c422fe">checkNumValley</a> (vector&lt; double &gt; vecMaxDelta, vector&lt; int &gt; &amp;valleyHistPos, bool &amp;plateau, int &amp;smallestDeltaInd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptivehistogramvalidation_8cpp.shtml#accbf75aa99bc63d1c10e85e3f3f24f3c">getCurrentYatClass</a> (vector&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecRowYatSet, vector&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecColYatSet, list&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;listYatSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptivehistogramvalidation_8cpp.shtml#a34c69f3d97096d5aaf88958a1449963b">getFinMixIntervalTrueDelta</a> (<a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, double tol, int deg, std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;YatSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cxsc::real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptivehistogramvalidation_8cpp.shtml#a9a9e088604995104a0313e525d4771e7">getUnifTrueDelta</a> (<a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, double weight, vector&lt; int &gt; holesLoc, std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;YatSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="adaptivehistogramvalidation_8cpp.shtml#a49d507fa0b75a7ad720204f0f581af6d">getMappedFunctionTrueDelta</a> (<a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;nodeEstHist, std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;YatSet)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5028384ac48cd67696b157d497c422fe"></a><!-- doxytag: member="adaptivehistogramvalidation.cpp::checkNumValley" ref="a5028384ac48cd67696b157d497c422fe" args="(vector&lt; double &gt; vecMaxDelta, vector&lt; int &gt; &amp;valleyHistPos, bool &amp;plateau, int &amp;smallestDeltaInd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="adaptivehistogramvalidation_8hpp.shtml#a93dfc6a08f529c2082c7ffcf6a5225c8">checkNumValley</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vecMaxDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>valleyHistPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>plateau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>smallestDeltaInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03978">3978</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">size_t</span> flagValley = 0;
  <span class="keywordtype">size_t</span> flagSame = 0;
  <span class="keywordtype">size_t</span> flagSameLarger = 0;
  <span class="keywordtype">int</span> Prev = 1;
  <span class="keywordtype">double</span> currentSmallest = vecMaxDelta[0];
  
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; (vecMaxDelta.size()); i++) {
    <span class="comment">//cout &lt;&lt; &quot;====current: &quot; &lt;&lt; vecMaxDelta[i] &lt;&lt; &quot;\t previous: &quot; &lt;&lt; vecMaxDelta[i-1] &lt;&lt; &quot;=====&quot; &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; &quot;Prev before checks: &quot; &lt;&lt; Prev &lt;&lt; endl;</span>
    <span class="keywordtype">double</span> stopCritCurrent = vecMaxDelta[i];
    <span class="keywordtype">double</span> stopCritPrevious = vecMaxDelta[i-1];
  
    <span class="comment">// check if it is a local minimum</span>
    <span class="keywordflow">if</span> ( ((stopCritCurrent &gt; stopCritPrevious) &amp;&amp; (Prev == 1)) ) { <span class="comment">//|| ((flagSame &gt;= 20) &amp;&amp; (Prev == 1)) ) {</span>
      <span class="comment">//cout &lt;&lt; &quot;larger: &quot; &lt;&lt; (stopCritCurrent &gt; stopCritPrevious) &lt;&lt; &quot;\t Prev: &quot; &lt;&lt; Prev &lt;&lt; endl;</span>
      
      <span class="keywordflow">if</span> ( stopCritPrevious &lt;= currentSmallest) {
        currentSmallest = stopCritPrevious;
        <span class="comment">//valleyHistPos.pop_back(); //only keep the smallest delta</span>
        valleyHistPos.push_back(i-1);
        smallestDeltaInd = i-1;
        Prev = 0;
        flagSame = 0;
        flagValley++;
        <span class="comment">//cout &lt;&lt; &quot;!!! Local minima previously at split !!! &quot; &lt;&lt; i-1 &lt;&lt; endl;</span>
      }
    }
    <span class="comment">// check if stopCrit is decreasing</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stopCritCurrent &lt; stopCritPrevious) {
      flagSameLarger = 0;
      <span class="comment">//cout &lt;&lt; &quot;current &lt; previous &quot; &lt;&lt; endl;</span>
      Prev = 1;
    }
    <span class="comment">// if stopCritCurrent = stopCritPrevious</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (stopCritCurrent == stopCritPrevious) &amp;&amp; (Prev == 1) ) {
      flagSame++;
      <span class="comment">//cout &lt;&lt; &quot;same smaller: &quot; &lt;&lt; flagSame &lt;&lt; endl;</span>
    }
    <span class="comment">//  increasing</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (stopCritCurrent == stopCritPrevious) &amp;&amp; (Prev == 0) ) {
      flagSameLarger++;
      <span class="comment">//cout &lt;&lt; &quot;same larger: &quot; &lt;&lt; flagSameLarger &lt;&lt; endl;</span>
    }
    <span class="comment">//cout &lt;&lt; &quot;Prev after checks: &quot; &lt;&lt; Prev &lt;&lt; endl;</span>
    
    <span class="keywordflow">if</span> (flagSameLarger &gt;= 20) { 
      plateau = 0;
      <span class="comment">//cout &lt;&lt; &quot;Perhaps have arrived at a plateau.&quot; &lt;&lt; endl; </span>
    }
  }
  
  <span class="comment">//cout &lt;&lt; &quot;There are &quot; &lt;&lt; flagValley &lt;&lt; &quot; valleys.&quot; &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> flagValley;
}
</pre></div>
</div>
</div>
<a class="anchor" id="accbf75aa99bc63d1c10e85e3f3f24f3c"></a><!-- doxytag: member="adaptivehistogramvalidation.cpp::getCurrentYatClass" ref="accbf75aa99bc63d1c10e85e3f3f24f3c" args="(vector&lt; set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecRowYatSet, vector&lt; set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecColYatSet, list&lt; set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;listYatSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="adaptivehistogramvalidation_8hpp.shtml#a08484be3202c86d9a369d04b1a1c7e1e">getCurrentYatClass</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecRowYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecColYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>listYatSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04036">4036</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator vecIt;
  
  <span class="comment">//insert vecRowYatSet and vecColYatSet into listYatSet</span>
  
  <span class="keywordflow">if</span> (!vecRowYatSet.empty()) {
    <span class="keywordflow">for</span> (vecIt =  vecRowYatSet.begin(); vecIt &lt; vecRowYatSet.end(); vecIt++){
        listYatSet.push_back(*vecIt);
    }
  }
  
  <span class="keywordflow">if</span> (!vecColYatSet.empty()) {
    <span class="keywordflow">for</span> (vecIt =  vecColYatSet.begin(); vecIt &lt; vecColYatSet.end(); vecIt++){
      listYatSet.push_back(*vecIt);
    }
  } 
  
  <span class="keywordflow">if</span> (!listYatSet.empty()) {
    <span class="comment">//sort and get unique</span>
    listYatSet.sort();
    listYatSet.unique();
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a34c69f3d97096d5aaf88958a1449963b"></a><!-- doxytag: member="adaptivehistogramvalidation.cpp::getFinMixIntervalTrueDelta" ref="a34c69f3d97096d5aaf88958a1449963b" args="(FinMix &amp;mixt, double tol, int deg, std::set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &amp;YatSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::interval <a class="el" href="adaptivehistogramvalidation_8hpp.shtml#a34c69f3d97096d5aaf88958a1449963b">getFinMixIntervalTrueDelta</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the true delta for a finite gaussian mixture distribution. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04065">4065</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01504">getL1error()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00221">FinMix::M</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00222">FinMix::S</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00220">FinMix::W</a>.</p>

<p>Referenced by <a class="el" href="FinMixScheffe_8cpp_source.shtml#l00044">main()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02858">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  interval totalArea(0.0); <span class="comment">//initialize</span>
  interval muValids(0.0);

  <span class="comment">// need to iterate through the nodes</span>
  set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt;::iterator it;

  <span class="comment">// container is filled by reading leaves off tree from left to right</span>
  <span class="keywordflow">for</span>(it = YatSet.begin(); it != YatSet.end(); it++) {
    <span class="comment">//cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; (*it)-&gt;getNodeName() &lt;&lt; endl;</span>
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;

    <span class="comment">//get the box of this leaf node</span>
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout &lt;&lt; (*it)-&gt;getBox() &lt;&lt; endl;</span>
    
    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    rvector lb = Inf(thisBox);
    rvector ub = Sup(thisBox);
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(_double(lb[1]), _double(ub[1]));
    interval thisInt(_double(lb[1]), _double(ub[1]));
    
    <span class="comment">// find the root</span>
    <span class="comment">//cout &lt;&lt; &quot;finding roots at this node &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
    <span class="keywordtype">double</span> fhat = 0;
    <a class="code" href="errorfunc_8cpp.shtml#a4a991d5ab1bd0a117e02af6f83369bab">bisect</a>(thisIntW, tol, fhat, rootVec, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>); 

    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      <span class="comment">//cout &lt;&lt; &quot;no roots at &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        <span class="comment">//cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
        <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      <span class="comment">//cout &lt;&lt; &quot;==There are &quot; &lt;&lt; uniqueRootVec.size() &lt;&lt; &quot; unique root(s)==&quot; &lt;&lt; endl;</span>
      
      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        <span class="comment">//cout &lt;&lt; &quot;there is only one root..&quot; &lt;&lt; endl;</span>
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the left/right boundary:&quot; &lt;&lt; rootVec[0] &lt;&lt; endl;</span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          <span class="comment">//cout &lt;&lt; &quot;no root at the boundaries&quot; &lt;&lt; endl;</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;left interval: &quot; &lt;&lt; thisSubIntLeft &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLeft, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          <span class="comment">//cout &lt;&lt; &quot;right interval: &quot; &lt;&lt; thisSubIntRight &lt;&lt; endl; </span>
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntRight, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;let&#39;s have a look at all the roots:&quot; &lt;&lt; endl;</span>
        <span class="comment">//for (size_t i = 0; i &lt; uniqueRootVec.size(); i++) {</span>
          <span class="comment">//cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//}</span>

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>
    
    <span class="comment">// get the empirical measure of the validation data at this node</span>
    interval muValid((*it)-&gt;getVemp(), (*it)-&gt;getVemp());
    muValids = muValids + muValid;
  } <span class="comment">// end of iterating through the leaf nodes</span>

  <span class="comment">// get the difference</span>
  interval trueDelta = totalArea - muValids;
  
  <span class="keywordflow">return</span> trueDelta;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a49d507fa0b75a7ad720204f0f581af6d"></a><!-- doxytag: member="adaptivehistogramvalidation.cpp::getMappedFunctionTrueDelta" ref="a49d507fa0b75a7ad720204f0f581af6d" args="(RealMappedSPnode &amp;nodeEstHist, std::set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &amp;YatSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="adaptivehistogramvalidation_8hpp.shtml#a918a753fde4f86110c4fd1f958ae29b1">getMappedFunctionTrueDelta</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1RealMappedSPnode.shtml">RealMappedSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeEstHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the true delta for mapped functions. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04344">4344</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01847">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;-------function called---------&quot; &lt;&lt; endl;</span>
  
  <span class="comment">//iterator for YatSet</span>
  std::set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt;::iterator histNodeIt;

  <span class="comment">//traverse the tree and get the heights </span>
  real trueArea = 0.0;
  real muValid = 0.0;

  <span class="keywordflow">for</span> (histNodeIt = YatSet.begin(); histNodeIt != YatSet.end(); 
      histNodeIt++) {
    
    real thisArea = 0.0;
    
    <span class="comment">//cout &lt;&lt; (*histNodeIt)-&gt;getNodeName() &lt;&lt; endl;</span>
    ivector thisBox = (*histNodeIt)-&gt;getBox();

    <span class="comment">// need to get the area of the nodes of nodeEst in thisBox</span>
    <span class="comment">//thisArea = nodeEstHist.getArea(thisArea, thisBox);</span>

    <span class="comment">//cout &lt;&lt; thisArea &lt;&lt; &quot;\t&quot; &lt;&lt; (*histNodeIt)-&gt;getVemp() &lt;&lt; endl;</span>
     
    trueArea += thisArea;
    muValid += (*histNodeIt)-&gt;getVemp();

  } <span class="comment">// end of traversing iterating through YatSet</span>

  <span class="comment">//cout &lt;&lt; &quot;Final: &quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; trueArea &lt;&lt; &quot;\t&quot; &lt;&lt; muValid &lt;&lt; endl;</span>
  
  real trueDelta = trueArea - muValid;
  <span class="keywordflow">return</span> abs(trueDelta);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9a9e088604995104a0313e525d4771e7"></a><!-- doxytag: member="adaptivehistogramvalidation.cpp::getUnifTrueDelta" ref="a9a9e088604995104a0313e525d4771e7" args="(AdaptiveHistogram &amp;myPart, double weight, vector&lt; int &gt; holesLoc, std::set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &amp;YatSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cxsc::real <a class="el" href="adaptivehistogramvalidation_8hpp.shtml#a9a9e088604995104a0313e525d4771e7">getUnifTrueDelta</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the true delta for a finite gaussian mixture distribution. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04264">4264</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l02316">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  
  <span class="comment">//cout &lt;&lt; &quot;Calling dunction: &quot; &lt;&lt; endl;</span>
  real totalArea = 0; <span class="comment">//initialize</span>
  real muValids = 0;

  <span class="comment">// get the true height, f of the corresponding box in myPart</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> trueLeaves;
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> trueIt;
  (myPart).getSubPaving()-&gt;getLeaves(trueLeaves);
  <span class="keywordtype">double</span> trueF; <span class="comment">//true density</span>
  ivector temp;

  dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>;    <span class="comment">// use type dotprecision for summation  </span>
  dpIAE=0.0;
  
  <span class="comment">// need to iterate through the nodes</span>
  set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt;::iterator it;

  <span class="comment">// container is filled by reading leaves off tree from left to right</span>
  <span class="keywordflow">for</span>(it = YatSet.begin(); it != YatSet.end(); it++) {
    ivector thisBox = (*it)-&gt;getBox();
    <span class="comment">//cout  &lt;&lt; &quot;=====checking &quot; &lt;&lt; thisBox &lt;&lt; &quot;======&quot; &lt;&lt; endl;</span>
    <span class="keywordtype">size_t</span> L = 0;
    <span class="keywordflow">for</span> (trueIt = trueLeaves.begin(); trueIt &lt; trueLeaves.end(); trueIt++) {
      <span class="comment">//cout &lt;&lt; &quot;----True leaf: &quot; &lt;&lt; (*trueIt)-&gt;getBox() &lt;&lt; &quot;\t&quot; &lt;&lt; endl;</span>
      ivector trueBox = (*trueIt)-&gt;getBox();

      <span class="keywordflow">if</span> (  holesLoc[L] == 0 ) { trueF = 0; }
      <span class="keywordflow">else</span> { trueF = weight/((*trueIt)-&gt;nodeVolume()); }
      <span class="comment">//cout &lt;&lt; &quot;pdf: &quot; &lt;&lt; trueF &lt;&lt; endl;</span>
      
      <span class="comment">// if this is contained in trueBox</span>
      <span class="keywordflow">if</span> ( (*it)-&gt;getBox() &lt;= (*trueIt)-&gt;getBox() || (*it)-&gt;getBox() == (*trueIt)-&gt;getBox() ) {
        <span class="comment">//use the volume of this</span>
        real r = ((*it)-&gt;nodeVolume())*(trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
        <span class="comment">//can move on to next leaf rather than iterating thru all trueBoxes</span>
        <span class="comment">//think about this later</span>
      } <span class="comment">//end of if this box is in trueBox</span>
      
      <span class="comment">// if this contains trueBox</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*trueIt)-&gt;getBox() &lt;= (*it)-&gt;getBox()) {
        <span class="comment">//use the volume of trueBox</span>
        real r = ((*trueIt)-&gt;nodeVolume())*(trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
      } <span class="comment">//end of if trueBox is in this box</span>
      
      <span class="comment">// if this is partially contained in trueBox </span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>   (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(temp, thisBox, trueBox)) {
        <span class="keywordflow">if</span> (Inf(temp) != Sup(temp)){
          <span class="keywordtype">double</span> volume = <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(temp);
          real r = volume*(trueF);
          <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
          accumulate(dpIAE, abs(r), 1.0);
        }
      }
      L++;
    } <span class="comment">// end of going through trueBoxes</span>

    <span class="comment">// get the empirical measure of the validation data at this node</span>
    real muValid = (*it)-&gt;getVemp();
    muValids = muValids + muValid;
    <span class="comment">//cout &lt;&lt; &quot;Area \t Emp Mass&quot; &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; rnd(dpIAE) &lt;&lt; &quot;\t&quot; &lt;&lt; muValids &lt;&lt; endl;</span>
  } <span class="comment">// end of iterating through the leaf nodes</span>

  <span class="comment">// get the difference</span>
  totalArea = rnd(dpIAE);
  real trueDelta = (totalArea - muValids);
  
  <span class="keywordflow">return</span> trueDelta;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a931e209c5c58806a0f5713fd505043b9"></a><!-- doxytag: member="adaptivehistogramvalidation.cpp::operator&lt;&lt;" ref="a931e209c5c58806a0f5713fd505043b9" args="(std::ostream &amp;os, const AdaptiveHistogramValidation &amp;adh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">subpavings::AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>adh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the contents of an AdaptiveHistogramValidation object. </p>
<p>Verbose output for an AdaptiveHistogramValidation object, including all boxes (not just leaves), data, and summary statistics. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03970">3970</a> of file <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml">adaptivehistogramvalidation.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">subpavings::AdaptiveHistogramValidation::getSubPaving()</a>.</p>
<div class="fragment"><pre class="fragment">{
    os &lt;&lt; (adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>())-&gt;nodesAllOutput(os, 1) &lt;&lt; std::endl;

    <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="adaptivehistogramvalidation_8cpp.shtml">adaptivehistogramvalidation.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:18 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
