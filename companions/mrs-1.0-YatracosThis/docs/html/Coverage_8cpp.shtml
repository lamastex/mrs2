<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: Coverage.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('Coverage_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Coverage.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;vector&gt;</code><br/>
<code>#include &lt;iterator&gt;</code><br/>
<code>#include &lt;valarray&gt;</code><br/>
<code>#include &lt;map&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;sstream&gt;</code><br/>
<code>#include &quot;<a class="el" href="toolz_8hpp_source.shtml">toolz.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="histall_8hpp_source.shtml">histall.hpp</a>&quot;</code><br/>
<code>#include &quot;dataprep.hpp&quot;</code><br/>
<code>#include &lt;gsl/gsl_qrng.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_randist.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_cdf.h&gt;</code><br/>
</div>
<p><a href="Coverage_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Coverage_8cpp.shtml#aa761d6c65ae1def2134f8829dd6be8fd">getUnifIAE</a> (vector&lt; double &gt;, vector&lt; double &gt;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Coverage_8cpp.shtml#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa761d6c65ae1def2134f8829dd6be8fd"></a><!-- doxytag: member="Coverage.cpp::getUnifIAE" ref="aa761d6c65ae1def2134f8829dd6be8fd" args="(vector&lt; double &gt;, vector&lt; double &gt;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="CoverageUniform_8cpp.shtml#aa761d6c65ae1def2134f8829dd6be8fd">getUnifIAE</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>vol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Coverage_8cpp_source.shtml#l00329">329</a> of file <a class="el" href="Coverage_8cpp_source.shtml">Coverage.cpp</a>.</p>

<p>Referenced by <a class="el" href="Coverage_8cpp_source.shtml#l00051">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
dotprecision UnifIAE;
UnifIAE = 0.0;

<span class="keywordtype">int</span> nLeaves = vol.size();
cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; nLeaves &lt;&lt; <span class="stringliteral">&quot; leaf boxes in this subpaving.&quot;</span> &lt;&lt; endl;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k &lt; nLeaves; k++){
<span class="comment">//    cout &lt;&lt; &quot;calculating IAE for box &quot; &lt;&lt; k &lt;&lt; endl;</span>
    <span class="keywordflow">if</span> ((1- fhat[k]) &lt; 0.0){
    real r= vol[k]*(fhat[k]-1);
    accumulate(UnifIAE, r, 1.0);
    }

    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((1- fhat[k]) &gt; 0.0){
    real r = vol[k]*(1-fhat[k]);
    accumulate(UnifIAE, r, 1.0);
    }
  }

<span class="keywordflow">return</span> UnifIAE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3c04138a5bfe5d72780bb7e82a18e627"></a><!-- doxytag: member="Coverage.cpp::main" ref="a3c04138a5bfe5d72780bb7e82a18e627" args="(int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="ImageSetDiff_8cpp.shtml#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="Coverage_8cpp_source.shtml#l00051">51</a> of file <a class="el" href="Coverage_8cpp_source.shtml">Coverage.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01328">subpavings::SPSnode::getLeaves()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l01216">subpavings::AdaptiveHistogram::getSubPaving()</a>, <a class="el" href="Coverage_8cpp_source.shtml#l00329">getUnifIAE()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l00925">subpavings::AdaptiveHistogram::insertFromRVec()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, <a class="el" href="sptypes_8hpp_source.shtml#l00093">subpavings::NOLOG</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, <a class="el" href="adaptivehistogram_8hpp_source.shtml#l01150">subpavings::AdaptiveHistogram::prioritySplit()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02236">subpavings::spLeaves()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">{
ofstream oss;
oss &lt;&lt; scientific;
oss.precision(5);
    <span class="comment">// ------- prepare to generate some data for the tests -----------</span>
    <span class="comment">// set up a random number generator for uniform rvs</span>
    <span class="keyword">const</span> gsl_rng_type * T;
    gsl_rng * r;
    <span class="comment">//create a generator chosen by the environment variable GSL_RNG_TYPE</span>
    gsl_rng_env_setup();
    T = gsl_rng_default;
    r = gsl_rng_alloc (T);
    <span class="keywordtype">long</span> s = time (NULL) * getpid();
    gsl_rng_set(r, s);

   <span class="comment">//----------set up domain----------------------------------</span>
    <span class="keywordtype">int</span> d = atoi(argv[2]); <span class="comment">// dimension of the uniform hypercube to sample data from</span>
    ivector pavingBox(d);

    <span class="comment">// domain is a hypercube</span>
    interval pavingInterval(0,1);
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i &lt;= d; i++) pavingBox[i] = pavingInterval;

    <span class="keywordtype">int</span> n = atoi(argv[1]); <span class="comment">// total points from random number generator</span>
    <span class="keywordtype">int</span> numHist = atoi(argv[3]); <span class="comment">// the number of histograms to make</span>
    <span class="keywordtype">int</span> step = atoi(argv[4]);
<span class="comment">//  int bigD = atoi(argv[5]);</span>
<span class="comment">//-------------make histograms-----------------------------------------</span>
    <span class="keywordtype">bool</span> successfulInsertion = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> successfulPQSplit = <span class="keyword">false</span>;
    <span class="keywordtype">bool</span> successfulPQMerge = <span class="keyword">false</span>;
  
<span class="comment">// for different maxCount</span>
<span class="keywordtype">size_t</span> maxCount = n;

<span class="comment">//container to keep number of leaf boxes for histograms</span>
vector&lt;double&gt; boxCountVec;
vector&lt;double&gt;::iterator itBoxCountVec;

<span class="comment">// loop to make histograms</span>
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt;= numHist; j++){ 
       cout &lt;&lt; <span class="stringliteral">&quot;Doing hist number &quot;</span> &lt;&lt; j &lt;&lt; endl;
        
<span class="comment">// container to keep IAE</span>
vector&lt;dotprecision&gt; dpIAEVec;
vector&lt;dotprecision&gt;::iterator dpIAEVecIt;

<span class="comment">//container to keep time</span>
vector&lt;double&gt; timeVec;
vector&lt;double&gt;::iterator itTimeVec;

<span class="comment">//container to keep %of bins in envelope</span>
vector&lt;double&gt; covAllVec;
vector&lt;double&gt;::iterator itCovAllVec;

<span class="comment">//container to keep difference in measures</span>
vector&lt;double&gt; diffMuVec;
vector&lt;double&gt;::iterator itDiffMuVec;

        <span class="comment">// ----- generate data---------------------------</span>
        <a class="code" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68" title="Define type RVecData as a container for rvectors.">RVecData</a> theData;   <span class="comment">// a container for all the points generated</span>
        rvector thisrv(d);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k =0; k &lt;n; k++){
            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1; i &lt;= d; i++) {
               thisrv[i]  = gsl_rng_uniform(r);
             } 
          <span class="comment">// put points generated into container</span>
          theData.push_back(thisrv);
         } <span class="comment">// data  should be in theData</span>

        cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot; samples generated.&quot;</span> &lt;&lt; endl;

     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> mC = 1; mC &lt;= 100; mC++){
       <span class="keywordtype">int</span> maxC = mC*step;
       cout &lt;&lt; <span class="stringliteral">&quot;Maximum count is : &quot;</span> &lt;&lt; maxC &lt;&lt; endl;


      <span class="comment">//----- make an Adaptive Histogram object with a specified box</span>
       <a class="code" href="classsubpavings_1_1AdaptiveHistogram.shtml" title="A wrapper or manager for an SPSnode aka StatsSubPaving in conjunction with massive amounts of sample ...">AdaptiveHistogram</a> myHist(pavingBox);

      <span class="comment">//--- put the data from the container into the histogram</span>
      <span class="keywordtype">bool</span> successfulInsertion = myHist.insertFromRVec(theData);
          

      <span class="comment">// split node wth most points in first (compCount)</span>
      <a class="code" href="classsubpavings_1_1CompCount.shtml" title="Class comparing on count of data points associated with a node.">CompCount</a> nodeCompCount;
      <a class="code" href="classsubpavings_1_1CritLargestCount__LTE.shtml" title="Class for testing the count of the node with the largest count in histogram&#39;s subpaving.">CritLargestCount_LTE</a> critCount(maxC);
       
      <span class="keywordflow">if</span> (successfulInsertion) {
        clock_t start, end;
        start = clock();
      <span class="comment">// now split with priority queue</span>
      <span class="comment">// Stopping Criteria: critCount</span>
      successfulPQSplit = myHist.prioritySplit(nodeCompCount, critCount, <a class="code" href="namespacesubpavings.shtml#aef8e51096b59ecaf1a1e9b2ee24b6089a1e5eba048e2496b2450d63fc2e9d1737">NOLOG</a>);
      
        end = clock();
        <span class="keywordtype">double</span> timing;
        timing = ((<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(end - start)) / CLOCKS_PER_SEC);
        cout &lt;&lt; <span class="stringliteral">&quot;Computing time : &quot;</span> &lt;&lt; timing &lt;&lt; <span class="stringliteral">&quot; s.&quot;</span>&lt;&lt; endl;
        timeVec.push_back(timing);
      } <span class="comment">// end of if successfulInsertion</span>

     <span class="keywordflow">if</span> (successfulPQSplit) {

    
      <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> leaves; <span class="comment">// set up empty container for leaf node pointers</span>
      <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> it; <span class="comment">// and an iterator over the container</span>
      myHist.getSubPaving()-&gt;getLeaves(leaves); <span class="comment">// fill the container</span>
      <span class="comment">// container is filled by reading leaves off tree from left to right</span>

          <span class="comment">// a container for the counts</span>
          <a class="code" href="namespacesubpavings.shtml#aed8e75b2af342b9c1460431c223dca8e" title="Define type IntVec as a container for ints.">IntVec</a> counts;  <span class="comment">// IntVec is a typedef for vector&lt;int&gt;</span>
                            <span class="comment">// the iterator is typedefed as IntVecItr</span>
          <span class="comment">// a container for the boxes</span>
          vector&lt;ivector&gt; boxes;
          vector&lt;ivector&gt;::iterator itBoxes;
          <span class="comment">// a container for the volumes</span>
          vector&lt;double&gt; volumes;
          <span class="comment">// a valarray container for the node levels, sized to fit</span>
          valarray&lt;int&gt; levels(<a class="code" href="namespacesubpavings.shtml#acd777346441d8790899ec09af3b11d61" title="Get the number of leaves of a tree (boxes in the subpaving)">spLeaves</a>(myHist.getSubPaving()));
          <span class="comment">// a container for fhat</span>
          vector&lt;double&gt; fhat;
          vector&lt;double&gt;::iterator itFhat;
         
          <span class="keywordtype">double</span> diffMu = 0;

          <span class="keywordflow">for</span>(it = leaves.begin(); it &lt; leaves.end(); it++) {
          <span class="comment">// remember that it points to a pointer, so *it is still a ptr</span>
               <span class="comment">// get the counts in all the leaves</span>
               counts.push_back((*it)-&gt;getCounter());
               <span class="comment">// get the boxes from all the leaves</span>
               boxes.push_back((*it)-&gt;getBox());
               <span class="comment">// get the volumes of all the leaves</span>
               volumes.push_back((*it)-&gt;nodeVolume());
               <span class="comment">// get fhat for all leaves</span>
               fhat.push_back(((*it)-&gt;getCounter())/((*it)-&gt;nodeVolume())/n);
               <span class="comment">//calculate \mu_n - \mu</span>
               diffMu += fabs((*it)-&gt;nodeVolume() - ((*it)-&gt;getCounter()*1.0/(n*1.0)));
<span class="comment">//              double diffMu=fabs((*it)-&gt;nodeVolume() - ((*it)-&gt;getCounter()*1.0/(n*1.0)));</span>
            }
         
              diffMuVec.push_back(diffMu);
     <span class="comment">//------------Calcuate Integrated Absolute Error------------------//</span>
     dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>;
     dpIAE=0.0;
     rvector result(1);
     result[1] = 0.0;

     dpIAE = <a class="code" href="Coverage_8cpp.shtml#aa761d6c65ae1def2134f8829dd6be8fd">getUnifIAE</a>(fhat, volumes);
     dpIAEVec.push_back(dpIAE);


<span class="comment">//------------Calculate lower and upper bounds---------------------</span>
<span class="keywordtype">int</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a> = fhat.size();
boxCountVec.push_back(Nbin);

<span class="keywordflow">for</span> (<span class="keywordtype">int</span> a=1; a&lt;=90; a++){
<span class="keywordtype">double</span> alpha = a*0.01;
<span class="keywordtype">double</span> yesCovOne = 0;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; i &lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; i++){
  <span class="comment">// c</span>
  <span class="keywordtype">double</span> c = gsl_cdf_ugaussian_Qinv(alpha/2*volumes[i])*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1/volumes[i])/2/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(n);

  <span class="comment">// lower bound</span>
  <span class="keywordtype">double</span> <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a> = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(fmax(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(fhat[i])-c, 0), 2);
  <span class="comment">// upper bound</span>
  <span class="keywordtype">double</span> <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a> = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(fhat[i]) + c, 2);

  <span class="keywordflow">if</span> (1&gt;= Lb &amp;&amp; 1&lt;= Ub)
  { yesCovOne += 1;}
}
<span class="comment">//cout &lt;&lt; yesCovOne*1.0/Nbin*1.0 &lt;&lt; &quot; bins inside envelope&quot; &lt;&lt; endl;</span>
covAllVec.push_back(yesCovOne*1.0/(Nbin*1.0));
} <span class="comment">// end of loop for alpha</span>

std::ostringstream stm1;
stm1 &lt;&lt; j;
<span class="keywordtype">string</span> CIFileName;
CIFileName = <span class="stringliteral">&quot;UnifCI&quot;</span>;
CIFileName += stm1.str();
CIFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
oss.open(CIFileName.c_str());
<span class="keywordflow">for</span> (itCovAllVec = covAllVec.begin(); itCovAllVec &lt; covAllVec.end(); itCovAllVec++){
oss &lt;&lt; (*itCovAllVec) &lt;&lt; endl ;
}
oss &lt;&lt; flush;
oss.close();
cout &lt;&lt; <span class="stringliteral">&quot;CI&#39;s output to &quot;</span> &lt;&lt; CIFileName &lt;&lt; endl;
     } <span class="comment">// end of if(successfulPQSplit)</span>

    } <span class="comment">// end of loop for maxCount</span>

<span class="comment">//-------------------------output vecIAE to .txt file--------------------</span>
  <span class="keywordtype">string</span> outputFileName;<span class="comment">// for output file</span>

outputFileName = <span class="stringliteral">&quot;UnifIAEHist&quot;</span>;
std::ostringstream stm1, stm2;
stm1 &lt;&lt; j;
outputFileName += stm1.str();
stm2&lt;&lt; maxCount;
outputFileName+=<span class="stringliteral">&quot;max&quot;</span>;
outputFileName+=stm2.str();
outputFileName+= <span class="stringliteral">&quot;.txt&quot;</span>;

oss.open(outputFileName.c_str());
<span class="keywordflow">for</span> (dpIAEVecIt = dpIAEVec.begin(); dpIAEVecIt &lt; dpIAEVec.end(); dpIAEVecIt++){
oss &lt;&lt; (*dpIAEVecIt) &lt;&lt; endl;
}
oss &lt;&lt; flush;
oss.close();
cout &lt;&lt; <span class="stringliteral">&quot;IAE output to &quot;</span> &lt;&lt; outputFileName &lt;&lt; endl;

<span class="keywordtype">string</span> timeFileName;
timeFileName = <span class="stringliteral">&quot;UnifIAETime&quot;</span>;
timeFileName += stm1.str();
timeFileName += <span class="stringliteral">&quot;.txt&quot;</span>;

oss.open(timeFileName.c_str());
<span class="keywordflow">for</span> (itTimeVec = timeVec.begin(); itTimeVec &lt; timeVec.end(); itTimeVec++){
oss &lt;&lt; (*itTimeVec) &lt;&lt; endl ;
}
oss &lt;&lt; flush;
oss.close();
cout &lt;&lt; <span class="stringliteral">&quot;Timings output to &quot;</span> &lt;&lt; timeFileName &lt;&lt; endl;

cout &lt;&lt; <span class="stringliteral">&quot;--------------------------------------------------------&quot;</span> &lt;&lt; endl &lt;&lt; endl;
<span class="comment">//------output Epsilon------------------</span>
<span class="keywordtype">string</span> diffMuFileName;
<span class="comment">//std::ostringstream stm3;</span>
<span class="comment">//stm3 &lt;&lt; bigD;</span>
diffMuFileName = <span class="stringliteral">&quot;UnifDiffMu&quot;</span>;
<span class="comment">//diffMuFileName += stm3.str();</span>
diffMuFileName += stm1.str();
diffMuFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
oss.open(diffMuFileName.c_str());
<span class="keywordflow">for</span> (itDiffMuVec = diffMuVec.begin(); itDiffMuVec &lt; diffMuVec.end(); itDiffMuVec
++){
oss &lt;&lt; (*itDiffMuVec) &lt;&lt; endl ;
}
oss &lt;&lt; flush;
oss.close();
cout &lt;&lt; <span class="stringliteral">&quot;Diff Mu output to &quot;</span> &lt;&lt; diffMuFileName &lt;&lt; endl;
} <span class="comment">//end of loop for histograms</span>

<span class="keywordtype">string</span> boxCountFileName;
std::ostringstream stm3;
<span class="comment">//stm3 &lt;&lt; bigD;</span>
boxCountFileName = <span class="stringliteral">&quot;UnifBoxCount&quot;</span>;
<span class="comment">//boxCountFileName += stm3.str();</span>
boxCountFileName += <span class="stringliteral">&quot;.txt&quot;</span>;
oss.open(boxCountFileName.c_str());
<span class="keywordflow">for</span> (itBoxCountVec = boxCountVec.begin(); itBoxCountVec &lt; boxCountVec.end(); itBoxCountVec
++){
oss &lt;&lt; (*itBoxCountVec) &lt;&lt; endl ;
}
oss &lt;&lt; flush;
oss.close();
cout &lt;&lt; <span class="stringliteral">&quot;Box Count output to &quot;</span> &lt;&lt; boxCountFileName &lt;&lt; endl;










<span class="comment">// free the random number generator</span>
gsl_rng_free (r);

<span class="keywordflow">return</span> 0;

} <span class="comment">// end of histogram report test program</span>
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="Coverage_8cpp.shtml">Coverage.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:19 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
