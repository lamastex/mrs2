<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: errorfunc.hpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('errorfunc_8hpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">errorfunc.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>L1-error function declarations.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="sptypes_8hpp_source.shtml">sptypes.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="adaptivehistogram_8hpp_source.shtml">adaptivehistogram.hpp</a>&quot;</code><br/>
<code>#include &lt;gsl/gsl_rng.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_randist.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_cdf.h&gt;</code><br/>
<code>#include &lt;gsl/gsl_integration.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="Int_8h_source.shtml">../examples/StatsSubPav/ExactInt/Int.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="dim2taylor_8hpp_source.shtml">../examples/StatsSubPav/ExactInt/dim2taylor.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="intervalw_8h_source.shtml">intervalw.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ia__ad_8h_source.shtml">ia_ad.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="itaylor_8h_source.shtml">itaylor.h</a>&quot;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
</div>
<p><a href="errorfunc_8hpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFinMix.shtml">FinMix</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRegHist.shtml">RegHist</a></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesubpavings.shtml">subpavings</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The namespace subpavings. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declarations of typedef taylor. This is used for 2D integrations.  <a href="#ac90353a98ada0c22146b3ea9f0ac7a4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitaylor.shtml">itaylor</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a> )(const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;, vector&lt; double &gt; &amp;, vector&lt; double &gt; &amp;, vector&lt; double &gt; &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitaylor.shtml">itaylor</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a20ba5d9759ec5f70b3772967b589ed3e">pfcnLaplace</a> )(const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classitaylor.shtml">itaylor</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a48908ee3bc312005f3b46888bcc0cdd3">pfcnLognormal</a> )(const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a64a6fd302dffeebb366383e265ea20f6">myMean</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mean of the data (this is used when building the regular histogram)  <a href="#a64a6fd302dffeebb366383e265ea20f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a674756d3d6aae91356b22688a849bd0f">myStd</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the standard deviation of the data (this is used when building the regular histogram)  <a href="#a674756d3d6aae91356b22688a849bd0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ae767ea3ddeac1e55d74384fe0cd42ecd">gaussian</a> (std::vector&lt; double &gt; &amp;vecNPD, std::vector&lt; double &gt; &amp;XX, double SS)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian probability density function. Generates normal probability density values corresponding to X which is a vector of doubles.  <a href="#ae767ea3ddeac1e55d74384fe0cd42ecd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classia__ad.shtml">ia_ad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitaylor.shtml">itaylor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ae473bc19e57e3781680652a61018aa79">integrand</a> (const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a118fce03849bd0483b3b66ae6df14365">DF</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#abcd464084d71d1ca5caf89793fa1d050">N</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S, double fhat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a4954d5b0e64b315bea343c911e1cd0e3">findRoot</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;domain, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S, double fhat, vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;rootList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#afbbae9b11925b35788b24ce58e63336f">bisect</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, const double &amp;TOL, double &amp;fhat, vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;rootList, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ad7abf0d6b473ad78b1737a9e972395c2">riemannTerm</a> (<a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval X, int Deg, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aa0f25ae1a698fab2a49e83283c2b0dd1">integrate</a> (<a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval X, int Deg, double Tol, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a> (double fhat, interval &amp;thisInt, int Deg, double TOL, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classia__ad.shtml">ia_ad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a5c072ddf22efaed3c1dc612f42290f30">LaplacePDF</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitaylor.shtml">itaylor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a113114b7f2ac4e8e3c7900ab491eaf1b">LaplaceIntegrand</a> (const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a83cb93d97adbc26d2b6731e89725b7d6">LaplaceF</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a1df0b848b1e7ebd2de5866266df70ceb">LaplaceDF</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a64a77490c542f82e7ae00ab525f3efe1">LaplaceNewton</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, double fhat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aeda7aada753d81a54e812a7ce416d0f5">LaplacefindRoot</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;domain, double fhat, vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;rootList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ac2975a7f53b8bbdf01bb073b661a766d">LaplaceBisect</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, const double &amp;TOL, double &amp;fhat, vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;rootList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#acf4170da9030fb2776342b5e04e2ef7b">LaplaceRiemannTerm</a> (<a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval X, int Deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a18bf9ac674a2a633029b5ca438084099">LaplaceIntegrate</a> (<a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval X, int Deg, double Tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a> (double fhat, interval &amp;thisInt, int Deg, double TOL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classia__ad.shtml">ia_ad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a6640f4518f5a29d2caa7dd15c3d05be0">LognormalPDF</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitaylor.shtml">itaylor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aacb93c77ab57e8ed2b6a1c581e60db5d">LognormalIntegrand</a> (const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a256e19e7647e7510144ff8e3064b07c1">LognormalF</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a45238105e02452f020b01a332fee8913">LognormalDF</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classintervalw.shtml">intervalw</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a2ad23089c1ee547e199a0e481a973f02">LognormalNewton</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, double fhat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ad0d44cb3344c0a21cfbf56bb7d263066">LognormalfindRoot</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;domain, double fhat, vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;rootList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ae609c2490a47ae5b66bbc9ed34ede493">LognormalBisect</a> (const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;x, const double &amp;TOL, double &amp;fhat, vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;rootList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a13b6ea07dcfc5c287205aab201a94c2e">LognormalRiemannTerm</a> (<a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval X, int Deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aab82d694198dfbd61222e06b563af748">LognormalIntegrate</a> (<a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval X, int Deg, double Tol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a> (double fhat, interval &amp;thisInt, int Deg, double TOL)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Family of functions for the bivariate gaussian</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#abd72fe76528917561a4e1a7fdf7890d9">BiGOP</a> (<a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a> X, interval fhat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IAE for the bivariate gaussian.  <a href="#abd72fe76528917561a4e1a7fdf7890d9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Family of functions for the Levy 2D</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a72f3aaf218533dc785d09b0dffacbad7">LevyOP</a> (<a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a> X, interval fhat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IAE for the Levy 2D.  <a href="#a72f3aaf218533dc785d09b0dffacbad7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Family of functions for the Rosenbrock 2D</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a77af86554abcee2e013b9d8631ed4c5f">RosenOP</a> (<a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a> X, interval fhat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IAE for a Rosenbrock 2D.  <a href="#a77af86554abcee2e013b9d8631ed4c5f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Family of functions for finite mixtures.</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a2f3a0386e9b82f691a73f7710b759117">FinMixPDF</a> (double x, std::vector&lt; double &gt; &amp;W, std::vector&lt; double &gt; &amp;M, std::vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the probability density function of a finite mixture r.v.  <a href="#a2f3a0386e9b82f691a73f7710b759117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aa5f10d5325f39aa971fc7e984557514a">FinMixCDF</a> (double, double, std::vector&lt; double &gt; &amp;W, std::vector&lt; double &gt; &amp;M, std::vector&lt; double &gt; &amp;S)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cumulative distribution function of a finite mixture r.v.  <a href="#aa5f10d5325f39aa971fc7e984557514a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a0350bc07337b5abac1dca82fb195940d">FinMixAbs</a> (double x, void *params)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute error of a finite mixture at x.  <a href="#a0350bc07337b5abac1dca82fb195940d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">dotprecision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a3050c350d49593d9b2aa0b0cf58857a4">dpFinMixIAEBoun</a> (double x1, double x2, <a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the IAE at boundaries of a finite mixture.  <a href="#a3050c350d49593d9b2aa0b0cf58857a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a9e3934b3e6ab0c312ffc4e1af23b0417">findComp</a> (vector&lt; double &gt; &amp;u, int &amp;intp, const int n, double *weight, int w)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the number of generated U(0,1) data that is less the weight of the components.  <a href="#a9e3934b3e6ab0c312ffc4e1af23b0417"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a01b414e902b54359e1a77e52f0e6fbb3">cumsum</a> (vector&lt; double &gt; &amp;weight, double *w)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Family of functions for the regular histogram including error</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>calculations. Bandwidth method: 0 = Scott's normal reference rule, 1 = Wand's one-stage rule, 2 = Wand's two-stage rule, </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a1cbeb2c4ee32bf849533e448710c50e3">makeRegularHist</a> (<a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, ivector theBox, int bwmethod)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a regular histogram (using Dominic's histogram.m file)  <a href="#a1cbeb2c4ee32bf849533e448710c50e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#accc20534ffc0e82153262d1a063c2059">makeRegularHist</a> (<a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, ivector theBox, double bw)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aeec9912b8816ad5b3a449f80f9e5d983">psi</a> (const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;rvec, double g, double r)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function required for regular histogram.  <a href="#aeec9912b8816ad5b3a449f80f9e5d983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a9e8c99f0ea9229f7e86f263f834e9869">getRegHistUnifIAE</a> (<a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, <a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;myPart, size_t n, double weight, vector&lt; int &gt; holesLoc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a538c5046923fbdee301324f35285d79c">getRegHistFinMixIAE</a> (size_t n, <a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, <a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a3b281b5e62f571e14e7c127af8d7e74a">getRegHistFinMixIntervalIAE</a> (size_t n, <a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, <a class="el" href="structFinMix.shtml">FinMix</a> &amp;mixt, double tol, int deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#a7edbd158ed300803fe59b38c60f90875">getRegHistLaplaceIntervalIAE</a> (size_t n, <a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, double tol, int deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">interval&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#ac2e78d0ba1f818d2e1a81b95544972d8">getRegHistLognormalIntervalIAE</a> (size_t n, <a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, double tol, int deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="errorfunc_8hpp.shtml#aad70f5031a514e5cc5799cda7e878258">outputRegHistToTxt</a> (<a class="el" href="structRegHist.shtml">RegHist</a> &amp;myRegHist, std::string &amp;s)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>L1-error function declarations. </p>

<p>Definition in file <a class="el" href="errorfunc_8hpp_source.shtml">errorfunc.hpp</a>.</p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ac90353a98ada0c22146b3ea9f0ac7a4d"></a><!-- doxytag: member="errorfunc.hpp::d2t" ref="ac90353a98ada0c22146b3ea9f0ac7a4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtaylor_1_1dim2taylor.shtml">taylor::dim2taylor</a> <a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declarations of typedef taylor. This is used for 2D integrations. </p>

<p>Definition at line <a class="el" href="errorfunc_8hpp_source.shtml#l00053">53</a> of file <a class="el" href="errorfunc_8hpp_source.shtml">errorfunc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a40f7b267e7bca7091a0d4b941ebe3495"></a><!-- doxytag: member="errorfunc.hpp::d2tv" ref="a40f7b267e7bca7091a0d4b941ebe3495" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtaylor_1_1dim2taylor__vector.shtml">taylor::dim2taylor_vector</a> <a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8hpp_source.shtml#l00054">54</a> of file <a class="el" href="errorfunc_8hpp_source.shtml">errorfunc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeac7a36a4f16518672428778c5db67dc"></a><!-- doxytag: member="errorfunc.hpp::pfcn" ref="aeac7a36a4f16518672428778c5db67dc" args=")(const itaylor &amp;, vector&lt; double &gt; &amp;, vector&lt; double &gt; &amp;, vector&lt; double &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classitaylor.shtml">itaylor</a>(* <a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a>)(const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;, vector&lt; double &gt; &amp;, vector&lt; double &gt; &amp;, vector&lt; double &gt; &amp;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8hpp_source.shtml#l00110">110</a> of file <a class="el" href="errorfunc_8hpp_source.shtml">errorfunc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20ba5d9759ec5f70b3772967b589ed3e"></a><!-- doxytag: member="errorfunc.hpp::pfcnLaplace" ref="a20ba5d9759ec5f70b3772967b589ed3e" args=")(const itaylor &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classitaylor.shtml">itaylor</a>(* <a class="el" href="errorfunc_8hpp.shtml#a20ba5d9759ec5f70b3772967b589ed3e">pfcnLaplace</a>)(const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8hpp_source.shtml#l00150">150</a> of file <a class="el" href="errorfunc_8hpp_source.shtml">errorfunc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48908ee3bc312005f3b46888bcc0cdd3"></a><!-- doxytag: member="errorfunc.hpp::pfcnLognormal" ref="a48908ee3bc312005f3b46888bcc0cdd3" args=")(const itaylor &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classitaylor.shtml">itaylor</a>(* <a class="el" href="errorfunc_8hpp.shtml#a48908ee3bc312005f3b46888bcc0cdd3">pfcnLognormal</a>)(const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8hpp_source.shtml#l00186">186</a> of file <a class="el" href="errorfunc_8hpp_source.shtml">errorfunc.hpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="abd72fe76528917561a4e1a7fdf7890d9"></a><!-- doxytag: member="errorfunc.hpp::BiGOP" ref="abd72fe76528917561a4e1a7fdf7890d9" args="(d2tv X, interval fhat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a> <a class="el" href="errorfunc_8hpp.shtml#abd72fe76528917561a4e1a7fdf7890d9">BiGOP</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a>&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>fhat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IAE for the bivariate gaussian. </p>
<p>The integral of the absolute error for a bivariate gaussian. </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00059">59</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00132">taylor::init_const()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00592">taylor::sqr()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03408">subpavings::AdaptiveHistogramValidation::getIAE()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03748">subpavings::AdaptiveHistogram::getIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;Calling BiGOP: &quot; &lt;&lt; endl;</span>
   <span class="comment">// Parameters specific to the Bivariate Gaussian target</span>
  real rsigma_x = 1.0;
  real rsigma_y = 1.0;
  real rrho = 0;
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a> = <a class="code" href="namespacetaylor.shtml#a2d1667d3b5c500795eb06c586d75c309">taylor::init_const</a>(X[1].order(),interval(0.0));
  real det = 1.0/(2*M_PI*rsigma_x*rsigma_y*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(1-<a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(rrho)));
  f = <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(X[1]/rsigma_x) + <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(X[2]/rsigma_y) - 
            (2*rrho*X[1]*X[2])/(rsigma_x*rsigma_y);
  f = det * <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a> (-((1.0/2*(1-<a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(rrho))) * f));
  
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> result = <a class="code" href="namespacetaylor.shtml#a2d1667d3b5c500795eb06c586d75c309">taylor::init_const</a>(X[1].order(),interval(0.0));

  <span class="comment">//split the integrand to get positive values only (absolute values) </span>
  <span class="keywordflow">if</span> ( (Sup(f[0][0]) &lt; Inf(fhat)) ) {   
    result = fhat - <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>;
    <span class="comment">//cout &lt;&lt; &quot;fhat - f: &quot; &lt;&lt; result[0][0] &lt;&lt; &quot;\n&quot; &lt;&lt; endl;</span>
  }  
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Sup(f[0][0]) &gt; Inf(fhat))) { 
     result = f - fhat; 
    <span class="comment">//cout &lt;&lt; &quot;f-fhat: &quot; &lt;&lt; result[0][0] &lt;&lt; &quot;\n&quot; &lt;&lt; endl;</span>
  }   
  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="afbbae9b11925b35788b24ce58e63336f"></a><!-- doxytag: member="errorfunc.hpp::bisect" ref="afbbae9b11925b35788b24ce58e63336f" args="(const intervalw &amp;x, const double &amp;TOL, double &amp;fhat, vector&lt; intervalw &gt; &amp;rootList, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#afbbae9b11925b35788b24ce58e63336f">bisect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rootList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01432">1432</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01390">DF()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01404">findRoot()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l01391">subpavings::AdaptiveHistogramCollator::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">subpavings::AdaptiveHistogramValidation::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03970">subpavings::AdaptiveHistogram::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04065">getFinMixIntervalTrueDelta()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00733">getRegHistFinMixIntervalIAE()</a>, and <a class="el" href="IntervalArithIAE_8cpp_source.shtml#l00066">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;root finding routine: &quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot;\t&quot; &lt;&lt; F(x, W, M, S)  &lt;&lt; &quot;\t&quot; &lt;&lt; DF(x, W, M, S) &lt;&lt; endl;</span>

  <span class="comment">//if the function is twice differentiable?</span>
  <span class="keywordflow">if</span> ( !subset(0.0, <a class="code" href="errorfunc_8cpp.shtml#a118fce03849bd0483b3b66ae6df14365">DF</a>(x, W, M, S)) ) {
    <span class="comment">//cout &lt;&lt; &quot;Sending &quot; &lt;&lt; x &lt;&lt; &quot; to the Newton operator...&quot; &lt;&lt; endl;</span>
    <a class="code" href="errorfunc_8cpp.shtml#ac2e7de1da18a8a42ff1752b888026284">findRoot</a>(x, W, M, S, fhat, rootVec);
  }
  
  <span class="keywordflow">else</span> {
   <span class="comment">// if the function is not differentiable</span>
    <span class="keywordflow">if</span> ( subset(fhat, <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>(x, W, M, S)) ) {
      <span class="comment">//cout &lt;&lt; diam(x) &lt;&lt; &quot;\t&quot; &lt;&lt; TOL &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> ( diam(x) &lt; TOL ) {
        <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; may contain roots. &quot; &lt;&lt; endl;</span>
        rootVec.push_back(x); <span class="comment">//keep the roots in a container</span>
      }
      <span class="keywordflow">else</span> {
        <a class="code" href="errorfunc_8cpp.shtml#a4a991d5ab1bd0a117e02af6f83369bab">bisect</a>(<a class="code" href="classintervalw.shtml">intervalw</a>(inf(x), mid(x)), TOL, fhat, rootVec, W, M, S);
        <a class="code" href="errorfunc_8cpp.shtml#a4a991d5ab1bd0a117e02af6f83369bab">bisect</a>(<a class="code" href="classintervalw.shtml">intervalw</a>(mid(x), sup(x)), TOL, fhat, rootVec, W, M, S);
      }
    }
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a01b414e902b54359e1a77e52f0e6fbb3"></a><!-- doxytag: member="errorfunc.hpp::cumsum" ref="a01b414e902b54359e1a77e52f0e6fbb3" args="(vector&lt; double &gt; &amp;weight, double *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#a01b414e902b54359e1a77e52f0e6fbb3">cumsum</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to get cumulative sum </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">weight</td><td>is the weights of members in mixtures </td></tr>
    <tr><td class="paramname">w</td><td>is the component of weight </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a118fce03849bd0483b3b66ae6df14365"></a><!-- doxytag: member="errorfunc.hpp::DF" ref="a118fce03849bd0483b3b66ae6df14365" args="(const intervalw &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a118fce03849bd0483b3b66ae6df14365">DF</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01390">1390</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01396">N()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> deriv(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>(x, W, M, S)); }
</pre></div>
</div>
</div>
<a class="anchor" id="a3050c350d49593d9b2aa0b0cf58857a4"></a><!-- doxytag: member="errorfunc.hpp::dpFinMixIAEBoun" ref="a3050c350d49593d9b2aa0b0cf58857a4" args="(double x1, double x2, FinMix &amp;mixt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dotprecision <a class="el" href="HoldOutFinMix_8cpp.shtml#ac799088b059b39fe7ba90b2baeaf0208">dpFinMixIAEBoun</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the IAE at boundaries of a finite mixture. </p>
<p>get the integrated absolute of a finite mixture at the boundaries </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00200">200</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l00200">dpFinMixIAEBoun()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01389">taylor::erf()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00221">FinMix::M</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00222">FinMix::S</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00220">FinMix::W</a>.</p>

<p>Referenced by <a class="el" href="CoverageNormal_8cpp_source.shtml#l00490">dpFinMixIAEBoun()</a>, and <a class="el" href="CoverageNormal_8cpp_source.shtml#l00085">main()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  dotprecision <a class="code" href="errorfunc_8cpp.shtml#a3050c350d49593d9b2aa0b0cf58857a4" title="Calculate the IAE at boundaries of a finite mixture.">dpFinMixIAEBoun</a>;
  dpFinMixIAEBoun = 0.0;
  <span class="keywordtype">double</span> Ncomp = (mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>).size();
  <span class="keywordtype">double</span> cdfLeft = 0.0;
  <span class="keywordtype">double</span> cdfRight = 0.0;
  <span class="keywordtype">int</span> c;

  <span class="keywordflow">for</span> (c=0; c &lt; Ncomp; c++) {
    cdfLeft += mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>[c]*0.5*(1 + <a class="code" href="namespacetaylor.shtml#ac58758459f916c91fbadcdb56c22c543">erf</a>((x1-mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>[c])/mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>[c]/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2)));
    cdfRight += 1-mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>[c]*0.5*(1 + <a class="code" href="namespacetaylor.shtml#ac58758459f916c91fbadcdb56c22c543">erf</a>((x2-mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>[c])/mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>[c]/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2)));
  }

  accumulate(dpFinMixIAEBoun, cdfLeft, 1.0);
  accumulate(dpFinMixIAEBoun, cdfRight, 1.0);

  <span class="keywordflow">return</span> <a class="code" href="errorfunc_8cpp.shtml#a3050c350d49593d9b2aa0b0cf58857a4" title="Calculate the IAE at boundaries of a finite mixture.">dpFinMixIAEBoun</a>;
} 
</pre></div>
</div>
</div>
<a class="anchor" id="aacb77b1211a6ca2e2beff1811cf9ecf4"></a><!-- doxytag: member="errorfunc.hpp::f" ref="aacb77b1211a6ca2e2beff1811cf9ecf4" args="(const intervalw &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classia__ad.shtml">ia_ad</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01529">1529</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>, and <a class="el" href="classia__ad.shtml#a4b29351e6e75dabcdc06ea86a83d1212">ia_ad::variable()</a>.</p>

<p>Referenced by <a class="el" href="dim2taylor_8cpp_source.shtml#l01267">taylor::acos()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01336">taylor::acosh()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01301">taylor::acot()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01371">taylor::acoth()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01250">taylor::asin()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01318">taylor::asinh()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01284">taylor::atan()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01354">taylor::atanh()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00059">BiGOP()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01113">taylor::cot()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01233">taylor::coth()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01390">DF()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00174">subpavings::Evaluate()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">Evaluate()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03854">subpavings::AdaptiveHistogram::getUnifIAE()</a>, <a class="el" href="GOpt_8cpp_source.shtml#l00100">GOptMax()</a>, <a class="el" href="GOpt_8cpp_source.shtml#l00061">GOptMin()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00088">LevyOP()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00960">taylor::ln()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00975">taylor::lnp1()</a>, <a class="el" href="CesaroBellNo_8cpp_source.shtml#l00063">main()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01462">riemannTerm()</a>, <a class="el" href="Quadrature1_8cpp_source.shtml#l00040">Rosenbrock()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00129">RosenOP()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00991">taylor::sqrtp1m1()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01095">taylor::tan()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01216">taylor::tanh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classia__ad.shtml">ia_ad</a> PDF(<a class="code" href="classia__ad.shtml#a4b29351e6e75dabcdc06ea86a83d1212">ia_ad::variable</a>(x));

  <a class="code" href="classintervalw.shtml">intervalw</a> startPDF(0,0);
  PDF = startPDF;
  
  <span class="keywordtype">size_t</span> Ncomp = W.size();
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c=0; c &lt; Ncomp; c++){
    <span class="comment">//cout &lt;&lt; c &lt;&lt; &quot;-th component:&quot; &lt;&lt; W[c] &lt;&lt; &quot;\t&quot; &lt;&lt; M[c] &lt;&lt; &quot;\t&quot; &lt;&lt; S[c] &lt;&lt; endl;</span>
    <a class="code" href="classintervalw.shtml">intervalw</a> z = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((x-M[c])/S[c], 2);
    <a class="code" href="classintervalw.shtml">intervalw</a> expPart = <a class="code" href="classintervalw.shtml">intervalw</a>(<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-0.5*sup(z)), <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-0.5*inf(z)));
    PDF = PDF + expPart*(W[c]/(S[c]*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2*M_PI)));
  }
  <span class="comment">//cout &lt;&lt; &quot;Domain: &quot; &lt;&lt; x &lt;&lt; &quot;\t PDF: &quot; &lt;&lt; PDF &lt;&lt; endl;</span>

  <span class="keywordflow">return</span> PDF;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9b001c0caead3a0c05ed60872773d535"></a><!-- doxytag: member="errorfunc.hpp::F" ref="a9b001c0caead3a0c05ed60872773d535" args="(const intervalw &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01386">1386</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03530">subpavings::AdaptiveHistogramValidation::getFinMixIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03895">subpavings::AdaptiveHistogram::getFinMixIAE()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00683">getRegHistFinMixIAE()</a>, <a class="el" href="CoverageNormal_8cpp_source.shtml#l00085">main()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01396">N()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> value(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>(x, W, M, S)); }
</pre></div>
</div>
</div>
<a class="anchor" id="a9e3934b3e6ab0c312ffc4e1af23b0417"></a><!-- doxytag: member="errorfunc.hpp::findComp" ref="a9e3934b3e6ab0c312ffc4e1af23b0417" args="(vector&lt; double &gt; &amp;u, int &amp;intp, const int n, double *weight, int w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#a9e3934b3e6ab0c312ffc4e1af23b0417">findComp</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>intp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to find the number of generated U(0,1) data that is less the weight of the components. </p>
<p>Find the number of generated U(0,1) data that is less the weight of the components. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>is an array that holds U(0,1) rv. </td></tr>
    <tr><td class="paramname">intp</td><td>is always 0 </td></tr>
    <tr><td class="paramname">n</td><td>is the total number of data points </td></tr>
    <tr><td class="paramname">weight</td><td>is the weights of the mixture </td></tr>
    <tr><td class="paramname">w</td><td>is the weight component that we want to find the number of members of </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00223">223</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>Referenced by <a class="el" href="MCMCGRSimsDbl_8cpp_source.shtml#l00133">doMCMCGRAuto()</a>, and <a class="el" href="FiniteMixture_8cpp_source.shtml#l00045">main()</a>.</p>
<div class="fragment"><pre class="fragment">{     
  <span class="comment">// set up an array that checks whether a U(0,1) r.v. is a member of that </span>
  <span class="comment">// component or not. &#39;1&#39; if true; &#39;0&#39; if false.</span>
  <span class="comment">//vector&lt;int&gt; u_one(n);</span>
  
  <span class="keywordtype">int</span> j;
  <span class="comment">// check if the U(0,1) r.v. is a member of the component or not.</span>
  <span class="keywordflow">if</span> (w==0) {
    <span class="keywordflow">for</span> (j=0; j&lt;n; j++) {
      <span class="keywordflow">if</span> (u[j] &lt;= *(weight + w))
      { intp++; }
      <span class="comment">//cout&lt;&lt;u_one[j1]&lt;&lt;endl;</span>
    }
  }
  <span class="keywordflow">else</span> {
  <span class="comment">//cout &lt;&lt; &quot;Checking for members between &quot; &lt;&lt; *(WeightCumPtr + m-1) &lt;&lt; </span>
  <span class="comment">//&quot; and &quot; &lt;&lt; *(WeightCumPtr + m) &lt;&lt; endl;</span>
    <span class="keywordflow">for</span> (j=0; j&lt;n; j++) {
      <span class="keywordtype">bool</span> a = (u[j] &gt; (*(weight + w-1)));
      <span class="keywordtype">bool</span> b = ( u[j] &lt;= (*(weight + w)));
      <span class="keywordflow">if</span> (a==1 &amp;&amp; b==1) { intp++; }
      <span class="comment">//cout&lt;&lt;u_one[j]&lt;&lt;endl;</span>
    }
  }

  <span class="comment">// count how many &#39;1&#39;s are there in u_rv. This is the number of members </span>
  <span class="comment">//in component m.</span>
  <span class="comment">//intp = (int) count(u_one, u_one+n, 1);</span>
} <span class="comment">//end find_comp()</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a4954d5b0e64b315bea343c911e1cd0e3"></a><!-- doxytag: member="errorfunc.hpp::findRoot" ref="a4954d5b0e64b315bea343c911e1cd0e3" args="(const intervalw &amp;domain, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S, double fhat, vector&lt; intervalw &gt; &amp;rootList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#a4954d5b0e64b315bea343c911e1cd0e3">findRoot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rootList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01404">1404</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01396">N()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;finding root at &quot; &lt;&lt; domain &lt;&lt; &quot; for &quot; &lt;&lt; fhat &lt;&lt; endl;</span>
  
  <a class="code" href="classintervalw.shtml">intervalw</a> newX       = domain;
  <a class="code" href="classintervalw.shtml">intervalw</a> oldX       = domain + 1;
  <span class="keywordtype">bool</span>     rootUnique = <span class="keyword">false</span>;
  <span class="keywordtype">bool</span>     rootExists = <span class="keyword">true</span>;

  <span class="keywordflow">while</span>( (newX != oldX) &amp;&amp; rootExists ) {
    oldX = newX;
    <span class="keywordflow">if</span>( !intersect(newX, <a class="code" href="errorfunc_8cpp.shtml#abcd464084d71d1ca5caf89793fa1d050">N</a>(oldX, W, M, S, fhat), oldX) ) 
      rootExists = <span class="keyword">false</span>;
    <span class="keywordflow">if</span> ( subset(newX, oldX) ) 
      rootUnique = <span class="keyword">true</span>;
  }
  <span class="keywordflow">if</span> ( rootExists ) {
    cout &lt;&lt; newX;
    rootVec.push_back(newX);
    <span class="keywordflow">if</span> ( rootUnique )
      cout &lt;&lt; <span class="stringliteral">&quot; contains a unique root.&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">else</span>
      cout &lt;&lt; <span class="stringliteral">&quot; may contain a simple root.&quot;</span> &lt;&lt; endl;
  } 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0350bc07337b5abac1dca82fb195940d"></a><!-- doxytag: member="errorfunc.hpp::FinMixAbs" ref="a0350bc07337b5abac1dca82fb195940d" args="(double x, void *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="HoldOutFinMix_8cpp.shtml#ab91f1fa7223911ea415a2637eadb6a26">FinMixAbs</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the absolute error of a finite mixture at x. </p>
<p>get the integrated absolute of a finite mixture of boxes in the root box</p>
<p>Function to get absolute error </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00191">191</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<a class="code" href="structFinMix.shtml">FinMix</a> mixt = *(<a class="code" href="structFinMix.shtml">FinMix</a> *) params;
<span class="keywordtype">double</span> <a class="code" href="errorfunc_8cpp.shtml#a0350bc07337b5abac1dca82fb195940d" title="Get the absolute error of a finite mixture at x.">FinMixAbs</a> = fabs(mixt.<a class="code" href="structFinMix.shtml#a7d058312162e6b9ccb408ddc688a274f">fhat</a> - <a class="code" href="errorfunc_8cpp.shtml#af969a1749ecbaf78a8656cb6b65b8c60" title="Get the probability density function of a finite mixture r.v.">FinMixPDF</a>(x, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>));
<span class="keywordflow">return</span> <a class="code" href="errorfunc_8cpp.shtml#a0350bc07337b5abac1dca82fb195940d" title="Get the absolute error of a finite mixture at x.">FinMixAbs</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa5f10d5325f39aa971fc7e984557514a"></a><!-- doxytag: member="errorfunc.hpp::FinMixCDF" ref="aa5f10d5325f39aa971fc7e984557514a" args="(double, double, std::vector&lt; double &gt; &amp;W, std::vector&lt; double &gt; &amp;M, std::vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="HoldOutFinMix_8cpp.shtml#ae8fb9bc2f15455a39056110b8d4032d4">FinMixCDF</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the cumulative distribution function of a finite mixture r.v. </p>
<p>get the CDF of a finite mixture </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00176">176</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01389">taylor::erf()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="CoverageNormal_8cpp_source.shtml#l00085">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="keywordtype">double</span> Ncomp = W.size();
<span class="keywordtype">double</span> CDF = 0;
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c &lt; Ncomp; c++){
CDF += 0.5*(1 + <a class="code" href="namespacetaylor.shtml#ac58758459f916c91fbadcdb56c22c543">erf</a>((x2-M[c])/S[c]/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2))) -
       0.5*(1 + <a class="code" href="namespacetaylor.shtml#ac58758459f916c91fbadcdb56c22c543">erf</a>((x1-M[c])/S[c]/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2)));
<span class="comment">//cout &lt;&lt; &quot;CDF is: &quot; &lt;&lt; CDF &lt;&lt; endl;</span>
}
<span class="keywordflow">return</span> CDF;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2f3a0386e9b82f691a73f7710b759117"></a><!-- doxytag: member="errorfunc.hpp::FinMixPDF" ref="a2f3a0386e9b82f691a73f7710b759117" args="(double x, std::vector&lt; double &gt; &amp;W, std::vector&lt; double &gt; &amp;M, std::vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="HoldOutFinMix_8cpp.shtml#a9021606bd7e0ccdbdb204b596e265de0">FinMixPDF</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the probability density function of a finite mixture r.v. </p>
<p>A finite mixture distribution is the sum of c gaussian components. Its PDF (CDF) is obtained by summing the PDFs (CDF) of each component. The integrated absolute error is calculated using a quadrature routine from the GSL library. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the data point at which we take the PDF (CDF). </td></tr>
    <tr><td class="paramname">x1</td><td>(only for the IAE at the boundary) is the infimum of the root box. </td></tr>
    <tr><td class="paramname">x2</td><td>(only for the IAE at the boundary) is the supremum of the root box. </td></tr>
    <tr><td class="paramname">W</td><td>is a vector of the weights of each component. </td></tr>
    <tr><td class="paramname">M</td><td>is a vector of the means of each component. </td></tr>
    <tr><td class="paramname">S</td><td>is a vector of the standard deviations of each component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the integrated absolute error. get the PDF of a finite mixture </dd></dl>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00162">162</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l00191">FinMixAbs()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="keywordtype">int</span> Ncomp = W.size();
<span class="keywordtype">double</span> PDF = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> c=0; c &lt; Ncomp; c++){
    <span class="keywordtype">double</span> z = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((x-M[c])/S[c], 2);
    PDF += W[c]*<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-0.5*z)/(S[c]*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2*M_PI));
  }  
<span class="keywordflow">return</span> PDF;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae767ea3ddeac1e55d74384fe0cd42ecd"></a><!-- doxytag: member="errorfunc.hpp::gaussian" ref="ae767ea3ddeac1e55d74384fe0cd42ecd" args="(std::vector&lt; double &gt; &amp;vecNPD, std::vector&lt; double &gt; &amp;XX, double SS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="errorfunc_8hpp.shtml#ae767ea3ddeac1e55d74384fe0cd42ecd">gaussian</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecNPD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>XX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>SS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gaussian probability density function. Generates normal probability density values corresponding to X which is a vector of doubles. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">XX</td><td>is a row vector of support points for which normal density values are required; </td></tr>
    <tr><td class="paramname">SS</td><td>is a row vector of standard deviations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NPD: row vector of normal probability density values.</dd></dl>
<p>Gaussian probability density function. </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00668">668</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l00450">psi()</a>.</p>
<div class="fragment"><pre class="fragment">{
  vector&lt;double&gt;::iterator vecIt;
  
  <span class="keywordflow">for</span> (vecIt = XX.begin(); vecIt &lt; XX.end(); vecIt++){
    <span class="keywordtype">double</span> X = *vecIt;
      vecNPD.push_back(<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-(X*X)/(2*SS*SS))/(<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2*M_PI)*SS));
  }

 <span class="keywordflow">return</span> vecNPD;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2fbcb5575d9958b3d4168369e3425258"></a><!-- doxytag: member="errorfunc.hpp::getL1error" ref="a2fbcb5575d9958b3d4168369e3425258" args="(double fhat, interval &amp;thisInt, int Deg, double TOL, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval &amp;&#160;</td>
          <td class="paramname"><em>thisInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01504">1504</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01551">integrand()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01485">integrate()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l01391">subpavings::AdaptiveHistogramCollator::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">subpavings::AdaptiveHistogramValidation::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03970">subpavings::AdaptiveHistogram::getFinMixIntervalIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04065">getFinMixIntervalTrueDelta()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00733">getRegHistFinMixIntervalIAE()</a>, and <a class="el" href="IntervalArithIAE_8cpp_source.shtml#l00066">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;==========get L1 error for &quot; &lt;&lt; thisInt &lt;&lt;  endl;</span>
  <span class="comment">//hard-code this temporarily</span>
  <span class="keywordtype">double</span> Tol = 0.0000001;
  <span class="comment">//cout &lt;&lt; Tol &lt;&lt; endl;</span>
  
  <span class="comment">//get the area of the histogram at this interval</span>
  real histArea = diam(thisInt) * fhat;

  <span class="comment">//integrate the function at this sub-interval</span>
  interval fArea = <a class="code" href="errorfunc_8cpp.shtml#aa0f25ae1a698fab2a49e83283c2b0dd1">integrate</a>(<a class="code" href="errorfunc_8cpp.shtml#ae473bc19e57e3781680652a61018aa79">integrand</a>, thisInt, Deg, Tol, W, M, S);

  <span class="comment">//cout &lt;&lt; &quot;get the differences &quot; &lt;&lt; endl;</span>
  <span class="comment">//get the differences of the areas</span>
  interval diffArea = abs(abs(fArea) - histArea);
  <span class="comment">//cout &lt;&lt; &quot;fArea: &quot; &lt;&lt; fArea &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;\t histArea: &quot; &lt;&lt; histArea &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; diffArea &lt;&lt; endl;</span>

  <span class="keywordflow">return</span> diffArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a538c5046923fbdee301324f35285d79c"></a><!-- doxytag: member="errorfunc.hpp::getRegHistFinMixIAE" ref="a538c5046923fbdee301324f35285d79c" args="(size_t n, RegHist &amp;myRegHist, FinMix &amp;mixt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="errorfunc_8hpp.shtml#a538c5046923fbdee301324f35285d79c">getRegHistFinMixIAE</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a finite mixture distribution for regular histograms </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00683">683</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAEBoun</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00223">FinMix::fhat</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00191">FinMixAbs()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//----------------get the IAE-----------------------------------------------</span>
dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>, <a class="code" href="HoldOutFinMix_8cpp.shtml#a97e24d3d1886f2162f0daa315bc812a7">dpIAEBoun</a>;
dpIAE = 0.0;
<span class="keywordtype">int</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>=(myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>).size();

gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
<span class="keywordtype">double</span> result = 0.0;
<span class="keywordtype">double</span> error;
gsl_function <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>;

F.function = &amp;<a class="code" href="errorfunc_8cpp.shtml#a0350bc07337b5abac1dca82fb195940d" title="Get the absolute error of a finite mixture at x.">FinMixAbs</a>;
F.params =  &amp;mixt;

<span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; j++){
  mixt.<a class="code" href="structFinMix.shtml#a7d058312162e6b9ccb408ddc688a274f">fhat</a> = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>[j];
  <span class="keywordtype">double</span> xupp = _double(myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>[j]);
  <span class="keywordtype">double</span> xlow = _double(myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>[j]);
  gsl_integration_qags(&amp;F, xlow, xupp, 0, 1e-7, 1000, w, &amp;result, &amp;error);
  accumulate(dpIAE, result, 1.0);
}

<span class="comment">/*</span>
<span class="comment">// Accounting for the boundaries</span>
<span class="comment">ivector theBoxVec;</span>
<span class="comment">interval boxes;</span>
<span class="comment">//upper bound</span>
<span class="comment">theBoxVec = myRegHist.theBoxes[Nbin-1];</span>
<span class="comment">boxes = theBoxVec[1];</span>
<span class="comment">double xupp1 = _double(Sup(boxes));</span>
<span class="comment">//lower bound</span>
<span class="comment">theBoxVec = myRegHist.theBoxes[0];</span>
<span class="comment">boxes = theBoxVec[1];</span>
<span class="comment">double xlow1 = _double(Inf(boxes));</span>
<span class="comment">dpIAEBoun = dpFinMixIAEBoun(xlow1, xupp1, mixt);</span>
<span class="comment">dpIAE += dpIAEBoun;</span>
<span class="comment">*/</span>

<span class="comment">// cast dot precision to real</span>
real FinMixIAE = rnd(dpIAE);

<span class="comment">// free the workspace</span>
gsl_integration_workspace_free (w);

<span class="keywordflow">return</span> FinMixIAE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3b281b5e62f571e14e7c127af8d7e74a"></a><!-- doxytag: member="errorfunc.hpp::getRegHistFinMixIntervalIAE" ref="a3b281b5e62f571e14e7c127af8d7e74a" args="(size_t n, RegHist &amp;myRegHist, FinMix &amp;mixt, double tol, int deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#a3b281b5e62f571e14e7c127af8d7e74a">getRegHistFinMixIntervalIAE</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFinMix.shtml">FinMix</a> &amp;&#160;</td>
          <td class="paramname"><em>mixt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the interval IAE for a finite mixture distribution for regular histograms</p>
<p>Get the IAE for a finite mixture distribution for regular histograms </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00733">733</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01432">bisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01504">getL1error()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00221">FinMix::M</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00222">FinMix::S</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00220">FinMix::W</a>.</p>

<p>Referenced by <a class="el" href="FiniteMixture_8cpp_source.shtml#l00045">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  interval totalArea(0.0);
  <span class="keywordtype">size_t</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a> = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>.size();
  
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; j++){
    <span class="keywordtype">double</span> fhat = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>[j];
    <span class="keywordtype">double</span> xupp = _double(myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>[j]);
    <span class="keywordtype">double</span> xlow = _double(myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>[j]);
    
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;

    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(xlow, xupp);
    interval thisInt(xlow, xupp);

    <span class="comment">// find the root</span>
    <span class="comment">//cout &lt;&lt; &quot;finding roots at this node &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
    <a class="code" href="errorfunc_8cpp.shtml#a4a991d5ab1bd0a117e02af6f83369bab">bisect</a>(thisIntW, tol, fhat, rootVec, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>); 

    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      <span class="comment">//cout &lt;&lt; &quot;no roots at &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        <span class="comment">//cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
        <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      <span class="comment">//cout &lt;&lt; &quot;==There are &quot; &lt;&lt; uniqueRootVec.size() &lt;&lt; &quot; unique root(s)==&quot; &lt;&lt; endl;</span>
      
      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        <span class="comment">//cout &lt;&lt; &quot;there is only one root..&quot; &lt;&lt; endl;</span>
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the left/right boundary:&quot; &lt;&lt; rootVec[0] &lt;&lt; endl;</span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          <span class="comment">//cout &lt;&lt; &quot;no root at the boundaries&quot; &lt;&lt; endl;</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;left interval: &quot; &lt;&lt; thisSubIntLeft &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLeft, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          <span class="comment">//cout &lt;&lt; &quot;right interval: &quot; &lt;&lt; thisSubIntRight &lt;&lt; endl; </span>
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntRight, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;let&#39;s have a look at all the roots:&quot; &lt;&lt; endl;</span>
        <span class="comment">//for (size_t i = 0; i &lt; uniqueRootVec.size(); i++) {</span>
          <span class="comment">//cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//}</span>

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntFirst, deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubInt,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a2fbcb5575d9958b3d4168369e3425258">getL1error</a>(fhat, thisSubIntLast,  deg, tol, mixt.<a class="code" href="structFinMix.shtml#a5e3e0c0a40f75ec6df8e4513828342be">W</a>, mixt.<a class="code" href="structFinMix.shtml#af6b13f65037448ae8a22965ccffd9330">M</a>, mixt.<a class="code" href="structFinMix.shtml#ac96c7d4bec4e00d981a609a4ffd0c3d3">S</a>);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>

  } <span class="comment">// end of iterating through the leaf nodes</span>
  
  <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; totalArea &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> totalArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7edbd158ed300803fe59b38c60f90875"></a><!-- doxytag: member="errorfunc.hpp::getRegHistLaplaceIntervalIAE" ref="a7edbd158ed300803fe59b38c60f90875" args="(size_t n, RegHist &amp;myRegHist, double tol, int deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#a7edbd158ed300803fe59b38c60f90875">getRegHistLaplaceIntervalIAE</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the interval IAE for a finite mixture distribution for regular histograms</p>
<p>Get the IAE for a laplace distribution for regular histograms </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00917">917</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01692">LaplaceBisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01777">LaplaceGetL1error()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>.</p>

<p>Referenced by <a class="el" href="Laplace1_8cpp_source.shtml#l00038">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  interval totalArea(0.0);
  <span class="keywordtype">size_t</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a> = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>.size();
  
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; j++){
    <span class="keywordtype">double</span> fhat = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>[j];
    <span class="keywordtype">double</span> xupp = _double(myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>[j]);
    <span class="keywordtype">double</span> xlow = _double(myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>[j]);
    
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;

    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(xlow, xupp);
    interval thisInt(xlow, xupp);

    <span class="comment">// find the root</span>
    <span class="comment">//cout &lt;&lt; &quot;finding roots at this node &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
    <a class="code" href="errorfunc_8cpp.shtml#a4de668d5d847a753a9a4baf05c7d8d52">LaplaceBisect</a>(thisIntW, tol, fhat, rootVec); 

    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      <span class="comment">//cout &lt;&lt; &quot;no roots at &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisInt, deg, tol);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        <span class="comment">//cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
        <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      <span class="comment">//cout &lt;&lt; &quot;==There are &quot; &lt;&lt; uniqueRootVec.size() &lt;&lt; &quot; unique root(s)==&quot; &lt;&lt; endl;</span>
      
      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        <span class="comment">//cout &lt;&lt; &quot;there is only one root..&quot; &lt;&lt; endl;</span>
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the left/right boundary:&quot; &lt;&lt; rootVec[0] &lt;&lt; endl;</span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisInt, deg, tol);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          <span class="comment">//cout &lt;&lt; &quot;no root at the boundaries&quot; &lt;&lt; endl;</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;left interval: &quot; &lt;&lt; thisSubIntLeft &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLeft, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          <span class="comment">//cout &lt;&lt; &quot;right interval: &quot; &lt;&lt; thisSubIntRight &lt;&lt; endl; </span>
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntRight, deg, tol);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;let&#39;s have a look at all the roots:&quot; &lt;&lt; endl;</span>
        <span class="comment">//for (size_t i = 0; i &lt; uniqueRootVec.size(); i++) {</span>
          <span class="comment">//cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//}</span>

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>

  } <span class="comment">// end of iterating through the leaf nodes</span>
  
  <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; totalArea &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> totalArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac2e78d0ba1f818d2e1a81b95544972d8"></a><!-- doxytag: member="errorfunc.hpp::getRegHistLognormalIntervalIAE" ref="ac2e78d0ba1f818d2e1a81b95544972d8" args="(size_t n, RegHist &amp;myRegHist, double tol, int deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#ac2e78d0ba1f818d2e1a81b95544972d8">getRegHistLognormalIntervalIAE</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the interval IAE for a finite mixture distribution for regular histograms</p>
<p>Get the IAE for a lognormal distribution for regular histograms </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01101">1101</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01878">LognormalBisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01960">LognormalGetL1error()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>.</p>

<p>Referenced by <a class="el" href="Lognormal1_8cpp_source.shtml#l00038">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  interval totalArea(0.0);
  <span class="keywordtype">size_t</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a> = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>.size();
  
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0; j&lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; j++){
    <span class="keywordtype">double</span> fhat = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>[j];
    <span class="keywordtype">double</span> xupp = _double(myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>[j]);
    <span class="keywordtype">double</span> xlow = _double(myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>[j]);
    
    <span class="comment">//a container for the roots at this leaf node</span>
    vector&lt;intervalw&gt; rootVec;

    <span class="comment">//---------find the root at this domain</span>
    <span class="comment">// make an intervalw object using thisBox</span>
    <a class="code" href="classintervalw.shtml">intervalw</a> thisIntW(xlow, xupp);
    interval thisInt(xlow, xupp);

    <span class="comment">// find the root</span>
    <span class="comment">//cout &lt;&lt; &quot;finding roots at this node &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
    <a class="code" href="errorfunc_8cpp.shtml#a9722cc78b34593d877ec8cbbb22ac9f2">LognormalBisect</a>(thisIntW, tol, fhat, rootVec); 

    <span class="comment">//---------find the area at this domain and take the absolute value</span>
    <span class="comment">//if rootVec is empty, there are no roots - so we can integrate over</span>
    <span class="comment">//this domain</span>
    <span class="keywordflow">if</span> ((rootVec.size() == 0)) { 
      <span class="comment">//cout &lt;&lt; &quot;no roots at &quot; &lt;&lt; thisInt &lt;&lt; endl;</span>
      <span class="comment">//get the L1 error</span>
      interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisInt, deg, tol);
      <span class="comment">//add to totalArea</span>
      totalArea += diffArea;
    } <span class="comment">//end of rootVec is empty</span>

    <span class="keywordflow">else</span> { <span class="comment">//if rootVec is not empty</span>
      vector&lt;intervalw&gt; uniqueRootVec;
      <span class="comment">// make the elements in vector unique</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (rootVec.size()); i++) {
        <span class="comment">//cout &lt;&lt; &quot;root &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; rootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//first insert into uniqueRootVec</span>
        uniqueRootVec.push_back(rootVec[i]);
      <span class="comment">//cout &lt;&lt; i-1 &lt;&lt; &quot;\t&quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; i+1 &lt;&lt; endl;</span>
        <span class="comment">//now check for uniqueness</span>
        <span class="keywordflow">if</span> (((i-1) &gt;= 0) &amp;&amp; (i &lt; rootVec.size())) {
          <span class="comment">//cout &lt;&lt; rootVec[i] &lt;&lt; &quot;\t&quot; &lt;&lt; rootVec[i-1] &lt;&lt; endl;</span>
          <span class="keywordtype">bool</span> uniq = (subset(abs(rootVec[i] - rootVec[i-1]), <a class="code" href="classintervalw.shtml">intervalw</a>(0, 1e-10)));
          <span class="keywordflow">if</span> ( uniq ) { 
            <span class="comment">//cout &lt;&lt; &quot;this root has a duplicate&quot; &lt;&lt; endl;</span>
            uniqueRootVec.pop_back(); }
        }
      }
      <span class="comment">//cout &lt;&lt; &quot;==There are &quot; &lt;&lt; uniqueRootVec.size() &lt;&lt; &quot; unique root(s)==&quot; &lt;&lt; endl;</span>
      
      <span class="comment">// if there&#39;s only 1 root</span>
      <span class="keywordflow">if</span> (uniqueRootVec.size() == 1) {
        <span class="comment">//cout &lt;&lt; &quot;there is only one root..&quot; &lt;&lt; endl;</span>
        <span class="comment">// is the root at the left or right boundary?</span>
        <span class="keywordflow">if</span> ( (abs(Inf(thisInt) - inf(rootVec[0])) &lt; 1e-10) || 
            (abs(Sup(thisInt) - inf(rootVec[0])) &lt; 1e-10) ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the left/right boundary:&quot; &lt;&lt; rootVec[0] &lt;&lt; endl;</span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisInt, deg, tol);
          totalArea += diffArea;
        }
        <span class="keywordflow">else</span> { <span class="comment">// the root is not at the boundaries</span>
          <span class="comment">//cout &lt;&lt; &quot;no root at the boundaries&quot; &lt;&lt; endl;</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntLeft = interval(Inf(thisInt), sup(uniqueRootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;left interval: &quot; &lt;&lt; thisSubIntLeft &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLeft, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">//get the right sub-interval</span>
          <span class="comment">//get the left sub-interval</span>
          interval thisSubIntRight = interval(inf(uniqueRootVec[0]), Sup(thisInt));
          <span class="comment">//cout &lt;&lt; &quot;right interval: &quot; &lt;&lt; thisSubIntRight &lt;&lt; endl; </span>
          diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntRight, deg, tol);
          totalArea += diffArea;
        }
      } <span class="comment">// end of rootVec.size() == 1</span>

        <span class="comment">// if there is more than 1 root</span>
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;let&#39;s have a look at all the roots:&quot; &lt;&lt; endl;</span>
        <span class="comment">//for (size_t i = 0; i &lt; uniqueRootVec.size(); i++) {</span>
          <span class="comment">//cout &lt;&lt; uniqueRootVec[i] &lt;&lt; endl;</span>
        <span class="comment">//}</span>

        <span class="comment">//first check if the first root is at the boundary</span>
        <span class="comment">//cout &lt;&lt; &quot;check boundaries: &quot; &lt;&lt; Inf(thisInt) &lt;&lt; &quot;\t&quot; &lt;&lt; inf(rootVec[0]) &lt;&lt; endl;</span>
        <span class="keywordflow">if</span> ( abs(Inf(thisInt) - inf(uniqueRootVec[0])) &lt; 1e-10 ) {
          <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the leftmost boundary:&quot; &lt;&lt; endl;</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(uniqueRootVec[1]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval:&quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th root is: &quot; &lt;&lt; rootVec[i+1] &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (excep the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea =<a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of if first root is the boundary</span>
        
        <span class="keywordflow">else</span> {
          <span class="comment">//cout &lt;&lt; &quot;root not at boundary&quot; &lt;&lt; endl;</span>
          <span class="comment">//if it is not the boundary, make the first sub-interval</span>
          interval thisSubIntFirst = interval(Inf(thisInt), sup(rootVec[0]));
          <span class="comment">//cout &lt;&lt; &quot;0-th interval: &quot; &lt;&lt; thisSubIntFirst &lt;&lt; endl; </span>
          interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntFirst, deg, tol);
          totalArea += diffArea;
          
          <span class="comment">// now iterate through each root (except the first and last) and </span>
          <span class="comment">// get the sub-itnervals</span>
          <span class="comment">//cout &lt;&lt; &quot;iterating through each root&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; (uniqueRootVec.size() - 1); i++) {
            <span class="keywordflow">if</span> ( (i+1) &gt; uniqueRootVec.size() ) { <span class="comment">// already no more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; Sup(thisInt) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), Sup(thisInt));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea =<a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
            <span class="keywordflow">else</span> { <span class="comment">//there are still more roots</span>
              <span class="comment">//cout &lt;&lt; inf(rootVec[i]) &lt;&lt; &quot;\t&quot; &lt;&lt; sup(rootVec[i+1]) &lt;&lt; endl;</span>
              interval thisSubInt = interval(inf(uniqueRootVec[i]), sup(uniqueRootVec[i+1]));
              <span class="comment">//cout &lt;&lt; &quot;the &quot; &lt;&lt; i+1 &lt;&lt; &quot;-th interval: &quot; &lt;&lt; thisSubInt &lt;&lt; endl;</span>
              interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubInt, deg, tol);
              totalArea += diffArea;
            }
          } <span class="comment">// end of iterate through each root (except the first and last)</span>
          
          <span class="comment">// now check if the last root is at the boundary</span>
          <span class="keywordflow">if</span> ( abs(Sup(thisInt) - sup(uniqueRootVec[uniqueRootVec.size()-1])) &lt; 1e-10 ) {
            <span class="comment">//cout &lt;&lt; &quot;there&#39;s a root at the rightmost boundary:&quot; &lt;&lt; endl;</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-2]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea =<a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          }
          <span class="keywordflow">else</span> { <span class="comment">//the last root is not at the boundary</span>
            interval thisSubIntLast = interval(inf(uniqueRootVec[uniqueRootVec.size()-1]), Sup(thisInt));
            <span class="comment">//cout &lt;&lt; &quot;last interval: &quot; &lt;&lt; thisSubIntLast &lt;&lt; endl; </span>
            interval diffArea = <a class="code" href="errorfunc_8cpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a>(fhat, thisSubIntLast, deg, tol);
            totalArea += diffArea;
          } 
        } <span class="comment">// end of first root is not the boundary</span>
      } <span class="comment">// end of rootVec.size() &gt; 1</span>
    } <span class="comment">// end of rootVec is not empty</span>

  } <span class="comment">// end of iterating through the leaf nodes</span>
  
  <span class="comment">//cout &lt;&lt; &quot;IAE: &quot; &lt;&lt; totalArea &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> totalArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e8c99f0ea9229f7e86f263f834e9869"></a><!-- doxytag: member="errorfunc.hpp::getRegHistUnifIAE" ref="a9e8c99f0ea9229f7e86f263f834e9869" args="(RegHist &amp;myRegHist, AdaptiveHistogram &amp;myPart, size_t n, double weight, vector&lt; int &gt; holesLoc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="errorfunc_8hpp.shtml#a9e8c99f0ea9229f7e86f263f834e9869">getRegHistUnifIAE</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1AdaptiveHistogram.shtml">AdaptiveHistogram</a> &amp;&#160;</td>
          <td class="paramname"><em>myPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>holesLoc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the IAE for a uniform mixture distribution for regular histograms.</p>
<p>Get the IAE for a uniform mixture distribution for regular histograms </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01286">1286</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00500">dpIAE</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, <a class="el" href="HoldOutFinMix_8cpp_source.shtml#l00503">Nbin</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="UniformMixture_8cpp_source.shtml#l00041">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//-------setting up containers-------------------------------</span>
   dotprecision <a class="code" href="HoldOutFinMix_8cpp.shtml#a894b8d12887c7363e41db774d05a13b4">dpIAE</a>;    <span class="comment">// use type dotprecision for summation  </span>
   dpIAE=0.0;

   <span class="comment">// get the true height, rueF of the corresponding box in myPart</span>
  <a class="code" href="namespacesubpavings.shtml#ad23942a388da964ca7487e496d0f2923" title="Define type SPSnodePtrs as container of pointers to SPSnodes.">SPSnodePtrs</a> trueLeaves;
  <a class="code" href="namespacesubpavings.shtml#a3d06253195e32236cc10b1c2050073c9" title="Define type SPSnodePtrsItr as an iterator over SPSnodePtrs.">SPSnodePtrsItr</a> trueIt;
  (myPart).getSubPaving()-&gt;getLeaves(trueLeaves);

  ivector temp; <span class="comment">//for the intersections</span>
  
   <span class="comment">//go through all the leaves in the regular histogram</span>
  <span class="keywordtype">int</span> <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>=(myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>).size();

   
   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="HoldOutFinMix_8cpp.shtml#a5048e3a13ffcb20124b62a989f4c5524">Nbin</a>; i++) {
    <span class="comment">// get the height of this leaf</span>
      <span class="keywordtype">double</span> fhat = myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>[i];
    
    <span class="comment">//make this box into an ivector</span>
    interval iBox(myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>[i], myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>[i]);
    ivector thisBox(1);
    thisBox[1] = iBox;
    
    <span class="comment">//cout &lt;&lt; &quot;====checking &quot; &lt;&lt; thisBox &lt;&lt; endl;</span>
      <span class="comment">//cout &lt;&lt; &quot;fhat for box &quot; &lt;&lt; &quot;:&quot; &lt;&lt; fhat &lt;&lt; endl;</span>

    <span class="keywordtype">size_t</span> L = 0;
    <span class="keywordflow">for</span> (trueIt = trueLeaves.begin(); trueIt &lt; trueLeaves.end(); trueIt++) {
      <span class="comment">//cout &lt;&lt; &quot;----True leaf: &quot; &lt;&lt; (*trueIt)-&gt;getBox() &lt;&lt; &quot;\t&quot; &lt;&lt; endl;</span>
      ivector trueBox = (*trueIt)-&gt;getBox();

      <span class="keywordtype">double</span> trueF;
      <span class="keywordflow">if</span> (  holesLoc[L] == 0 ) { trueF = 0; }
      <span class="keywordflow">else</span> { trueF = weight/((*trueIt)-&gt;nodeVolume()); }
      <span class="comment">//cout &lt;&lt; &quot;pdf: &quot; &lt;&lt; trueF &lt;&lt; &quot;------&quot; &lt;&lt; endl;</span>
      
      <span class="comment">// if this is contained in trueBox</span>
      <span class="keywordflow">if</span> ( thisBox &lt;= trueBox || thisBox == trueBox ) {
        <span class="comment">//use the volume of this</span>
        real r = <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(thisBox)*(fhat - trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
        <span class="comment">//can move on to next leaf rather than iterating thru all trueBoxes</span>
        <span class="comment">//think about this later</span>
      } <span class="comment">//end of if this box is in trueBox</span>
      
      <span class="comment">// if this contains trueBox</span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( trueBox &lt;= thisBox) {
        <span class="comment">//use the volume of trueBox</span>
        real r = ((*trueIt)-&gt;nodeVolume())*(fhat - trueF);
        <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
        accumulate(dpIAE, abs(r), 1.0);
      } <span class="comment">//end of if trueBox is in this box</span>
      
      <span class="comment">// if this is partially contained in trueBox </span>
      <span class="keywordflow">else</span> <span class="keywordflow">if</span>   (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(temp, thisBox, trueBox)) {
        <span class="keywordflow">if</span> (Inf(temp) != Sup(temp)){
          <span class="keywordtype">double</span> volume = <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(temp);
          real r = volume*(fhat - trueF);
          <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; &quot;\t&quot; &lt;&lt; abs(r) &lt;&lt; endl;</span>
          accumulate(dpIAE, abs(r), 1.0);
        }
      }
      L++;
    } <span class="comment">// end of going through trueBoxes</span>
  } <span class="comment">// end of going through thisBoxes</span>
  
    
    
   <span class="comment">//cast dotprecision to real</span>
   real unifIAE = rnd(dpIAE);
  <span class="keywordflow">return</span> unifIAE;                
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae473bc19e57e3781680652a61018aa79"></a><!-- doxytag: member="errorfunc.hpp::integrand" ref="ae473bc19e57e3781680652a61018aa79" args="(const itaylor &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitaylor.shtml">itaylor</a> <a class="el" href="errorfunc_8hpp.shtml#ae473bc19e57e3781680652a61018aa79">integrand</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01551">1551</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>, and <a class="el" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01504">getL1error()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  
  <a class="code" href="classitaylor.shtml">itaylor</a> PDF(<a class="code" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable</a>(interval(0,0), orderOf(x)));
  <span class="comment">//cout &lt;&lt; &quot;-------initializing variable PDF: ---------&quot; &lt;&lt; PDF &lt;&lt; endl;</span>

  <span class="comment">//cout &lt;&lt; &quot;x: &quot; &lt;&lt; x[0] &lt;&lt; endl;</span>
  <span class="keywordtype">size_t</span> Ncomp = W.size();
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c=0; c &lt; Ncomp; c++){
    <span class="comment">//cout &lt;&lt; c &lt;&lt; &quot;-th component: &quot; &lt;&lt; W[c] &lt;&lt; &quot;\t&quot; &lt;&lt; M[c] &lt;&lt; &quot;\t&quot; &lt;&lt; S[c] &lt;&lt; endl;</span>

    <a class="code" href="classitaylor.shtml">itaylor</a> z1 = (x-M[c])/S[c]; 
    <span class="comment">//when inf is negative and sup is positive - split into two parts </span>
    <span class="keywordflow">if</span> (Inf(z1[0]) &lt; 0 &amp;&amp; Sup(z1[0]) &gt; 0) {  
      <span class="comment">//cout &lt;&lt; &quot;===========&quot; &lt;&lt; endl;</span>
      <span class="comment">//cout &lt;&lt; z1[0] &lt;&lt; endl;</span>
      <a class="code" href="classitaylor.shtml">itaylor</a> z = z1*z1;
      <span class="comment">//cout &lt;&lt; z[0] &lt;&lt; endl;</span>
      Inf(z[0]) = 0;
      <span class="comment">//cout &lt;&lt; z[0] &lt;&lt; endl;</span>
      PDF = PDF + <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-0.5*z)*(W[c]/(S[c]*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2*M_PI)));
    }  
    <span class="keywordflow">else</span> {
      <a class="code" href="classitaylor.shtml">itaylor</a> z = z1*z1;
      <span class="comment">//cout &lt;&lt; &quot;z: &quot; &lt;&lt; z[0] &lt;&lt; endl;</span>
      <a class="code" href="classitaylor.shtml">itaylor</a> expPart = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-0.5*z);
      <span class="comment">//cout &lt;&lt; &quot;exp part:&quot; &lt;&lt; expPart[0] &lt;&lt; endl;</span>
      PDF = PDF + expPart*(W[c]/(S[c]*<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2*M_PI)));
    }
  }
  <span class="comment">//cout &lt;&lt; &quot;Domain: &quot; &lt;&lt; x[0] &lt;&lt; &quot;\t PDF: &quot; &lt;&lt; PDF[0] &lt;&lt; endl;</span>
  
  <span class="keywordflow">return</span> PDF;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa0f25ae1a698fab2a49e83283c2b0dd1"></a><!-- doxytag: member="errorfunc.hpp::integrate" ref="aa0f25ae1a698fab2a49e83283c2b0dd1" args="(pfcn f, interval X, int Deg, double Tol, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="Int_8h.shtml#a7fc07253fd3c6b7fb6104122a13683a3">integrate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01485">1485</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01485">integrate()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01462">riemannTerm()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01504">getL1error()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01485">integrate()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;-------integrating over the domain -------------&quot; &lt;&lt; X &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;get  riemann term of &quot; &lt;&lt; X &lt;&lt; endl;</span>
  interval sum = <a class="code" href="errorfunc_8cpp.shtml#ad7abf0d6b473ad78b1737a9e972395c2">riemannTerm</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, X, Deg, W, M, S);
  <span class="comment">//cout &lt;&lt; &quot;sum: &quot; &lt;&lt; sum &lt;&lt; &quot;\t diam(sum):&quot; &lt;&lt; diam(sum) &lt;&lt; &quot;\t Tol: &quot; &lt;&lt; Tol &lt;&lt;  endl;</span>
  
  <span class="keywordflow">if</span> ( diam(sum) &lt;= Tol ) {
    <span class="comment">//cout &lt;&lt; &quot;Domain: &quot; &lt;&lt; X &lt;&lt; &quot;\t Sum: &quot; &lt;&lt; sum &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> sum;
  }
  <span class="keywordflow">else</span> {  
    <span class="comment">//cout &lt;&lt; &quot;*****diam(sum) &gt; tol: inf(x), mid(x) + mid(x), sup(x)*****&quot; &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> <a class="code" href="errorfunc_8cpp.shtml#aa0f25ae1a698fab2a49e83283c2b0dd1">integrate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval(Inf(X), mid(X)), Deg, Tol/2, W, M, S) + \
        integrate(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, interval(mid(X), Sup(X)), Deg, Tol/2, W, M, S);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac2975a7f53b8bbdf01bb073b661a766d"></a><!-- doxytag: member="errorfunc.hpp::LaplaceBisect" ref="ac2975a7f53b8bbdf01bb073b661a766d" args="(const intervalw &amp;x, const double &amp;TOL, double &amp;fhat, vector&lt; intervalw &gt; &amp;rootList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#ac2975a7f53b8bbdf01bb073b661a766d">LaplaceBisect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rootList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01692">1692</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01692">LaplaceBisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01652">LaplaceDF()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01648">LaplaceF()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01665">LaplacefindRoot()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04206">subpavings::AdaptiveHistogram::getLaplaceIntervalIAE()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00917">getRegHistLaplaceIntervalIAE()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01692">LaplaceBisect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;===========root finding routine at domain: &quot; &lt;&lt; x &lt;&lt;  endl;</span>
  <span class="comment">//cout &lt;&lt; LaplacePDF(x) &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;gsl: &quot; &lt;&lt; gsl_ran_laplace_pdf(inf(x), 1) &lt;&lt; &quot;\t&quot; &lt;&lt;  gsl_ran_laplace_pdf(sup(x), 1) &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot;\t&quot; &lt;&lt; LaplaceF(x)  &lt;&lt; &quot;\t&quot; &lt;&lt; LaplaceDF(x) &lt;&lt; endl;</span>

  <span class="comment">//if the function is twice differentiable?</span>
  <span class="keywordflow">if</span> ( !subset(0.0, <a class="code" href="errorfunc_8cpp.shtml#a1df0b848b1e7ebd2de5866266df70ceb">LaplaceDF</a>(x)) ) {
    cout &lt;&lt; <span class="stringliteral">&quot;Sending &quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; to the Newton operator...&quot;</span> &lt;&lt; endl;
    <a class="code" href="errorfunc_8cpp.shtml#a6c2d3ad910df045a1fa44cb3fd190bbe">LaplacefindRoot</a>(x, fhat, rootVec);
    cerr &lt;&lt; <span class="stringliteral">&quot;check this!&quot;</span> &lt;&lt; endl;
    exit(0);
  }
  
  <span class="keywordflow">else</span> {
   <span class="comment">// if the function is not differentiable</span>
    <span class="comment">//cout &lt;&lt; &quot;------------compare fhats&quot; &lt;&lt; endl;</span>
    <span class="comment">//cout.precision(10);</span>
    <span class="comment">//cout &lt;&lt; intervalw(fhat) &lt;&lt; &quot;\t&quot; &lt;&lt; LaplaceF(x) &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; ( fhat &lt;= sup(LaplaceF(x)) ) &lt;&lt; endl;</span>
    
    <span class="keywordflow">if</span> ( subset(<a class="code" href="classintervalw.shtml">intervalw</a>(fhat), <a class="code" href="errorfunc_8cpp.shtml#a83cb93d97adbc26d2b6731e89725b7d6">LaplaceF</a>(x)) ) {
      <span class="comment">//cout &lt;&lt; &quot;check tolerance: &quot; &lt;&lt; endl;</span>
      <span class="comment">//cout &lt;&lt; diam(x) &lt;&lt; &quot;\t&quot; &lt;&lt; TOL &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> ( diam(x) &lt; TOL ) {
        <span class="comment">//cout &lt;&lt; diam(x) &lt;&lt; &quot;\t&quot; &lt;&lt; TOL &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; may contain roots. &quot; &lt;&lt; endl;</span>
        rootVec.push_back(x); <span class="comment">//keep the roots in a container</span>
      }
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;bisect: &quot; &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; &quot;left&quot; &lt;&lt; endl;</span>
        <a class="code" href="errorfunc_8cpp.shtml#a4de668d5d847a753a9a4baf05c7d8d52">LaplaceBisect</a>(<a class="code" href="classintervalw.shtml">intervalw</a>(inf(x), mid(x)), TOL, fhat, rootVec);
        <span class="comment">//cout &lt;&lt; &quot;right&quot; &lt;&lt; endl;</span>
        <a class="code" href="errorfunc_8cpp.shtml#a4de668d5d847a753a9a4baf05c7d8d52">LaplaceBisect</a>(<a class="code" href="classintervalw.shtml">intervalw</a>(mid(x), sup(x)), TOL, fhat, rootVec);
      }
    }
    <span class="comment">//else { cout &lt;&lt; &quot;fhat not here. &quot; &lt;&lt; endl; }</span>
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1df0b848b1e7ebd2de5866266df70ceb"></a><!-- doxytag: member="errorfunc.hpp::LaplaceDF" ref="a1df0b848b1e7ebd2de5866266df70ceb" args="(const intervalw &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a1df0b848b1e7ebd2de5866266df70ceb">LaplaceDF</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01652">1652</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01589">LaplacePDF()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01692">LaplaceBisect()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01658">LaplaceNewton()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> deriv(<a class="code" href="errorfunc_8cpp.shtml#a5c072ddf22efaed3c1dc612f42290f30">LaplacePDF</a>(x)); }
</pre></div>
</div>
</div>
<a class="anchor" id="a83cb93d97adbc26d2b6731e89725b7d6"></a><!-- doxytag: member="errorfunc.hpp::LaplaceF" ref="a83cb93d97adbc26d2b6731e89725b7d6" args="(const intervalw &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a83cb93d97adbc26d2b6731e89725b7d6">LaplaceF</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01648">1648</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01589">LaplacePDF()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01692">LaplaceBisect()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01658">LaplaceNewton()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> value(<a class="code" href="errorfunc_8cpp.shtml#a5c072ddf22efaed3c1dc612f42290f30">LaplacePDF</a>(x)); }
</pre></div>
</div>
</div>
<a class="anchor" id="aeda7aada753d81a54e812a7ce416d0f5"></a><!-- doxytag: member="errorfunc.hpp::LaplacefindRoot" ref="aeda7aada753d81a54e812a7ce416d0f5" args="(const intervalw &amp;domain, double fhat, vector&lt; intervalw &gt; &amp;rootList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#aeda7aada753d81a54e812a7ce416d0f5">LaplacefindRoot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rootList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01665">1665</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01658">LaplaceNewton()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01692">LaplaceBisect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;finding root at &quot; &lt;&lt; domain &lt;&lt; &quot; for &quot; &lt;&lt; fhat &lt;&lt; endl;</span>
 
  <a class="code" href="classintervalw.shtml">intervalw</a> newX       = domain;
  <a class="code" href="classintervalw.shtml">intervalw</a> oldX       = domain + 1;
  <span class="keywordtype">bool</span>     rootUnique = <span class="keyword">false</span>;
  <span class="keywordtype">bool</span>     rootExists = <span class="keyword">true</span>;

  <span class="keywordflow">while</span>( (newX != oldX) &amp;&amp; rootExists ) {
    oldX = newX;
    <span class="keywordflow">if</span>( !intersect(newX, <a class="code" href="errorfunc_8cpp.shtml#a64a77490c542f82e7ae00ab525f3efe1">LaplaceNewton</a>(oldX, fhat), oldX) ) 
      rootExists = <span class="keyword">false</span>;
    <span class="keywordflow">if</span> ( subset(newX, oldX) ) 
      rootUnique = <span class="keyword">true</span>;
  }
  <span class="keywordflow">if</span> ( rootExists ) {
    cout &lt;&lt; newX;
    rootVec.push_back(newX);
    <span class="keywordflow">if</span> ( rootUnique )
      cout &lt;&lt; <span class="stringliteral">&quot; contains a unique root.&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">else</span>
      cout &lt;&lt; <span class="stringliteral">&quot; may contain a simple root.&quot;</span> &lt;&lt; endl;
  } 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a76a4c9e6350419472c3285481c1690e2"></a><!-- doxytag: member="errorfunc.hpp::LaplaceGetL1error" ref="a76a4c9e6350419472c3285481c1690e2" args="(double fhat, interval &amp;thisInt, int Deg, double TOL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#a76a4c9e6350419472c3285481c1690e2">LaplaceGetL1error</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval &amp;&#160;</td>
          <td class="paramname"><em>thisInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>TOL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01777">1777</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01620">LaplaceIntegrand()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01758">LaplaceIntegrate()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04206">subpavings::AdaptiveHistogram::getLaplaceIntervalIAE()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l00917">getRegHistLaplaceIntervalIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//  cout &lt;&lt; &quot;==========get L1 error for &quot; &lt;&lt; thisInt &lt;&lt;  endl;</span>
  <span class="comment">//hard-code this temporarily</span>
  <span class="keywordtype">double</span> Tol = 0.0000001;
  <span class="comment">//cout &lt;&lt; Tol &lt;&lt; endl;</span>
  
  <span class="comment">//get the area of the histogram at this interval</span>
  real histArea = diam(thisInt) * fhat;

  <span class="comment">//integrate the function at this sub-interval</span>
  interval fArea = <a class="code" href="errorfunc_8cpp.shtml#ae9e1f8084e10ac335146e7849cc23fbd">LaplaceIntegrate</a>(<a class="code" href="errorfunc_8cpp.shtml#a113114b7f2ac4e8e3c7900ab491eaf1b">LaplaceIntegrand</a>, thisInt, Deg, Tol);
  <span class="comment">//cout &lt;&lt; &quot;integrate: &quot; &lt;&lt; fArea &lt;&lt; endl;</span>

  <span class="comment">//cout &lt;&lt; &quot;get the differences &quot; &lt;&lt; endl;</span>
  <span class="comment">//get the differences of the areas</span>
  <span class="comment">//double up = gsl_cdf_laplace_P(_double(Sup(thisInt)), 1);</span>
  <span class="comment">//double low = gsl_cdf_laplace_P(_double(Inf(thisInt)), 1);</span>
  <span class="comment">//cout &lt;&lt; &quot;gsl: &quot; &lt;&lt; up-low &lt;&lt; endl;</span>
  interval diffArea = abs(abs(fArea) - histArea);
  <span class="comment">//cout &lt;&lt; &quot;fArea: &quot; &lt;&lt; fArea &lt;&lt; &quot;\t&quot; &lt;&lt; diam(thisInt) &lt;&lt; </span>
  <span class="comment">//&quot;\t fhat:&quot; &lt;&lt; fhat &lt;&lt; &quot;\t histArea: &quot; &lt;&lt; histArea &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; diffArea &lt;&lt; endl;</span>

  <span class="keywordflow">return</span> diffArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a113114b7f2ac4e8e3c7900ab491eaf1b"></a><!-- doxytag: member="errorfunc.hpp::LaplaceIntegrand" ref="a113114b7f2ac4e8e3c7900ab491eaf1b" args="(const itaylor &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitaylor.shtml">itaylor</a> <a class="el" href="errorfunc_8hpp.shtml#a113114b7f2ac4e8e3c7900ab491eaf1b">LaplaceIntegrand</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01620">1620</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, and <a class="el" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01777">LaplaceGetL1error()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01736">LaplaceRiemannTerm()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <span class="comment">//cout &lt;&lt; &quot;-------Integrand: ---------&quot; &lt;&lt; x[0] &lt;&lt; &quot;\t&quot;;</span>
  <a class="code" href="classitaylor.shtml">itaylor</a> PDF(<a class="code" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable</a>(interval(0,0), orderOf(x)));

  <span class="keywordflow">if</span> ( Sup(x[0]) &lt; 0.0 ) {
    PDF = 0.5*<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-(-x));
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( Inf(x[0]) &gt;= 0.0 ) { 
    PDF = 0.5*<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-(x));
  }
  <span class="comment">// 0 is inside the interval x</span>
  <span class="keywordflow">else</span> { 
    <span class="comment">//cout &lt;&lt; gsl_ran_laplace_pdf(_double(Inf(x[0])), 1) &lt;&lt; &quot;\t&quot; &lt;&lt; gsl_ran_laplace_pdf(_double(Sup(x[0])), 1) &lt;&lt; endl;</span>
    <span class="keywordflow">if</span> ( abs(Inf(x[0])) &gt;= Sup(x[0]) ) {
      PDF = 0.5*<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(x);
    }
    <span class="keywordflow">else</span> {
      PDF = 0.5*<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-x);
    }
  }
  
  <span class="comment">//cout &lt;&lt; &quot;PDF: &quot; &lt;&lt; PDF[0] &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> PDF;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a18bf9ac674a2a633029b5ca438084099"></a><!-- doxytag: member="errorfunc.hpp::LaplaceIntegrate" ref="a18bf9ac674a2a633029b5ca438084099" args="(pfcn f, interval X, int Deg, double Tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#a18bf9ac674a2a633029b5ca438084099">LaplaceIntegrate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a64a77490c542f82e7ae00ab525f3efe1"></a><!-- doxytag: member="errorfunc.hpp::LaplaceNewton" ref="a64a77490c542f82e7ae00ab525f3efe1" args="(const intervalw &amp;x, double fhat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a64a77490c542f82e7ae00ab525f3efe1">LaplaceNewton</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01658">1658</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01652">LaplaceDF()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01648">LaplaceF()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01665">LaplacefindRoot()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classintervalw.shtml">intervalw</a> midX(mid(x));
  <span class="keywordflow">return</span> midX - <a class="code" href="errorfunc_8cpp.shtml#a83cb93d97adbc26d2b6731e89725b7d6">LaplaceF</a>(midX)/<a class="code" href="errorfunc_8cpp.shtml#a1df0b848b1e7ebd2de5866266df70ceb">LaplaceDF</a>(x);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5c072ddf22efaed3c1dc612f42290f30"></a><!-- doxytag: member="errorfunc.hpp::LaplacePDF" ref="a5c072ddf22efaed3c1dc612f42290f30" args="(const intervalw &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classia__ad.shtml">ia_ad</a> <a class="el" href="errorfunc_8hpp.shtml#a5c072ddf22efaed3c1dc612f42290f30">LaplacePDF</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01589">1589</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, and <a class="el" href="classia__ad.shtml#a4b29351e6e75dabcdc06ea86a83d1212">ia_ad::variable()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01652">LaplaceDF()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01648">LaplaceF()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classia__ad.shtml">ia_ad</a> PDF(<a class="code" href="classia__ad.shtml#a4b29351e6e75dabcdc06ea86a83d1212">ia_ad::variable</a>(x));

  <span class="comment">//strictly negative cases</span>
  <span class="keywordflow">if</span> ( sup(x) &lt; 0.0 ) {
    PDF = 0.5*<a class="code" href="classintervalw.shtml">intervalw</a>(<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(inf(x)), <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(sup(x)));
  }
  <span class="comment">//strictly positive</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( inf(x) &gt;= 0.0 ) {
    PDF = 0.5*<a class="code" href="classintervalw.shtml">intervalw</a>(<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-sup(x)), <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-inf(x)));
  }
  <span class="comment">// 0 is inside the interval x</span>
  <span class="keywordflow">else</span> {
     <span class="comment">// this is a symmetric density</span>
     <span class="keywordflow">if</span> ( fabs(inf(x)) &gt;= sup(x) ) {
      PDF = 0.5*<a class="code" href="classintervalw.shtml">intervalw</a>(<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(inf(x)), <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(0));
     }
     <span class="keywordflow">else</span> { 
       PDF = 0.5*<a class="code" href="classintervalw.shtml">intervalw</a>(<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-sup(x)), <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(0));
     }
  }
  
  <span class="comment">//cout &lt;&lt; &quot;Domain: &quot; &lt;&lt; x &lt;&lt; &quot;PDF: &quot; &lt;&lt; PDF &lt;&lt; endl;</span>

  <span class="keywordflow">return</span> PDF;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acf4170da9030fb2776342b5e04e2ef7b"></a><!-- doxytag: member="errorfunc.hpp::LaplaceRiemannTerm" ref="acf4170da9030fb2776342b5e04e2ef7b" args="(pfcn f, interval X, int Deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#acf4170da9030fb2776342b5e04e2ef7b">LaplaceRiemannTerm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a72f3aaf218533dc785d09b0dffacbad7"></a><!-- doxytag: member="errorfunc.hpp::LevyOP" ref="a72f3aaf218533dc785d09b0dffacbad7" args="(d2tv X, interval fhat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a> <a class="el" href="errorfunc_8hpp.shtml#a72f3aaf218533dc785d09b0dffacbad7">LevyOP</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a>&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>fhat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IAE for the Levy 2D. </p>
<p>The integral of the absolute error for a Levy 2D. </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00088">88</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="LevyFobj2D_8cpp_source.shtml#l00020">Center1</a>, <a class="el" href="LevyFobj2D_8cpp_source.shtml#l00021">Center2</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01052">taylor::cos()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>, <a class="el" href="LevyFobj2D_8cpp_source.shtml#l00022">GlobalMax</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00132">taylor::init_const()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00592">taylor::sqr()</a>, and <a class="el" href="LevyFobj2D_8cpp_source.shtml#l00019">Temperature</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03408">subpavings::AdaptiveHistogramValidation::getIAE()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03748">subpavings::AdaptiveHistogram::getIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;Calling LevyOP: &quot; &lt;&lt; endl;</span>
  <span class="comment">// Parameters specific to the Levy target </span>
  real <a class="code" href="LevyFobj2D_8cpp.shtml#ae3d1dc6c8ff5f4490d10dd105dfce9a7">Temperature</a> = 40.0;
  real <a class="code" href="LevyFobj2D_8cpp.shtml#abe2298578938894ea3823f8baea9361e">Center1</a> = 1.42513; 
  real <a class="code" href="LevyFobj2D_8cpp.shtml#a896d9a31b2c3aeb2deecb90e98e18a14">Center2</a> = 0.80032; 
  real <a class="code" href="LevyFobj2D_8cpp.shtml#a37e4011a5b0b8b87b1893520477568a2">GlobalMax</a> = 176.14;
  
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> isum = <a class="code" href="namespacetaylor.shtml#a2d1667d3b5c500795eb06c586d75c309">taylor::init_const</a>(X[1].order(),interval(0.0));
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> jsum = <a class="code" href="namespacetaylor.shtml#a2d1667d3b5c500795eb06c586d75c309">taylor::init_const</a>(X[1].order(),interval(0.0));

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 5; i++)
  {
    isum = isum + i * <a class="code" href="namespacetaylor.shtml#af7e3108838177d298e5ef3930dd9605f">cos</a> ((i - 1) * X[1] + (i));
    jsum = jsum + i * <a class="code" href="namespacetaylor.shtml#af7e3108838177d298e5ef3930dd9605f">cos</a> ((i + 1) * X[2] + (i));
  }
                    <span class="comment">// Avoid real conversion error</span>
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> hh = isum * jsum + <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a> (X[1] + Center1) +
    <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a> (X[2] + Center2);
  hh = hh + <a class="code" href="LevyFobj2D_8cpp.shtml#a37e4011a5b0b8b87b1893520477568a2">GlobalMax</a>;  
  <span class="comment">// TEMPERATURE = 1, 4, 40, 400, 4000</span>
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a> = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a> (-hh / Temperature);

  <span class="comment">//integrand  </span>
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> result = <a class="code" href="namespacetaylor.shtml#a2d1667d3b5c500795eb06c586d75c309">taylor::init_const</a>(X[1].order(),interval(0.0));
  <span class="comment">//split the integrand to get positive values only (absolute values) </span>
  <span class="keywordflow">if</span> ( (Sup(f[0][0]) &lt; Inf(fhat)) ) {   
    result = fhat - <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>;
    <span class="comment">//cout &lt;&lt; &quot;fhat - f: &quot; &lt;&lt; result[0][0] &lt;&lt; &quot;\n&quot; &lt;&lt; endl;</span>
  }  
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Sup(f[0][0]) &gt; Inf(fhat))) { 
     result = f - fhat; 
    <span class="comment">//cout &lt;&lt; &quot;f-fhat: &quot; &lt;&lt; result[0][0] &lt;&lt; &quot;\n&quot; &lt;&lt; endl;</span>
  }   
  
  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae609c2490a47ae5b66bbc9ed34ede493"></a><!-- doxytag: member="errorfunc.hpp::LognormalBisect" ref="ae609c2490a47ae5b66bbc9ed34ede493" args="(const intervalw &amp;x, const double &amp;TOL, double &amp;fhat, vector&lt; intervalw &gt; &amp;rootList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#ae609c2490a47ae5b66bbc9ed34ede493">LognormalBisect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>TOL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rootList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01878">1878</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01878">LognormalBisect()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01839">LognormalDF()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01835">LognormalF()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01851">LognormalfindRoot()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04402">subpavings::AdaptiveHistogram::getLognormalIntervalIAE()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01101">getRegHistLognormalIntervalIAE()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01878">LognormalBisect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;===========root finding routine at domain: &quot; &lt;&lt; x &lt;&lt;  endl;</span>
  <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot;\t&quot; &lt;&lt; LaplaceF(x)  &lt;&lt; &quot;\t&quot; &lt;&lt; LognormalDF(x) &lt;&lt; endl;</span>

  <span class="comment">//if the function is twice differentiable?</span>
  <span class="keywordflow">if</span> ( !subset(0.0, <a class="code" href="errorfunc_8cpp.shtml#a45238105e02452f020b01a332fee8913">LognormalDF</a>(x)) ) {
    cout &lt;&lt; <span class="stringliteral">&quot;Sending &quot;</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">&quot; to the Newton operator...&quot;</span> &lt;&lt; endl;
    <a class="code" href="errorfunc_8cpp.shtml#a75c63219b8792609e96391a851a5306e">LognormalfindRoot</a>(x, fhat, rootVec);
    cerr &lt;&lt; <span class="stringliteral">&quot;check this!&quot;</span> &lt;&lt; endl;
    exit(1);
  }
  
  <span class="keywordflow">else</span> {
   <span class="comment">// if the function is not differentiable</span>
  <span class="comment">//  cout &lt;&lt; &quot;------------compare fhats&quot; &lt;&lt; endl;</span>
<span class="comment">//    cout.precision(10);</span>
  <span class="comment">//  cout &lt;&lt; intervalw(fhat) &lt;&lt; &quot;\t&quot; &lt;&lt; LaplaceF(x) &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; ( fhat &lt;= sup(LaplaceF(x)) ) &lt;&lt; endl;</span>
    
    <span class="keywordflow">if</span> ( subset(<a class="code" href="classintervalw.shtml">intervalw</a>(fhat), <a class="code" href="errorfunc_8cpp.shtml#a256e19e7647e7510144ff8e3064b07c1">LognormalF</a>(x)) ) {
    <span class="comment">//  cout &lt;&lt; &quot;check tolerance: &quot; &lt;&lt; endl;</span>
  <span class="comment">//    cout &lt;&lt; diam(x) &lt;&lt; &quot;\t&quot; &lt;&lt; TOL &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> ( diam(x) &lt; TOL ) {
        <span class="comment">//cout &lt;&lt; diam(x) &lt;&lt; &quot;\t&quot; &lt;&lt; TOL &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; x &lt;&lt; &quot; may contain roots. &quot; &lt;&lt; endl;</span>
        rootVec.push_back(x); <span class="comment">//keep the roots in a container</span>
      }
      <span class="keywordflow">else</span> {
    <span class="comment">//    cout &lt;&lt; &quot;bisect: &quot; &lt;&lt; endl;</span>
    <span class="comment">//    cout &lt;&lt; &quot;left&quot; &lt;&lt; endl;</span>
        <a class="code" href="errorfunc_8cpp.shtml#a9722cc78b34593d877ec8cbbb22ac9f2">LognormalBisect</a>(<a class="code" href="classintervalw.shtml">intervalw</a>(inf(x), mid(x)), TOL, fhat, rootVec);
      <span class="comment">//  cout &lt;&lt; &quot;right&quot; &lt;&lt; endl;</span>
        <a class="code" href="errorfunc_8cpp.shtml#a9722cc78b34593d877ec8cbbb22ac9f2">LognormalBisect</a>(<a class="code" href="classintervalw.shtml">intervalw</a>(mid(x), sup(x)), TOL, fhat, rootVec);
      }
    }
    <span class="comment">//else { cout &lt;&lt; &quot;fhat not here. &quot; &lt;&lt; endl; }</span>
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a45238105e02452f020b01a332fee8913"></a><!-- doxytag: member="errorfunc.hpp::LognormalDF" ref="a45238105e02452f020b01a332fee8913" args="(const intervalw &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a45238105e02452f020b01a332fee8913">LognormalDF</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01839">1839</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01807">LognormalPDF()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01878">LognormalBisect()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01844">LognormalNewton()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> deriv(<a class="code" href="errorfunc_8cpp.shtml#a6640f4518f5a29d2caa7dd15c3d05be0">LognormalPDF</a>(x)); }
</pre></div>
</div>
</div>
<a class="anchor" id="a256e19e7647e7510144ff8e3064b07c1"></a><!-- doxytag: member="errorfunc.hpp::LognormalF" ref="a256e19e7647e7510144ff8e3064b07c1" args="(const intervalw &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a256e19e7647e7510144ff8e3064b07c1">LognormalF</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01835">1835</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01807">LognormalPDF()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01878">LognormalBisect()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01844">LognormalNewton()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> value(<a class="code" href="errorfunc_8cpp.shtml#a6640f4518f5a29d2caa7dd15c3d05be0">LognormalPDF</a>(x)); }
</pre></div>
</div>
</div>
<a class="anchor" id="ad0d44cb3344c0a21cfbf56bb7d263066"></a><!-- doxytag: member="errorfunc.hpp::LognormalfindRoot" ref="ad0d44cb3344c0a21cfbf56bb7d263066" args="(const intervalw &amp;domain, double fhat, vector&lt; intervalw &gt; &amp;rootList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#ad0d44cb3344c0a21cfbf56bb7d263066">LognormalfindRoot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classintervalw.shtml">intervalw</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rootList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01851">1851</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01844">LognormalNewton()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01878">LognormalBisect()</a>.</p>
<div class="fragment"><pre class="fragment">{
  cout &lt;&lt; <span class="stringliteral">&quot;finding root at &quot;</span> &lt;&lt; domain &lt;&lt; <span class="stringliteral">&quot; for &quot;</span> &lt;&lt; fhat &lt;&lt; endl;
 
  <a class="code" href="classintervalw.shtml">intervalw</a> newX       = domain;
  <a class="code" href="classintervalw.shtml">intervalw</a> oldX       = domain + 1;
  <span class="keywordtype">bool</span>     rootUnique = <span class="keyword">false</span>;
  <span class="keywordtype">bool</span>     rootExists = <span class="keyword">true</span>;

  <span class="keywordflow">while</span>( (newX != oldX) &amp;&amp; rootExists ) {
    oldX = newX;
    <span class="keywordflow">if</span>( !intersect(newX, <a class="code" href="errorfunc_8cpp.shtml#a2ad23089c1ee547e199a0e481a973f02">LognormalNewton</a>(oldX, fhat), oldX) ) 
      rootExists = <span class="keyword">false</span>;
    <span class="keywordflow">if</span> ( subset(newX, oldX) ) 
      rootUnique = <span class="keyword">true</span>;
  }
  <span class="keywordflow">if</span> ( rootExists ) {
    cout &lt;&lt; newX;
    rootVec.push_back(newX);
    <span class="keywordflow">if</span> ( rootUnique )
      cout &lt;&lt; <span class="stringliteral">&quot; contains a unique root.&quot;</span> &lt;&lt; endl;
    <span class="keywordflow">else</span>
      cout &lt;&lt; <span class="stringliteral">&quot; may contain a simple root.&quot;</span> &lt;&lt; endl;
  } 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac99ece8c6ec9b7be0d2eec8911aff71a"></a><!-- doxytag: member="errorfunc.hpp::LognormalGetL1error" ref="ac99ece8c6ec9b7be0d2eec8911aff71a" args="(double fhat, interval &amp;thisInt, int Deg, double TOL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#ac99ece8c6ec9b7be0d2eec8911aff71a">LognormalGetL1error</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval &amp;&#160;</td>
          <td class="paramname"><em>thisInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>TOL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01960">1960</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01821">LognormalIntegrand()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01942">LognormalIntegrate()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogram_8cpp_source.shtml#l04402">subpavings::AdaptiveHistogram::getLognormalIntervalIAE()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01101">getRegHistLognormalIntervalIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;==========get L1 error for &quot; &lt;&lt; thisInt &lt;&lt;  endl;</span>
  <span class="comment">//cout.precision(10);</span>
  
  <span class="comment">//hard-code this temporarily</span>
  <span class="keywordtype">double</span> Tol = 0.0000001;
  <span class="comment">//cout &lt;&lt; Tol &lt;&lt; endl;</span>
  
  <span class="comment">//get the area of the histogram at this interval</span>
  real histArea = diam(thisInt) * fhat;

  <span class="comment">//integrate the function at this sub-interval</span>
  interval fArea = <a class="code" href="errorfunc_8cpp.shtml#af9a4802a471fb3809209d48e33864b6d">LognormalIntegrate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb93c77ab57e8ed2b6a1c581e60db5d">LognormalIntegrand</a>, thisInt, Deg, Tol);
  <span class="comment">//cout &lt;&lt; &quot;integrate: &quot; &lt;&lt; fArea &lt;&lt; endl;</span>

  <span class="comment">//cout &lt;&lt; &quot;get the differences &quot; &lt;&lt; endl;</span>
  <span class="comment">//get the differences of the areas</span>
  <span class="comment">//double up = gsl_cdf_lognormal_P(_double(Sup(thisInt)), 0, 1);</span>
  <span class="comment">//double low = gsl_cdf_lognormal_P(_double(Inf(thisInt)), 0, 1);</span>
  <span class="comment">//cout &lt;&lt; &quot;gsl: &quot; &lt;&lt; up-low &lt;&lt; endl;</span>
  interval diffArea = abs(abs(fArea) - histArea);
  <span class="comment">//cout &lt;&lt; &quot;fArea: &quot; &lt;&lt; fArea &lt;&lt; &quot;\t&quot; &lt;&lt; diam(thisInt) &lt;&lt; </span>
  <span class="comment">//&quot;\t fhat:&quot; &lt;&lt; fhat &lt;&lt; &quot;\t histArea: &quot; &lt;&lt; histArea &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; diffArea &lt;&lt; endl;</span>

  <span class="keywordflow">return</span> diffArea;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aacb93c77ab57e8ed2b6a1c581e60db5d"></a><!-- doxytag: member="errorfunc.hpp::LognormalIntegrand" ref="aacb93c77ab57e8ed2b6a1c581e60db5d" args="(const itaylor &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitaylor.shtml">itaylor</a> <a class="el" href="errorfunc_8hpp.shtml#aacb93c77ab57e8ed2b6a1c581e60db5d">LognormalIntegrand</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitaylor.shtml">itaylor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01821">1821</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>, and <a class="el" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01960">LognormalGetL1error()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01920">LognormalRiemannTerm()</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <span class="comment">//cout &lt;&lt; &quot;-------Integrand: ---------&quot; &lt;&lt; endl;</span>
  <a class="code" href="classitaylor.shtml">itaylor</a> PDF(<a class="code" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable</a>(interval(0,0), orderOf(x)));
  
  PDF = 1/x*1/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2*M_PI)*<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-0.5*log(x)*log(x));

  <span class="comment">//cout &lt;&lt; PDF[0] &lt;&lt; endl;</span>
  
  <span class="keywordflow">return</span> PDF;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aab82d694198dfbd61222e06b563af748"></a><!-- doxytag: member="errorfunc.hpp::LognormalIntegrate" ref="aab82d694198dfbd61222e06b563af748" args="(pfcn f, interval X, int Deg, double Tol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#aab82d694198dfbd61222e06b563af748">LognormalIntegrate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ad23089c1ee547e199a0e481a973f02"></a><!-- doxytag: member="errorfunc.hpp::LognormalNewton" ref="a2ad23089c1ee547e199a0e481a973f02" args="(const intervalw &amp;x, double fhat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#a2ad23089c1ee547e199a0e481a973f02">LognormalNewton</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01844">1844</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01839">LognormalDF()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01835">LognormalF()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01851">LognormalfindRoot()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classintervalw.shtml">intervalw</a> midX(mid(x));
  <span class="keywordflow">return</span> midX - <a class="code" href="errorfunc_8cpp.shtml#a256e19e7647e7510144ff8e3064b07c1">LognormalF</a>(midX)/<a class="code" href="errorfunc_8cpp.shtml#a45238105e02452f020b01a332fee8913">LognormalDF</a>(x);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6640f4518f5a29d2caa7dd15c3d05be0"></a><!-- doxytag: member="errorfunc.hpp::LognormalPDF" ref="a6640f4518f5a29d2caa7dd15c3d05be0" args="(const intervalw &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classia__ad.shtml">ia_ad</a> <a class="el" href="errorfunc_8hpp.shtml#a6640f4518f5a29d2caa7dd15c3d05be0">LognormalPDF</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01807">1807</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>, and <a class="el" href="classia__ad.shtml#a4b29351e6e75dabcdc06ea86a83d1212">ia_ad::variable()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01839">LognormalDF()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01835">LognormalF()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classia__ad.shtml">ia_ad</a> PDF(<a class="code" href="classia__ad.shtml#a4b29351e6e75dabcdc06ea86a83d1212">ia_ad::variable</a>(x));
  
  PDF = 1/x*1/<a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(2*M_PI)*<a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a>(-0.5*log(x)*log(x));
  
  <span class="keywordflow">return</span> PDF;
  
  <span class="comment">//cout &lt;&lt; &quot;Domain: &quot; &lt;&lt; x &lt;&lt; &quot;PDF: &quot; &lt;&lt; PDF &lt;&lt; endl;</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a13b6ea07dcfc5c287205aab201a94c2e"></a><!-- doxytag: member="errorfunc.hpp::LognormalRiemannTerm" ref="a13b6ea07dcfc5c287205aab201a94c2e" args="(pfcn f, interval X, int Deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#a13b6ea07dcfc5c287205aab201a94c2e">LognormalRiemannTerm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1cbeb2c4ee32bf849533e448710c50e3"></a><!-- doxytag: member="errorfunc.hpp::makeRegularHist" ref="a1cbeb2c4ee32bf849533e448710c50e3" args="(RegHist &amp;myRegHist, const RVecData &amp;rvec, ivector theBox, int bwmethod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#accc20534ffc0e82153262d1a063c2059">makeRegularHist</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>theBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bwmethod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a regular histogram (using Dominic's histogram.m file) </p>
<p>Make a regular histogram, i.e. histogram of equal width. Only for one-dimensional data. </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00272">272</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8hpp_source.shtml#l00283">RegHist::binwidth</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00651">myStd()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00450">psi()</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>.</p>

<p>Referenced by <a class="el" href="FiniteMixture_8cpp_source.shtml#l00045">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// vector for heights</span>
  vector&lt;double&gt; heights;

  <span class="keywordtype">size_t</span> n = sortedData.size();
  <span class="comment">//cout &lt;&lt; &quot;there are &quot; &lt;&lt; n &lt;&lt; &quot; points.&quot; &lt;&lt; endl;</span>

  <span class="comment">// determine the bandwidth</span>
  <span class="keywordtype">double</span> n3 = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(n, -1.0/3.0); 
  <span class="keywordtype">double</span> n5 = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(n, -0.2); 
  <span class="keywordtype">double</span> n7 = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(n, -1.0/7.0);
  <span class="comment">//cout &lt;&lt; &quot;n3: &quot; &lt;&lt; n3 &lt;&lt; &quot;\tn5: &quot; &lt;&lt; n5 &lt;&lt; &quot;\tn7: &quot; &lt;&lt; n7 &lt;&lt; endl;</span>

  <span class="comment">/*</span>
<span class="comment">  // put the data into a list to sort the data</span>
<span class="comment">  RVecDataCItr rvecIt;</span>
<span class="comment">  list&lt;rvector&gt; rvecList;</span>
<span class="comment">  list&lt;rvector&gt;::iterator rvecListIt;</span>
<span class="comment">  for (rvecIt = rvec.begin(); rvecIt &lt; rvec.end(); rvecIt++){</span>
<span class="comment">    rvector thisrv(1);</span>
<span class="comment">    thisrv = *rvecIt;</span>
<span class="comment">    rvecList.push_back(thisrv);</span>
<span class="comment">  }</span>
<span class="comment">  rvecList.sort(); //sort the data</span>
<span class="comment">  RVecData sortedData; // put back into vector</span>
<span class="comment">  for (rvecListIt = rvecList.begin(); rvecListIt != rvecList.end(); rvecListIt++)</span>
<span class="comment">  { </span>
<span class="comment">    rvector thisrv(1);</span>
<span class="comment">    thisrv = *rvecListIt;</span>
<span class="comment">    sortedData.push_back(thisrv);</span>
<span class="comment">  }</span>
<span class="comment">  */</span>
  
  <span class="comment">// get the interquartile range</span>
  <span class="keywordtype">int</span> upperQ = ceil(0.75*n);  <span class="comment">//upper quartile</span>
  <span class="keywordtype">int</span> lowerQ = ceil(0.25*n);  <span class="comment">//lower quartile</span>
  <span class="keywordtype">double</span> upperQx = _double((sortedData[upperQ-1])[1]);
  <span class="keywordtype">double</span> lowerQx = _double((sortedData[lowerQ-1])[1]);
  <span class="keywordtype">double</span> xiq = upperQx - lowerQx; <span class="comment">// interquartile range</span>

  <span class="keywordtype">double</span> xsd = <a class="code" href="errorfunc_8cpp.shtml#a674756d3d6aae91356b22688a849bd0f" title="get the standard deviation of the data (this is used when building the regular histogram)">myStd</a>(sortedData);
  <span class="comment">// determine which sigma to use</span>
  <span class="keywordtype">double</span> sigma;
  <span class="keywordflow">if</span> (xiq == 0) { sigma = xsd; }
  <span class="keywordflow">else</span> { sigma = min(xsd, (xiq/1.349)); }

  <span class="comment">// determine which bandwidth method to use</span>
  <span class="keywordtype">double</span> bw = 0.0;
  
  cout &lt;&lt; <span class="stringliteral">&quot;determine which bandwidth method to use:&quot;</span> &lt;&lt; endl;
  <span class="comment">// Scott if bwmethod == 0</span>
  <span class="keywordflow">if</span> (bwmethod == 0) { bw = 3.4908 * sigma * n3; } 
  <span class="comment">// Wand&#39;s one stage if bwmethod == 1 </span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bwmethod == 1) {
    <span class="keywordtype">double</span> g11 = 1.3041 * sigma * n5;
    bw  = 1.8171 * <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(-<a class="code" href="errorfunc_8cpp.shtml#aeec9912b8816ad5b3a449f80f9e5d983" title="Function required for regular histogram.">psi</a>(sortedData, g11, 2), (-1.0/3.0)) * n3;
  }
  <span class="comment">// Wand&#39;s two stage if bwmethod == 2</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bwmethod == 2) {
    <span class="keywordtype">double</span> g22 = 1.2407 * sigma * n7;
    <span class="keywordtype">double</span> g21 = 0.9558 * <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((<a class="code" href="errorfunc_8cpp.shtml#aeec9912b8816ad5b3a449f80f9e5d983" title="Function required for regular histogram.">psi</a>(sortedData,g22,4)),(-0.2)) * n5; 
    bw  = 1.8171 * <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((-<a class="code" href="errorfunc_8cpp.shtml#aeec9912b8816ad5b3a449f80f9e5d983" title="Function required for regular histogram.">psi</a>(sortedData,g21,2)),(-1.0/3.0)) * n3;
  }

  <span class="comment">// Determine bin origin</span>
  <span class="comment">//cout &lt;&lt; &quot;determine the bin origin&quot; &lt;&lt; endl;</span>
  rvector xmin = sortedData[0]; <span class="comment">//the minimum value;</span>
  rvector xmax = sortedData[n-1]; <span class="comment">//the maximum value</span>
  <span class="keywordtype">double</span> xrange =  _double(xmax[1]) - _double(xmin[1]); <span class="comment">// range of data  </span>
  <span class="keywordtype">int</span> nbin  = ceil(xrange/ bw); <span class="comment">// number of bins</span>
  real xoffset = _real((nbin * bw - xrange) / 2); <span class="comment">// offset</span>
  rvector xlow = Inf(theBox);
  rvector xupp = Sup(theBox);
  real bbeg = max(xlow[1], xmin[1] - xoffset); <span class="comment">// bin origin</span>
  real bend = min(xupp[1], xmax[1] + xoffset); <span class="comment">// bin end</span>
  real bwR = (bend - bbeg) / (nbin*1.0); <span class="comment">// binwidth</span>
  myRegHist.<a class="code" href="structRegHist.shtml#a4303d3e3de079e309a6b71a422a13947">binwidth</a> = bwR;

  cout &lt;&lt; <span class="stringliteral">&quot;there are &quot;</span> &lt;&lt; nbin &lt;&lt; <span class="stringliteral">&quot; bins&quot;</span> &lt;&lt; endl;
  <span class="keywordtype">int</span> J = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbin; i++) {
    <span class="comment">// bin edges</span>
    myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>.push_back(bbeg + bwR*i);
    myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>.push_back(bbeg + bwR*(i+1));

    <span class="comment">//cout &lt;&lt; &quot;getting the counts:&quot; &lt;&lt; endl;</span>
    <span class="keywordtype">size_t</span> P = 0;
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = J; j &lt; n; j++) {
      rvector thisrv(1);
      thisrv = sortedData[j];
      <span class="keywordflow">if</span> (thisrv[1] &gt;= (bbeg + bwR*i) &amp;&amp; thisrv[1] &lt; (bbeg + bwR*(i+1)) ) {
        P += 1; <span class="comment">// Count frequencies:</span>
      }
      <span class="keywordflow">else</span> { J = j+1; <span class="keywordflow">break</span>; }
    }
    myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>.push_back((P*1.0)/(n*1.0*_double(bwR)));  <span class="comment">//height  </span>
  }
}  
</pre></div>
</div>
</div>
<a class="anchor" id="accc20534ffc0e82153262d1a063c2059"></a><!-- doxytag: member="errorfunc.hpp::makeRegularHist" ref="accc20534ffc0e82153262d1a063c2059" args="(RegHist &amp;myRegHist, const RVecData &amp;rvec, ivector theBox, double bw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#accc20534ffc0e82153262d1a063c2059">makeRegularHist</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>theBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00373">373</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8hpp_source.shtml#l00283">RegHist::binwidth</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l00651">myStd()</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// vector for heights</span>
  vector&lt;double&gt; heights;

  <span class="keywordtype">size_t</span> n = sortedData.size();
  <span class="comment">//cout &lt;&lt; &quot;there are &quot; &lt;&lt; n &lt;&lt; &quot; points.&quot; &lt;&lt; endl;</span>

  <span class="comment">/*</span>
<span class="comment">  // put the data into a list to sort the data</span>
<span class="comment">  RVecDataCItr rvecIt;</span>
<span class="comment">  list&lt;rvector&gt; rvecList;</span>
<span class="comment">  list&lt;rvector&gt;::iterator rvecListIt;</span>
<span class="comment">  for (rvecIt = rvec.begin(); rvecIt &lt; rvec.end(); rvecIt++){</span>
<span class="comment">    rvector thisrv(1);</span>
<span class="comment">    thisrv = *rvecIt;</span>
<span class="comment">    rvecList.push_back(thisrv);</span>
<span class="comment">  }</span>
<span class="comment">  rvecList.sort(); //sort the data</span>
<span class="comment">  RVecData sortedData; // put back into vector</span>
<span class="comment">  for (rvecListIt = rvecList.begin(); rvecListIt != rvecList.end(); rvecListIt++)</span>
<span class="comment">  { </span>
<span class="comment">    rvector thisrv(1);</span>
<span class="comment">    thisrv = *rvecListIt;</span>
<span class="comment">    sortedData.push_back(thisrv);</span>
<span class="comment">  } */</span>

  <span class="comment">// get the interquartile range</span>
  <span class="keywordtype">int</span> upperQ = ceil(0.75*n);  <span class="comment">//upper quartile</span>
  <span class="keywordtype">int</span> lowerQ = ceil(0.25*n);  <span class="comment">//lower quartile</span>
  <span class="keywordtype">double</span> upperQx = _double((sortedData[upperQ-1])[1]);
  <span class="keywordtype">double</span> lowerQx = _double((sortedData[lowerQ-1])[1]);
  <span class="keywordtype">double</span> xiq = upperQx - lowerQx; <span class="comment">// interquartile range</span>

  <span class="comment">// determine which sigma to use</span>
  <span class="keywordtype">double</span> xsd = <a class="code" href="errorfunc_8cpp.shtml#a674756d3d6aae91356b22688a849bd0f" title="get the standard deviation of the data (this is used when building the regular histogram)">myStd</a>(sortedData); <span class="comment">// standard deviation</span>
  <span class="keywordtype">double</span> sigma;
  <span class="keywordflow">if</span> (xiq == 0) { sigma = xsd; }
  <span class="keywordflow">else</span> { sigma = min(xsd, (xiq/1.349)); }

  <span class="comment">// Determine bin origin</span>
  <span class="comment">//cout &lt;&lt; &quot;determine the bin origin&quot; &lt;&lt; endl;</span>
  rvector xmin = sortedData[0]; <span class="comment">//the minimum value;</span>
  rvector xmax = sortedData[n-1]; <span class="comment">//the maximum value</span>
  <span class="keywordtype">double</span> xrange =  _double(xmax[1]) - _double(xmin[1]); <span class="comment">// range of data  </span>
  <span class="keywordtype">int</span> nbin  = ceil(xrange/ bw); <span class="comment">// number of bins</span>
  real xoffset = _real((nbin * bw - xrange) / 2); <span class="comment">// offset</span>
  rvector xlow = Inf(theBox);
  rvector xupp = Sup(theBox);
  real bbeg = max(xlow[1], xmin[1] - xoffset); <span class="comment">// bin origin</span>
  real bend = min(xupp[1], xmax[1] + xoffset); <span class="comment">// bin end</span>
  real bwR = (bend - bbeg) / (nbin*1.0); <span class="comment">// binwidth</span>
  myRegHist.<a class="code" href="structRegHist.shtml#a4303d3e3de079e309a6b71a422a13947">binwidth</a> = bwR;

  <span class="keywordtype">int</span> J = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nbin; i++) {
    <span class="comment">// bin edges</span>
    myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>.push_back(bbeg + bwR*i);
    myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>.push_back(bbeg + bwR*(i+1));

    <span class="comment">//cout &lt;&lt; &quot;getting the counts:&quot; &lt;&lt; endl;</span>
    <span class="keywordtype">size_t</span> P = 0;
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = J; j &lt; n; j++) {
      rvector thisrv(1);
      thisrv = sortedData[j];           
      <span class="keywordflow">if</span> (thisrv[1] &gt;= (bbeg + bwR*i) &amp;&amp; thisrv[1] &lt; (bbeg + bwR*(i+1)) ) {
        P += 1; <span class="comment">// Count frequencies:</span>
      }
      <span class="keywordflow">else</span> { J = j+1; <span class="keywordflow">break</span>; }
    }
    myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>.push_back((P*1.0)/(n*1.0*_double(bwR)));  <span class="comment">//height  </span>
  }
}  
</pre></div>
</div>
</div>
<a class="anchor" id="a64a6fd302dffeebb366383e265ea20f6"></a><!-- doxytag: member="errorfunc.hpp::myMean" ref="a64a6fd302dffeebb366383e265ea20f6" args="(const RVecData &amp;rvec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="errorfunc_8hpp.shtml#a64a6fd302dffeebb366383e265ea20f6">myMean</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the mean of the data (this is used when building the regular histogram) </p>
<p>Get mean of RVecData </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00634">634</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l00651">myStd()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;getmean&quot; &lt;&lt; endl;</span>
  <span class="keywordtype">size_t</span> n = rvec.size(); <span class="comment">// number of points</span>
  <span class="comment">// get the sum</span>
  <span class="keywordtype">double</span> mySum = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; i++){
    rvector thisrv = rvec[i];
    mySum += _double(thisrv[1]);
  }
   <span class="keywordtype">double</span> theMean = mySum/n;
  
  <span class="keywordflow">return</span> theMean; 
}
</pre></div>
</div>
</div>
<a class="anchor" id="a674756d3d6aae91356b22688a849bd0f"></a><!-- doxytag: member="errorfunc.hpp::myStd" ref="a674756d3d6aae91356b22688a849bd0f" args="(const RVecData &amp;rvec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="errorfunc_8hpp.shtml#a674756d3d6aae91356b22688a849bd0f">myStd</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the standard deviation of the data (this is used when building the regular histogram) </p>
<p>Get standard deviation of RVecData </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00651">651</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l00634">myMean()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00678">taylor::sqrt()</a>.</p>

<p>Referenced by <a class="el" href="UnifRegHist_8cpp_source.shtml#l00041">main()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l00272">makeRegularHist()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;get std dev&quot; &lt;&lt; endl;</span>
  <span class="keywordtype">size_t</span> n = rvec.size(); <span class="comment">// number of points</span>
  <span class="keywordtype">double</span> theMean = <a class="code" href="errorfunc_8cpp.shtml#a64a6fd302dffeebb366383e265ea20f6" title="Get the mean of the data (this is used when building the regular histogram)">myMean</a>(rvec);
  <span class="comment">// get the sum of squares of the deviation</span>
  <span class="keywordtype">double</span> mySquaredSum = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; i++){
    rvector thisrv = rvec[i];
    mySquaredSum += <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(_double(thisrv[1]) - theMean, 2);
  }
  <span class="keywordtype">double</span> theStd = <a class="code" href="namespacetaylor.shtml#af90786d46d07cc1e02c6011fee55f165">sqrt</a>(mySquaredSum/(n-1));
  <span class="keywordflow">return</span> theStd; 
}
</pre></div>
</div>
</div>
<a class="anchor" id="abcd464084d71d1ca5caf89793fa1d050"></a><!-- doxytag: member="errorfunc.hpp::N" ref="abcd464084d71d1ca5caf89793fa1d050" args="(const intervalw &amp;x, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S, double fhat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classintervalw.shtml">intervalw</a> <a class="el" href="errorfunc_8hpp.shtml#abcd464084d71d1ca5caf89793fa1d050">N</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classintervalw.shtml">intervalw</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fhat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01396">1396</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01390">DF()</a>, and <a class="el" href="errorfunc_8cpp_source.shtml#l01386">F()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01404">findRoot()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03650">subpavings::AdaptiveHistogram::getEstLogLikelihoodFromRSSample()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03711">subpavings::AdaptiveHistogramValidation::getFinMixIntervalIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classintervalw.shtml">intervalw</a> midX(mid(x));
  <span class="keywordflow">return</span> midX - <a class="code" href="errorfunc_8cpp.shtml#a9b001c0caead3a0c05ed60872773d535">F</a>(midX, W, M, S)/<a class="code" href="errorfunc_8cpp.shtml#a118fce03849bd0483b3b66ae6df14365">DF</a>(x, W, M, S);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aad70f5031a514e5cc5799cda7e878258"></a><!-- doxytag: member="errorfunc.hpp::outputRegHistToTxt" ref="aad70f5031a514e5cc5799cda7e878258" args="(RegHist &amp;myRegHist, std::string &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="errorfunc_8hpp.shtml#aad70f5031a514e5cc5799cda7e878258">outputRegHistToTxt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRegHist.shtml">RegHist</a> &amp;&#160;</td>
          <td class="paramname"><em>myRegHist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Output the regular histogram to .txt file </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01366">1366</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8hpp_source.shtml#l00282">RegHist::heights</a>, <a class="el" href="errorfunc_8hpp_source.shtml#l00280">RegHist::LowerBoxes</a>, and <a class="el" href="errorfunc_8hpp_source.shtml#l00281">RegHist::UpperBoxes</a>.</p>

<p>Referenced by <a class="el" href="FiniteMixture_8cpp_source.shtml#l00045">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> prec = 5; <span class="comment">// precision for output</span>
  ofstream os(s.c_str()); 
  <span class="comment">//output the nodeVolume, height, boxes</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>.size(); i++) {
    os &lt;&lt; myRegHist.<a class="code" href="structRegHist.shtml#a587ad6fc6b0ba0a0c723efeafe299189">heights</a>[i];
    streamsize oldPrec = os.precision();
    os &lt;&lt; setprecision(prec);
    <span class="comment">// intervals of box using Inf and Sup</span>
    os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; myRegHist.<a class="code" href="structRegHist.shtml#ac6b64da4f93f7d21cbdd2c566a7d32bf">LowerBoxes</a>[i];
    os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; myRegHist.<a class="code" href="structRegHist.shtml#a1336612a62cb90cb7dc2cf2610dc5eee">UpperBoxes</a>[i];
    os &lt;&lt; setprecision(oldPrec);
    os &lt;&lt; endl;
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeec9912b8816ad5b3a449f80f9e5d983"></a><!-- doxytag: member="errorfunc.hpp::psi" ref="aeec9912b8816ad5b3a449f80f9e5d983" args="(const RVecData &amp;rvec, double g, double r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="errorfunc_8hpp.shtml#aeec9912b8816ad5b3a449f80f9e5d983">psi</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesubpavings.shtml#a30e15e24c8d81a2160d7422ef3c39d68">RVecData</a> &amp;&#160;</td>
          <td class="paramname"><em>rvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function required for regular histogram. </p>
<p>Get psi (this is used when building the regular histogram). Reference: Wand M.P. (1997), "Data-based choice of histogram bin width", American Statistician 51, 59-64: Equations (2.2), (4.1)-(4.4). </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00450">450</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l00668">gaussian()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l00272">makeRegularHist()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// value to be returned by this function</span>
  <span class="keywordtype">double</span> myPsi = 0;
  
  <span class="comment">//sample size</span>
  <span class="keywordtype">int</span> n = rvec.size();
  
  <span class="comment">//put the sample into a vector&lt;double&gt;</span>
  <span class="comment">//cout &lt;&lt; &quot;data in rvector type:&quot; &lt;&lt; endl;</span>
  <span class="comment">//vector&lt;double&gt; theData;</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; i++){
    rvector thisrv = rvec[i];
  <span class="comment">//  cout &lt;&lt; thisrv[1] &lt;&lt; &quot;\t&quot;;</span>
  }
<span class="comment">//  cout &lt;&lt; &quot;\n&quot; &lt;&lt; endl;</span>
  
  <span class="comment">//data-based value</span>
  <span class="keywordtype">double</span> c = <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((<span class="keywordtype">double</span>(n)),(-2)) * <a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(g,(-r-1));
   <span class="comment">//cout &lt;&lt; &quot;C: &quot; &lt;&lt; c &lt;&lt; endl;</span>
  
   <span class="keywordflow">if</span> (n &lt; 1000) {       
      vector&lt;double&gt; XX, XX2;
      
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {
        rvector rv1 = rvec[i];
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; n; j++) {
          rvector rv2 = rvec[j];    
          XX.push_back((_double(rv2[1])-_double(rv1[1]))/g);      
          XX2.push_back(<a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((_double(rv2[1])-_double(rv1[1]))/g, 2));
        }     
      }
    
    <span class="comment">// get the normal probability density values corresponding to X</span>
    vector&lt;double&gt; vecNPD;
    vecNPD = <a class="code" href="errorfunc_8cpp.shtml#ae767ea3ddeac1e55d74384fe0cd42ecd" title="Gaussian probability density function. Generates normal probability density values corresponding to X...">gaussian</a>(vecNPD, XX, 1);
   
    <span class="keywordflow">if</span> (r == 2) {
       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; XX2.size(); i++) {
        myPsi += (XX2[i]-1)*vecNPD[i];
      }
      
      myPsi *= c;
    <span class="comment">//  cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; &quot;\tmyPsi: &quot; &lt;&lt; myPsi &lt;&lt; endl; </span>
    } <span class="comment">// end of r==2</span>
    
    
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r == 4) {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; XX2.size(); i++) {
         <span class="keywordtype">double</span> XX4 = XX2[i] * XX2[i];
        myPsi += (XX4 - 6*XX2[i] + 3) * vecNPD[i];
      }     
      myPsi *= c;
    <span class="comment">//  cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; &quot;\tmyPsi: &quot; &lt;&lt; myPsi &lt;&lt; endl; </span>
    }
    
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r == 6) {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; XX2.size(); i++) {
         <span class="keywordtype">double</span> XX4 = XX2[i] * XX2[i];
        <span class="keywordtype">double</span> XX6 = XX4 * XX2[i];
        myPsi += (XX6 - 15*XX4 + 45*XX2[i] - 15) * vecNPD[i];
      }     
      myPsi *= c;
    <span class="comment">//  cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; &quot;\tmyPsi: &quot; &lt;&lt; myPsi &lt;&lt; endl; </span>
    }
    
    <span class="keywordflow">else</span> {
      cout &lt;&lt; <span class="stringliteral">&quot;Error: Input r for Function PSI must be 2, 4 or 6.&quot;</span> &lt;&lt; endl;
    }
  
  } <span class="comment">// end of if n &lt; 1000</span>
  
  <span class="keywordflow">else</span> { <span class="comment">// n &gt;= 1000   </span>
    rvector xmin = rvec[0]; <span class="comment">//the minimum value;</span>
    rvector xmax = rvec[n-1]; <span class="comment">//the maximum value</span>
    <span class="keywordtype">int</span> m = 500; 
    rvector d =  (xmax(1) - xmin(1)) / (m - 1);
    
    <span class="comment">/*</span>
<span class="comment">    rmatrix Data(n, 1);</span>
<span class="comment">    rmatrix Ones(n, 1);</span>
<span class="comment">    for (int i = 0; i &lt; n; i++) {</span>
<span class="comment">      Data[i+1][1] = (rvec[i][1] - xmin[1])/d[1];</span>
<span class="comment">      Ones[i+1][1] = 1;</span>
<span class="comment">    }*/</span>

    cout &lt;&lt; <span class="stringliteral">&quot;get c&quot;</span> &lt;&lt; endl;
    vector&lt;rvector&gt; C; 
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m; j++) {

      rvector indC(1);
      indC[1] = 0;

      <span class="comment">/*rmatrix J(n, 1);</span>
<span class="comment">      for (int i = 0; i &lt; n; i++) {</span>
<span class="comment">        J[i+1][1] = -j + 2;</span>
<span class="comment">      }*/</span>

      <span class="comment">//else { //cout &lt;&lt; ((Ones - abs(Data + J)) &gt;= 0) &lt;&lt; endl; } </span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; i++) {
        rvector newX(1);
        rvector thisrv = rvec[i];
        newX[1] = thisrv[1] - xmin[1]; 
        indC[1] += max((1 - abs((newX[1] / d[1]) - j + 1 + 1)), 0);
      }
        C.push_back(indC);
      <span class="comment">//}</span>
    }

    cout &lt;&lt; <span class="stringliteral">&quot;get cc&quot;</span> &lt;&lt; endl;
    vector&lt;rvector&gt; CC;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; C.size(); i++) {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; C.size(); j++) {
        rvector thisrv(1);
        thisrv[1] = C[j]*C[i];
        CC.push_back(thisrv);
      }
    }
    
    cout &lt;&lt; <span class="stringliteral">&quot;get jj and jj2&quot;</span> &lt;&lt; endl;
    vector&lt;double&gt; JJ, JJ2;     
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m; i++) {
      rvector rv1(1);
      rv1[1] = i;
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; m; j++) {
        rvector rv2(1);
        rv2[1] = j;   
        JJ.push_back(_double(d[1])*( _double(rv2[1]) - _double(rv1[1]))/g);     
        JJ2.push_back(<a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>(_double(d[1])*(_double(rv2[1]) - _double(rv1[1]))/g, 2));
        <span class="comment">//cout &lt;&lt; &quot;JJ: &quot; &lt;&lt; _double(d[1])*( _double(rv2[1]) - _double(rv1[1]))/g &lt;&lt; endl;</span>
      }     
    }
    
    cout &lt;&lt; <span class="stringliteral">&quot;get gaussian&quot;</span> &lt;&lt; endl;
    vector&lt;double&gt; vecJJNPD;
    vecJJNPD = <a class="code" href="errorfunc_8cpp.shtml#ae767ea3ddeac1e55d74384fe0cd42ecd" title="Gaussian probability density function. Generates normal probability density values corresponding to X...">gaussian</a>(vecJJNPD, JJ,1);
  
    cout &lt;&lt; <span class="stringliteral">&quot;get cphi &quot;</span> &lt;&lt; endl;
    vector&lt;double&gt; CPhi;
     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; vecJJNPD.size(); i++) {
      rvector thisrv(1);
      thisrv = CC[i];
      CPhi.push_back(_double(thisrv[1])*vecJJNPD[i]);
    }
      
    cout &lt;&lt; <span class="stringliteral">&quot;get psi &quot;</span> &lt;&lt; endl;
    <span class="keywordflow">if</span>  (r == 2) {       
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; JJ2.size(); i++) {        
        myPsi += ( JJ2[i] - 1) * CPhi[i];
      }     
      myPsi *= c;
  <span class="comment">//    cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; &quot;\tmyPsi: &quot; &lt;&lt; myPsi &lt;&lt; endl; </span>
    } <span class="comment">// end of if r = 2</span>
     
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r == 4) {      
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; JJ2.size(); i++) {
        <span class="keywordtype">double</span> JJ4 = JJ2[i] * JJ2[i];
        myPsi += (JJ4 - 6*JJ2[i] + 3) * CPhi[i];
      }     
      myPsi *= c;
  <span class="comment">//    cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; &quot;\tmyPsi: &quot; &lt;&lt; myPsi &lt;&lt; endl; </span>
    } <span class="comment">// end of r = 4</span>
     
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r == 6) {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; JJ2.size(); i++) {
        <span class="keywordtype">double</span> JJ4 = JJ2[i] * JJ2[i];
        <span class="keywordtype">double</span> JJ6 = JJ4 * JJ2[i];
        myPsi += (JJ6 - 15*JJ4 + 45*JJ2[i] - 15) * CPhi[i];
      }     
      myPsi *= c;
    <span class="comment">//  cout &lt;&lt; &quot;r=&quot; &lt;&lt; r &lt;&lt; &quot;\tmyPsi: &quot; &lt;&lt; myPsi &lt;&lt; endl; </span>
    } <span class="comment">// end of r =6 </span>
    
    <span class="keywordflow">else</span> {
        cout &lt;&lt; <span class="stringliteral">&quot;Error: Input r for Function PSI must be 2, 4 or 6.&quot;</span> &lt;&lt; endl;
      }    
   } <span class="comment">// end of n &gt;= 1000    </span>
    
    <span class="keywordflow">return</span> myPsi;
  } <span class="comment">// end of function psi</span>
</pre></div>
</div>
</div>
<a class="anchor" id="ad7abf0d6b473ad78b1737a9e972395c2"></a><!-- doxytag: member="errorfunc.hpp::riemannTerm" ref="ad7abf0d6b473ad78b1737a9e972395c2" args="(pfcn f, interval X, int Deg, vector&lt; double &gt; &amp;W, vector&lt; double &gt; &amp;M, vector&lt; double &gt; &amp;S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">interval <a class="el" href="errorfunc_8hpp.shtml#ad7abf0d6b473ad78b1737a9e972395c2">riemannTerm</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#aeac7a36a4f16518672428778c5db67dc">pfcn</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Deg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l01462">1462</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00815">taylor::pow()</a>, and <a class="el" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable()</a>.</p>

<p>Referenced by <a class="el" href="errorfunc_8cpp_source.shtml#l01485">integrate()</a>.</p>
<div class="fragment"><pre class="fragment">                                              {
  
  interval Mid = interval(mid(X));

  <span class="comment">// Taylor series...</span>
  <span class="comment">// cout &lt;&lt; &quot;taylor series:&quot; &lt;&lt; endl;</span>
  <a class="code" href="classitaylor.shtml">itaylor</a> fx  = <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>(<a class="code" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable</a>(Mid, Deg), W, M, S);
  interval sum = fx[0]*(diam(X))/2;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 2; k &lt;= Deg; k += 2) 
   { sum += fx[k]*<a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((diam(X))/2, k + 1)/(k + 1); }

  <span class="comment">// Remainder term...</span>
  <span class="comment">// cout &lt;&lt; &quot;remainder term: &quot; &lt;&lt; endl;</span>
  <a class="code" href="classitaylor.shtml">itaylor</a> Fx  = <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>(<a class="code" href="classitaylor.shtml#a2c8074fdc97258d6581ce18a6d76d8d8">itaylor::variable</a>(X, Deg), W, M, S);
  <span class="comment">//cout &lt;&lt; &quot;Fx: &quot; &lt;&lt; Fx &lt;&lt; endl;</span>
  interval eps = abs(Fx[Deg] - fx[Deg]); 
  <span class="comment">//cout &lt;&lt; &quot;eps: &quot; &lt;&lt; eps &lt;&lt; endl;</span>
  sum += interval(-1.0*Sup(eps), Sup(eps))*<a class="code" href="namespacetaylor.shtml#a769606a4634cc75e25da1a652cf19b14">pow</a>((diam(X))/2, Deg + 1)/(Deg + 1); 

  <span class="keywordflow">return</span> 2*sum;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a77af86554abcee2e013b9d8631ed4c5f"></a><!-- doxytag: member="errorfunc.hpp::RosenOP" ref="a77af86554abcee2e013b9d8631ed4c5f" args="(d2tv X, interval fhat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="errorfunc_8hpp.shtml#ac90353a98ada0c22146b3ea9f0ac7a4d">d2t</a> <a class="el" href="errorfunc_8hpp.shtml#a77af86554abcee2e013b9d8631ed4c5f">RosenOP</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="errorfunc_8hpp.shtml#a40f7b267e7bca7091a0d4b941ebe3495">d2tv</a>&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">interval&#160;</td>
          <td class="paramname"><em>fhat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IAE for a Rosenbrock 2D. </p>
<p>The integral of the absolute error for a Rosenbrock 2D. </p>

<p>Definition at line <a class="el" href="errorfunc_8cpp_source.shtml#l00129">129</a> of file <a class="el" href="errorfunc_8cpp_source.shtml">errorfunc.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l00923">taylor::exp()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>, <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00018">Height</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00132">taylor::init_const()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l00592">taylor::sqr()</a>, and <a class="el" href="RosenFobj2D_8cpp_source.shtml#l00017">Tinverse</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03408">subpavings::AdaptiveHistogramValidation::getIAE()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03748">subpavings::AdaptiveHistogram::getIAE()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;Calling RosenOP: &quot; &lt;&lt; endl;</span>
  <span class="comment">// Parameters specific to the Rosenbrock 2D target </span>
  real <a class="code" href="RosenFobj2D_8cpp.shtml#aec5c4d9798cfa73539577e4a2206ab1a">Tinverse</a> = 1.0;
  real <a class="code" href="RosenFobj2D_8cpp.shtml#ab0eb64c1a8d085bcf238d947f3fa839f">Height</a> = 100.0;
  
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a> = <a class="code" href="namespacetaylor.shtml#a2d1667d3b5c500795eb06c586d75c309">taylor::init_const</a>(X[1].order(),interval(0.0));
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 2; i++) <span class="comment">//2nd term should be size_k</span>
    {
      f = f + (Height * <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(X[i+1] - <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(X[i])) +
        <a class="code" href="namespacetaylor.shtml#ad814819d656f5760e836bfa130f1d3a4">sqr</a>(X[i] - 1.0));
    }
  f = <a class="code" href="namespacetaylor.shtml#a478ad7631859d3793d8fc867cbd813d6">exp</a> (-(Tinverse * f));

  <span class="comment">//integrand  </span>
  <a class="code" href="classtaylor_1_1dim2taylor.shtml">d2t</a> result = <a class="code" href="namespacetaylor.shtml#a2d1667d3b5c500795eb06c586d75c309">taylor::init_const</a>(X[1].order(),interval(0.0));
  <span class="comment">//split the integrand to get positive values only (absolute values) </span>
  <span class="keywordflow">if</span> ( (Sup(f[0][0]) &lt; Inf(fhat)) ) {   
    result = fhat - <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>;
    <span class="comment">//cout &lt;&lt; &quot;fhat - f: &quot; &lt;&lt; result[0][0] &lt;&lt; &quot;\n&quot; &lt;&lt; endl;</span>
  }  
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((Sup(f[0][0]) &gt; Inf(fhat))) { 
     result = f - fhat; 
    <span class="comment">//cout &lt;&lt; &quot;f-fhat: &quot; &lt;&lt; result[0][0] &lt;&lt; &quot;\n&quot; &lt;&lt; endl;</span>
  }   
  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="errorfunc_8hpp.shtml">errorfunc.hpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:20 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
