<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: AIAsubpaving.cpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('AIAsubpaving_8cpp.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AIAsubpaving.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> (AISSubPaving) definitions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="AIAsubpaving_8hpp_source.shtml">AIAsubpaving.hpp</a>&quot;</code><br/>
</div>
<p><a href="AIAsubpaving_8cpp_source.shtml">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a545707f4bc32ad5dac67608be229b51d">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6">AIA_BOOL_INTERVAL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a3dadc4f37899578c97e85ec6ea73b724">operator&lt;=</a> (const ivector &amp;z, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> X)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, int comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7">ReUnite</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> lChild, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> rChild, ivector x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a9bc7ba1f54979fabaf0f0ffeab245234">Sivia</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ac3a2af016d66120f37b7e4b3da564876">AIA_PIBT</a> BoolTest, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, double eps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, double eps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, list&lt; ivector &gt; &amp;evalImages, ivector &amp;hull)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a8713b30834070a586c0b99d9899f9b74">volCompare</a> (const ivector &amp;a, const ivector &amp;b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for comparing ivectors based on volume.  <a href="#a8713b30834070a586c0b99d9899f9b74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a1b1148d30745256482cbc7cca090253d">Regularize</a> (ivector &amp;hull, list&lt; ivector &gt; &amp;ivectorList, double eps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="AIAsubpaving_8cpp.shtml#a6df9f8ffe0d5fbd9ec10bd6954b3b800">ImageSp</a> (<a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a> <a class="el" href="errorfunc_8hpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, <a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> A, double eps)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a> (AISSubPaving) definitions. </p>

<p>Definition in file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae77e1251191663a8f7eb8043cc1b3774"></a><!-- doxytag: member="AIAsubpaving.cpp::Evaluate" ref="ae77e1251191663a8f7eb8043cc1b3774" args="(AIA_PIVF f, AIASubPaving A, list&lt; ivector &gt; &amp;evalImages, ivector &amp;hull)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; ivector &gt; &amp;&#160;</td>
          <td class="paramname"><em>evalImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>hull</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to evaluate all the boxes in AIASubPaving. The images of all the boxes are formed and put into a list and the interval hull of the union of all the boxes is formed. Interval hull of a union is implemented under cxsc with | operator. Boxes are expected to have been created by <a class="el" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince()</a>. The argument f is a pointer to an interval vector function AIA_PIVF (which returns an interval vector). AIASubPaving A is the AIASubPaving to be evaluated (should be const - it is not changed in this function). evalImages is the current list of images to be added to in the function call, hull is an ivector hull of images currently in the list which may be altered in this call if an image is added to list </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">365</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="errorfunc_8cpp_source.shtml#l01529">f()</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="spalgorithms_8cpp_source.shtml#l00174">subpavings::Evaluate()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00214">subpavings::ImageSp()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00491">ImageSp()</a>, and <a class="el" href="spalgorithms_8cpp_source.shtml#l00263">subpavings::ImageSpNonMinimal()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (A!=NULL &amp;&amp; IsLeaf(A))
  {
    <span class="comment">// make an ivector image using the AIA_PIVF function f on Box(A)</span>
    ivector image = <a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>(Box(A));

    <span class="comment">// if no images in image set yet, make hull the image</span>
    <span class="keywordflow">if</span> (evalImages.size() == 0) hull = image;
    <span class="comment">// if there are images in the image set, hull is the convex hull of</span>
    <span class="keywordflow">else</span> hull = (hull | image);
    <span class="comment">// the current hull and the ivector image from f(Box(A))</span>

    <span class="comment">// add the image to the list of images</span>
    evalImages.push_back(image);

  }                 <span class="comment">// end of is a leaf</span>

  <span class="comment">// if not a leaf, recursively call Evaluate on children</span>
  <span class="keywordflow">if</span> (A!=NULL &amp;&amp; !IsLeaf(A))
  {

    <a class="code" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>, evalImages, hull);
    <a class="code" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>, evalImages, hull);

  }                 <span class="comment">// end of if is not a leaf</span>

  <span class="comment">// case where A == NULL does nothing, just returns</span>
  <span class="keywordflow">return</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa3ceca06b6916b5ac1382a5aa8bf56aa"></a><!-- doxytag: member="AIAsubpaving.cpp::Expand" ref="aa3ceca06b6916b5ac1382a5aa8bf56aa" args="(AIASubPaving A, int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="AIAsubpaving_8cpp.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a pointer to the node to be expanded. </td></tr>
    <tr><td class="paramname">comp</td><td>is the dimension to split along. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">227</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">subpavings::Mince()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">subpavings::Sivia()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">Sivia()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// comp argument is passed to Upper() and Lower()</span>
  <span class="comment">// these functions split the box normal to direction set by comp</span>

  <span class="keywordflow">if</span> (!IsLeaf(A)) <span class="keywordflow">return</span>;
  ivector lC,rC;
  <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(Box(A),lC,comp); <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(Box(A), rC, comp);
  A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a> = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(lC);
  A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a> = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(rC);
  <span class="comment">//A-&gt;leftChild = new AIASPnode(Lower(Box(A),comp));</span>
  <span class="comment">//A-&gt;rightChild = new AIASPnode(Upper(Box(A),comp));</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6df9f8ffe0d5fbd9ec10bd6954b3b800"></a><!-- doxytag: member="AIAsubpaving.cpp::ImageSp" ref="a6df9f8ffe0d5fbd9ec10bd6954b3b800" args="(AIA_PIVF f, AIASubPaving A, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classsubpavings_1_1SPnode.shtml#a5e79ff65a692b09c98ff53264ddfba9f">ImageSp</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#aee443215927e43ef8f6880f25b053a2e">AIA_PIVF</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal regular subpaving coveringing the image of A under some function f </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>a (*AIA_PIVF) which specifies the inclusion function of f and returns the inclusion function image [f][x] of an interval vector [x] </td></tr>
    <tr><td class="paramname">A</td><td>the subpaving for which we wish to find a subpaving covering the image under f </td></tr>
    <tr><td class="paramname">eps</td><td>the precision with which the returned subpaving should be formed ImageSp uses <a class="el" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince()</a> to chop up A and then <a class="el" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate()</a> and <a class="el" href="AIAsubpaving_8cpp.shtml#a1b1148d30745256482cbc7cca090253d">Regularize()</a> to find a regular minimal subpaving covering the set of images of the boxes of the minced A. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00491">491</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00365">Evaluate()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">Mince()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">Regularize()</a>.</p>

<p>Referenced by <a class="el" href="Exm__3__3_8cpp_source.shtml#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  list&lt;ivector&gt; images;
  ivector hull;

  <a class="code" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a>(A, eps);

  <span class="comment">//cout &lt;&lt; &quot;After mince &quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;A has volume  &quot; &lt;&lt; Volume (A) &lt;&lt; &quot; and number of leaves &quot;</span>
  <span class="comment">//  &lt;&lt; NbLeaves(A) &lt;&lt; endl;</span>

  <a class="code" href="AIAsubpaving_8cpp.shtml#ae77e1251191663a8f7eb8043cc1b3774">Evaluate</a>(<a class="code" href="errorfunc_8cpp.shtml#aacb77b1211a6ca2e2beff1811cf9ecf4">f</a>, A, images, hull);

  <span class="comment">//cout &lt;&lt; &quot;After evaluate &quot; &lt;&lt; endl;</span>
  <span class="comment">//cout &lt;&lt; &quot;Size of image list is : &quot; &lt;&lt; images.size()</span>
  <span class="comment">//  &lt;&lt; &quot;  and hull has volume &quot; &lt;&lt; Volume(hull) &lt;&lt; endl;</span>

  <span class="comment">/* the output of eval is not included in the AIA examples, but it makes</span>
<span class="comment">  an interesting comparison to the final subpaving */</span>
  <span class="comment">// Filename</span>
  ofstream os2(<span class="stringliteral">&quot;eval.txt&quot;</span>);
  list&lt;ivector&gt;::iterator it;
  <span class="keywordflow">for</span> (it=images.begin(); it!=images.end(); it++)
  {
    ivector box = *it;
    os2 &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(box[1]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(box[1]) &lt;&lt; <span class="stringliteral">&quot; ] , [ &quot;</span>
      &lt;&lt; Inf(box[2]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(box[2]) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span> &lt;&lt;  endl;
  }
  <span class="comment">// end of difference from AIA examples</span>

  <span class="keywordflow">return</span> (<a class="code" href="AIAsubpaving_8cpp.shtml#a1b1148d30745256482cbc7cca090253d">Regularize</a>(hull, images, eps));

}
</pre></div>
</div>
</div>
<a class="anchor" id="ab7921c5bd80f01985ee134c5d2ab595d"></a><!-- doxytag: member="AIAsubpaving.cpp::Mince" ref="ab7921c5bd80f01985ee134c5d2ab595d" args="(AIASubPaving A, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mince transforms a minimal AIASubPaving into a non-minimal AIASubPaving, ie may have sibling leaves. Any leaf AIASubPaving with a box with diameter greater than eps will be expanded. Mince will keep mincing until every leaf AIASubPaving has a box with diameter &lt; eps </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00331">331</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="spalgorithms_8cpp_source.shtml#l00214">subpavings::ImageSp()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00491">ImageSp()</a>, <a class="el" href="spalgorithms_8cpp_source.shtml#l00263">subpavings::ImageSpNonMinimal()</a>, and <a class="el" href="spalgorithms_8cpp_source.shtml#l00053">subpavings::Mince()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (IsEmpty(A)) <span class="keywordflow">return</span>;

  <span class="keywordflow">if</span> (IsLeaf(A))
  {
    <span class="keywordtype">int</span> comp;       <span class="comment">// value is given by calling MaxDiam function below</span>

    <span class="comment">// if leaf and box smaller than eps then return</span>
    <span class="keywordflow">if</span>(<a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(Box(A),comp)&lt;eps) <span class="keywordflow">return</span>;

    <span class="comment">// if leaf and box not smaller than eps then expand</span>
    <a class="code" href="AIAsubpaving_8cpp.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a>(A,comp);

  }                 <span class="comment">// end if a leaf</span>

  <span class="comment">// not a leaf, recurse Mince() on left and right children</span>
  <a class="code" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a>(A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>,eps);
  <a class="code" href="AIAsubpaving_8cpp.shtml#ab7921c5bd80f01985ee134c5d2ab595d">Mince</a>(A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>,eps);

}
</pre></div>
</div>
</div>
<a class="anchor" id="a6cc4fba2aef7df53e990c5348f84bd3b"></a><!-- doxytag: member="AIAsubpaving.cpp::NbLeaves" ref="a6cc4fba2aef7df53e990c5348f84bd3b" args="(AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00061">61</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="Exm__3__3_8cpp_source.shtml#l00074">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> nbleaves=0;

  <span class="keywordflow">if</span> (IsEmpty(a)) <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (IsLeaf(a))  <span class="keywordflow">return</span> 1;

  nbleaves += <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>);
  nbleaves += <a class="code" href="AIAsubpaving_8cpp.shtml#a6cc4fba2aef7df53e990c5348f84bd3b">NbLeaves</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>);

  <span class="keywordflow">return</span> (nbleaves);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a545707f4bc32ad5dac67608be229b51d"></a><!-- doxytag: member="AIAsubpaving.cpp::operator&lt;&lt;" ref="a545707f4bc32ad5dac67608be229b51d" args="(std::ostream &amp;os, AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This output format is not the same as used in the example code provided for [AIA2001], but is adapted for easy reading and rendering in Matlab. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00040">40</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00086">AIASPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (a==NULL) <span class="keywordflow">return</span> os;

  <span class="comment">//if (IsLeaf(a)) os &lt;&lt; (*(a-&gt;theBox)) &lt;&lt; std::endl;</span>
  <span class="comment">//output for Jenny&#39;s matlab format, dimension = 2 max</span>
  <span class="keywordflow">if</span> (IsLeaf(a))
  {
    ivector x = *(a-&gt;<a class="code" href="classAIASPnode.shtml#ab904c07918618a89d5511fbaf87f5143" title="The interval vector the node represents.">theBox</a>);
    os &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(x[1]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(x[1]) &lt;&lt; <span class="stringliteral">&quot; ] , &quot;</span>
      &lt;&lt; <span class="stringliteral">&quot;[ &quot;</span> &lt;&lt; Inf(x[2]) &lt;&lt; <span class="stringliteral">&quot; , &quot;</span> &lt;&lt; Sup(x[2]) &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span>   &lt;&lt; std::endl;
  }
  <span class="keywordflow">else</span>
    { os &lt;&lt; (a-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>); os &lt;&lt; (a-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>); }

    <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3dadc4f37899578c97e85ec6ea73b724"></a><!-- doxytag: member="AIAsubpaving.cpp::operator&lt;=" ref="a3dadc4f37899578c97e85ec6ea73b724" args="(const ivector &amp;z, AIASubPaving X)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6">AIA_BOOL_INTERVAL</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00098">98</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00038">BI_FALSE</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00038">BI_INDET</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00038">BI_TRUE</a>, <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// z is assumed not to be empty</span>
  <span class="comment">// note that Intersection() gives an error if unequal index sets passed</span>

  <span class="keywordflow">if</span> (IsEmpty(X)) <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;

  ivector r;        <span class="comment">// ivector to be passed to Intersection()</span>
  <span class="comment">// to contain the intersection</span>

  <span class="comment">// check if X is a leaf and if so</span>
  <span class="keywordflow">if</span> (IsLeaf(X))
  {
    <span class="comment">// *************** old code</span>
    <span class="comment">//if (z&lt;=Box(X)) return BI_TRUE;</span>
    <span class="comment">//if (!Intersection(r,z,Box(X))) return BI_FALSE;</span>
    <span class="comment">// what if Intersection() returns 1, ie there is an intersection</span>
    <span class="comment">// but z&lt;=Box(X) is not true?</span>
    <span class="comment">// at present this goes down to the default (else) case below</span>

    <span class="comment">//**************** replacement code</span>
    <span class="keywordflow">if</span> (z&lt;=Box(X))
                    <span class="comment">// true if z is in the box</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(r,z,Box(X)))
                    <span class="comment">// false if there is no intersection between z and the box</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="keywordflow">else</span>          <span class="comment">// z is not contained in the box but there is an intersection</span>
                  <span class="comment">// so result is indeterminate</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;
  }                 <span class="comment">// end isLeaf()</span>

  <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> Ltest=<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>,Rtest=<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a>;

  ivector Lz,Rz;    <span class="comment">// ivectors to be passed to Intersection()</span>
  <span class="comment">// will contain intersection after call to Intersection()</span>

                    <span class="comment">// both children exist</span>
  <span class="keywordflow">if</span> (!IsEmpty(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>)&amp;&amp;!IsEmpty(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>))
  {

                    <span class="comment">// intersection with left child</span>
    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Lz,z,Box(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>)))
      <span class="comment">// Lz now contains this intersection</span>
    {
                    <span class="comment">// compare Lz and left child</span>
      Ltest = (Lz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>));

                    <span class="comment">//check intersection with right child</span>
      <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz,z,Box(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>)))
      {
                    <span class="comment">// compare Rz and right child</span>
        Rtest = (Rz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>));
                    <span class="comment">// if left and right child tests same</span>
        <span class="keywordflow">if</span> (Ltest==Rtest)
                    <span class="comment">// return this result from child tests</span>
          <span class="keywordflow">return</span> Ltest;
        <span class="keywordflow">else</span>
                    <span class="comment">// z overlaps the boundary of X</span>
          <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;
      }
      <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> Ltest;
    }               <span class="comment">// end if intersection with left child</span>

                    <span class="comment">// given no intersection with left child</span>
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz,z,Box(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>)))
                    <span class="comment">// check intersection with right child</span>
                    <span class="comment">// compare Rz and right child</span>
      <span class="keywordflow">return</span> (Rz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>));

    <span class="keywordflow">else</span>            <span class="comment">// no intersection with either child</span>
                    <span class="comment">// used to be BI_TRUE here from the AIA website</span>
        <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="comment">// but this cannot possibly be correct!</span>
  }                 <span class="comment">// end if both children exist</span>

                    <span class="comment">// only left child exists</span>
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!IsEmpty(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>))
  {
                    <span class="comment">// no intersection with left child</span>
    <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Lz,z,Box(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>)))
      <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="comment">// there is an intersection with the left child, this intersection now in Lz</span>
                    <span class="comment">// compare Lz and the left child</span>
    Ltest = (Lz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>));
    <span class="comment">// Rtest will still be at default value of TRUE</span>

                    <span class="comment">// if left child intersection with z is not z</span>
    <span class="keywordflow">if</span> (!(Lz==z)) Rtest = <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="keywordflow">else</span>            <span class="comment">// if left child intersection with z = z</span>
      <span class="keywordflow">return</span> Ltest; <span class="comment">// ie is whole of z in left child</span>
  }                 <span class="comment">// end if  only left child exists</span>

  <span class="keywordflow">else</span>              <span class="comment">// if is not a leaf, only right child exists</span>
  <span class="comment">// BUT if it is a leaf and there is an intersection but not full containment?</span>
  <span class="comment">// I have now replaced the code that gave rise to the latter case</span>
  {
                    <span class="comment">// no intersection with right child</span>
    <span class="keywordflow">if</span> (!<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(Rz,z,Box(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>)))
      <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="comment">//there is an intersection with the right child, this intersection now in Rz</span>
                    <span class="comment">// compare Rz and right child</span>
    Rtest = (Rz&lt;=(X-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>));
    <span class="comment">// Ltest will still be at default value of TRUE</span>
                    <span class="comment">// if right child intersection with z is not z</span>
    <span class="keywordflow">if</span> (!(Rz==z)) Ltest = <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a>;
    <span class="keywordflow">else</span>            <span class="comment">// if right child intersection with z = z</span>
      <span class="keywordflow">return</span> Rtest; <span class="comment">// ie is whole of z in right child</span>
  }                 <span class="comment">// end if only right child exists</span>

  <span class="comment">// only get here if only one child (left or right exists)</span>
  <span class="comment">// and the intersection of that child with z exists but is not z</span>
  <span class="comment">// in which case the other test will have been set to FALSE?</span>
  <span class="comment">// or if is a leaf and both Intersection() returns 1 but z&lt;=Box(X) is not 1</span>
  <span class="comment">// in which case Ltest and Rtest will both be TRUE? - that code now replaced</span>

  <span class="keywordflow">if</span> (Ltest==Rtest)
    <span class="keywordflow">return</span> Ltest;
  <span class="keywordflow">else</span>
    <span class="comment">// if only one child, and the whole of z is not in that child but</span>
    <span class="comment">// the intersection of z with that child is inside the child</span>
    <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6aa43b2bfa91b022f8aa5c08a522eb4fce">BI_INDET</a>;<span class="comment">// z overlaps the boundary of X</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1b1148d30745256482cbc7cca090253d"></a><!-- doxytag: member="AIAsubpaving.cpp::Regularize" ref="a1b1148d30745256482cbc7cca090253d" args="(ivector &amp;hull, list&lt; ivector &gt; &amp;ivectorList, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="AIAsubpaving_8cpp.shtml#a1b1148d30745256482cbc7cca090253d">Regularize</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; ivector &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivectorList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Regularize creates an AIASubPaving from all the ivectors in the ivectorList. The root of the AIASubPaving will have Box = hull where hull has already been formed from the union of all the ivectors in the ivectorList. Regularize is applied recursively on bisected half of hull and new lists until either there are no images in the list or the diameter of the hull is below eps. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">427</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="toolz_8cpp_source.shtml#l00203">Intersection()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00247">ReUnite()</a>, <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00397">AIASPnode::volCompare()</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00491">ImageSp()</a>.</p>
<div class="fragment"><pre class="fragment">{
                    <span class="comment">// return NULL if the list is empty</span>
  <span class="keywordflow">if</span> (ivectorList.size()==0) <span class="keywordflow">return</span> NULL;

  <span class="comment">// sort the list</span>
  <span class="comment">// Jaulin et al do not have this step because they have their own IMAGELIST</span>
  <span class="comment">// class which acts like a set and keeps the contents in order.  But we are</span>
  <span class="comment">// using the stl std::list and so it is unsorted when it is passed to</span>
  <span class="comment">// Regularize.  It is more effient to sort it once per call to Regularise</span>
  <span class="comment">// than to keep it sorted as it is being built because the sorted order is</span>
  <span class="comment">// only needed when the entire list has been built</span>

  <span class="comment">// sort using the volCompare function</span>
  ivectorList.sort(<a class="code" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74" title="Compare volumes of two boxes.">volCompare</a>);
  <span class="comment">// this sorts smallest to largest (the opposite to Jaulin et al)</span>

  <span class="comment">// if the hull is equal to the last (largest) box in the list,</span>
  <span class="comment">// this becomes the AIASubPaving</span>
  <span class="keywordflow">if</span> (hull==(*ivectorList.rbegin())) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(hull);

  <span class="comment">// un-valued int to take value for larged dimension calculated from MaxDiam</span>
  <span class="keywordtype">int</span> maxdiamcomp;

  <span class="comment">//if the current maximum diameter is &lt; eps return a new AIASubPaving from hull</span>
  <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(hull,maxdiamcomp)&lt;eps) <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(hull);

  <span class="comment">// new ivectors from splitting hull in its biggest dimension</span>
  ivector lefthull = <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(hull,maxdiamcomp);
  ivector righthull = <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(hull,maxdiamcomp);

  <span class="comment">// create two empty lists</span>
  list&lt;ivector&gt; leftlist,rightlist;

  <span class="comment">// iterator to for the list</span>
  list&lt;ivector&gt;::iterator it;

  <span class="comment">// iterate through the current list and put the intersection of any element</span>
  <span class="comment">// with the lefthull into the new left list, and the intersection of any</span>
  <span class="comment">// element with new right hull into the new rightlist.</span>
  <span class="keywordflow">for</span> (it=ivectorList.begin(); it!=ivectorList.end(); it++)
  {
    <span class="comment">// temporary variables to take the results of call in Intersect</span>
    ivector interLeft, interRight;

    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interLeft, *it, lefthull))
    {
      leftlist.push_back(interLeft);
    }

    <span class="keywordflow">if</span> (<a class="code" href="toolz_8cpp.shtml#a4b95fc9f126441c04e5b773e5fe56533" title="Compute the intersection interval r of interval a and interval b.">Intersection</a>(interRight, *it, righthull))
    {
      rightlist.push_back(interRight);
    }

  }  <span class="comment">// end of iteration through list elements</span>

  <span class="comment">// recursively call Regularize with lefthull, leftlist, righthull, rightlist</span>
  <span class="comment">// reunite the results using hull as the box for the parent node</span>
  <span class="comment">// Regularize creates a minimal AIASubPaving (no sibling child nodes)</span>
  <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8cpp.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7">ReUnite</a>(<a class="code" href="AIAsubpaving_8cpp.shtml#a1b1148d30745256482cbc7cca090253d">Regularize</a>(lefthull,leftlist,eps),
    <a class="code" href="AIAsubpaving_8cpp.shtml#a1b1148d30745256482cbc7cca090253d">Regularize</a>(righthull,rightlist,eps),hull);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad0b3998c79d0cbf91d21c550a6bb72e7"></a><!-- doxytag: member="AIAsubpaving.cpp::ReUnite" ref="ad0b3998c79d0cbf91d21c550a6bb72e7" args="(AIASubPaving lChild, AIASubPaving rChild, ivector x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="AIAsubpaving_8cpp.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7">ReUnite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>rChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ivector&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If two potential children are provided and they are both leaves, then Reunite combines the two leaf siblings into this. If the potential children are not leaves or if only one potential child is provided, grafts the potential child/children onto this as its child/children.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a minimal subpaving from two sibling subpavings </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lChild</td><td>a pointer to the leftChild node to be reunited </td></tr>
    <tr><td class="paramname">rChild</td><td>a pointer to the rightChild node to be reunited </td></tr>
    <tr><td class="paramname">x</td><td>is the box of the new subpaving to be returned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00247">247</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00427">Regularize()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">Sivia()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span>(IsEmpty(lChild)&amp;&amp;IsEmpty(rChild)) <span class="keywordflow">return</span> NULL;
  <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASubPaving</a> result = <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(x);
  <span class="comment">// both AIASubPavings are leaves so discard them: new AIASubPaving is a leaf</span>
  <span class="keywordflow">if</span>( IsLeaf(lChild)
    &amp;&amp;IsLeaf(rChild)
    &amp;&amp;(  x == ( Box(lChild) | Box(rChild) )  )
    )
    { <span class="keyword">delete</span> lChild; <span class="keyword">delete</span> rChild; <span class="keywordflow">return</span> result; }

    <span class="comment">// if there are not two non-null potential children</span>
    <span class="comment">// (so presumably just one child), just graft it on</span>
    <span class="comment">// similarly if at least one child is not a leaf, just graft the potential</span>
    <span class="comment">// children on</span>
    result-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a> = lChild; result-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a> = rChild;

  <span class="keywordflow">return</span> result;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9bc7ba1f54979fabaf0f0ffeab245234"></a><!-- doxytag: member="AIAsubpaving.cpp::Sivia" ref="a9bc7ba1f54979fabaf0f0ffeab245234" args="(AIA_PIBT BoolTest, AIASubPaving A, double eps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a> <a class="el" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93">Sivia</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ac3a2af016d66120f37b7e4b3da564876">AIA_PIBT</a>&#160;</td>
          <td class="paramname"><em>BoolTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set Inversion Via Interval Analysis method taken from AIA2001. Sivia gives an AIASubPaving which is based on the reciprocal image X of some function. Note that in this implementation, we get the outer AIASubPaving of a two, (lowerX and UpperX) such that lowerX is in X is in upperX The AIA_PIBT points to a function wich specifies the function for which we want the reciprocal image and the AIASubPaving Y which should contain the reciprocal image. The AIA_PIBT function evaluates whether the image of some box (ivector) is in Y. The AIA_PIBT can return BI_TRUE, BI_FALSE, or BI_INDET (box partly in Y but not totally). If the AIASubPaving box tests BI_INDET and the box diameter is sufficiently small then it is given the benefit of the doubt and included in upperX. Otherwise if the AIA_PIBT function returns BI_INDET then the AIASubPaving is expanded, ie two AIASubPaving children created, and these AIASubPaving children are then tested. The argument A is an AIASubPaving. On the first pass through SIVIA, A should have a box which is guaranteed to contain upperX; this AIASubPaving is progressively refined. The argument eps specifies the 'sufficiently small' width for a box to be included in upperX... </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00288">288</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00038">BI_FALSE</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00038">BI_TRUE</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00227">Expand()</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00247">ReUnite()</a>, <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>, and <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">subpavings::SPnode::Sivia()</a>.</p>

<p>Referenced by <a class="el" href="Exm__3__3_8cpp_source.shtml#l00074">main()</a>, and <a class="el" href="spalgorithms_8cpp_source.shtml#l00097">subpavings::Sivia()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (A==NULL) <span class="keywordflow">return</span> NULL;

                    <span class="comment">// test the box of the given AIASubPaving</span>
  <a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6" title="Define type &quot;Interval Booleans&quot; This is used to extend the usual booleans TRUE and FALSE for use with...">AIA_BOOL_INTERVAL</a> test = BoolTest(Box(A));
  <span class="comment">// Test function (may be passed as parameter to Sivia)</span>

  <span class="comment">// maxdiamcomp will be given a value by call to MaxDiam() below</span>
  <span class="keywordtype">int</span> maxdiamcomp;

  <span class="comment">// the box fails the test</span>
  <span class="keywordflow">if</span> ( test==<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a57a124e19ed919ea8c7a944c309d7636">BI_FALSE</a> ) <span class="keywordflow">return</span> NULL;

  <span class="comment">// if the box passes or the result is BI_INDET but the maximum diameter of</span>
  <span class="comment">// the box is small enough, then return a new AIASubPaving which is a copy of</span>
  <span class="comment">// the current one, ie include this AIASubPaving in outerX, our approximation</span>
  <span class="comment">// of X the reciprocal image</span>
  <span class="keywordflow">if</span> (test==<a class="code" href="AIAsubpaving_8hpp.shtml#a04a5da87f7c1570d6ef4843fb476d1a6a966ca7244fcb98834f2b3afbb5d32ac2">BI_TRUE</a> || <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">MaxDiam</a>(Box(A),maxdiamcomp)&lt;eps)
    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classAIASPnode.shtml" title="AIASubPaving node class.">AIASPnode</a>(*A);

  <span class="comment">// SIVIA will only reach this point if the result of the test was BI_INDET</span>
  <span class="comment">// and the maximum diameter of the box is not small enough for the box to be</span>
  <span class="comment">// in outerX -- in this case we expand the AIASubPaving by giving it child</span>
  <span class="comment">// nodes and test them</span>
  <span class="keywordflow">if</span> (IsLeaf(A)) <a class="code" href="AIAsubpaving_8cpp.shtml#aa3ceca06b6916b5ac1382a5aa8bf56aa">Expand</a>(A,maxdiamcomp);

  <span class="comment">// ReUnite is used to get a minimal AIASubPaving from merging two</span>
  <span class="comment">// AIASubPavings.  So will ensure that the AIASubPaving we return from Sivia</span>
  <span class="comment">// is minimal, ie will not have sibling leaves</span>
  <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8cpp.shtml#ad0b3998c79d0cbf91d21c550a6bb72e7">ReUnite</a>( <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(BoolTest,A-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>,eps),
    <a class="code" href="classsubpavings_1_1SPnode.shtml#ace7e46329dbdb96110f7f24bba46ee93" title="Set Inversion Via Interval Analysis.">Sivia</a>(BoolTest,A-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>,eps),
    Box(A));

}
</pre></div>
</div>
</div>
<a class="anchor" id="a8713b30834070a586c0b99d9899f9b74"></a><!-- doxytag: member="AIAsubpaving.cpp::volCompare" ref="a8713b30834070a586c0b99d9899f9b74" args="(const ivector &amp;a, const ivector &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAIASPnode.shtml#a8713b30834070a586c0b99d9899f9b74">volCompare</a> </td>
          <td>(</td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ivector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A function for comparing ivectors based on volume. </p>
<p>Used in sorting a list of ivectors ordered by volume.</p>
<p>Uses <a class="el" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume()</a> as defined in toolz. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the Volume of a is strictly less than Volume of b. </dd></dl>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00397">397</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="spnode_8cpp_source.shtml#l02032">subpavings::SPnode::makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">subpavings::SPnode::makeTreeFromVoxels()</a>, <a class="el" href="sptemplates_8hpp_source.shtml#l00184">subpavings::Regularize()</a>, and <a class="el" href="sptemplates_8hpp_source.shtml#l00309">subpavings::RegularizeNonMinimal()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> returnValue = 0;

  <span class="comment">// Make sure the vectors have the same number of elements and at</span>
  <span class="comment">// least one element each</span>
  <span class="keywordflow">if</span>( (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(a) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(a)) == (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(b) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(b)) &amp;&amp; (<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(a) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(a))&gt;=1 )
  {

                    <span class="comment">// compare the two volumes</span>
    returnValue = ((<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(a)&lt;<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(b)));

  }
  <span class="keywordflow">else</span>
  {
    std::cout
      &lt;&lt; <span class="stringliteral">&quot;Error in volCompare : comparing ivectors of different dimensions&quot;</span>
      &lt;&lt; std::endl;
  }

  <span class="keywordflow">return</span> returnValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7f6354ab5e7b1310b03f0e190169eabe"></a><!-- doxytag: member="AIAsubpaving.cpp::Volume" ref="a7f6354ab5e7b1310b03f0e190169eabe" args="(AIASubPaving a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="toolz_8hpp.shtml#ae06411dd54912b039475819875c13ecb">Volume</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AIAsubpaving_8hpp.shtml#ab6618d8727b32e897c1b7ab3415b93ff">AIASubPaving</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sums the volumes of the leaves of the AIASubPaving. </p>

<p>Definition at line <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">77</a> of file <a class="el" href="AIAsubpaving_8cpp_source.shtml">AIAsubpaving.cpp</a>.</p>

<p>References <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00088">AIASPnode::leftChild</a>, and <a class="el" href="AIAsubpaving_8hpp_source.shtml#l00090">AIASPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">subpavings::CollatorSPnode::_marginalise()</a>, <a class="el" href="errorfunc_8cpp_source.shtml#l01286">getRegHistUnifIAE()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l01271">subpavings::AdaptiveHistogramCollator::getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l03435">subpavings::AdaptiveHistogramValidation::getUnifIAE()</a>, <a class="el" href="adaptivehistogram_8cpp_source.shtml#l03774">subpavings::AdaptiveHistogram::getUnifIAE()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l04264">getUnifTrueDelta()</a>, <a class="el" href="Exm__3__3_8cpp_source.shtml#l00074">main()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02032">subpavings::SPnode::makeTreeFromLeaves()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01851">subpavings::SPnode::makeTreeFromVoxels()</a>, <a class="el" href="MRSampler_8cpp_source.shtml#l00235">MRSampler::MRSoutput()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="sptools_8cpp_source.shtml#l00450">subpavings::volCompare()</a>, <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00397">volCompare()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01827">subpavings::SPnode::volDifference()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01725">subpavings::SPnode::volIntersection()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01641">subpavings::SPnode::volOuterJacket()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l01957">subpavings::SPnode::vtkPaving()</a>.</p>
<div class="fragment"><pre class="fragment">{

  <span class="keywordflow">if</span> (IsEmpty(a)) <span class="keywordflow">return</span> 0.0;
  <span class="keywordflow">if</span> (IsLeaf(a))
  {

                    <span class="comment">// using Volume taking ivector argument</span>
    <span class="keywordflow">return</span> <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(Box(a));
  }
  <span class="keywordtype">double</span> vol=0.0;

  vol += <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#a64dc679fe03b03b7beb6ddb04b2a0f85" title="The node&#39;s left child.">leftChild</a>);
  vol += <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(a-&gt;<a class="code" href="classAIASPnode.shtml#adbaa03014929ff2ab653d6d916ca2fc1" title="The node&#39;s right child.">rightChild</a>);

  <span class="keywordflow">return</span> (vol);
}
</pre></div>
</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="AIAsubpaving_8cpp.shtml">AIAsubpaving.cpp</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:19 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
