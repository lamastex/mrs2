<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::CollatorSPVnode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1CollatorSPVnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::CollatorSPVnode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::CollatorSPVnode" --><!-- doxytag: inherits="subpavings::SPnode" -->
<p>A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for creating summaries.  
 <a href="classsubpavings_1_1CollatorSPVnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="collatorspvnode_8hpp_source.shtml">collatorspvnode.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for subpavings::CollatorSPVnode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1CollatorSPVnode__inherit__graph.png" border="0" usemap="#subpavings_1_1CollatorSPVnode_inherit__map" alt="Inheritance graph"/></div>
<map name="subpavings_1_1CollatorSPVnode_inherit__map" id="subpavings_1_1CollatorSPVnode_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::CollatorSPVnode:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1CollatorSPVnode__coll__graph.png" border="0" usemap="#subpavings_1_1CollatorSPVnode_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1CollatorSPVnode_coll__map" id="subpavings_1_1CollatorSPVnode_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1CollatorSPVnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c">CollatorSPVnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor.  <a href="#afc907faf6fc53e9fdea4c6895e14a42c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a238d7e9e52b2014b97d10903f54df691">CollatorSPVnode</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const spn, int whatSum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalised constructor.  <a href="#a238d7e9e52b2014b97d10903f54df691"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#afefc26f6a3e9ba25ccf69d47dbdf99d7">CollatorSPVnode</a> (ivector &amp;v, int lab, <a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> summ, double Vsumm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#afefc26f6a3e9ba25ccf69d47dbdf99d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaf38d226e1bacab0a109a3525f73cc0">CollatorSPVnode</a> (const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aeaf38d226e1bacab0a109a3525f73cc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ab7123fe7fb187c082d968a8d3be9944d">CollatorSPVnode</a> (const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;other, int toSubtract)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for the subtracted ADHVC.  <a href="#ab7123fe7fb187c082d968a8d3be9944d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a36bedf0d99a2a3e1a0188c24b68c2e18">operator=</a> (const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a36bedf0d99a2a3e1a0188c24b68c2e18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0d2a5d445ac27dd3bf81a6f55c4087f">makeAverageCollation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad7fa37be86eb1d964b384a090dc3552f">getSummary</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the summary.  <a href="#ad7fa37be86eb1d964b384a090dc3552f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ac3cc6fb2f09dc7d6d99b52631fc4f60e">getVemp</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the validation summary.  <a href="#ac3cc6fb2f09dc7d6d99b52631fc4f60e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a72f2564ee548571ef026a8548ca0b0ba">getNumberSummarised</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of subpavings summarised.  <a href="#a72f2564ee548571ef026a8548ca0b0ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae996eeb1103aa689f6f64d3db742ce2f">leavesAbsAccumulationMultVol</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sum over leaf nodes of absolute accumulated summary x volume.  <a href="#ae996eeb1103aa689f6f64d3db742ce2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a782737eae50163bbae2dc9c4b5e23aec">nodePrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the details of a specific node.  <a href="#a782737eae50163bbae2dc9c4b5e23aec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a60e3798526abbe3db915b8a9a9d0aa19">leafOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a60e3798526abbe3db915b8a9a9d0aa19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a994d9779baf89f37351656d4d615d340">leafOutputTabs</a> (std::ostream &amp;os, int whichColl) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4">leavesOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a214a7d5e78c28dbad8da0753eebe31f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#af432d9c3c95ad16f40274a0ab35948b8">leavesOutputTabs</a> (std::ostream &amp;os, int whichColl) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad2fe162c253c15b43027ccd44ce9136b">leavesAverageOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#ad2fe162c253c15b43027ccd44ce9136b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a74c11c958cf56fbfff724d464c02f03a">leavesAccumulationOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a74c11c958cf56fbfff724d464c02f03a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a63529191a0b2eb1bc253c5c717fc2965">leavesDifferenceOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae6555e847a720e43c07ad0c56788f9b6">nodeExpand</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand leaf node to make two more leaves as children and copy summary and Vemp down to the children.  <a href="#ae6555e847a720e43c07ad0c56788f9b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a43e370d7120f8cc8c1cde489f61e7fc5">nodeExpand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand leaf node to make two more leaves as children and copy summary and Vemp down to the children.  <a href="#a43e370d7120f8cc8c1cde489f61e7fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#abef4fa1adf9483d78e21350712864fd2">nodesReunite</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reunite nodes to form one leaf.  <a href="#abef4fa1adf9483d78e21350712864fd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a7a6318a53eb8efeecc8ea81244c98859">nodeAdoptLeft</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *lChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes. This adopts a left child rather than attempting to reunite two children into this.  <a href="#a7a6318a53eb8efeecc8ea81244c98859"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a47cfd580379397fa0f713de7306a65c3">nodeAdoptRight</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#a47cfd580379397fa0f713de7306a65c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#af01fff5efb1889862b36606bed10746a">addPavingWithVal</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add paving with Vemp to collation.  <a href="#af01fff5efb1889862b36606bed10746a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a0c7ea11fa66829ec974813779c052c61">nodeNegate</a> (double c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates the summary for every node in tree rooted at this.  <a href="#a0c7ea11fa66829ec974813779c052c61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a2976605178012f7d9b23bca1d7f9beb4">addNegatedPaving</a> (const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const spn, double c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Incorporate negation of a Collator subpaving to this summmary.  <a href="#a2976605178012f7d9b23bca1d7f9beb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae3670805f36e313e7e541d57552d6b34">getSplitNodePtrCSPV</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&amp;splitCollNode, <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> pointer to the corresponding <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> that was split.  <a href="#ae3670805f36e313e7e541d57552d6b34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ab134b9b98ed7b15b1cabb9eca1ced1eb">getScheffeNode</a> (int theta1, int theta2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2, where theta1 &lt; theta2.  <a href="#ab134b9b98ed7b15b1cabb9eca1ced1eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a199762d07823cde9934100fb6d11228c">nodeCheckRowSummary</a> (int theta, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matrix against the columns.  <a href="#a199762d07823cde9934100fb6d11228c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a61360380c921f78c1ac9689ffe004c60">nodeCheckColSummary</a> (int theta, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos matrix against the rows.  <a href="#a61360380c921f78c1ac9689ffe004c60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a1ebdb63b747d9c7a477b6ad86d58b714">getNodeDelta</a> (int thisTheta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the delta value for a specific theta.  <a href="#a1ebdb63b747d9c7a477b6ad86d58b714"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0bdf61f72d586c8944c076e310b3240">getYatSet</a> (std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;YatSetRow, std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;YatSetCol, size_t cand1, size_t cand2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Yatracos set for a particular pair.  <a href="#ad0bdf61f72d586c8944c076e310b3240"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a8d430b2bdfb2d8032e5d7f9e9bddb53d">getScheffeSet</a> (std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;ScheffeSet, size_t cand1, size_t cand2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Scheffe set for a particular pair.  <a href="#a8d430b2bdfb2d8032e5d7f9e9bddb53d"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors for links between the nodes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These accessor methods shadow equivalent methods in the base class. Thus the method used is determined at compile time, not run time as would be the case if virtual methods were used. Because the pointers to parents and children are part of the base class definition, the methods have to cast the base class from to the derived class form in order for the pointer returned to be able to be used with derived class members.</p>
<p>Note that pointers for parent, leftChild, and rightChild are not reference counted so there could potentially be problems with the use of returned pointers (for instance, being used to delete nodes). These pointers might be better implemented with boost::shared_ptr . </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a635b2b0884e6d8fc328e058bd3fadbcc">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the parent of a node.  <a href="#a635b2b0884e6d8fc328e058bd3fadbcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce">getLeftChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the left child of a node.  <a href="#aeaea28b3b2d7ca59a28cd3fbb3438cce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b">getRightChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the right child of a node.  <a href="#aaaa6264c4020a5e0ccfdedb19228fa2b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#af92d7a31e4c7f97661d3e812948a8aee">addPavings</a> (const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two collator subpavings together.  <a href="#af92d7a31e4c7f97661d3e812948a8aee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ab662ab5025178c145b83b386ef475415">subtractPavings</a> (const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const rhs, double c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one collator subpavings from another together.  <a href="#ab662ab5025178c145b83b386ef475415"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a9f0d632933ae94b99777c01fa8d1677e">CollatorSPVnode</a> (const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const spn, size_t bigN, size_t bigM, int whatSum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aac50041302262e7503e68cbd9103aa0b">leafAverageOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#aac50041302262e7503e68cbd9103aa0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a158da654dc12bf34a61950df57d2d742">leafAccumulationOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a158da654dc12bf34a61950df57d2d742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a20f7af5ed80d8860009cfd39f1dafc03">leafDifferenceOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a5fb3b27a05bb36fc409ed1ffe17cab9f">nodeAccumulation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a8493e447407309758e72abcd2a6faf6a">nodeDifference</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aab5d343b96bf5be2ef7ebfaa4ead0319">getLeaves</a> (std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp;leaves) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a49322e88d40a59c02bb6c3eb5841584a">getAllNodes</a> (std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp;allNodes) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#acf8c07b59699383cc9983aefb8c8945d">nodeAbsAccumulation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a0c350ae6fe0fc1719ec294f5828c64a6">nodeAccumulationMultVol</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ac89894e566fc5b4f86b2b9d749db10a1">nodeAbsAccumulationMultVol</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92">summary</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container of summary values from the collated subpavings.  <a href="#ad85d48d6c14888cc7d375f74b63c2f92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4">Vemp</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Empirical measure for the validation data from the collated subpavings.  <a href="#a31cd9926485cf1190effb77a9ce8dac4"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for creating summaries. </p>
<p>Creates summaries and empirical measures from other nodes from the <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> family.</p>
<p>The base class <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is a node in the representation of a regular subpaving as a binary tree. A node represents a box (interval vector). SPnodes are linked together to form the tree. The initial box of the subpaving is the box represented by the root node of the tree. A box which has been split will be represented as node with one or two children. A subpaving of [<b>x</b>] (union of non-overlapping sub- boxes of [<b>x</b>]) is represented by the leaves (degenerate/ child-less) nodes in the tree.</p>
<p>The <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> class collates data from a collection of SPnodes or objects from classes derived from <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>.</p>
<p>An entire tree structure represents a union over each tree collated, ie the boxes of the leaves of the collated tree make a subpaving that is the union of the subpavings represented by each tree collated.</p>
<p>Each node has a container structure (the summary) holding one value for each corresponding collated, and also the empirical measure of the data contained inside the node. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8hpp_source.shtml#l00068">68</a> of file <a class="el" href="collatorspvnode_8hpp_source.shtml">collatorspvnode.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9f0d632933ae94b99777c01fa8d1677e"></a><!-- doxytag: member="subpavings::CollatorSPVnode::CollatorSPVnode" ref="a9f0d632933ae94b99777c01fa8d1677e" args="(const SPSVnode *const spn, size_t bigN, size_t bigM, int whatSum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a9f0d632933ae94b99777c01fa8d1677e">subpavings::CollatorSPVnode::CollatorSPVnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bigN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bigM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatSum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Private initialised constructor whatSum indicats what type of summary is to be tracked 1: histogram density estimate 2: counts only </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">57</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">CollatorSPVnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00382">subpavings::SPnode::getDimension()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00894">subpavings::SPSVnode::getVcounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00057">CollatorSPVnode()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {
         <span class="comment">//cout &lt;&lt; &quot;private initialised constructor with validation summ&quot; &lt;&lt; endl;</span>
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(spn-&gt;getBox());
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = spn-&gt;getDimension();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = spn-&gt;getLabel();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = spn-&gt;getNodeName();
       <span class="comment">//     cout &lt;&lt; nodeName &lt;&lt; endl;</span>

            <span class="keywordflow">if</span> (whatSum==1){
            <span class="comment">// add the summary to the vector summary</span>
        <span class="comment">// cout &lt;&lt; &quot;counter from private constructor: &quot; &lt;&lt; (spn-&gt;getCounter()) &lt;&lt; &quot;\t&quot;;</span>
        <span class="comment">// cout &lt;&lt; &quot;bigN: &quot;&lt;&lt; bigN &lt;&lt; &quot;\t&quot;;</span>
        <span class="comment">// cout &lt;&lt; &quot;spn-&gt;nodeVolume(): &quot; &lt;&lt; spn-&gt;nodeVolume() &lt;&lt; endl;</span>
        <span class="comment">// cout &lt;&lt; &quot;height &quot; &lt;&lt; spn-&gt;getCounter()/(1.0*bigN*spn-&gt;nodeVolume()) &lt;&lt; endl;</span>
           <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back(spn-&gt;getCounter()/(1.0*bigN*spn-&gt;nodeVolume()));
            <span class="comment">// for validation data, add the summary to the vector summary</span>
        <span class="comment">// cout &lt;&lt; &quot;Vemp from private constructor: &quot; &lt;&lt; </span>
          <span class="comment">//         (spn-&gt;getVcounter())/(1.0 * bigM)&lt;&lt; endl;</span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = ((spn-&gt;getVcounter())/(1.0 * bigM));        

        }
        
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (whatSum==2) {
          <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back(spn-&gt;getCounter());
          <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = 0;
        }        

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (spn-&gt;hasLCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(spn-&gt;getLeftChild(), bigN, 
                            bigM, whatSum));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (spn-&gt;hasRCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(spn-&gt;getRightChild(), bigN, 
                             bigM, whatSum));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
     }
</pre></div>
</div>
</div>
<a class="anchor" id="afc907faf6fc53e9fdea4c6895e14a42c"></a><!-- doxytag: member="subpavings::CollatorSPVnode::CollatorSPVnode" ref="afc907faf6fc53e9fdea4c6895e14a42c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a9f0d632933ae94b99777c01fa8d1677e">subpavings::CollatorSPVnode::CollatorSPVnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>default constructor. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">259</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01181">addPavings()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">CollatorSPVnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">operator=()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01243">subtractPavings()</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<a class="anchor" id="a238d7e9e52b2014b97d10903f54df691"></a><!-- doxytag: member="subpavings::CollatorSPVnode::CollatorSPVnode" ref="a238d7e9e52b2014b97d10903f54df691" args="(const SPSVnode *const spn, int whatSum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a9f0d632933ae94b99777c01fa8d1677e">subpavings::CollatorSPVnode::CollatorSPVnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatSum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initalised constructor. </p>
<p>Initialised with a pointer to an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>. The CollatorSPSVnode summary information is the k/vol of the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>, ie effectively the height of a histogram bin formed by the box associated with that node. The empirical measure is k/m of the <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>, where m is the total number of validation points. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00263">263</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00382">subpavings::SPnode::getDimension()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00920">subpavings::SPSVnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00925">subpavings::SPSVnode::getRightChild()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01238">subpavings::SPSVnode::getRootCounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l01252">subpavings::SPSVnode::getRootVcounter()</a>, <a class="el" href="spsvnode_8cpp_source.shtml#l00894">subpavings::SPSVnode::getVcounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {
         <span class="comment">//   cout &lt;&lt; &quot;default constructor for validation data&quot; &lt;&lt; endl;</span>
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(spn-&gt;getBox());
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = spn-&gt;getDimension();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = spn-&gt;getLabel();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = spn-&gt;getNodeName();
            <span class="keywordtype">size_t</span> rootCounter = spn-&gt;getRootCounter();
        <span class="keywordtype">size_t</span> rootVCounter = spn-&gt;getRootVcounter(); <span class="comment">//get the total number</span>
                                                      <span class="comment">// of validation data</span>
        
        <span class="keywordflow">if</span> (whatSum==1) {
          <span class="comment">// get the empirical measure of the validation data in this node </span>
          <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = (spn-&gt;getVcounter()/(1.0*rootVCounter)); 
          <span class="comment">// add the normalised count/volume to the vector summary          </span>
          <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back(spn-&gt;getCounter()/
                                (1.0*rootCounter * spn-&gt;nodeVolume()));       
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (whatSum==2) {
          <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back(spn-&gt;getCounter());
          <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = 0;
        }
        
            <span class="comment">//recursion on the children using constructor which normalises </span>
        <span class="comment">// counts</span>
            <span class="keywordflow">if</span> (spn-&gt;hasLCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(spn-&gt;getLeftChild(),
                                               rootCounter, rootVCounter, 
                                               whatSum));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (spn-&gt;hasRCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(spn-&gt;getRightChild(),
                                                rootCounter, rootVCounter,
                                                whatSum));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="afefc26f6a3e9ba25ccf69d47dbdf99d7"></a><!-- doxytag: member="subpavings::CollatorSPVnode::CollatorSPVnode" ref="afefc26f6a3e9ba25ccf69d47dbdf99d7" args="(ivector &amp;v, int lab, VecDbl summ, double Vsumm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a9f0d632933ae94b99777c01fa8d1677e">subpavings::CollatorSPVnode::CollatorSPVnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a>&#160;</td>
          <td class="paramname"><em>summ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>Vsumm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a box, a label, a vector summary, and an empirical measure. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00314">314</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00081">Vemp</a>.</p>
<div class="fragment"><pre class="fragment">                                        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v, lab)
     {
         <span class="keywordflow">try</span> {
           <span class="comment">//   cout &lt;&lt; &quot;initialized constructor with box, label, summary, vsumm&quot; &lt;&lt; endl;</span>
             <span class="comment">// copy the vector summary</span>
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a> = summ;
         <span class="comment">// copy the empirical measure</span>
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = Vempp;
         }
         <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
             std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
             <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
             std::cout &lt;&lt; msg &lt;&lt; std::endl;
             <span class="keywordflow">throw</span>;
         }
     }
</pre></div>
</div>
</div>
<a class="anchor" id="aeaf38d226e1bacab0a109a3525f73cc0"></a><!-- doxytag: member="subpavings::CollatorSPVnode::CollatorSPVnode" ref="aeaf38d226e1bacab0a109a3525f73cc0" args="(const CollatorSPVnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a9f0d632933ae94b99777c01fa8d1677e">subpavings::CollatorSPVnode::CollatorSPVnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">334</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00081">Vemp</a>.</p>
<div class="fragment"><pre class="fragment">         : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*(other.theBox), other.label)
     {
        <span class="keywordflow">try</span> {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a> = other.summary;
             <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.nodeName;
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = other.Vemp;
 
            <span class="comment">//recursion on the children</span>
             <span class="keywordflow">if</span> (other.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(
                     *(other.getLeftChild())));
           }
             <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

           <span class="keywordflow">if</span> (other.rightChild) {
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(
                     *(other.getRightChild())));
            }
             <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
         }
         <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
             std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
             <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
             std::cout &lt;&lt; msg &lt;&lt; std::endl;
             <span class="keywordflow">throw</span>;
        }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="ab7123fe7fb187c082d968a8d3be9944d"></a><!-- doxytag: member="subpavings::CollatorSPVnode::CollatorSPVnode" ref="ab7123fe7fb187c082d968a8d3be9944d" args="(const CollatorSPVnode &amp;other, int toSubtract)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a9f0d632933ae94b99777c01fa8d1677e">subpavings::CollatorSPVnode::CollatorSPVnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toSubtract</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor for the subtracted ADHVC. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00366">366</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00212">nodeAccumulation()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00081">Vemp</a>.</p>
<div class="fragment"><pre class="fragment">         : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*(other.theBox), other.label)
     {
        <span class="keywordflow">try</span> {
         
         <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back(other.nodeAccumulation()); 
         <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.nodeName;
         <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = other.Vemp;
 
            <span class="comment">//recursion on the children</span>
             <span class="keywordflow">if</span> (other.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(
                     *(other.getLeftChild()), toSubtract));
           }
             <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

           <span class="keywordflow">if</span> (other.rightChild) {
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(
                     *(other.getRightChild()), toSubtract));
            }
             <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
         }
         <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
             std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
             <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
             std::cout &lt;&lt; msg &lt;&lt; std::endl;
             <span class="keywordflow">throw</span>;
        }
 
     }
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2976605178012f7d9b23bca1d7f9beb4"></a><!-- doxytag: member="subpavings::CollatorSPVnode::addNegatedPaving" ref="a2976605178012f7d9b23bca1d7f9beb4" args="(const CollatorSPVnode *const spn, double c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a2976605178012f7d9b23bca1d7f9beb4">subpavings::CollatorSPVnode::addNegatedPaving</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Incorporate negation of a Collator subpaving to this summmary. </p>
<p>Adjusts the tree rooted at this node for the tree being added. The tree rooted at this node will expand if necessary to have at least all the leaves of the tree of the tree being added. The summary for this node will increase to include the negation of the summary of the node being added.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>pointer to the Collator subpaving to be incorporated into the summary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that the contents of the Collator subpaving added will be altered: it is assumed that the Collator subpaving to be added is a temporary object made and passed in with a wrapper class </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01323">1323</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">nodeNegate()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01243">subtractPavings()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        SPSnode* temp = NULL;

        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>* temp = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a> (*spn);

            <span class="comment">// negate the node passed in</span>
            temp-&gt;nodeNegate(c);

            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#af01fff5efb1889862b36606bed10746a" title="Add paving with Vemp to collation.">addPavingWithVal</a>(temp);

            <span class="keyword">delete</span> temp;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addNegatedPaving&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af92d7a31e4c7f97661d3e812948a8aee"></a><!-- doxytag: member="subpavings::CollatorSPVnode::addPavings" ref="af92d7a31e4c7f97661d3e812948a8aee" args="(const CollatorSPVnode *const lhs, const CollatorSPVnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#af92d7a31e4c7f97661d3e812948a8aee">subpavings::CollatorSPVnode::addPavings</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two collator subpavings together. </p>
<p>Collator returned has summary with contents of both operands' summaries.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to the root of one collator to be added. </td></tr>
    <tr><td class="paramname">lhs</td><td>pointer to the root of the other collator to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the root of a new collator subpaving where the summmary is the combined summary of the operands (lhs first, then rhs). </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01181">1181</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>* newCollator = NULL;
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>* temp = NULL;
        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;
        <span class="keywordflow">try</span> {
            <span class="keywordflow">if</span> (lhs == NULL &amp;&amp; rhs == NULL) done = <span class="keyword">true</span>; <span class="comment">// return null</span>

            <span class="comment">// if exactly one is null we can return a copy of the non-null one</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs == NULL &amp;&amp; rhs != NULL) {
                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*rhs);
                done = <span class="keyword">true</span>;
            }
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs == NULL) {
                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*lhs);
                done = <span class="keyword">true</span>;
            }
            <span class="comment">// both not null</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs != NULL) {
                <span class="keywordflow">if</span> ((lhs-&gt;getBox() != NULL) &amp;&amp;
                                (lhs-&gt;getBox() != rhs-&gt;getBox())) {
                    <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes do not match&quot;</span>);
                }
                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*lhs);
                temp = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*rhs);
                newCollator-&gt;addPavingWithVal(temp);
                <span class="keyword">delete</span> temp;
                temp = NULL;
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">if</span> (temp != NULL) {
                <span class="keyword">delete</span> temp;
                temp = NULL;
            }
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addPavings&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">if</span> (temp != NULL) {
                <span class="keyword">delete</span> temp;
                temp = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newCollator;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af01fff5efb1889862b36606bed10746a"></a><!-- doxytag: member="subpavings::CollatorSPVnode::addPavingWithVal" ref="af01fff5efb1889862b36606bed10746a" args="(CollatorSPVnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#af01fff5efb1889862b36606bed10746a">subpavings::CollatorSPVnode::addPavingWithVal</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add paving with Vemp to collation. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">1048</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00512">getSummary()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00798">nodeExpand()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00081">Vemp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01181">addPavings()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">subpavings::AdaptiveHistogramVCollator::addToCollationWithVal()</a>, and <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00196">subpavings::AdaptiveHistogramVCollator::operator+=()</a>.</p>
<div class="fragment"><pre class="fragment">    {
       
        <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;  <span class="comment">// indicator for done adding</span>

        <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> summaryIt;

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (spn == NULL) {
                done = <span class="keyword">true</span>;

            }

            <span class="comment">// if the boxes are not the same we can&#39;t do anything</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) &amp;&amp; (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != spn-&gt;getBox())) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes do not match&quot;</span>);
            }

            <span class="comment">// if this has no box yet it has not incorporated anything</span>
            <span class="comment">// and so we just use spn to construct this</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> == NULL)) {
                <span class="comment">//cout &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; spn-&gt;getNodeName() &lt;&lt; endl;</span>
                ivector v = spn-&gt;getBox();
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(v);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(v) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(v) + 1;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = spn-&gt;getLabel();
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a> = spn-&gt;summary;               
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = spn-&gt;Vemp;
                <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;</span>
                                
                <span class="comment">//recursion on the children</span>
                <span class="keywordflow">if</span> (spn-&gt;leftChild) {
                    <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*(spn-&gt;getLeftChild())));
                }
                <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

                <span class="keywordflow">if</span> (spn-&gt;rightChild) {
                    <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*(spn-&gt;getRightChild())));
                 }
                <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;

                done = <span class="keyword">true</span>;
                retValue = <span class="keyword">true</span>;
            } <span class="comment">// end if theBox==NULL</span>
            
            <span class="comment">// do the rest only if done is not true</span>

            <span class="comment">// if this is a leaf and the paving to be added is a leaf we don&#39;t</span>
            <span class="comment">// this just sucks in the counter from spn</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; !done &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; spn-&gt;isLeaf()) {
           <span class="comment">//cout &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; spn-&gt;getNodeName() &lt;&lt; endl;</span>
                <span class="comment">//cout &lt;&lt; &quot;both are leaves&quot; &lt;&lt; endl;</span>
                <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp = spn-&gt;getSummary();
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.insert(<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(), temp.begin(),temp.end());
                
                <span class="comment">//danger!</span>
                <span class="comment">// if this is split and became a leaf because of addition into </span>
                <span class="comment">// collator, then we need to use spn&#39;s Vemp</span>
                <span class="comment">// assuming that spn&#39;s Vemp is smaller than Vemp</span>
          <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> &gt; (spn-&gt;Vemp) ) {
            <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;</span>
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = spn-&gt;Vemp;
            <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;</span>
          }
               <span class="comment">// if spn became a leaf because of addition, then we need to use </span>
               <span class="comment">// Vemp of this</span>
               <span class="comment">// if Vemp = spn-&gt;Vemp, doesn&#39;t matter which Vemp is used</span>
               <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> &lt;= (spn-&gt;Vemp) ) {
            <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;</span>
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a>;
            <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;</span>
          }
               
                done = <span class="keyword">true</span>;
                retValue = <span class="keyword">true</span>;
            }

            <span class="comment">// else not done and not both leaves,</span>
            <span class="comment">// if this is not a leaf or the paving to be added</span>
            <span class="comment">// is not a leaf, we may need to split</span>
            <span class="comment">// and we will need to recurse further</span>
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!done &amp;&amp; (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() || !(spn-&gt;isLeaf()))) {
                <span class="comment">// if this is leaf and spn not we need to split this</span>
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// so spn can&#39;t be a leaf</span>
                     <span class="comment">//cout &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; spn-&gt;getNodeName() &lt;&lt; endl;</span>
                     <span class="comment">//cout &lt;&lt; &quot;this is a leaf &quot; &lt;&lt; endl;</span>
                     <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a43e370d7120f8cc8c1cde489f61e7fc5" title="Expand leaf node to make two more leaves as children and copy summary and Vemp down to the children...">nodeExpand</a>();
                     <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;</span>
              <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = spn-&gt;Vemp;    
              <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;  </span>
                }

                <span class="comment">// if spn is leaf and this is not we need to split spn</span>
                <span class="comment">// THIS WILL CHANGE the CollatorSPVnode pointed to by spn</span>

                <span class="keywordflow">if</span> (spn-&gt;isLeaf()) { <span class="comment">// so this can&#39;t be a leaf</span>
              <span class="comment">//cout &lt;&lt; getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; spn-&gt;getNodeName() &lt;&lt; endl;</span>
                     <span class="comment">//cout &lt;&lt; &quot;spn is a leaf &quot; &lt;&lt; endl;</span>
              
              spn-&gt;nodeExpand();
                     <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;</span>
              <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a> = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a>;    
              <span class="comment">//cout &lt;&lt; Vemp &lt;&lt; endl;   </span>
                }

                <span class="comment">// put in the data</span>
                <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp = spn-&gt;getSummary();
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.insert(<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(), temp.begin(),temp.end());
                done = <span class="keyword">true</span>;
                               
                <span class="comment">// if they are were neither leaves originally</span>
                <span class="comment">// we go straight on to recursing with the children</span>
                <span class="comment">// otherwise expansions above are followed by recursion</span>

                <span class="comment">// recurse with children</span>
                <span class="comment">//cout &lt;&lt; &quot;recursing with children&quot; &lt;&lt; endl;</span>
                retValue=<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#af01fff5efb1889862b36606bed10746a" title="Add paving with Vemp to collation.">addPavingWithVal</a>(spn-&gt;getLeftChild());
                retValue=<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#af01fff5efb1889862b36606bed10746a" title="Add paving with Vemp to collation.">addPavingWithVal</a>(spn-&gt;getRightChild());
            } <span class="comment">// end of dealing with case where at least one is not a leaf</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addPaving&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a49322e88d40a59c02bb6c3eb5841584a"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getAllNodes" ref="a49322e88d40a59c02bb6c3eb5841584a" args="(std::vector&lt; CollatorSPVnode * &gt; &amp;allNodes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a49322e88d40a59c02bb6c3eb5841584a">subpavings::CollatorSPVnode::getAllNodes</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>allNodes</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return a reference to a container of node pointers. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">932</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">getAllNodes()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">getAllNodes()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) { <span class="comment">// this is not empty</span>
      <span class="comment">//if (!hasLCwithBox() &amp;&amp; !hasRCwithBox()) { // this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
        <span class="comment">//cout &lt;&lt; nodeName &lt;&lt; endl;</span>
            allNodes.push_back(const_cast&lt;CollatorSPVnode*&gt;(<span class="keyword">this</span>));
        }
      
      <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a49322e88d40a59c02bb6c3eb5841584a">getAllNodes</a>(allNodes);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a49322e88d40a59c02bb6c3eb5841584a">getAllNodes</a>(allNodes);
        }       
        <span class="keywordflow">return</span> allNodes;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="aab5d343b96bf5be2ef7ebfaa4ead0319"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getLeaves" ref="aab5d343b96bf5be2ef7ebfaa4ead0319" args="(std::vector&lt; CollatorSPVnode * &gt; &amp;leaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aab5d343b96bf5be2ef7ebfaa4ead0319">subpavings::CollatorSPVnode::getLeaves</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return a reference to a container of node pointers. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00911">911</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00911">getLeaves()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00911">getLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aab5d343b96bf5be2ef7ebfaa4ead0319">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aab5d343b96bf5be2ef7ebfaa4ead0319">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
            leaves.push_back(const_cast&lt;CollatorSPVnode*&gt;(<span class="keyword">this</span>));
        }
        <span class="keywordflow">return</span> leaves;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aeaea28b3b2d7ca59a28cd3fbb3438cce"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getLeftChild" ref="aeaea28b3b2d7ca59a28cd3fbb3438cce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce">subpavings::CollatorSPVnode::getLeftChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the left child of a node. </p>
<p>Returns a copy of the pointer to leftChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">503</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">CollatorSPVnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">getAllNodes()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00911">getLeaves()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">getScheffeSet()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01067">subpavings::AdaptiveHistogramVCollator::getScheffeSetAll()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01346">getSplitNodePtrCSPV()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">getYatSet()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">leavesAbsAccumulationMultVol()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">leavesAverageOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">leavesDifferenceOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">leavesOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">nodeNegate()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">nodesReunite()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">operator=()</a>.</p>
<div class="fragment"><pre class="fragment">     { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a1ebdb63b747d9c7a477b6ad86d58b714"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getNodeDelta" ref="a1ebdb63b747d9c7a477b6ad86d58b714" args="(int thisTheta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a1ebdb63b747d9c7a477b6ad86d58b714">subpavings::CollatorSPVnode::getNodeDelta</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisTheta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the delta value for a specific theta. </p>
<p>Get the delta value for a specific theta. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>split number in the set 0:(theta-1) </td></tr>
    <tr><td class="paramname">theta</td><td>the current split number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the delta value </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01448">1448</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00516">getVemp()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>
<div class="fragment"><pre class="fragment">   { 
     <span class="comment">//cout &lt;&lt; &quot;get delta for &quot; &lt;&lt; nodeName &lt;&lt; &quot; at theta = &quot; &lt;&lt; thisTheta &lt;&lt; endl;</span>
     <span class="comment">// get empirical measure of the training data</span>
     <span class="keywordtype">double</span> muTrain = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[thisTheta] * <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
     <span class="comment">//cout &lt;&lt; &quot;summary: &quot; &lt;&lt; summary[thisTheta] &lt;&lt; &quot;\t muTrain: &quot; &lt;&lt; muTrain &lt;&lt; endl;</span>
      
     <span class="comment">// get empirical measure of the validation data      </span>
     <span class="comment">//cout &lt;&lt; &quot;muValid: &quot; &lt;&lt; getVemp() &lt;&lt; endl;</span>

     <span class="keywordtype">double</span> delta= muTrain - <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ac3cc6fb2f09dc7d6d99b52631fc4f60e" title="Accessor for the validation summary.">getVemp</a>();
    <span class="comment">//cout &lt;&lt; &quot;Delta: &quot; &lt;&lt; delta &lt;&lt; endl; </span>

     <span class="keywordflow">return</span> delta; 

   } <span class="comment">// end of function getNodeDelta</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a72f2564ee548571ef026a8548ca0b0ba"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getNumberSummarised" ref="a72f2564ee548571ef026a8548ca0b0ba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a72f2564ee548571ef026a8548ca0b0ba">subpavings::CollatorSPVnode::getNumberSummarised</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of subpavings summarised. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00520">520</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>
<div class="fragment"><pre class="fragment">     { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a635b2b0884e6d8fc328e058bd3fadbcc"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getParent" ref="a635b2b0884e6d8fc328e058bd3fadbcc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a635b2b0884e6d8fc328e058bd3fadbcc">subpavings::CollatorSPVnode::getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the parent of a node. </p>
<p>Returns a copy of the pointer to parent node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00498">498</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>
<div class="fragment"><pre class="fragment">     { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="aaaa6264c4020a5e0ccfdedb19228fa2b"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getRightChild" ref="aaaa6264c4020a5e0ccfdedb19228fa2b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b">subpavings::CollatorSPVnode::getRightChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the right child of a node. </p>
<p>Returns a copy of the pointer to rightChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">508</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00334">CollatorSPVnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00932">getAllNodes()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00911">getLeaves()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">getScheffeSet()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01067">subpavings::AdaptiveHistogramVCollator::getScheffeSetAll()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01346">getSplitNodePtrCSPV()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">getYatSet()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">leavesAbsAccumulationMultVol()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">leavesAverageOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">leavesDifferenceOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">leavesOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">nodeNegate()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">nodesReunite()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">operator=()</a>.</p>
<div class="fragment"><pre class="fragment">     { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="ab134b9b98ed7b15b1cabb9eca1ced1eb"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getScheffeNode" ref="ab134b9b98ed7b15b1cabb9eca1ced1eb" args="(int theta1, int theta2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ab134b9b98ed7b15b1cabb9eca1ced1eb">subpavings::CollatorSPVnode::getScheffeNode</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2, where theta1 &lt; theta2. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta1</td><td>position of candidate f_theta1 </td></tr>
    <tr><td class="paramname">theta2</td><td>position of candidate f_theta2 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01397">1397</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">getScheffeSet()</a>, and <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01067">subpavings::AdaptiveHistogramVCollator::getScheffeSetAll()</a>.</p>
<div class="fragment"><pre class="fragment">   { 
     <span class="comment">//cout.precision(20);</span>
     <span class="comment">//cout &lt;&lt; &quot;Checking for Scheffe set at node: &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
     <span class="comment">//cout &lt;&lt; &quot;Theta1: &quot; &lt;&lt; theta1 &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;Theta2: &quot; &lt;&lt; theta2 &lt;&lt; endl;     </span>
     <span class="comment">//cout &lt;&lt; summary[theta1] &lt;&lt; &quot;\t&quot; &lt;&lt; summary[theta2] &lt;&lt; endl;</span>
     
    <span class="comment">//check that this is an ordered pair theta1 &lt; theta2</span>
    <span class="keywordflow">if</span> (theta1 &lt; theta2) {
      <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[theta1] &gt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[theta2])) {
          <span class="comment">//cout &lt;&lt; getNodeName() &lt;&lt; &quot; is an element of the Scheffe set.****&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">return</span> <span class="keyword">true</span>;          
      } 
      <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
    }
    <span class="keywordflow">else</span> {
      cerr &lt;&lt; <span class="stringliteral">&quot;theta1 must be less than theta2.&quot;</span> &lt;&lt; endl;
      exit(0);
    }
   }    
</pre></div>
</div>
</div>
<a class="anchor" id="a8d430b2bdfb2d8032e5d7f9e9bddb53d"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getScheffeSet" ref="a8d430b2bdfb2d8032e5d7f9e9bddb53d" args="(std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &amp;ScheffeSet, size_t cand1, size_t cand2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a8d430b2bdfb2d8032e5d7f9e9bddb53d">subpavings::CollatorSPVnode::getScheffeSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ScheffeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Scheffe set for a particular pair. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">1500</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01397">getScheffeNode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">getScheffeSet()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01500">getScheffeSet()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//iterate through the leaves in both candidate histograms to get the </span>
  <span class="comment">//Yatracos set</span>
   <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
      <span class="keywordtype">bool</span> ind = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ab134b9b98ed7b15b1cabb9eca1ced1eb" title="Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2...">getScheffeNode</a>(cand1, cand2);
        <span class="comment">// insert the node YatSet if return true</span>
    <span class="keywordflow">if</span> (ind) { 
      ScheffeSet.insert(&amp;(*<span class="keyword">this</span>));
    }
  }
    
   <span class="comment">//recurse on the children</span>
   <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
         <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a8d430b2bdfb2d8032e5d7f9e9bddb53d" title="Get the Scheffe set for a particular pair.">getScheffeSet</a>(ScheffeSet, cand1, cand2);
   }
   <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
         <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a8d430b2bdfb2d8032e5d7f9e9bddb53d" title="Get the Scheffe set for a particular pair.">getScheffeSet</a>(ScheffeSet, cand1, cand2);
   }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae3670805f36e313e7e541d57552d6b34"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getSplitNodePtrCSPV" ref="ae3670805f36e313e7e541d57552d6b34" args="(CollatorSPVnode *&amp;splitCollNode, SPSVnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae3670805f36e313e7e541d57552d6b34">subpavings::CollatorSPVnode::getSplitNodePtrCSPV</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&amp;&#160;</td>
          <td class="paramname"><em>splitCollNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> pointer to the corresponding <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> that was split. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chosenLargest</td><td>the current splitted node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>splitCollNode the current splitted node as a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01346">1346</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01346">getSplitNodePtrCSPV()</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01346">getSplitNodePtrCSPV()</a>.</p>
<div class="fragment"><pre class="fragment">    {
  <span class="comment">//  cout &lt;&lt; &quot;getSplitNodePtrCSPV for: &quot; &lt;&lt;spn-&gt;getNodeName() &lt;&lt; endl;</span>
    <span class="keywordtype">bool</span> retvalue=<span class="keyword">false</span>;
    <span class="keywordtype">bool</span> done=<span class="keyword">false</span>;
    <span class="comment">//cout &lt;&lt; &quot;done on top: &quot; &lt;&lt; done &lt;&lt; endl;</span>
        
    <span class="keywordflow">try</span> {
      
           <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> == NULL) { done = <span class="keyword">true</span>;
           retvalue = <span class="keyword">true</span>; } <span class="comment">// if there is no memory allocated to this pointer</span>
          
           <span class="keywordflow">else</span> {
    <span class="comment">//         cout &lt;&lt; &quot;now looking at node: &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
        <span class="comment">//    cout &lt;&lt; &quot;done: &quot; &lt;&lt; done &lt;&lt; endl;     </span>
          <span class="comment">//get the pointer to the CollatorSPVnode that was split</span>
          <span class="keywordflow">if</span> ( !done &amp;&amp; spn-&gt;getBox() == <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() ){ 
      <span class="comment">//      cout &lt;&lt; &quot;splitCollNode: &quot; &lt;&lt; spn-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; spn-&gt;getJustSplit() &lt;&lt; endl;</span>
            splitCollNode = (&amp;(*this));
            done = <span class="keyword">true</span>; 
            retvalue = <span class="keyword">true</span>;
          }
             
          <span class="comment">// if not done, recurse with children</span>
          <span class="keywordflow">if</span> ( done == <span class="keyword">false</span> ) { 
        <span class="comment">//    cout &lt;&lt; &quot;recursing with children&quot; &lt;&lt; endl;  </span>
          <span class="comment">//  cout &lt;&lt; &quot;still not done &quot; &lt;&lt; !done &lt;&lt; endl;</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>() != NULL&amp;&amp; retvalue == <span class="keyword">false</span>) {
            retvalue = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ae3670805f36e313e7e541d57552d6b34" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtrCSPV</a>(splitCollNode,                                 spn);
          <span class="comment">//  cout &lt;&lt; &quot;retvalue for left: &quot; &lt;&lt; retvalue &lt;&lt; &quot;done: &quot; &lt;&lt; done &lt;&lt; endl;</span>
            }
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>() != NULL &amp;&amp; retvalue == <span class="keyword">false</span>) {
            retvalue = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ae3670805f36e313e7e541d57552d6b34" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtrCSPV</a>(splitCollNode,                              spn);
            <span class="comment">//cout &lt;&lt; &quot;retvalue for right: &quot; &lt;&lt; retvalue &lt;&lt; &quot;done: &quot; &lt;&lt; done &lt;&lt; endl;</span>
            } 
          }
        }
      }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in getSplitNodePtrCSPV&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        
        <span class="keywordflow">return</span> retvalue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad7fa37be86eb1d964b384a090dc3552f"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getSummary" ref="ad7fa37be86eb1d964b384a090dc3552f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad7fa37be86eb1d964b384a090dc3552f">subpavings::CollatorSPVnode::getSummary</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the summary. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00512">512</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>.</p>
<div class="fragment"><pre class="fragment">     { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="ac3cc6fb2f09dc7d6d99b52631fc4f60e"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getVemp" ref="ac3cc6fb2f09dc7d6d99b52631fc4f60e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ac3cc6fb2f09dc7d6d99b52631fc4f60e">subpavings::CollatorSPVnode::getVemp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the validation summary. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00516">516</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8hpp_source.shtml#l00081">Vemp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01448">getNodeDelta()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">leafOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">makeAverageCollation()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00726">nodePrint()</a>.</p>
<div class="fragment"><pre class="fragment">     { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="ad0bdf61f72d586c8944c076e310b3240"></a><!-- doxytag: member="subpavings::CollatorSPVnode::getYatSet" ref="ad0bdf61f72d586c8944c076e310b3240" args="(std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &amp;YatSetRow, std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &amp;YatSetCol, size_t cand1, size_t cand2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0bdf61f72d586c8944c076e310b3240">subpavings::CollatorSPVnode::getYatSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSetRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSetCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Yatracos set for a particular pair. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">1466</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">getYatSet()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01435">nodeCheckColSummary()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01420">nodeCheckRowSummary()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">getYatSet()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//cout &lt;&lt; &quot;iterating through the leaves in candidate histograms&quot; &lt;&lt; endl;</span>
  <span class="comment">//iterate through the leaves in both candidate histograms to get the </span>
  <span class="comment">//Yatracos set</span>
   <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
      <span class="keywordtype">bool</span> rowInd = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a199762d07823cde9934100fb6d11228c" title="Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matr...">nodeCheckRowSummary</a>(cand1, cand2);
      <span class="comment">// insert the node YatSet if return true</span>
    <span class="keywordflow">if</span> (rowInd) { 
      <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; getNodeName() &lt;&lt; &quot; into YatSetRow&quot; &lt;&lt; endl; </span>
      YatSetRow.insert(&amp;(*<span class="keyword">this</span>));
    }
    <span class="keywordflow">else</span> {
      <span class="keywordtype">bool</span> colInd = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a61360380c921f78c1ac9689ffe004c60" title="Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos m...">nodeCheckColSummary</a>(cand1, cand2);
      <span class="keywordflow">if</span> (colInd) { 
        <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; getNodeName() &lt;&lt; &quot; into YatSetCol&quot; &lt;&lt; endl; </span>
        YatSetCol.insert(&amp;(*<span class="keyword">this</span>));
      }
    }
  }
  <span class="comment">//recurse on the children</span>
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
      <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0bdf61f72d586c8944c076e310b3240" title="Get the Yatracos set for a particular pair.">getYatSet</a>(YatSetRow, YatSetCol, cand1, cand2);
  }
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
      <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0bdf61f72d586c8944c076e310b3240" title="Get the Yatracos set for a particular pair.">getYatSet</a>(YatSetRow, YatSetCol, cand1, cand2);
  }
  
} <span class="comment">// end of getYatset</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a158da654dc12bf34a61950df57d2d742"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leafAccumulationOutputTabs" ref="a158da654dc12bf34a61950df57d2d742" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a158da654dc12bf34a61950df57d2d742">subpavings::CollatorSPVnode::leafAccumulationOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only. Outputs the accumulated sum of the summary for the node, ie the summary added together.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector with m elements in the summary is</p>
<p>label [tab] volume [tab] empirical measure [tab] sum(summary[1]... summary[m]) [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[n]) [tab] Sup(ivector[n] </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00147">147</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">leavesAccumulationOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            <span class="keywordtype">double</span> summ = 0;
            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="comment">// should change this to use for_each</span>
            <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
                summ+=(*it);
            }

            <span class="comment">// output the nodeName, nodeVolume</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
        <span class="comment">// followed by the empirical measure</span>
      <span class="comment">//  os &lt;&lt; &quot;\t&quot; &lt;&lt; getVemp();</span>
            <span class="comment">// followed by the sum of the summary</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a5fb3b27a05bb36fc409ed1ffe17cab9f">nodeAccumulation</a>();

            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aac50041302262e7503e68cbd9103aa0b"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leafAverageOutputTabs" ref="aac50041302262e7503e68cbd9103aa0b" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aac50041302262e7503e68cbd9103aa0b">subpavings::CollatorSPVnode::leafAverageOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only. Outputs the average over the summary.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector is</p>
<p>nodeName [tab] volume [tab] empirical measure [tab] average summary [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[n]) [tab] Sup(ivector[n] </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00109">109</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">leavesAverageOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            <span class="keywordtype">double</span> summ = 0;
            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="comment">// should change this to use for_each</span>
            <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
                summ+=(*it);
            }
            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            <span class="keywordtype">double</span> av =  summ/(1.0*<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.size());

            <span class="comment">// output the nodeName, nodeVolume</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
        
        <span class="comment">// followed by the empirical measure</span>
        os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ac3cc6fb2f09dc7d6d99b52631fc4f60e" title="Accessor for the validation summary.">getVemp</a>();
            
        <span class="comment">// followed by the average</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; av;

            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a20f7af5ed80d8860009cfd39f1dafc03"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leafDifferenceOutputTabs" ref="a20f7af5ed80d8860009cfd39f1dafc03" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a20f7af5ed80d8860009cfd39f1dafc03">subpavings::CollatorSPVnode::leafDifferenceOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00182">182</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">leavesDifferenceOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            <span class="keywordtype">double</span> diff = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[1] + <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[2];
           
         <span class="comment">// output the nodeName, nodeVolume</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
        <span class="comment">// followed by the empirical measure</span>
      <span class="comment">//  os &lt;&lt; &quot;\t&quot; &lt;&lt; getVemp();</span>
            <span class="comment">// followed by the sum of the summary</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; diff;

            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a60e3798526abbe3db915b8a9a9d0aa19"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leafOutputTabs" ref="a60e3798526abbe3db915b8a9a9d0aa19" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a60e3798526abbe3db915b8a9a9d0aa19">subpavings::CollatorSPVnode::leafOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only. Outputs summary for the node.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector with m elements in the summary is</p>
<p>label [tab] volume [tab] empirical measure [tab] \ summary[1] [tab] ... summary[m] [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[n]) [tab] Sup(ivector[n] </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">547</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00516">getVemp()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">     {
 
         <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>
 
             ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>
 
             <span class="comment">// output the nodeName, nodeVolume</span>
             os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
             <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
             os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
         <span class="comment">// followed by the empirical measure</span>
         os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ac3cc6fb2f09dc7d6d99b52631fc4f60e" title="Accessor for the validation summary.">getVemp</a>();
             <span class="comment">// followed by the summary</span>
             <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
             <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
                 os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; (*it);
             }
             <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
             <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
 
                 os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                     &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
             }
 
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="a994d9779baf89f37351656d4d615d340"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leafOutputTabs" ref="a994d9779baf89f37351656d4d615d340" args="(std::ostream &amp;os, int whichColl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a60e3798526abbe3db915b8a9a9d0aa19">subpavings::CollatorSPVnode::leafOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichColl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00578">578</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">     {
 
         <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>
 
             ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>
 
             <span class="comment">// output the nodeName, nodeVolume</span>
             os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
             <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
             os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
         <span class="comment">// followed by the empirical measure</span>
        <span class="comment">// os &lt;&lt; &quot;\t&quot; &lt;&lt; getVemp();</span>
             <span class="comment">// followed by the summary</span>
             os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[whichColl];
             
             <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
             <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
 
                 os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                     &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
             }
 
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="ae996eeb1103aa689f6f64d3db742ce2f"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leavesAbsAccumulationMultVol" ref="ae996eeb1103aa689f6f64d3db742ce2f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae996eeb1103aa689f6f64d3db742ce2f">subpavings::CollatorSPVnode::leavesAbsAccumulationMultVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sum over leaf nodes of absolute accumulated summary x volume. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum over the descendent leaf nodes of this of the absolule accumulated summary x volume for each leaf. </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">525</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">leavesAbsAccumulationMultVol()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00251">nodeAbsAccumulationMultVol()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">leavesAbsAccumulationMultVol()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="keywordtype">double</span> retValue = 0;
 
         <span class="comment">// uses  member function leafSummaryMultVolOutputTabs for node output</span>
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
             retValue = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ac89894e566fc5b4f86b2b9d749db10a1">nodeAbsAccumulationMultVol</a>();
         }
         <span class="comment">//recurse on the children</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ae996eeb1103aa689f6f64d3db742ce2f" title="sum over leaf nodes of absolute accumulated summary x volume.">leavesAbsAccumulationMultVol</a>();
         }
 
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ae996eeb1103aa689f6f64d3db742ce2f" title="sum over leaf nodes of absolute accumulated summary x volume.">leavesAbsAccumulationMultVol</a>();
         }
 
         <span class="keywordflow">return</span> retValue;
     }
</pre></div>
</div>
</div>
<a class="anchor" id="a74c11c958cf56fbfff724d464c02f03a"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leavesAccumulationOutputTabs" ref="a74c11c958cf56fbfff724d464c02f03a" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a74c11c958cf56fbfff724d464c02f03a">subpavings::CollatorSPVnode::leavesAccumulationOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a158da654dc12bf34a61950df57d2d742" title="Output for a node in a binary tree, tab-delimited.">leafAccumulationOutputTabs()</a> to output information for each leaf node. Outputs a accumulated summary for each leaf node, ie the sum of the summary. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">681</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00147">leafAccumulationOutputTabs()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">leavesAccumulationOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00681">leavesAccumulationOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="comment">// uses  member function leafAccumulationOutputTabs for nodes</span>
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a158da654dc12bf34a61950df57d2d742" title="Output for a node in a binary tree, tab-delimited.">leafAccumulationOutputTabs</a>(os);
             <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);
 
         }
 
             <span class="comment">//recurse on the children</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a74c11c958cf56fbfff724d464c02f03a" title="Output for for all leaves of a binary tree.">leavesAccumulationOutputTabs</a>(os);
         }
 
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a74c11c958cf56fbfff724d464c02f03a" title="Output for for all leaves of a binary tree.">leavesAccumulationOutputTabs</a>(os);
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="ad2fe162c253c15b43027ccd44ce9136b"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leavesAverageOutputTabs" ref="ad2fe162c253c15b43027ccd44ce9136b" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad2fe162c253c15b43027ccd44ce9136b">subpavings::CollatorSPVnode::leavesAverageOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#aac50041302262e7503e68cbd9103aa0b" title="Output for a node in a binary tree, tab-delimited.">leafAverageOutputTabs()</a> to output information for each leaf node. Outputs the average over the summary for each leaf. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">658</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00109">leafAverageOutputTabs()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">leavesAverageOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00658">leavesAverageOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="comment">// uses  member function leafAverageOutputTabs for node output</span>
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aac50041302262e7503e68cbd9103aa0b" title="Output for a node in a binary tree, tab-delimited.">leafAverageOutputTabs</a>(os);
             <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);
 
         }
 
             <span class="comment">//recurse on the children</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad2fe162c253c15b43027ccd44ce9136b" title="Output for for all leaves of a binary tree.">leavesAverageOutputTabs</a>(os);
         }
 
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad2fe162c253c15b43027ccd44ce9136b" title="Output for for all leaves of a binary tree.">leavesAverageOutputTabs</a>(os);
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="a63529191a0b2eb1bc253c5c717fc2965"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leavesDifferenceOutputTabs" ref="a63529191a0b2eb1bc253c5c717fc2965" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a63529191a0b2eb1bc253c5c717fc2965">subpavings::CollatorSPVnode::leavesDifferenceOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">703</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00182">leafDifferenceOutputTabs()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">leavesDifferenceOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00703">leavesDifferenceOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="comment">// uses  member function leafAccumulationOutputTabs for nodes</span>
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a20f7af5ed80d8860009cfd39f1dafc03">leafDifferenceOutputTabs</a>(os);
             <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);
 
         }
 
             <span class="comment">//recurse on the children</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a63529191a0b2eb1bc253c5c717fc2965">leavesDifferenceOutputTabs</a>(os);
         }
 
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a63529191a0b2eb1bc253c5c717fc2965">leavesDifferenceOutputTabs</a>(os);
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="a214a7d5e78c28dbad8da0753eebe31f4"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leavesOutputTabs" ref="a214a7d5e78c28dbad8da0753eebe31f4" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4">subpavings::CollatorSPVnode::leavesOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a60e3798526abbe3db915b8a9a9d0aa19" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs()</a> to output summary information for each leaf node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">609</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">leafOutputTabs()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">leavesOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="comment">// uses  member function leafSummaryMultVolOutputTabs for node output</span>
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
     <span class="comment">//    if (!(isEmpty())) { // this is a non-empty leaf</span>
     <span class="comment">//        cout &lt;&lt; *theBox &lt;&lt; endl; </span>
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a60e3798526abbe3db915b8a9a9d0aa19" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs</a>(os);
             <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);
 
         }
 
             <span class="comment">//recurse on the children</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
         }
 
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="af432d9c3c95ad16f40274a0ab35948b8"></a><!-- doxytag: member="subpavings::CollatorSPVnode::leavesOutputTabs" ref="af432d9c3c95ad16f40274a0ab35948b8" args="(std::ostream &amp;os, int whichColl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4">subpavings::CollatorSPVnode::leavesOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichColl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ac0d9484691c21a316308b4713e6e8bba">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00633">633</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">leafOutputTabs()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00609">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="comment">// uses  member function leafSummaryMultVolOutputTabs for node output</span>
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
     <span class="comment">//    if (!(isEmpty())) { // this is a non-empty leaf</span>
     <span class="comment">//        cout &lt;&lt; *theBox &lt;&lt; endl; </span>
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a60e3798526abbe3db915b8a9a9d0aa19" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs</a>(os, whichColl);
             <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);
 
         }
 
             <span class="comment">//recurse on the children</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
         }
 
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="ad0d2a5d445ac27dd3bf81a6f55c4087f"></a><!-- doxytag: member="subpavings::CollatorSPVnode::makeAverageCollation" ref="ad0d2a5d445ac27dd3bf81a6f55c4087f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0d2a5d445ac27dd3bf81a6f55c4087f">subpavings::CollatorSPVnode::makeAverageCollation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>make a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> which represents an average. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">453</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00516">getVemp()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">subpavings::SPnode::setNodeName()</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>* newnode = NULL;

         <span class="keywordflow">try</span> {
             <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> newsumm;
             <span class="keywordtype">double</span> summ = 0;
             <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="comment">// should change this to use for_each</span>
             <span class="keywordflow">for</span> (it = (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.begin()); it &lt; (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end()); it++) {
                 summ+=(*it);
             }
             newsumm.push_back(
                 summ/(1.0*(<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>).size()));

             ivector v = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
 
             <span class="comment">// make the new node</span>
             newnode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(v, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>, newsumm, <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ac3cc6fb2f09dc7d6d99b52631fc4f60e" title="Accessor for the validation summary.">getVemp</a>());
             newnode-&gt;setNodeName(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>); <span class="comment">// set name to this node name</span>
 
             <span class="comment">//recursion on the children</span>
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
                 newnode-&gt;nodeAddLeft(<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0d2a5d445ac27dd3bf81a6f55c4087f">makeAverageCollation</a>());
            }
 
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
                 newnode-&gt;nodeAddRight(<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0d2a5d445ac27dd3bf81a6f55c4087f">makeAverageCollation</a>());
             }
        }
 
         <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
             std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
             <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cout &lt;&lt; msg &lt;&lt; std::endl;
             <span class="keywordflow">throw</span>;
         }
 
       <span class="keywordflow">return</span> newnode;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="acf8c07b59699383cc9983aefb8c8945d"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeAbsAccumulation" ref="acf8c07b59699383cc9983aefb8c8945d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#acf8c07b59699383cc9983aefb8c8945d">subpavings::CollatorSPVnode::nodeAbsAccumulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the accumulation of absolute values in the summary for a node.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum over the absolute values in the summary for this node. </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00232">232</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
            <span class="keywordtype">double</span> absSumm = 0;
            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="comment">// should change this to use for_each</span>
            <span class="comment">// add together the absolute values of each summary</span>
            <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
                *it &lt; 0.0 ? absSumm-=(*it) : absSumm+=(*it);
            }
            <span class="keywordflow">return</span> absSumm;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac89894e566fc5b4f86b2b9d749db10a1"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeAbsAccumulationMultVol" ref="ac89894e566fc5b4f86b2b9d749db10a1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ac89894e566fc5b4f86b2b9d749db10a1">subpavings::CollatorSPVnode::nodeAbsAccumulationMultVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find accumulation of absolute values in summmary x volume in node.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum over the absolute values in the summary, multiplied by the volume, for this node. </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00251">251</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00525">leavesAbsAccumulationMultVol()</a>.</p>
<div class="fragment"><pre class="fragment">    {
            <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#acf8c07b59699383cc9983aefb8c8945d">nodeAbsAccumulation</a>() * <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>());
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5fb3b27a05bb36fc409ed1ffe17cab9f"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeAccumulation" ref="a5fb3b27a05bb36fc409ed1ffe17cab9f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a5fb3b27a05bb36fc409ed1ffe17cab9f">subpavings::CollatorSPVnode::nodeAccumulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the accumulated summary for a node.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum over the summary for this node. </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00212">212</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00366">CollatorSPVnode()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">nodesReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
            <span class="keywordtype">double</span> summ = 0;
            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="comment">// should change this to use for_each</span>
            <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
                summ+=(*it);
            }
            <span class="keywordflow">return</span> summ;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0c350ae6fe0fc1719ec294f5828c64a6"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeAccumulationMultVol" ref="a0c350ae6fe0fc1719ec294f5828c64a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a0c350ae6fe0fc1719ec294f5828c64a6">subpavings::CollatorSPVnode::nodeAccumulationMultVol</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the accumulated summary multiplied by volume for a node.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum over the summary for this node x node volume. </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00245">245</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
            <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a5fb3b27a05bb36fc409ed1ffe17cab9f">nodeAccumulation</a>() * <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>());
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7a6318a53eb8efeecc8ea81244c98859"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeAdoptLeft" ref="a7a6318a53eb8efeecc8ea81244c98859" args="(CollatorSPVnode *lChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a7a6318a53eb8efeecc8ea81244c98859">subpavings::CollatorSPVnode::nodeAdoptLeft</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. This adopts a left child rather than attempting to reunite two children into this. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00958">958</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="keywordtype">size_t</span> i = 0;

        <span class="keywordtype">size_t</span> n = (lChild-&gt;summary).size();

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.empty()) { <span class="comment">// no summary in this box already</span>
            <span class="comment">// put into this summary the summary of the new child</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back((lChild-&gt;summary)[i]);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// has summary already</span>

            <span class="comment">// we have to make summary for this match</span>
            <span class="comment">// that of the children</span>
            <span class="comment">// number of elements in this summary should = child</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.size() != n) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Summaries do not match&quot;</span>);;
            }

            <span class="comment">// store current summary temporarily</span>
            <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp_summary = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>;

            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.clear();

            <span class="comment">// put into this summary the average of</span>
            <span class="comment">// the summary of the new child and the old summary</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back(((lChild-&gt;summary)[i]
                                + temp_summary[i])/2.0);
            }
        }

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddLeft() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(lChild);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a47cfd580379397fa0f713de7306a65c3"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeAdoptRight" ref="a47cfd580379397fa0f713de7306a65c3" args="(CollatorSPVnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a47cfd580379397fa0f713de7306a65c3">subpavings::CollatorSPVnode::nodeAdoptRight</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a right child rather than attempting to reunite two children into this. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01003">1003</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>
        <span class="keywordtype">size_t</span> i = 0;

        <span class="keywordtype">size_t</span> n = (rChild-&gt;summary).size();

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.empty()) { <span class="comment">// no summary in this box already</span>
            <span class="comment">// put into this summary the summary of the new child</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back((rChild-&gt;summary)[i]);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// has summary already</span>

            <span class="comment">// we have to make summary for this match</span>
            <span class="comment">// that of the children</span>
            <span class="comment">// number of elements in this summary should = child</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.size() != n) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Summaries do not match&quot;</span>);
            }
            <span class="comment">// store current summary temporarily</span>
            <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp_summary = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>;

            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.clear();

            <span class="comment">// put into this summary the average of the summary</span>
            <span class="comment">// of the new child and the old summary</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.push_back(((rChild-&gt;summary)[i]
                                + temp_summary[i])/2.0);
            }
        }

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddRight() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(rChild);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a61360380c921f78c1ac9689ffe004c60"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeCheckColSummary" ref="a61360380c921f78c1ac9689ffe004c60" args="(int theta, int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a61360380c921f78c1ac9689ffe004c60">subpavings::CollatorSPVnode::nodeCheckColSummary</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos matrix against the rows. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>current split number </td></tr>
    <tr><td class="paramname">k</td><td>split number in the set 0:(theta-1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01435">1435</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">getYatSet()</a>.</p>
<div class="fragment"><pre class="fragment">   { 
     <span class="comment">//cout &lt;&lt; &quot;checking for Yat at node: &quot; &lt;&lt; getNodeName() &lt;&lt; endl;     </span>
      <span class="comment">//cout &lt;&lt; &quot;theta: &quot; &lt;&lt; theta &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;k: &quot; &lt;&lt; k &lt;&lt; endl;</span>
      <span class="comment">//cout &lt;&lt; summary[theta] &lt;&lt; &quot;\t&quot; &lt;&lt; summary[k] &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[k] &gt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[theta])) {
    <span class="comment">//cout &lt;&lt; &quot;height at &quot; &lt;&lt; k &lt;&lt; &quot; larger than height at &quot; &lt;&lt; theta &lt;&lt; endl;</span>
         <span class="keywordflow">return</span> <span class="keyword">true</span>;
      }   
    <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <span class="keyword">false</span>; }    
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a199762d07823cde9934100fb6d11228c"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeCheckRowSummary" ref="a199762d07823cde9934100fb6d11228c" args="(int theta, int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a199762d07823cde9934100fb6d11228c">subpavings::CollatorSPVnode::nodeCheckRowSummary</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matrix against the columns. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>current split number </td></tr>
    <tr><td class="paramname">k</td><td>split number in the set 0:(theta-1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01420">1420</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramVCollator::getYatracosClassAll()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01466">getYatSet()</a>.</p>
<div class="fragment"><pre class="fragment">   { 
     <span class="comment">//out &lt;&lt; &quot;checking for Yat at node: &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
     <span class="comment">//cout &lt;&lt; &quot;theta: &quot; &lt;&lt; theta &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;k: &quot; &lt;&lt; k &lt;&lt; endl;     </span>
     <span class="comment">//cout &lt;&lt; summary[theta] &lt;&lt; &quot;\t&quot; &lt;&lt; summary[k] &lt;&lt; endl;</span>
      
      <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[theta] &gt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[k])) {
    <span class="comment">//cout &lt;&lt; &quot;height at &quot; &lt;&lt; theta &lt;&lt; &quot; larger than height at &quot; &lt;&lt; k &lt;&lt; endl;</span>
            <span class="keywordflow">return</span> <span class="keyword">true</span>;          
      } <span class="comment">// end of filling up rows</span>
      <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
   }   
</pre></div>
</div>
</div>
<a class="anchor" id="a8493e447407309758e72abcd2a6faf6a"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeDifference" ref="a8493e447407309758e72abcd2a6faf6a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a8493e447407309758e72abcd2a6faf6a">subpavings::CollatorSPVnode::nodeDifference</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00224">224</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
            <span class="keywordtype">double</span> diff = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[1] + <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[2]; 
            <span class="keywordflow">return</span> diff;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ae6555e847a720e43c07ad0c56788f9b6"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeExpand" ref="ae6555e847a720e43c07ad0c56788f9b6" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae6555e847a720e43c07ad0c56788f9b6">subpavings::CollatorSPVnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand leaf node to make two more leaves as children and copy summary and Vemp down to the children. </p>
<p>Equivalent to bisecting a box in a regular subpaving. Makes two new sibling child nodes of this one and grafts them on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>is the dimension on which to bisect theBox. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">762</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">subpavings::SPnode::setNodeName()</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00081">Vemp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="keywordflow">try</span>
         {
             <span class="comment">// only do something if this CollatorSPVnode is a leaf</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                 <span class="comment">// ivectors to become boxes for new children</span>
                 ivector lC, rC;
                 <span class="comment">// Call Lower() and Upper() to put split boxes</span>
                 <span class="comment">// into lC and rC respectively</span>
                 <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lC, comp);
                 <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rC, comp);
 
                 <span class="comment">// make and add the new children</span>
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(lC, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>, <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>, <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a>));
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(rC, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>, <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>, <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4" title="Empirical measure for the validation data from the collated subpavings.">Vemp</a>));
 
                 <span class="comment">//name the new children</span>
                 <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
                 <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);

                <span class="comment">// new children have summary from this</span>
        }
      }

    <span class="keywordflow">catch</span> (bad_alloc&amp;)
    {
         std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in &quot;</span>
            &lt;&lt; <span class="stringliteral">&quot;CollatorSPVnode::nodeExpand()&quot;</span>
            &lt;&lt; std::endl;
         <span class="keywordflow">throw</span>;
    }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a43e370d7120f8cc8c1cde489f61e7fc5"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeExpand" ref="a43e370d7120f8cc8c1cde489f61e7fc5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ae6555e847a720e43c07ad0c56788f9b6">subpavings::CollatorSPVnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand leaf node to make two more leaves as children and copy summary and Vemp down to the children. </p>
<p>Finds the dimension to split on and passes to NodeExpand(int comp) to carry out the bisection. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00798">798</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>.</p>
<div class="fragment"><pre class="fragment">   {
      <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
    <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
      <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a43e370d7120f8cc8c1cde489f61e7fc5" title="Expand leaf node to make two more leaves as children and copy summary and Vemp down to the children...">nodeExpand</a>(maxdiamcomp); <span class="comment">// complete nodeExpand</span>
 
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a0c7ea11fa66829ec974813779c052c61"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodeNegate" ref="a0c7ea11fa66829ec974813779c052c61" args="(double c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a0c7ea11fa66829ec974813779c052c61">subpavings::CollatorSPVnode::nodeNegate</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negates the summary for every node in tree rooted at this. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">1303</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">nodeNegate()</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">nodeNegate()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01243">subtractPavings()</a>.</p>
<div class="fragment"><pre class="fragment">   {
      <span class="comment">// transform(summary.begin(), summary.end(), summary.begin(),</span>
      <span class="comment">//                                negate&lt;double&gt;());</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.size(); i++) {  
      <span class="keywordtype">double</span> temp = c * <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[i];
      <span class="keywordflow">if</span> ( temp == -0) { temp = 0; }
      summary[i] = temp;        
    }

        <span class="comment">// recurse on children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a0c7ea11fa66829ec974813779c052c61" title="Negates the summary for every node in tree rooted at this.">nodeNegate</a>(c);
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a0c7ea11fa66829ec974813779c052c61" title="Negates the summary for every node in tree rooted at this.">nodeNegate</a>(c);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a782737eae50163bbae2dc9c4b5e23aec"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodePrint" ref="a782737eae50163bbae2dc9c4b5e23aec" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a782737eae50163bbae2dc9c4b5e23aec">subpavings::CollatorSPVnode::nodePrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the details of a specific node. </p>
<p>This is intended for console output or output to a mixed alpha and numeric file. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#aaf14185437d50e955c5ea938dc6e7559">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00726">726</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00516">getVemp()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="comment">// output for box in form:</span>
         <span class="comment">// box, volume, summary data</span>
 
         <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>
 
            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>
 
            <a class="code" href="namespacesubpavings.shtml#af79bf496cfc0df4bddcbe13a62f12bff" title="Define type NodeDataItr as a NodeData iterator.">NodeDataItr</a> dataItr;
 
            os &lt;&lt; <span class="stringliteral">&quot;Box is :&quot;</span>;
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
                 <span class="comment">// c-xsc default output for intervals</span>
                 os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; thisBox[i];   
        }
 
        os &lt;&lt; std::endl;
        os &lt;&lt; <span class="stringliteral">&quot;Box volume is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>() &lt;&lt; std::endl;
        os &lt;&lt; <span class="stringliteral">&quot;Empirical measure is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ac3cc6fb2f09dc7d6d99b52631fc4f60e" title="Accessor for the validation summary.">getVemp</a>() &lt;&lt; std::endl;
        os &lt;&lt; <span class="stringliteral">&quot;Summary data: &quot;</span> ;
 
        <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
        <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
          os &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
        }
             os &lt;&lt; std::endl;
      }
            
      <span class="keywordflow">return</span> os;
      }
</pre></div>
</div>
</div>
<a class="anchor" id="abef4fa1adf9483d78e21350712864fd2"></a><!-- doxytag: member="subpavings::CollatorSPVnode::nodesReunite" ref="abef4fa1adf9483d78e21350712864fd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#abef4fa1adf9483d78e21350712864fd2">subpavings::CollatorSPVnode::nodesReunite</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to reunite nodes to form one leaf. </p>
<p>Note that the nodes provided, lChild and rChild, are not the actual children of this, they are potential children which we are trying to either totally bring into this (if there are two of them) or to graft onto this if there is only one of them. This is typically a new, part-formed node whose formation can be completed by reuniting already two already-formed nodes into it or by adding on one child if only one is available. nodeReunite is used in building a tree upwards (rather than in pruning leaves of formed tree from the bottom up).</p>
<p>If two potential children are provided and they are both leaves, it combines the two leaf siblings into this. If the potential children are not leaves or if only one potential child is provided, it grafts the potential child/children onto this as its child/children.</p>
<p>Summary data associated with the children is related to the new parent.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>nodeReunite would not normally be used with CollatorSPnodes but is in the base class and is reimplemented to try do it appropriately for this derived class should it be needed. This function is untested. </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">817</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00212">nodeAccumulation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">nodesReunite()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">nodesReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
      <span class="comment">//  cout &lt;&lt; &quot;calling nodesReunite&quot; &lt;&lt; endl;</span>
     
     <span class="comment">/*</span>
<span class="comment">      // *this is the node which will become the parent</span>
<span class="comment">        </span>
<span class="comment">      // check that the labels match and exit if not</span>
<span class="comment">        if ((lChild-&gt;label != label ) || (rChild-&gt;label != label)) {</span>
<span class="comment">            throw SPnodeException(&quot;Labels do not match&quot;);</span>
<span class="comment">        }</span>
<span class="comment">      </span>
<span class="comment">        // if both subpavings are leaves and hull of boxes is x</span>
<span class="comment">        // discard them: *this is a leaf</span>
<span class="comment">        if (lChild-&gt;isLeaf() &amp;&amp; rChild-&gt;isLeaf()) {</span>
<span class="comment">        cout &lt;&lt; &quot;both are leaves&quot; &lt;&lt; endl;</span>
<span class="comment">         if (*theBox != (*(lChild-&gt;theBox) |</span>
<span class="comment">                            *(rChild-&gt;theBox))) {</span>
<span class="comment">                throw SPnodeException(&quot;Boxes cannot be combined&quot;);</span>
<span class="comment"></span>
<span class="comment">            }               </span>
<span class="comment">        // how many elements in the left child&#39;s summary</span>
<span class="comment">            size_t n = (lChild-&gt;summary).size();</span>
<span class="comment">            // elements in summary for each child should be same</span>
<span class="comment">            if ((rChild-&gt;summary).size() != n) {</span>
<span class="comment">                throw SPnodeException(&quot;Summaries cannot be combined&quot;);</span>
<span class="comment"></span>
<span class="comment">            }</span>
<span class="comment">            // put into this summary the average of summary of children</span>
<span class="comment">            size_t i = 0;</span>
<span class="comment">        for (i=0; i &lt; n; i++) {</span>
<span class="comment">           //to take note</span>
<span class="comment">                summary.push_back(((lChild-&gt;summary)[i]</span>
<span class="comment">                                +(rChild-&gt;summary)[i])/2.0);</span>
<span class="comment">            }   </span>
<span class="comment">            //discard the two subpavings given</span>
<span class="comment">        delete lChild;</span>
<span class="comment">            delete rChild;</span>
<span class="comment">        }</span>
<span class="comment"></span>
<span class="comment">        else {  // at least one child is not a leaf</span>
<span class="comment">            // this has to adopt them rather than reuniting them</span>
<span class="comment">        cout &lt;&lt; &quot;at least one child is not a leaf&quot; &lt;&lt; endl;</span>
<span class="comment">            nodeAdoptLeft(lChild);</span>
<span class="comment">            nodeAdoptRight(rChild);</span>
<span class="comment">            recursiveRename();</span>
<span class="comment">        }</span>
<span class="comment">      */</span>
      
      <span class="comment">//only propagate if nodeAccumulation for both left and right child are</span>
      <span class="comment">// the same</span>
      
     <span class="comment">// cout &lt;&lt; getNodeName() &lt;&lt; endl;</span>
  
      <span class="comment">// first recursively deal with the children of the children           </span>
       <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>())
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#abef4fa1adf9483d78e21350712864fd2" title="Try to reunite nodes to form one leaf.">nodesReunite</a>();
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>())
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#abef4fa1adf9483d78e21350712864fd2" title="Try to reunite nodes to form one leaf.">nodesReunite</a>();

      <span class="comment">// now deal with this</span>
      <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
          <span class="comment">//cout &lt;&lt; &quot;both are leaves&quot; &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; getLeftChild()-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; getRightChild()-&gt;getNodeName() &lt;&lt; endl;</span>
        <span class="comment">//  cout &lt;&lt; getLeftChild()-&gt;nodeAccumulation() &lt;&lt; &quot;\t&quot; &lt;&lt; getRightChild()-&gt;nodeAccumulation() &lt;&lt; endl;</span>
          
          <span class="keywordflow">if</span> ( ((<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a5fb3b27a05bb36fc409ed1ffe17cab9f">nodeAccumulation</a>())==0) &amp;&amp; 
              ((<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a5fb3b27a05bb36fc409ed1ffe17cab9f">nodeAccumulation</a>())==0) ) {
        <span class="comment">//    cout &lt;&lt; &quot;----reunite to get &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
            
            <span class="keywordtype">size_t</span> i = 0;
            <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>.size();
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
              <span class="comment">//to take note</span>
              <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>[i]=(((<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>)[i]
                        +(<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a>)[i]));
            <span class="comment">//  cout &lt;&lt; &quot;reunited summary: &quot; &lt;&lt; ((getLeftChild()-&gt;summary)[i]</span>
            <span class="comment">//            +(getRightChild()-&gt;summary)[i]) &lt;&lt; endl;</span>
            }   
            <span class="comment">//discard the two children</span>
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>;
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
          } 
        } 
      }
   } <span class="comment">// end of function</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a36bedf0d99a2a3e1a0188c24b68c2e18"></a><!-- doxytag: member="subpavings::CollatorSPVnode::operator=" ref="a36bedf0d99a2a3e1a0188c24b68c2e18" args="(const CollatorSPVnode &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp; subpavings::CollatorSPVnode::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">399</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">summary</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="keywordflow">try</span> {
 
            <span class="comment">// delete the current children (deletes their children as well)</span>
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> != NULL) {
                 <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>();
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
             }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> != NULL) {
                 <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>();
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
             }
            <span class="comment">// and delete the current box</span>
             <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) {
               <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>;
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = NULL;
            }

            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>=NULL;
 
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(*rhs.theBox);
             <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = rhs.dimension;
             <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = rhs.label;
             <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = rhs.nodeName;
 
             <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92" title="A container of summary values from the collated subpavings.">summary</a> = rhs.summary;
 
             <span class="comment">//recursion on the children</span>
             <span class="keywordflow">if</span> (rhs.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(
                     *(rhs.getLeftChild())));
             }
             <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;
 
            <span class="keywordflow">if</span> (rhs.rightChild) {
                 <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(
                     *(rhs.getRightChild())));
             }
             <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
         }
         <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
             <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
             std::cout &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
         }
 
         <span class="keywordflow">return</span> *<span class="keyword">this</span>;

     }
</pre></div>
</div>
</div>
<a class="anchor" id="ab662ab5025178c145b83b386ef475415"></a><!-- doxytag: member="subpavings::CollatorSPVnode::subtractPavings" ref="ab662ab5025178c145b83b386ef475415" args="(const CollatorSPVnode *const lhs, const CollatorSPVnode *const rhs, double c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ab662ab5025178c145b83b386ef475415">subpavings::CollatorSPVnode::subtractPavings</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract one collator subpavings from another together. </p>
<p>Collator returned has tree which is the union of lhs and rhs trees and summary with lhs summary and negative of rhs summary values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to the root of one collator. </td></tr>
    <tr><td class="paramname">lhs</td><td>pointer to the root of the other collator to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the root of a new collator subpaving where the summmary is the summary of lhs and the negative values from the summary of rhs. </dd></dl>

<p>Definition at line <a class="el" href="collatorspvnode_8cpp_source.shtml#l01243">1243</a> of file <a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00259">CollatorSPVnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">nodeNegate()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00233">subpavings::AdaptiveHistogramVCollator::operator-()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        cout &lt;&lt; <span class="stringliteral">&quot;subtract pavings called&quot;</span> &lt;&lt; endl;
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>* newCollator = NULL;

        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (lhs == NULL &amp;&amp; rhs == NULL) done = <span class="keyword">true</span>; <span class="comment">// return null</span>

            <span class="keywordflow">if</span> (!done &amp;&amp; lhs == NULL &amp;&amp; rhs != NULL) {

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*rhs);
                newCollator-&gt;nodeNegate(c);

                done = <span class="keyword">true</span>;

            }
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs == NULL) {

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*lhs);
                done = <span class="keyword">true</span>;
            }
            <span class="comment">// both not null</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs != NULL) {

                <span class="keywordflow">if</span> ((lhs-&gt;getBox() != NULL) &amp;&amp;
                                (lhs-&gt;getBox() != rhs-&gt;getBox())) {
                    <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes do not match&quot;</span>);
                }

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#afc907faf6fc53e9fdea4c6895e14a42c" title="default constructor.">CollatorSPVnode</a>(*lhs);
                newCollator-&gt;addNegatedPaving(rhs, c);  <span class="comment">// uses a temp copy of rhs</span>
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addPavings&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newCollator;
    }
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad85d48d6c14888cc7d375f74b63c2f92"></a><!-- doxytag: member="subpavings::CollatorSPVnode::summary" ref="ad85d48d6c14888cc7d375f74b63c2f92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#ad85d48d6c14888cc7d375f74b63c2f92">subpavings::CollatorSPVnode::summary</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container of summary values from the collated subpavings. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8hpp_source.shtml#l00076">76</a> of file <a class="el" href="collatorspvnode_8hpp_source.shtml">collatorspvnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00314">CollatorSPVnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01448">getNodeDelta()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00520">getNumberSummarised()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01397">getScheffeNode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00512">getSummary()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00547">leafOutputTabs()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00453">makeAverageCollation()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00958">nodeAdoptLeft()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01003">nodeAdoptRight()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01435">nodeCheckColSummary()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01420">nodeCheckRowSummary()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">nodeExpand()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01303">nodeNegate()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00726">nodePrint()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00817">nodesReunite()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00399">operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a31cd9926485cf1190effb77a9ce8dac4"></a><!-- doxytag: member="subpavings::CollatorSPVnode::Vemp" ref="a31cd9926485cf1190effb77a9ce8dac4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml#a31cd9926485cf1190effb77a9ce8dac4">subpavings::CollatorSPVnode::Vemp</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Empirical measure for the validation data from the collated subpavings. </p>

<p>Definition at line <a class="el" href="collatorspvnode_8hpp_source.shtml#l00081">81</a> of file <a class="el" href="collatorspvnode_8hpp_source.shtml">collatorspvnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">addPavingWithVal()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00314">CollatorSPVnode()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00516">getVemp()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l00762">nodeExpand()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="collatorspvnode_8hpp_source.shtml">collatorspvnode.hpp</a></li>
<li><a class="el" href="collatorspvnode_8cpp_source.shtml">collatorspvnode.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:33 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
