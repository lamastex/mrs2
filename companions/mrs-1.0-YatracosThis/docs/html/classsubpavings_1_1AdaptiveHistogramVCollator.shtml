<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::AdaptiveHistogramVCollator Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1AdaptiveHistogramVCollator.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::AdaptiveHistogramVCollator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::AdaptiveHistogramVCollator" -->
<p>A wrapper or manager for a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>.  
 <a href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml">adaptivehistogramvcollator.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::AdaptiveHistogramVCollator:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1AdaptiveHistogramVCollator__coll__graph.png" border="0" usemap="#subpavings_1_1AdaptiveHistogramVCollator_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1AdaptiveHistogramVCollator_coll__map" id="subpavings_1_1AdaptiveHistogramVCollator_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1AdaptiveHistogramVCollator-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#addfe1e7d9ec6cfeed3bcbd6f35ce98b2">AdaptiveHistogramVCollator</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#addfe1e7d9ec6cfeed3bcbd6f35ce98b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a28798e968c6693434cd189a64b185b96">AdaptiveHistogramVCollator</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;adh, int whatSum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">initialised constructor. Initialised with an AdaptiveHistogramVal object.  <a href="#a28798e968c6693434cd189a64b185b96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab2c174cc93b8d61a5dae5d698a47e392">AdaptiveHistogramVCollator</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#ab2c174cc93b8d61a5dae5d698a47e392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#af0f2129ebf8fc93357f877c5bac8e5b8">AdaptiveHistogramVCollator</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;other, int toSubtract)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for the subtracted ADHVC.  <a href="#af0f2129ebf8fc93357f877c5bac8e5b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a06855795e0d1d9c5a268ec91153346d4">operator=</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a06855795e0d1d9c5a268ec91153346d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ae8856c3f66db77b6f0ce896ff4f54ce5">operator+=</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a56acb0f59cd7c99a5ef8db73fd2b3294">operator-</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;rhs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7fdc8a90199d4b39d4fb9179a8aada56">~AdaptiveHistogramVCollator</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a7fdc8a90199d4b39d4fb9179a8aada56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1d9fe1618884a4cdbfc211a04dcd4a65">makeAverage</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4fc5807fde8de008b9551f6347c6d46e">getSubPaving</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> this manages.  <a href="#a4fc5807fde8de008b9551f6347c6d46e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173">getNumberCollated</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Adaptive Histogram objects collated.  <a href="#a7268bf31ef2baf216134f5751e5c6173"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a6cbc7efc97efaa397a6ed5c38b817e3a">outputGraphDot</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a .dot graph file from collated histogram structure.  <a href="#a6cbc7efc97efaa397a6ed5c38b817e3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#af05a34e32911a81b2af37529994bae57">outputAverageToTxtTabs</a> (const std::string &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output average normalised histogram over collation to a txt file.  <a href="#af05a34e32911a81b2af37529994bae57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a95cf6201a4b2259eb5138193affc5f6b">outputAccumulationToTxtTabs</a> (const std::string &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the accumulated data over the collation to a txt file.  <a href="#a95cf6201a4b2259eb5138193affc5f6b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ac58c3f7d536168d4c9c8cbceb95b1908">outputDifferenceToTxtTabs</a> (const std::string &amp;s) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad2a470a3974ad963de7debb7fe870efe">outputToTxtTabs</a> (const std::string &amp;s) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the collated information to a txt file.  <a href="#ad2a470a3974ad963de7debb7fe870efe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a3a6ff433649c11815e6be5dbd04977bf">outputToTxtTabs</a> (const std::string &amp;s, int whichColl) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02">addToCollationWithVal</a> (const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;adh, int whatSum, size_t &amp;agg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an AdaptiveHistogramVal object to the collation.  <a href="#a5db65fac4ff8b3de933909f6d83f8e02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab38cfd38290579694a35950af5c80c36">getSplitNodePtr</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&amp;splitCollNode, <a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> pointer to the corresponding <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> that was split.  <a href="#ab38cfd38290579694a35950af5c80c36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad94f1c5c6943e7bb35e74030af5113fd">getYatracosClassAll</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const splitCollNode, std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecRowYatSet, std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecColYatSet, std::list&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;listYatSet)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Yatracos set.  <a href="#ad94f1c5c6943e7bb35e74030af5113fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b">getNodesDelta</a> (std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;YatSet, int thisTheta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the delta value for each Yatracos element at the specified split number.  <a href="#a174349942bc7f76e6804aeb3714d1f3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a045c1338ed19503f5485f40ee7d2e218">getNodesMaxDelta</a> (std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecYatSet, int thisTheta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a741a4e9b7dac5673c641b3a991b4a419">getYatracosDelta</a> (std::list&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;listYatSet, std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecRowYatSet, std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecColYatSet, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecMaxDeltaVec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum delta values for all thetas for the Yatracos Class.  <a href="#a741a4e9b7dac5673c641b3a991b4a419"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a6b81c529e7249fa666b288e24cbac5fd">getBisectionSearchEstimate</a> (int method, std::vector&lt; size_t &gt; &amp;winner, std::vector&lt; size_t &gt; &amp;loser, std::vector&lt; double &gt; &amp;deltaWinner, std::vector&lt; double &gt; &amp;deltaLoser)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum distance estimate from the MDE method.  <a href="#a6b81c529e7249fa666b288e24cbac5fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a78eefcadb3a5247ce6712493b85976f9">getMinDistTheta</a> (std::vector&lt; std::vector&lt; int &gt; &gt; &amp;vecMinDistTheta, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaMaxVec, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thetas that gives the minimum distance. Get the thetas that gives the minimum distance. Write definition for the min. dist. theta here.  <a href="#a78eefcadb3a5247ce6712493b85976f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#adc9f2cb78559081ca925defe641bd583">getMinDelta</a> (int maxCheck, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaMaxVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab121bb960439438575c2115944990724">getInfDelta</a> (std::vector&lt; double &gt; &amp;vecInfDelta, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaMaxVec, int n)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the infimum delta value for all thetas.  <a href="#ab121bb960439438575c2115944990724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ivector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a53105611d6db4dc208275fd049475cd6">getRootBox</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the root box. Get the root box of the <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> object.  <a href="#a53105611d6db4dc208275fd049475cd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab9c2ad2ebbf0f50de0e06f92f222f0a7">makeMinimal</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a503d9bbe2f7854466570bad4fd2d0d42">getLeafLevelsString</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get leaf levels string  <a href="#a503d9bbe2f7854466570bad4fd2d0d42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a49437661609894461106a99c37ddeed5">getTotalNodes</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Get the Scheffe Tournament Winner</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Exhaustive and bisection search. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listScheffeSet</td><td>the list of set of pointers to sets of <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a> (pointers to the leaf boxes) </td></tr>
    <tr><td class="paramname">vecScheffeSet</td><td>the current vector of pointers to sets of <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a> (pointers to the leaf boxes) </td></tr>
    <tr><td class="paramname">vecWinnerVec</td><td>the updated vector of vectors of tournament winners </td></tr>
    <tr><td class="paramname">vecDeltaWinnerVec</td><td>the updated vector of vectors of delta of winners </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aa66a678df6a370f60bb7141ddb28a043">getScheffeSetAll</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const splitNode, vector&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecScheffeSet, list&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;listScheffeSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4b3830bf47fe4738c22f4a53858d90fc">getScheffeWinner</a> (std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecScheffeSet, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;vecWinnerVec, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaWinnerVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a8f7b4de816404be827c1b201aa0d6edc">getHistScheffeSet</a> (std::vector&lt; std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &gt; &amp;vecScheffeSetVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a596a34b5f83f532160c5ab9104d6aa00">getHistYatSet</a> (std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;vecYatSet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1ea3cb0ee5fea756fc45445fec2db166">getHistScheffeWinner</a> (std::vector&lt; std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &gt; &amp;vecScheffeSetVec, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;vecWinnerVec, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaWinnerVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a130f3418c9610b38030221924a846011">getMinDistEst</a> (std::vector&lt; double &gt; &amp;maxDelta, std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;veYatSet)</td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1c28c75c070df4a922a066092cd7427e">AdaptiveHistogramVCollator</a> (<a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Private initialised constructor.  <a href="#a1c28c75c070df4a922a066092cd7427e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac">rootVCollator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the root <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>.  <a href="#aceeaa0eac30ad826088e670544e1fcac"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A wrapper or manager for a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>. </p>
<p><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> class objects manage <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a> objects for the purpose of collating information from a number of AdaptiveHistogramVal objects.</p>
<p>The <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a>'s <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> tree represents the subpaving that is the union of all the subpavings associated with each AdaptiveHistogramVal in the collation. Each node in the tree has two data members: a container structure holding one value for each collated histogram's training data and a double corresponding to the empirical measure of the histogram's validation data. For a collation of histograms the container holds the <b>normalised height</b> for each collated histogram of the histogram bin represented by the box of that node.</p>
<p>(The normalised height associated with a bin which is represented by the box of a leaf node of a tree managed by an AdaptiveHistogramVal object is the number of data points associated with that bin divided by (the total number of data points in the histogram x the volume of the bin). Thus the areas (heights x volumes) of the bins sum to 1.</p>
<p>Since the tree represents the union of the subpavings associated with each AdaptiveHistogramVal in the collation, the collation tree will have at least as many and usually more bins than any of the collated histograms.</p>
<p>Each collated histogram will be represented in the summaries in the order in which it was added to the collation. Eg, the heights of the bins of the first histogram to be collated will be first (index [1]) in the summary container.</p>
<p>If the collated AdaptiveHistogramVals have been properly formed and added to the collation, the sum, over all the leaf nodes of the collation, of the volume of the box of the leaf node multiplied by the values of the leaf node summary corresponding a particular collated histogram will be 1 for each collated histogram. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml#l00076">76</a> of file <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml">adaptivehistogramvcollator.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1c28c75c070df4a922a066092cd7427e"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::AdaptiveHistogramVCollator" ref="a1c28c75c070df4a922a066092cd7427e" args="(CollatorSPVnode *spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1c28c75c070df4a922a066092cd7427e">AdaptiveHistogramVCollator::AdaptiveHistogramVCollator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td><code> [explicit, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Private initialised constructor. </p>
<p>Initialised with pointer to subpaving. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00063">63</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL == spn) {
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Null CollatorSPVnode pointer in constructor&quot;</span>);
    }
    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = spn;
}    
</pre></div>
</div>
</div>
<a class="anchor" id="addfe1e7d9ec6cfeed3bcbd6f35ce98b2"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::AdaptiveHistogramVCollator" ref="addfe1e7d9ec6cfeed3bcbd6f35ce98b2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1c28c75c070df4a922a066092cd7427e">AdaptiveHistogramVCollator::AdaptiveHistogramVCollator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00076">76</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>();
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor: original error &quot;</span>
                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a28798e968c6693434cd189a64b185b96"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::AdaptiveHistogramVCollator" ref="a28798e968c6693434cd189a64b185b96" args="(const AdaptiveHistogramValidation &amp;adh, int whatSum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1c28c75c070df4a922a066092cd7427e">AdaptiveHistogramVCollator::AdaptiveHistogramVCollator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>adh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatSum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>initialised constructor. Initialised with an AdaptiveHistogramVal object. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00091">91</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">subpavings::AdaptiveHistogramValidation::getSubPaving()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>(adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>(), whatSum);
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor: original error &quot;</span>
                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab2c174cc93b8d61a5dae5d698a47e392"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::AdaptiveHistogramVCollator" ref="ab2c174cc93b8d61a5dae5d698a47e392" args="(const AdaptiveHistogramVCollator &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1c28c75c070df4a922a066092cd7427e">AdaptiveHistogramVCollator::AdaptiveHistogramVCollator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00107">107</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml#l00099">rootVCollator</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>(*(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>));
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std:: endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;SPnodeException in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor: &quot;</span> + msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af0f2129ebf8fc93357f877c5bac8e5b8"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::AdaptiveHistogramVCollator" ref="af0f2129ebf8fc93357f877c5bac8e5b8" args="(const AdaptiveHistogramVCollator &amp;other, int toSubtract)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1c28c75c070df4a922a066092cd7427e">AdaptiveHistogramVCollator::AdaptiveHistogramVCollator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toSubtract</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor for the subtracted ADHVC. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00134">134</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml#l00099">rootVCollator</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>(*(other.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>), toSubtract);
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std:: endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;SPnodeException in constructor: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in constructor: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in constructor: &quot;</span> + msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7fdc8a90199d4b39d4fb9179a8aada56"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::~AdaptiveHistogramVCollator" ref="a7fdc8a90199d4b39d4fb9179a8aada56" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7fdc8a90199d4b39d4fb9179a8aada56">AdaptiveHistogramVCollator::~AdaptiveHistogramVCollator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00276">276</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>; }
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5db65fac4ff8b3de933909f6d83f8e02"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::addToCollationWithVal" ref="a5db65fac4ff8b3de933909f6d83f8e02" args="(const AdaptiveHistogramValidation &amp;adh, int whatSum, size_t &amp;agg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a5db65fac4ff8b3de933909f6d83f8e02">AdaptiveHistogramVCollator::addToCollationWithVal</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml">AdaptiveHistogramValidation</a> &amp;&#160;</td>
          <td class="paramname"><em>adh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whatSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>agg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an AdaptiveHistogramVal object to the collation. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00466">466</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00543">subpavings::AdaptiveHistogramValidation::getSubPaving()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02257">subpavings::spTotalNodes()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="AirTraffic_8cpp_source.shtml#l00043">main()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
     <span class="keywordflow">try</span> {
        <span class="comment">// make the AdaptiveHistogram into a new CollatorSPVnode</span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> toAdd(adh.<a class="code" href="classsubpavings_1_1AdaptiveHistogramValidation.shtml#a6449b127c16423141cbed8f193cfcf59" title="Return a pointer to the SPSVnode this manages.">getSubPaving</a>(), whatSum);
        <span class="comment">// add the new CollatorSPVnode into the collation</span>
        <span class="comment">// note that addPaving will alter toAdd, but that is okay because</span>
        <span class="comment">// toAdd is a temporary object created and deleted in this procedure</span>
        <span class="keywordtype">bool</span> successfullyAdded = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#af01fff5efb1889862b36606bed10746a" title="Add paving with Vemp to collation.">addPavingWithVal</a>(&amp;toAdd);
      
      <span class="comment">//for space complexity purposes</span>
      agg = <a class="code" href="namespacesubpavings.shtml#aa737c3b183c306abbef9b3d515f632fb" title="Get the number of leaves of a tree (boxes in the subpaving)">spTotalNodes</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>);
      
        <span class="keywordflow">if</span> (!successfullyAdded) { <span class="comment">// addition returned false</span>
            std::cout &lt;&lt; <span class="stringliteral">&quot;Nothing added - check console output &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;for error messages&quot;</span> &lt;&lt; std::endl;
        }
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory adding to collation.  Orginal error: &quot;</span>
                                            + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6b81c529e7249fa666b288e24cbac5fd"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getBisectionSearchEstimate" ref="a6b81c529e7249fa666b288e24cbac5fd" args="(int method, std::vector&lt; size_t &gt; &amp;winner, std::vector&lt; size_t &gt; &amp;loser, std::vector&lt; double &gt; &amp;deltaWinner, std::vector&lt; double &gt; &amp;deltaLoser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a6b81c529e7249fa666b288e24cbac5fd">subpavings::AdaptiveHistogramVCollator::getBisectionSearchEstimate</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>winner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>loser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>deltaWinner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>deltaLoser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the minimum distance estimate from the MDE method. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">method,:</td><td>1. Scheffe tournament 2. Minimum distance estimate </td></tr>
    <tr><td class="paramname">winner</td><td>vector of winners </td></tr>
    <tr><td class="paramname">loser</td><td>vector for losers </td></tr>
    <tr><td class="paramname">deltaWinner</td><td>vector for deltas of winners </td></tr>
    <tr><td class="paramname">deltaLoser</td><td>vector for deltas of losers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f7b4de816404be827c1b201aa0d6edc"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getHistScheffeSet" ref="a8f7b4de816404be827c1b201aa0d6edc" args="(std::vector&lt; std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &gt; &amp;vecScheffeSetVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a8f7b4de816404be827c1b201aa0d6edc">AdaptiveHistogramVCollator::getHistScheffeSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecScheffeSetVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the Scheffe set from subpavings </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01144">1144</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="comment">//=============end of setting up containers================================// </span>
  <span class="keywordtype">int</span> numAdd = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>(); <span class="comment">// the number of histograms collated including the 0-th histogram</span>
  <span class="comment">//cout &lt;&lt; &quot;getNumberCollated: &quot; &lt;&lt; numAdd &lt;&lt; endl;</span>
  <span class="keywordtype">size_t</span> theta = numAdd-1; <span class="comment">// the current number of splits</span>

    <span class="comment">//============begin pairwise comparisons===================================//</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k &lt; numAdd; k++) {
    vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt; vecScheffeSet;
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 1; j &lt; numAdd; j++) {
      <span class="keywordflow">if</span> ( (k != j) &amp;&amp; (k &lt; j) ) {
        set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; currentScheffeSet;
        cout &lt;&lt; <span class="stringliteral">&quot;k= &quot;</span> &lt;&lt; k &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <span class="stringliteral">&quot;theta = &quot;</span> &lt;&lt; j &lt;&lt; endl;
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4fc5807fde8de008b9551f6347c6d46e" title="Return a pointer to the CollatorSPVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a8d430b2bdfb2d8032e5d7f9e9bddb53d" title="Get the Scheffe set for a particular pair.">getScheffeSet</a>(currentScheffeSet, k, j);
        <span class="comment">//if (currentScheffeSet.empty()) { cout &lt;&lt; &quot;nothing here&quot; &lt;&lt; endl; }</span>
        vecScheffeSet.push_back(currentScheffeSet);
      }
    }
    vecScheffeSetVec.push_back(vecScheffeSet);
  } <span class="comment">// end of pairwise comparisons</span>
} <span class="comment">// end of function getHistScheffeSet</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a1ea3cb0ee5fea756fc45445fec2db166"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getHistScheffeWinner" ref="a1ea3cb0ee5fea756fc45445fec2db166" args="(std::vector&lt; std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &gt; &amp;vecScheffeSetVec, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;vecWinnerVec, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaWinnerVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1ea3cb0ee5fea756fc45445fec2db166">AdaptiveHistogramVCollator::getHistScheffeWinner</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecScheffeSetVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecWinnerVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecDeltaWinnerVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00931">931</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <span class="comment">// go through each ordered pair to get the winner</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vecScheffeSetVec.size(); i++) {
    
    vector&lt;int&gt; WinnerVec(vecScheffeSetVec[i].size());
    vector&lt;double&gt; DeltaVec;

    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; vecScheffeSetVec[i].size(); j++) {

      <span class="keywordflow">if</span> ( vecScheffeSetVec[i][j].empty() ) {
        <span class="comment">//size_t cand1 = i;</span>
        <span class="comment">//size_t cand2 = j+i+1;</span>
        WinnerVec[j] = (-1);
        DeltaVec.push_back(-1*(numeric_limits&lt;double&gt;::infinity()));
        <span class="comment">//cout &lt;&lt; &quot;no scheffe set at position &quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; endl;</span>
        <span class="comment">//cout &lt;&lt; &quot;========&quot; &lt;&lt; endl;</span>
      } 
    
      <span class="keywordflow">else</span> {
        <span class="comment">//cout &lt;&lt; &quot;scheffe at position &quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; j &lt;&lt; endl;</span>
        <span class="keywordtype">size_t</span> cand1 = i;
        <span class="keywordtype">size_t</span> cand2 = j+i+1;
        cout &lt;&lt; cand1 &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; cand2 &lt;&lt; endl;

        <span class="comment">//cout &lt;&lt; &quot;----------get delta for &quot; &lt;&lt; cand1 &lt;&lt; endl;</span>
        <span class="keywordtype">double</span> deltaI = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>(vecScheffeSetVec[i][j], cand1);
        <span class="comment">//cout &lt;&lt; &quot;---------get delta for &quot; &lt;&lt; cand2 &lt;&lt; endl;</span>
        <span class="keywordtype">double</span> deltaJ = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>(vecScheffeSetVec[i][j], cand2);

        <span class="comment">// perform competition</span>
        <span class="keywordflow">if</span> ( deltaI &lt; deltaJ ) {
          <span class="comment">//cout &lt;&lt; cand1 &lt;&lt; &quot;\t&quot; &lt;&lt; deltaI &lt;&lt; &quot;\n&quot; &lt;&lt; cand2 &lt;&lt; &quot;\t&quot; &lt;&lt; deltaJ &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; &quot;Winner is: &quot; &lt;&lt; cand1 &lt;&lt; endl;</span>
          <span class="comment">// winner is i</span>
          WinnerVec[j] = (1);
          DeltaVec.push_back(deltaI);
        }
        <span class="keywordflow">else</span> { <span class="comment">// deltaTheta &gt;= delta </span>
          <span class="comment">//cout &lt;&lt; cand1 &lt;&lt; &quot;\t&quot; &lt;&lt; deltaI &lt;&lt; &quot;\n&quot; &lt;&lt; cand2 &lt;&lt; &quot;\t&quot; &lt;&lt; deltaJ &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; &quot;Winner is: &quot; &lt;&lt; cand2 &lt;&lt; endl;</span>
          WinnerVec[j] = (0);
          DeltaVec.push_back(deltaJ);
        }  <span class="comment">// end</span>
      } <span class="comment">// end of set not empty</span>
    } <span class="comment">// end of going through j</span>
    vecWinnerVec.push_back(WinnerVec);
    vecDeltaWinnerVec.push_back(DeltaVec);
  } <span class="comment">// end of going through vecScheffeSet</span>

} <span class="comment">// end of getHistScheffeWinner</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a596a34b5f83f532160c5ab9104d6aa00"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getHistYatSet" ref="a596a34b5f83f532160c5ab9104d6aa00" args="(std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecYatSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a596a34b5f83f532160c5ab9104d6aa00">AdaptiveHistogramVCollator::getHistYatSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecYatSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01168">1168</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="comment">//=============end of setting up containers================================// </span>
  <span class="keywordtype">int</span> numAdd = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>(); <span class="comment">// the number of histograms collated including the 0-th histogram</span>
  <span class="comment">//============begin pairwise comparisons===================================//</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k= 0; k &lt; numAdd; k++) {
    <span class="comment">// get A_ij</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; numAdd; j++) {
      <span class="keywordflow">if</span> ( (k != j) &amp;&amp; (k&lt;j) ) {
        set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; RowSet;
        set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; ColSet;
        <span class="comment">//cout &lt;&lt; &quot;k= &quot; &lt;&lt; k &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;theta = &quot; &lt;&lt; j &lt;&lt; endl;</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4fc5807fde8de008b9551f6347c6d46e" title="Return a pointer to the CollatorSPVnode this manages.">getSubPaving</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad0bdf61f72d586c8944c076e310b3240" title="Get the Yatracos set for a particular pair.">getYatSet</a>(RowSet, ColSet, k, j);
        vecYatSet.push_back(RowSet);
        vecYatSet.push_back(ColSet);
      }
    }
  } <span class="comment">// end of pairwise comparisons</span>
} <span class="comment">// end of function getHistScheffeSet</span>
</pre></div>
</div>
</div>
<a class="anchor" id="ab121bb960439438575c2115944990724"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getInfDelta" ref="ab121bb960439438575c2115944990724" args="(std::vector&lt; double &gt; &amp;vecInfDelta, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaMaxVec, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab121bb960439438575c2115944990724">AdaptiveHistogramVCollator::getInfDelta</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecInfDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecDeltaMaxVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the infimum delta value for all thetas. </p>
<p>Get the infimum delta value at each theta over the list of Yatracos leaf boxes for all thetas.</p>
<p>This may also be used as a stopping critera. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vecInfDelta</td><td>the current vector of vectors to the infimum delta values for each theta </td></tr>
    <tr><td class="paramname">vecMaxDeltaVec</td><td>a vector of vectors to the maximum delta values for each theta </td></tr>
    <tr><td class="paramname">n</td><td>sample size </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>vecInfDelta a vector of vectors to the infimum delta values for each theta </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01042">1042</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment"> {
   <span class="comment">//want the vector of DeltaMax at the last entry of vecMaxDeltaVec </span>
   vector&lt;double&gt; vecDeltaMax = vecMaxDeltaVec.back();

  <span class="comment">//  cout &lt;&lt; &quot;getting the upper limit&quot; &lt;&lt; endl;</span>
  <span class="comment">//  double DeltaInf = *(min_element(vecDeltaMax.begin(), vecDeltaMax.end()));</span>
    <span class="keywordtype">double</span> DeltaInf = *(min_element(vecDeltaMax.begin(), vecDeltaMax.end()));
    
    vecInfDelta.push_back(DeltaInf);      
    
    <span class="keywordflow">return</span> vecInfDelta;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a503d9bbe2f7854466570bad4fd2d0d42"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getLeafLevelsString" ref="a503d9bbe2f7854466570bad4fd2d0d42" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a503d9bbe2f7854466570bad4fd2d0d42">AdaptiveHistogramVCollator::getLeafLevelsString</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get leaf levels string </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01367">1367</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">   {
    <span class="keywordtype">string</span> retValue = <span class="stringliteral">&quot;&quot;</span>;
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>)
        retValue = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a7ea8cd3649cbf13d5743d3cb23315d72" title="Get a string of leaf node levels.">getLeafNodeLevelsString</a>();

    <span class="keywordflow">return</span> retValue;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="adc9f2cb78559081ca925defe641bd583"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getMinDelta" ref="adc9f2cb78559081ca925defe641bd583" args="(int maxCheck, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaMaxVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#adc9f2cb78559081ca925defe641bd583">AdaptiveHistogramVCollator::getMinDelta</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecDeltaMaxVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00990">990</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//want the vector of DeltaMax at the last entry of vecMaxDeltaVec </span>
  vector&lt;double&gt; vecDeltaMax = vecMaxDeltaVec.back();
  <span class="keywordtype">double</span> minDelta = *(min_element(vecDeltaMax.begin(), vecDeltaMax.end()));
  <span class="keywordtype">size_t</span> minPos = -1;
  
  vector&lt;bool&gt; signs;
  <span class="comment">//subtract each element from vecDeltaMax</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; vecDeltaMax.size(); i++) {
<span class="comment">//    cout &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; vecDeltaMax[i] &lt;&lt; &quot;\t&quot; &lt;&lt; minDelta &lt;&lt; endl;</span>
    <span class="keywordflow">if</span> ( vecDeltaMax[i]  &gt; minDelta ) { signs.push_back(1); }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( vecDeltaMax[i] == minDelta ) {  
      signs.push_back(0); 
      <span class="comment">// get the position at which the first time this happens</span>
      <span class="keywordflow">if</span> ( minPos == -1 ) { minPos = i; }
    }

    <span class="keywordflow">if</span> ( vecDeltaMax[i] &lt; minDelta ) {
      cerr &lt;&lt; <span class="stringliteral">&quot;vecDeltaMax[i] &lt; minDelta!&quot;</span> &lt;&lt; endl;
      exit(0);
    }
  }
  
<span class="comment">//  cout &lt;&lt; &quot;Min Delta at position &quot; &lt;&lt; minPos &lt;&lt; endl;</span>

  <span class="keywordtype">bool</span> toStop = <span class="keyword">false</span>;

  <span class="comment">//if the infimum is at the last theta - continue splitting</span>
<span class="comment">//  cout &lt;&lt; &quot;======check if minDelta is at the last row====&quot; &lt;&lt; endl;</span>
  <span class="keywordflow">if</span> ( minPos == (<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>()-1) ) { 
<span class="comment">//    cout &lt;&lt; &quot;continue splitting&quot; &lt;&lt; endl;</span>
    <span class="keywordflow">return</span> toStop;
  }
  
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( (<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>()-1) != minPos ) {
<span class="comment">//  cout &lt;&lt; &quot;======minDelta is not in the last row, check all the following deltas====&quot; &lt;&lt; endl;</span>
<span class="comment">//  cout &lt;&lt; &quot;=======now check if at least k of the following deltas are equal or greater =====&quot; &lt;&lt; endl;</span>
    <span class="keywordtype">int</span> flag = 0;
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = (minPos+1); i &lt; signs.size(); i++) {
<span class="comment">//      cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; &quot; sign: &quot; &lt;&lt; signs[i] &lt;&lt; endl;</span>
      flag++;
      cout &lt;&lt; <span class="stringliteral">&quot;flag:&quot;</span>  &lt;&lt; flag &lt;&lt; endl;
    }
  
    <span class="keywordflow">if</span> ( flag &gt;= maxCheck ) { <span class="keywordflow">return</span> toStop = <span class="keyword">true</span>;}
    <span class="keywordflow">else</span> { <span class="keywordflow">return</span> toStop = <span class="keyword">false</span>; }
  } <span class="comment">// end of else if</span>
} <span class="comment">// end of function</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a130f3418c9610b38030221924a846011"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getMinDistEst" ref="a130f3418c9610b38030221924a846011" args="(std::vector&lt; double &gt; &amp;maxDelta, std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;veYatSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a130f3418c9610b38030221924a846011">AdaptiveHistogramVCollator::getMinDistEst</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxDelta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>veYatSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01387">1387</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>Referenced by <a class="el" href="FinMixScheffe_8cpp_source.shtml#l00044">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//get the yatracos class for ALL the candidates</span>
  <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a596a34b5f83f532160c5ab9104d6aa00">getHistYatSet</a>(vecYatSet); 
  
  <span class="comment">//get the maximum delta at each &quot;theta&quot; - here theta refers to the position of the</span>
  <span class="comment">//candidate in the collator</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>(); i++) {
    <span class="comment">//get the maximum delta at this candidate</span>
    <span class="keywordtype">double</span> deltaMax = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a045c1338ed19503f5485f40ee7d2e218">getNodesMaxDelta</a>(vecYatSet, i);
    maxDelta.push_back(deltaMax);
  }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a78eefcadb3a5247ce6712493b85976f9"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getMinDistTheta" ref="a78eefcadb3a5247ce6712493b85976f9" args="(std::vector&lt; std::vector&lt; int &gt; &gt; &amp;vecMinDistTheta, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaMaxVec, int n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a78eefcadb3a5247ce6712493b85976f9">AdaptiveHistogramVCollator::getMinDistTheta</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecMinDistTheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecDeltaMaxVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the thetas that gives the minimum distance. Get the thetas that gives the minimum distance. Write definition for the min. dist. theta here. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vecMinDistTheta</td><td>the current vector of vectors of the thetas that gives the minimum distance for each theta </td></tr>
    <tr><td class="paramname">vecDeltaMaxVec</td><td>vector of vectors of the maximum delta values </td></tr>
    <tr><td class="paramname">n</td><td>sample size </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>vecMinDistTheta the updated vector of vectors of the thetas that gives the minimum distance for each theta </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00905">905</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{  
<span class="comment">//   cout &lt;&lt; &quot;Get the minimum:&quot; &lt;&lt; &quot;\t&quot; &lt;&lt; endl;</span>
  <span class="comment">//want the vector of DeltaMax at the last entry of vecMaxDeltaVec </span>
   vector&lt;double&gt; vecDeltaMax = vecMaxDeltaVec.back();
   <span class="keywordtype">double</span> DeltaInf = *(min_element(vecDeltaMax.begin(), vecDeltaMax.end()));
   <span class="comment">//cout &lt;&lt; DeltaInf &lt;&lt; endl;</span>
  <span class="comment">//double upperLimit = DeltaInf + 1.0/n*1.0;</span>

   <span class="comment">// keep the associated theta in a vector and then push back in the bigger vector</span>
   vector&lt;int&gt; minDistTheta;
   
     <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; vecDeltaMax.size(); i++) {
      <span class="comment">//   cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; &quot;\t&quot; &lt;&lt; DeltaInf &lt;&lt; &quot; vs &quot; &lt;&lt; vecDeltaMax[i] &lt;&lt; endl;</span>
         <span class="keywordflow">if</span> (vecDeltaMax[i] == DeltaInf) { 
      <span class="comment">//if (vecDeltaMax[i] &lt; upperLimit) </span>
      <span class="comment">//       cout &lt;&lt; &quot;this is at split &quot; &lt;&lt; i &lt;&lt; endl;</span>
             minDistTheta.push_back(i); 
      }  
    }
    vecMinDistTheta.push_back(minDistTheta);
 } 
</pre></div>
</div>
</div>
<a class="anchor" id="a174349942bc7f76e6804aeb3714d1f3b"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getNodesDelta" ref="a174349942bc7f76e6804aeb3714d1f3b" args="(std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &amp;YatSet, int thisTheta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b">AdaptiveHistogramVCollator::getNodesDelta</a> </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisTheta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the delta value for each Yatracos element at the specified split number. </p>
<p>Get the delta value for each element of the list of pointers to the Yatracos leaf boxes at the specified theta.</p>
<p>The delta value is the absolute difference between the empirical measure of the training data and the validation data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">YatSet</td><td>the set of pointers to sets of <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a> (pointers to the leaf boxes) </td></tr>
    <tr><td class="paramname">theta</td><td>the split number </td></tr>
    <tr><td class="paramname">currentStage</td><td>the most current split number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the delta value </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00626">626</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// iterator for Yatracos set</span>
  set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt;::iterator YatSetIt;  

  <span class="comment">//gloria - think about dotprecision summation</span>
  
  <span class="comment">//initialization</span>
  <span class="keywordtype">double</span> delta = 0;
  <span class="comment">//dotprecision deltaDP = 0;</span>
  
  <span class="comment">//go through each node in this set to get delta</span>
  <span class="keywordflow">for</span> (YatSetIt = YatSet.begin(); YatSetIt != YatSet.end(); YatSetIt++) {
    <span class="comment">//cout &lt;&lt; (*YatSetIt)-&gt;getNodeName() &lt;&lt; endl;</span>
    <span class="comment">//cout &lt;&lt; &quot;union &quot; &lt;&lt; endl;</span>
    delta += (*YatSetIt)-&gt;getNodeDelta(thisTheta);
    <span class="comment">//accumulate(deltaDP, (*YatSetIt)-&gt;getNodeDelta(k, thisTheta), 1.0);</span>
   }
   <span class="comment">//cout &lt;&lt; &quot;end of union&quot; &lt;&lt; endl;</span>

  <span class="comment">// take the absolute value of the sums</span>
  <span class="comment">//cout &lt;&lt; &quot;Delta: &quot; &lt;&lt; fabs(delta) &lt;&lt; endl;</span>
  <span class="keywordflow">return</span> fabs(delta);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a045c1338ed19503f5485f40ee7d2e218"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getNodesMaxDelta" ref="a045c1338ed19503f5485f40ee7d2e218" args="(std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecYatSet, int thisTheta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a045c1338ed19503f5485f40ee7d2e218">AdaptiveHistogramVCollator::getNodesMaxDelta</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisTheta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00654">654</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// iterators  </span>
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt;::iterator YatSetIt;  

  <span class="keywordtype">double</span> DeltaMax = 0;
  <span class="comment">//dotprecision deltaDP = 0;</span>
  set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; YatSet;
  
  <span class="comment">//go through each node in this set to get delta</span>
  <span class="keywordflow">for</span> (YatSetIt = vecYatSet.begin(); YatSetIt &lt; vecYatSet.end(); YatSetIt++){
    <span class="keywordtype">double</span> delta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>((*YatSetIt), thisTheta);
    <span class="comment">//accumulate(deltaDP, (*YatSetIt)-&gt;getNodeDelta(k, thisTheta), 1.0);</span>
    delta = fabs(delta);
    DeltaMax = (delta &gt; DeltaMax) ? delta : DeltaMax; 
    <span class="comment">//cout &lt;&lt; &quot;DeltaMax: &quot; &lt;&lt; DeltaMax &lt;&lt; endl;</span>
  }

  <span class="comment">// take the absolute value of the sums</span>
  <span class="keywordflow">return</span> fabs(DeltaMax);
  
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7268bf31ef2baf216134f5751e5c6173"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getNumberCollated" ref="a7268bf31ef2baf216134f5751e5c6173" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173">AdaptiveHistogramVCollator::getNumberCollated</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of Adaptive Histogram objects collated. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00341">341</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>Referenced by <a class="el" href="FinMixScheffe_8cpp_source.shtml#l00044">main()</a>, <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a72f2564ee548571ef026a8548ca0b0ba" title="Get number of subpavings summarised.">getNumberSummarised</a>(); }
</pre></div>
</div>
</div>
<a class="anchor" id="a53105611d6db4dc208275fd049475cd6"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getRootBox" ref="a53105611d6db4dc208275fd049475cd6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ivector <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a53105611d6db4dc208275fd049475cd6">AdaptiveHistogramVCollator::getRootBox</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the root box. Get the root box of the <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> object. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01060">1060</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
  ivector rootBox = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();  
  <span class="keywordflow">return</span> rootBox;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa66a678df6a370f60bb7141ddb28a043"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getScheffeSetAll" ref="aa66a678df6a370f60bb7141ddb28a043" args="(CollatorSPVnode *const splitNode, vector&lt; set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecScheffeSet, list&lt; set&lt; CollatorSPVnode *, less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;listScheffeSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aa66a678df6a370f60bb7141ddb28a043">AdaptiveHistogramVCollator::getScheffeSetAll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>splitNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecScheffeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list&lt; set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>listScheffeSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get Scheffe Tournmanet Winner (exhaustive). </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01067">1067</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">subpavings::CollatorSPVnode::getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">subpavings::CollatorSPVnode::getRightChild()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01397">subpavings::CollatorSPVnode::getScheffeNode()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//================setting up containers====================================//</span>
  <span class="comment">// cout &lt;&lt; &quot;set up containers&quot; &lt;&lt; endl;</span>
  <span class="comment">//iterator for vector</span>
   vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator vecIt;
    
   <span class="comment">//set for CollatorSPVnode* and iterator for sets</span>
   set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; setCSP;
   set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt;::iterator setIt;
    
   <span class="comment">//empty set</span>
   set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; emptySetCSP;
   <span class="comment">//=============end of setting up containers================================//</span>
  <span class="comment">//cout &lt;&lt; &quot;getNumberCollated: &quot; &lt;&lt; endl;  </span>
  <span class="keywordtype">int</span> numAdd = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>(); <span class="comment">// the number of histograms collated including the 0-th histogram</span>
  <span class="keywordtype">size_t</span> theta = numAdd-1; <span class="comment">// the current number of splits</span>
  
   <span class="comment">// initialize the vecScheffeSet</span>
   <span class="keywordflow">if</span> ( splitNode-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>() == <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a53105611d6db4dc208275fd049475cd6" title="Get the root box. Get the root box of the AdaptiveHistogramVCollator object.">getRootBox</a>() ) { <span class="comment">//initialize vecScheffeSet with the empty set (by definition)</span>
      setCSP.insert(splitNode); <span class="comment">// urm what is this for?</span>
      vecScheffeSet.push_back(emptySetCSP); 
  }
  <span class="comment">//cout &lt;&lt; &quot;get the left and right children of: &quot; &lt;&lt; splitNode-&gt;getNodeName() &lt;&lt; endl;   </span>
   <span class="comment">// get the left and right children of the split node</span>
    <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * lChild = splitNode-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>(); 
    <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * rChild = splitNode-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>();
    <span class="comment">//cout &lt;&lt; lChild-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; rChild-&gt;getNodeName() &lt;&lt; endl;</span>
  
    <span class="comment">//============begin pairwise comparisons===================================//</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k &lt; theta; k++) {  
   <span class="comment">//   cout &lt;&lt; &quot;k= &quot; &lt;&lt; k &lt;&lt; endl;      </span>
     <span class="comment">// insert the previous vecScheffeSet into listScheffeSet and</span>
    <span class="comment">// remove the node that was split from vecScheffeSet </span>
      <span class="keywordflow">if</span> (!(vecScheffeSet[k]).empty()) {
         listScheffeSet.push_back(vecScheffeSet[k]);  
      <span class="comment">//  for (setIt = vecScheffeSet[k].begin(); setIt != vecScheffeSet[k].end(); setIt++) { cout &lt;&lt; (*setIt)-&gt;getNodeName() &lt;&lt; endl; }</span>
      vecScheffeSet[k].erase(splitNode);
    }  
   
     <span class="comment">// check summaries of lChild and rChild for row</span>
    <span class="keywordtype">bool</span> leftRowInd = lChild-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ab134b9b98ed7b15b1cabb9eca1ced1eb" title="Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2...">getScheffeNode</a>(k, theta);
      <span class="keywordtype">bool</span> rightRowInd = rChild-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ab134b9b98ed7b15b1cabb9eca1ced1eb" title="Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2...">getScheffeNode</a>(k, theta);
      <span class="comment">// insert the node into vecScheffeSet if return true</span>
      <span class="keywordflow">if</span> (leftRowInd) { 
  <span class="comment">//    cout &lt;&lt; &quot;inserting &quot; &lt;&lt; lChild-&gt;getNodeName() &lt;&lt; &quot; into vecScheffeSet&quot; &lt;&lt; endl; </span>
      vecScheffeSet[k].insert(lChild);
    }
    <span class="keywordflow">if</span> (rightRowInd) { 
  <span class="comment">//    cout &lt;&lt; &quot;inserting &quot; &lt;&lt; rChild-&gt;getNodeName() &lt;&lt; &quot; into vecScheffeSet&quot; &lt;&lt; endl; </span>
      vecScheffeSet[k].insert(rChild);
    }
  } <span class="comment">// end of pairwise comparisons</span>

   <span class="comment">// checking the length of vecRowYatSet and vecColYatSet</span>
   <span class="keywordflow">if</span> ( vecScheffeSet.size() != theta) {
     cerr &lt;&lt; <span class="stringliteral">&quot;Length of vecRowYatSet is incorrect. Should have length &quot;</span> &lt;&lt; numAdd &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
    exit(0); 
   }
    
  <span class="comment">//push back empty sets at index theta (because that corresponds to theta-theta comparison)</span>
  vecScheffeSet.push_back(emptySetCSP); 
         
   <span class="comment">// get rid of repeated nodes/unions of nodes</span>
    <span class="comment">// sort the list</span>
    listScheffeSet.sort();
  
  <span class="comment">// check for uniqueness</span>
  listScheffeSet.unique();
  
} <span class="comment">// end of function getScheffeSetAll</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a4b3830bf47fe4738c22f4a53858d90fc"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getScheffeWinner" ref="a4b3830bf47fe4738c22f4a53858d90fc" args="(std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecScheffeSet, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;vecWinnerVec, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecDeltaWinnerVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4b3830bf47fe4738c22f4a53858d90fc">AdaptiveHistogramVCollator::getScheffeWinner</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecScheffeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecWinnerVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecDeltaWinnerVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the winner and delta values for all pairwise comparisons for the Scheffe set. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00790">790</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{ 
  <span class="comment">//  cout &lt;&lt; &quot;Get Scheffe Winner&quot; &lt;&lt; endl;</span>
    <span class="keywordtype">size_t</span> theta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>() - 1;  <span class="comment">// number of splits up to now</span>

    <span class="comment">// check that the size of vecMaxDeltaVec is theta   </span>
    <span class="keywordflow">if</span> (vecDeltaWinnerVec.size() != theta) {
      cerr &lt;&lt; <span class="stringliteral">&quot;Size of vecDeltaWinnerVec before getting delta should be &quot;</span> 
           &lt;&lt; theta &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
      exit(0);
    }
    <span class="keywordflow">if</span> (vecWinnerVec.size() != theta) {
      cerr &lt;&lt; <span class="stringliteral">&quot;Size of vecWinnerVec before running tournament should be &quot;</span>
           &lt;&lt; theta &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
      exit(0);
    } 
  
   <span class="comment">//check if the ScheffeSet for pair {theta-1, theta} is empty</span>
  <span class="keywordflow">if</span> ( vecScheffeSet[theta-1].empty() ) {
    <span class="comment">//initialize vecDeltaWinnerVec at the largest index</span>
    vector&lt;double&gt; dummyTheta;
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt;=theta; i++) {
      dummyTheta.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); 
      <span class="comment">// supremum of an empty set is -infinity</span>
    }
    vecDeltaWinnerVec.push_back(dummyTheta);
    <span class="comment">//initialize at the previous indices</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; theta; i++){
      vecDeltaWinnerVec[i].push_back(-1*(numeric_limits&lt;double&gt;::infinity()));
    }   
    <span class="comment">//push back 0 in vecWinnerVec at the largest index</span>
    vector&lt;int&gt; vecWinner;
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt;=theta; i++) {
      vecWinner.push_back(0); 
    }
    vecWinnerVec.push_back(vecWinner);
    <span class="comment">//push back 0 in vecWinnerVec at the previous indices</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; theta; i++){
      vecWinnerVec[i].push_back(0);
    }
  } <span class="comment">// end of vecScheffeSet[theta-1] is empty </span>
  
  <span class="keywordflow">else</span> {
    <span class="comment">// iterators</span>
    vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt;::iterator vecIt;
    set &lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt;::iterator setIt; 

    <span class="comment">//initialize vecDeltaWinnerVec at the largest index</span>
    vector&lt;double&gt; dummyTheta;
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt;=theta; i++) {
      dummyTheta.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); 
      <span class="comment">// supremum of an empty set is -infinity</span>
    }
    vecDeltaWinnerVec.push_back(dummyTheta);
    <span class="comment">//initialize at the previous indices</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; theta; i++){
      vecDeltaWinnerVec[i].push_back(-1*(numeric_limits&lt;double&gt;::infinity()));
    }
    
    <span class="comment">//initialize vecWinnerVec at the largest index</span>
    vector&lt;int&gt; vecWinner;
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt;=theta; i++) {
      vecWinner.push_back(0); 
    }
    vecWinnerVec.push_back(vecWinner);    
    <span class="comment">//initialize vecWinnerVec at the previous indices</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; theta; i++){
      vecWinnerVec[i].push_back(0);
    }
        
    <span class="comment">//get the current theta     </span>
    <span class="keywordtype">double</span> deltaTheta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>(vecScheffeSet[theta-1], theta);    
    
    <span class="comment">// go through each histogram i to get the winner</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; theta; i++) {
        <span class="keywordflow">if</span> (!(vecScheffeSet[i]).empty()) {        
          <span class="comment">//get delta</span>
          <span class="keywordtype">double</span> delta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>(vecScheffeSet[theta-1], i);
          <span class="comment">//perform competition</span>
          <span class="keywordtype">bool</span> i_win = delta &lt; deltaTheta;
          <span class="keywordflow">if</span> ( i_win == <span class="keyword">true</span> ) {
            cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; delta &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; theta &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; deltaTheta &lt;&lt; endl;
            cout &lt;&lt; <span class="stringliteral">&quot;Winner is: &quot;</span> &lt;&lt; i &lt;&lt; endl;
            <span class="comment">// winner is i</span>
            vecWinnerVec[theta][i]=(0);   
            vecWinnerVec[i][theta]=(1);               
            vecDeltaWinnerVec[theta][i]=(deltaTheta);   
            vecDeltaWinnerVec[i][theta]=(delta);      
          }
          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( i_win == <span class="keyword">false</span> ) { 
            cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; delta &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; theta &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; deltaTheta &lt;&lt; endl;
            cout &lt;&lt; <span class="stringliteral">&quot;Winner is: &quot;</span> &lt;&lt; theta &lt;&lt; endl;
            <span class="comment">// winner is theta</span>
            vecWinnerVec[i][theta]=(0);
            vecWinnerVec[theta][i]=(0);           
            vecDeltaWinnerVec[i][theta]=(delta);    
            vecDeltaWinnerVec[theta][i]=(deltaTheta);   
          }
          <span class="keywordflow">else</span> { <span class="comment">// deltaTheta = delta </span>
             cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; delta &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; theta &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; deltaTheta &lt;&lt; endl;
            cout &lt;&lt; <span class="stringliteral">&quot;tie&quot;</span> &lt;&lt; endl;
            vecWinnerVec[theta][i]=(0);
            vecWinnerVec[i][theta]=(0);           
            vecDeltaWinnerVec[theta][i] = (delta);    
            vecDeltaWinnerVec[i][theta]= (delta);               
          }  <span class="comment">// end of competition</span>
        } <span class="comment">// end of ScheffeSet not empty                   </span>
    } <span class="comment">// end of going through each histogram        </span>
  } <span class="comment">// end of vecScheffeSet[theta-1] not empty   </span>
} <span class="comment">// end of getScheffeDelta</span>
</pre></div>
</div>
</div>
<a class="anchor" id="ab38cfd38290579694a35950af5c80c36"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getSplitNodePtr" ref="ab38cfd38290579694a35950af5c80c36" args="(CollatorSPVnode *&amp;splitCollNode, SPSVnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab38cfd38290579694a35950af5c80c36">AdaptiveHistogramVCollator::getSplitNodePtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *&amp;&#160;</td>
          <td class="paramname"><em>splitCollNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1SPSVnode.shtml">SPSVnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> pointer to the corresponding <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> that was split. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">chosenLargest</td><td>the current splitted node </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>splitCollNode the current splitted node as a <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00511">511</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">bool</span> success = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ae3670805f36e313e7e541d57552d6b34" title="Get a CollatorSPVnode pointer to the corresponding SPSVnode that was split.">getSplitNodePtrCSPV</a>(splitCollNode, spn);
   <span class="keywordflow">if</span> (!success) { <span class="comment">// no pointers obtained</span>
            cerr &lt;&lt; <span class="stringliteral">&quot;No pointers obtained.&quot;</span> &lt;&lt; std::endl;
            exit(0);
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4fc5807fde8de008b9551f6347c6d46e"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getSubPaving" ref="a4fc5807fde8de008b9551f6347c6d46e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4fc5807fde8de008b9551f6347c6d46e">AdaptiveHistogramVCollator::getSubPaving</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> this manages. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00326">326</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00196">operator+=()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01405">operator&lt;&lt;()</a>, and <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01423">outputAllNodesToTxtTabs()</a>.</p>
<div class="fragment"><pre class="fragment">{<span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>;} <span class="comment">// boost::shared_ptr might be better</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a49437661609894461106a99c37ddeed5"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getTotalNodes" ref="a49437661609894461106a99c37ddeed5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a49437661609894461106a99c37ddeed5">AdaptiveHistogramVCollator::getTotalNodes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01377">1377</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02257">subpavings::spTotalNodes()</a>.</p>

<p>Referenced by <a class="el" href="AirTrafficDynamic_8cpp_source.shtml#l00043">main()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="keywordtype">size_t</span> numNodes = 0;
    <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>)
        numNodes = <a class="code" href="namespacesubpavings.shtml#aa737c3b183c306abbef9b3d515f632fb" title="Get the number of leaves of a tree (boxes in the subpaving)">spTotalNodes</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>);
    
    <span class="keywordflow">return</span> numNodes;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ad94f1c5c6943e7bb35e74030af5113fd"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getYatracosClassAll" ref="ad94f1c5c6943e7bb35e74030af5113fd" args="(CollatorSPVnode *const splitCollNode, std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecRowYatSet, std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecColYatSet, std::list&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;listYatSet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad94f1c5c6943e7bb35e74030af5113fd">AdaptiveHistogramVCollator::getYatracosClassAll</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *const&#160;</td>
          <td class="paramname"><em>splitCollNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecRowYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecColYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>listYatSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Yatracos set. </p>
<p>The Yatracos set is obtained by pairwise comparisons of the heights of the histogram at each leaf box and unions of leaf boxes for each theta (number of splits). For all i, j pairs, the leaf box/unions of leaf boxes at the i-th split goes into the Yatracos set if its height is higher than the height at leaf box/unions of leaf boxes at the j-th split.</p>
<p>The winning leaf boxes/union of leaf boxes are stored in a set of <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a>. The sets are then stored in a sorted list. Any repetitive elements are removed from the list by using the STL unique() algorithm.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spiltCollNode</td><td>the current splitted node </td></tr>
    <tr><td class="paramname">current</td><td>list of pointers to sets of <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a> </td></tr>
    <tr><td class="paramname">vecRowYatSet</td><td>the current row of the growing Yatracos matrix </td></tr>
    <tr><td class="paramname">vecColYatSet</td><td>the current column of the growing Yatracos matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an updated list of pointers to sets of <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a> </dd>
<dd>
an updated row and column vector of the current edges </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00521">521</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00503">subpavings::CollatorSPVnode::getLeftChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l00508">subpavings::CollatorSPVnode::getRightChild()</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01435">subpavings::CollatorSPVnode::nodeCheckColSummary()</a>, and <a class="el" href="collatorspvnode_8cpp_source.shtml#l01420">subpavings::CollatorSPVnode::nodeCheckRowSummary()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//================setting up containers====================================//</span>
   <span class="comment">//iterator for vector of sets</span>
   vector&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator vecIt;
   set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; emptySetCSP; <span class="comment">//empty set</span>
   set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt;::iterator setIt; <span class="comment">//iterator</span>
   
  <span class="comment">//=============initializations============================================//</span>
  <span class="keywordtype">int</span> numAdd = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>(); <span class="comment">// the number of histograms collated including the 0-th histogram</span>
  <span class="keywordtype">size_t</span> theta = numAdd-1; <span class="comment">// the current number of splits</span>

  <span class="comment">// initialize the vecRowYatSet and vecColYatSet if split node is root box</span>
   <span class="keywordflow">if</span> ( splitNode-&gt;getBox() == <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a53105611d6db4dc208275fd049475cd6" title="Get the root box. Get the root box of the AdaptiveHistogramVCollator object.">getRootBox</a>() ) { 
    <span class="comment">//cout &lt;&lt; &quot;initialize with empty set &quot; &lt;&lt; endl;</span>
    <span class="comment">//initialize vecRowYatSet and vecColYatSet with the empty set (by definition)</span>
      vecRowYatSet.push_back(emptySetCSP);
      vecColYatSet.push_back(emptySetCSP); 
  }

  <span class="comment">//cout &lt;&lt; &quot;get the left and right children of: &quot; &lt;&lt; splitNode-&gt;getNodeName() &lt;&lt; endl;</span>
   <span class="comment">// get the left and right children of the split node</span>
  <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * lChild = splitNode-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aeaea28b3b2d7ca59a28cd3fbb3438cce" title="Accessor for the left child of a node.">getLeftChild</a>(); 
  <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> * rChild = splitNode-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#aaaa6264c4020a5e0ccfdedb19228fa2b" title="Accessor for the right child of a node.">getRightChild</a>();
  <span class="comment">//cout &lt;&lt; lChild-&gt;getNodeName() &lt;&lt; &quot;\t&quot; &lt;&lt; rChild-&gt;getNodeName() &lt;&lt; endl;</span>

  <span class="comment">//============begin pairwise comparisons===================================//</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> k=0; k &lt; theta; k++) {
    <span class="comment">//cout &lt;&lt; &quot;k= &quot; &lt;&lt; k &lt;&lt; &quot;\t theta = &quot; &lt;&lt; theta &lt;&lt; endl;</span>
    <span class="comment">// insert the previous vecRowYatSet and vecColYatSet into listYatSet</span>
    <span class="comment">// remove the node that was split from vecRowYatSet/vecColYatSet </span>
      <span class="keywordflow">if</span> (!(vecRowYatSet[k]).empty()) {
      listYatSet.push_back(vecRowYatSet[k]);  
      <span class="comment">// cout &lt;&lt; &quot;YatRowSet:&quot; &lt;&lt; endl;</span>
      <span class="comment">//for (setIt = vecRowYatSet[k].begin(); setIt != vecRowYatSet[k].end(); setIt++) { </span>
      <span class="comment">//cout &lt;&lt; (*setIt)-&gt;getNodeName() &lt;&lt; endl; }</span>
      vecRowYatSet[k].erase(splitNode);
    }  
      <span class="keywordflow">if</span> (!(vecColYatSet[k]).empty()) {
      listYatSet.push_back(vecColYatSet[k]);
      <span class="comment">//cout &lt;&lt; &quot;YatColSet: &quot; &lt;&lt; endl;</span>
      <span class="comment">//for (setIt = vecColYatSet[k].begin(); setIt != vecColYatSet[k].end(); setIt++) { </span>
      <span class="comment">//cout &lt;&lt; (*setIt)-&gt;getNodeName() &lt;&lt; endl; }</span>
      vecColYatSet[k].erase(splitNode);
    }

      <span class="comment">// check summaries of lChild and rChild for row</span>
    <span class="comment">//cout &lt;&lt; &quot;check row: &quot; &lt;&lt; endl;</span>
    <span class="keywordtype">bool</span> leftRowInd = lChild-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a199762d07823cde9934100fb6d11228c" title="Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matr...">nodeCheckRowSummary</a>(theta, k);
      <span class="keywordtype">bool</span> rightRowInd = rChild-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a199762d07823cde9934100fb6d11228c" title="Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matr...">nodeCheckRowSummary</a>(theta, k);
      <span class="comment">// insert the node into vecRowYat Set if return true</span>
      <span class="keywordflow">if</span> (leftRowInd) { 
      <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; lChild-&gt;getNodeName() &lt;&lt; &quot; into vecRowYatSet&quot; &lt;&lt; endl; </span>
      vecRowYatSet[k].insert(lChild);
    }
    <span class="keywordflow">if</span> (rightRowInd) { 
      <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; rChild-&gt;getNodeName() &lt;&lt; &quot; into vecRowYatSet&quot; &lt;&lt; endl; </span>
      vecRowYatSet[k].insert(rChild);
    }
    
    <span class="comment">// check summaries of lChild and rChild for columns</span>
    <span class="comment">//cout &lt;&lt; &quot;check col: &quot; &lt;&lt; endl;</span>
    <span class="keywordtype">bool</span> leftColInd = lChild-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a61360380c921f78c1ac9689ffe004c60" title="Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos m...">nodeCheckColSummary</a>(theta, k);
    <span class="keywordtype">bool</span> rightColInd = rChild-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a61360380c921f78c1ac9689ffe004c60" title="Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos m...">nodeCheckColSummary</a>(theta, k);
      <span class="comment">// insert the node into vecColYat Set if return true</span>
        <span class="keywordflow">if</span> (leftColInd) { 
      <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; lChild-&gt;getNodeName() &lt;&lt; &quot; into vecColYatSet&quot; &lt;&lt; endl; </span>
      vecColYatSet[k].insert(lChild);
    }
    <span class="keywordflow">if</span> (rightColInd) { 
      <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; rChild-&gt;getNodeName() &lt;&lt; &quot; into vecColYatSet&quot; &lt;&lt; endl; </span>
      vecColYatSet[k].insert(rChild);
    }    
  } <span class="comment">// end of pairwise comparisons</span>

   <span class="comment">// checking the length of vecRowYatSet and vecColYatSet</span>
   <span class="keywordflow">if</span> ( vecColYatSet.size() != (theta) || vecRowYatSet.size() != theta) {
     cerr &lt;&lt; <span class="stringliteral">&quot;Length of vecRowYatSet and/or vecColYatSet is incorrect. Should have length &quot;</span> &lt;&lt; numAdd &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
    exit(0); 
   }

  <span class="comment">//cout &lt;&lt; &quot;push back empty sets in index theta.&quot; &lt;&lt; endl;</span>
  <span class="comment">//push back empty sets at index theta (because that corresponds to theta-theta comparison)</span>
  vecColYatSet.push_back(emptySetCSP); 
  vecRowYatSet.push_back(emptySetCSP);

  <span class="comment">//cout &lt;&lt; &quot;Getting rid of repetitions&quot; &lt;&lt; endl;</span>
   <span class="comment">// get rid of repeated nodes/unions of nodes by sorting the list and </span>
   <span class="comment">// checking for uniqueness</span>
  listYatSet.sort();
  listYatSet.unique();
  <span class="comment">/*</span>
<span class="comment">  list&lt; set&lt;CollatorSPVnode*, less &lt; CollatorSPVnode* &gt; &gt; &gt;::iterator listIt;     </span>
<span class="comment">  cout &lt;&lt; &quot;**Current Yatracos set has &quot; &lt;&lt; listYatSet.size() &lt;&lt; &quot; nodes.&quot; &lt;&lt; endl;</span>
<span class="comment">  for (listIt = (listYatSet).begin(); listIt != (listYatSet).end(); listIt++) {</span>
<span class="comment">    for (setIt = (*listIt).begin(); setIt != (*listIt).end(); setIt++) {</span>
<span class="comment">      cout &lt;&lt; (*setIt)-&gt;getNodeName() &lt;&lt; endl;</span>
<span class="comment">    }</span>
<span class="comment">  }*/</span>
} <span class="comment">// end of function getYatracos</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a741a4e9b7dac5673c641b3a991b4a419"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::getYatracosDelta" ref="a741a4e9b7dac5673c641b3a991b4a419" args="(std::list&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;listYatSet, std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecRowYatSet, std::vector&lt; std::set&lt; CollatorSPVnode *, std::less&lt; CollatorSPVnode * &gt; &gt; &gt; &amp;vecColYatSet, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;vecMaxDeltaVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a741a4e9b7dac5673c641b3a991b4a419">AdaptiveHistogramVCollator::getYatracosDelta</a> </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>listYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecRowYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a> * &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecColYatSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecMaxDeltaVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum delta values for all thetas for the Yatracos Class. </p>
<p>Get the maximum delta value at each theta over the list of Yatracos leaf boxes for all thetas.</p>
<p>The delta value is the absolute difference between the empirical measure of the training data and the validation data.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">listYatSet</td><td>the list of set of pointers to sets of <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode </a> (pointers to the leaf boxes) </td></tr>
    <tr><td class="paramname">vecMaxDeltaVec</td><td>the current vector of vectors to the maximum delta values for each theta </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00680">680</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l00922">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimate()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01387">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// iterators</span>
  list&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt;::iterator listYatSetIt;
  vector&lt; set&lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; &gt;::iterator vecIt;
  
  <span class="comment">//set for CollatorSPVnode*</span>
  set &lt;CollatorSPVnode*, less&lt;CollatorSPVnode*&gt; &gt; YatSet; 
  
  <span class="keywordtype">double</span> delta = 0; <span class="comment">// the delta value</span>
  <span class="keywordtype">double</span> DeltaMax = 0; <span class="comment">// the maximum delta</span>
  <span class="keywordtype">size_t</span> theta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a7268bf31ef2baf216134f5751e5c6173" title="Get the number of Adaptive Histogram objects collated.">getNumberCollated</a>() - 1;  <span class="comment">// number of splits up to now</span>
   
    <span class="comment">// check that the size of vecMaxDeltaVec is theta   </span>
  <span class="keywordflow">if</span> (vecMaxDeltaVec.size() != theta) {
    cerr &lt;&lt; <span class="stringliteral">&quot;Size of vecMaxDeltaVec before getting delta should be &quot;</span> &lt;&lt; theta 
         &lt;&lt; <span class="stringliteral">&quot;.&quot;</span> &lt;&lt; endl;
    exit(0);
  }

  <span class="comment">//initialize vecMaxDeltaVec at the largest index</span>
<span class="comment">//  cout &lt;&lt; &quot;initialize vecMaxDeltaVec at the largest index: &quot; &lt;&lt; endl;</span>
  vector&lt;double&gt; dummyTheta;
  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt;=theta; i++) {
    dummyTheta.push_back(-1*(numeric_limits&lt;double&gt;::infinity())); <span class="comment">// supremum of an empty set is -infinity</span>
  }
  vecMaxDeltaVec.push_back(dummyTheta);

    <span class="comment">// go through each histogram i to update DeltaMax for the new Scheffe </span>
    <span class="comment">// sets in vecRowYatSet and vecColYatSet </span>
    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt;= theta; i++) {
      <span class="comment">//cout &lt;&lt; &quot;\n =====Checking histogram  &quot; &lt;&lt; i &lt;&lt; &quot; for the &quot; &lt;&lt; theta &lt;&lt; &quot;-th split======&quot; &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> ( i &lt; theta) { <span class="comment">// only can compare with deltas in indices from 0:theta-1</span>
        DeltaMax = vecMaxDeltaVec[theta-1][i];
        <span class="comment">//cout &lt;&lt; &quot;The previous Delta is: &quot; &lt;&lt; DeltaMax &lt;&lt; endl;</span>
      }
      <span class="keywordflow">else</span> {
        DeltaMax = vecMaxDeltaVec[theta][theta];
        <span class="comment">//cout &lt;&lt; &quot;The previous Delta is: &quot; &lt;&lt; DeltaMax &lt;&lt; endl;  </span>
      }

      <span class="comment">//go through each node/union of nodes in the Yatracos set</span>
      <span class="keywordflow">for</span> (vecIt = vecRowYatSet.begin(); vecIt &lt; vecRowYatSet.end(); vecIt++){
        YatSet = *(vecIt); <span class="comment">//dereference the pointer to set of CollatorSPVnode</span>
           <span class="keywordflow">if</span> (!YatSet.empty()) {
          <span class="comment">//  cout &lt;&lt; &quot;this set is not empty&quot; &lt;&lt;endl;</span>
            <span class="comment">//get delta</span>
              delta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>(YatSet, i);
            <span class="comment">//cout &lt;&lt; &quot;delta for this node/union of nodes is: &quot; &lt;&lt; delta &lt;&lt; endl;</span>
            <span class="comment">//DeltaMax is delta if delta &gt; DeltaPrev; else DeltaMax is still DeltaPrev</span>
            <span class="comment">//cout &lt;&lt; &quot;Delta now: &quot; &lt;&lt; delta &lt;&lt; &quot;\tPrev Delta: &quot; &lt;&lt; DeltaMax &lt;&lt; endl;</span>
            DeltaMax = (delta &gt; DeltaMax) ? delta : DeltaMax; 
            <span class="comment">//cout &lt;&lt; &quot;Checking the comparisons of maximums: &quot; &lt;&lt; endl;</span>
            <span class="comment">//cout &lt;&lt; delta &lt;&lt; &quot;\t&quot; &lt;&lt; DeltaMax &lt;&lt; endl;</span>
          }
      <span class="comment">//   else { cout &lt;&lt; &quot; i am empty!&quot; &lt;&lt; endl; } </span>
      } <span class="comment">// end of going through each YatSet in vecRowYatSet for histogram i</span>

       <span class="comment">//cout &lt;&lt; &quot;DeltaMax after going through VecRowYatSet: &quot; &lt;&lt; DeltaMax &lt;&lt; endl; </span>
      <span class="comment">//go through each node/union of nodes in the Yatracos set</span>
      <span class="keywordflow">for</span> (vecIt = vecColYatSet.begin(); vecIt &lt; vecColYatSet.end(); vecIt++){
        YatSet = *(vecIt); <span class="comment">//dereference the pointer to set of CollatorSPVnode</span>
        
        <span class="keywordflow">if</span> (!YatSet.empty()) {
        <span class="comment">//  cout &lt;&lt; &quot;this set is not empty&quot; &lt;&lt;endl;</span>
          <span class="comment">//get delta</span>
          delta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>(YatSet, i);
          <span class="comment">//cout &lt;&lt; &quot;delta for this node/union of nodes is: &quot; &lt;&lt; delta &lt;&lt; endl;</span>
            
          <span class="comment">//DeltaMax is delta if delta &gt; DeltaPrev; else DeltaMax is still DeltaPrev</span>
          DeltaMax = (delta &gt; DeltaMax) ? delta : DeltaMax; 
          <span class="comment">//cout &lt;&lt; &quot;Checking the comparisons of maximums: &quot; &lt;&lt; endl;</span>
          <span class="comment">//cout &lt;&lt; delta &lt;&lt; &quot;\t&quot; &lt;&lt; DeltaMax &lt;&lt; endl;           </span>
        }
        
      <span class="comment">//  else { cout &lt;&lt; &quot; i am empty!&quot; &lt;&lt; endl; }</span>
      } <span class="comment">// end of going through each YatSet in vecColYatSet for histogram i</span>
      
      <span class="comment">// keep the updated DeltaMax in vecMaxDeltaVec at the [theta][i] position </span>
       <span class="comment">//cout &lt;&lt; &quot;the updated DeltaMax for the edges is: &quot; &lt;&lt; DeltaMax &lt;&lt;endl;  </span>
      vecMaxDeltaVec[theta][i] = DeltaMax;
  } <span class="comment">// end of going through each histogram</span>
      
  <span class="comment">// now go through listYatSet for the histogram at the largest index theta</span>
  <span class="keywordflow">if</span> (!(listYatSet.empty())) { <span class="comment">//listYatSet is not empty</span>
       DeltaMax = vecMaxDeltaVec[theta][theta];
       <span class="comment">//cout &lt;&lt; &quot;\n =====Checking histogram  &quot; &lt;&lt; theta &lt;&lt; &quot;for listYatSet=====&quot; &lt;&lt; endl;</span>
       <span class="comment">// go through each node/unions of nodes in listYatSet</span>
       <span class="keywordflow">for</span> (listYatSetIt = listYatSet.begin(); listYatSetIt != listYatSet.end(); listYatSetIt++) {
      YatSet = *(listYatSetIt);
        <span class="comment">//get delta</span>
         delta = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a174349942bc7f76e6804aeb3714d1f3b" title="Get the delta value for each Yatracos element at the specified split number.">getNodesDelta</a>(YatSet, theta);
            <span class="comment">//cout &lt;&lt; &quot;delta for this node/union of nodes is: &quot; &lt;&lt; delta &lt;&lt; endl;</span>
            
            <span class="comment">//DeltaMax is delta if delta &gt; DeltaPrev; else DeltaMax is still DeltaPrev</span>
            DeltaMax = (delta &gt; DeltaMax) ? delta : DeltaMax; 
            <span class="comment">//cout &lt;&lt; &quot;Checking the comparisons of maximums: &quot; &lt;&lt; endl;</span>
            <span class="comment">//cout &lt;&lt; delta &lt;&lt; &quot;\t&quot; &lt;&lt; DeltaMax &lt;&lt; endl;   </span>
    } <span class="comment">// end of going through listYatSet</span>
    <span class="comment">//cout &lt;&lt; &quot;the updated DeltaMax for the edges is: &quot; &lt;&lt; DeltaMax &lt;&lt;endl; </span>
     vecMaxDeltaVec[theta][theta] = DeltaMax; 
  } <span class="comment">// end of if listYatSet is not empty     </span>
} <span class="comment">// end of method getYatracosDelta</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a1d9fe1618884a4cdbfc211a04dcd4a65"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::makeAverage" ref="a1d9fe1618884a4cdbfc211a04dcd4a65" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a1d9fe1618884a4cdbfc211a04dcd4a65">AdaptiveHistogramVCollator::makeAverage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> which is the average over this collation.</p>
<p>Makes and returns an <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> which is the average over the collation of histograms represented by this. The tree managed by the average has structure exactly the same as the tree managed by this and one value in the summary for each node where that value is the average of the summary of the corresponding node in this.</p>
<p>This method can only be performed on summaries which do not include negated </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00280">280</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01416">isNegative()</a>, <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml#l00099">rootVCollator</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {
            <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Cannot average this: rootVCollator is NULL&quot;</span>;
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="comment">//average only makes sense if all values in the summary are positive</span>
    <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> mySummary = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad7fa37be86eb1d964b384a090dc3552f" title="Accessor for the summary.">getSummary</a>();

    <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it = find_if(mySummary.begin(), mySummary.end(), <a class="code" href="adaptivehistogramvcollator_8cpp.shtml#af83155cd50512e4cbad3f931370478ee" title="Find if double is negative.">isNegative</a>);
    <span class="keywordflow">if</span> (it &lt; mySummary.end()) {
            <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Cannot average this: the collation contains negatives&quot;</span>;
            <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> newCollator;
    <span class="keywordflow">try</span> {
        newCollator.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = (<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4fc5807fde8de008b9551f6347c6d46e" title="Return a pointer to the CollatorSPVnode this manages.">getSubPaving</a>())-&gt;makeAverageCollation();
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory making average.  Orginal error: &quot;</span>
                                            + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error making average.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException making average.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error making average.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }

    <span class="keywordflow">return</span> newCollator;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab9c2ad2ebbf0f50de0e06f92f222f0a7"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::makeMinimal" ref="ab9c2ad2ebbf0f50de0e06f92f222f0a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ab9c2ad2ebbf0f50de0e06f92f222f0a7">AdaptiveHistogramVCollator::makeMinimal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01338">1338</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>

<p>Referenced by <a class="el" href="AirTrafficDynamic_8cpp_source.shtml#l00043">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">try</span> {
      <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#abef4fa1adf9483d78e21350712864fd2" title="Try to reunite nodes to form one leaf.">nodesReunite</a>();    
   }
   <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory adding to collation.  Orginal error: &quot;</span>
                                            + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae8856c3f66db77b6f0ce896ff4f54ce5"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::operator+=" ref="ae8856c3f66db77b6f0ce896ff4f54ce5" args="(const AdaptiveHistogramVCollator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp; AdaptiveHistogramVCollator::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Addition operator.</p>
<p>Addition gives a histogram vcollator managing a tree which represents a subpaving which is the union of the subpavings represented by the operand collators. The summary for each node in the tree contains all the values from the summaries of the corresponding nodes in the trees managed by the operand AdaptiveHistogramVCollators. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00196">196</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="collatorspvnode_8cpp_source.shtml#l01048">subpavings::CollatorSPVnode::addPavingWithVal()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00326">getSubPaving()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>, and <a class="el" href="adaptivehistogram_8cpp_source.shtml#l05922">subpavings::HistException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {
        <span class="comment">// get the subpaving out of rhs to form a new CollatorSPnode</span>
        <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> toAdd(*rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a4fc5807fde8de008b9551f6347c6d46e" title="Return a pointer to the CollatorSPVnode this manages.">getSubPaving</a>());
        <span class="comment">// add the new CollatorSPnode into the collation</span>
        <span class="comment">// note that addPaving will alter toAdd, but that is okay because</span>
        <span class="comment">// toAdd is a temporary object created and deleted in this procedure</span>
        <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#af01fff5efb1889862b36606bed10746a" title="Add paving with Vemp to collation.">addPavingWithVal</a>(&amp;toAdd);
    }

    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> oldmsg(ba.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory adding to collation.  Orginal error: &quot;</span>
                                            + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.<a class="code" href="classsubpavings_1_1HistException.shtml#a08b10aa1f131d863b2260fca714afdbe">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;HistException error adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> oldmsg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;SPnodeException adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> oldmsg(e.what());
        <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error adding to collation.  Orginal error: &quot;</span> + oldmsg;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a56acb0f59cd7c99a5ef8db73fd2b3294"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::operator&#45;" ref="a56acb0f59cd7c99a5ef8db73fd2b3294" args="(const AdaptiveHistogramVCollator &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> AdaptiveHistogramVCollator::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Subtraction operator.</p>
<p>Subtraction gives a histogram collator managing a tree which represents a subpaving which is the union of the subpavings represented by the operand collators. The summary for each node in the tree contains all the values from the summary of the corresponding node in the trees managed by the left hand side operand and the negation of the values from the summary of the corresponding node in the trees managed by the right hand side operand. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00233">233</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml#l00099">rootVCollator</a>, <a class="el" href="collatorspvnode_8cpp_source.shtml#l01243">subpavings::CollatorSPVnode::subtractPavings()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> ((NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) &amp;&amp; (NULL != rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) &amp;&amp;
    ((<a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) != <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()))
    || (<a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()) != <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>()))))
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Histogram collators have unequal dimensions&quot;</span>);

       <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>* newnode = NULL;

    <span class="keywordflow">try</span> {
      <span class="keywordtype">double</span> c = -1.0;
         newnode =
            <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ab662ab5025178c145b83b386ef475415" title="Subtract one collator subpavings from another together.">CollatorSPVnode::subtractPavings</a>(<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>, rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>, c);
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in subtraction: original error &quot;</span>
                                    &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Memory allocation error in subtraction: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in subtraction: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;SPnodeException in subtraction: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error in subtraction: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in subtraction: &quot;</span> + msg);
    }

    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml" title="A wrapper or manager for a CollatorSPVnode.">AdaptiveHistogramVCollator</a> newCollatorHist(newnode);

    <span class="keywordflow">return</span> newCollatorHist;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a06855795e0d1d9c5a268ec91153346d4"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::operator=" ref="a06855795e0d1d9c5a268ec91153346d4" args="(const AdaptiveHistogramVCollator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp; AdaptiveHistogramVCollator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00161">161</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml#l00099">rootVCollator</a>, and <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {

        <span class="comment">// we have to make sure we delete the current paving</span>
        <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {
            <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>;
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = NULL;
        }

        <span class="keywordflow">if</span> (NULL != rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>)
            <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a> = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>(*(rhs.<a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>));
    }
    <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
        <span class="keywordtype">string</span> msg(ba.what());
        std::cout &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in assignment: original error &quot;</span>
                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(msg);
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; spe) {
        <span class="keywordtype">string</span> msg(spe.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;SPnodeExcepton in assignment: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;SPnodeException in assignment: &quot;</span> + msg);
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
        <span class="keywordtype">string</span> msg(e.what());
        std:: cout &lt;&lt; <span class="stringliteral">&quot;Error in assignment: original error &quot;</span>
                                            &lt;&lt; msg &lt;&lt; std::endl;
        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;Error in assignment: &quot;</span> + msg);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a95cf6201a4b2259eb5138193affc5f6b"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::outputAccumulationToTxtTabs" ref="a95cf6201a4b2259eb5138193affc5f6b" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a95cf6201a4b2259eb5138193affc5f6b">AdaptiveHistogramVCollator::outputAccumulationToTxtTabs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the accumulated data over the collation to a txt file. </p>
<p>Output tab delimited data on the average to a text file. Outputs the accumulation over the collation of data summarised in this.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the file to send the output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00409">409</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>

<p>Referenced by <a class="el" href="AirTraffic_8cpp_source.shtml#l00043">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {

        <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {

            <span class="comment">// To generate a file output of the AdaptiveHistogramVCollator object</span>
            ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>

            <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {
                <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a74c11c958cf56fbfff724d464c02f03a" title="Output for for all leaves of a binary tree.">leavesAccumulationOutputTabs</a>(os);
                std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the accumulated AdaptiveHistograms &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;has been written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
            }
            <span class="keywordflow">else</span> {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry, nothing is in collation to accumulate&quot;</span>
                    &lt;&lt; std::endl;
            }
        }
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; e) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Problem acccumulating: &quot;</span> &lt;&lt; e.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>() &lt;&lt; std::endl;
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="af05a34e32911a81b2af37529994bae57"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::outputAverageToTxtTabs" ref="af05a34e32911a81b2af37529994bae57" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#af05a34e32911a81b2af37529994bae57">AdaptiveHistogramVCollator::outputAverageToTxtTabs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output average normalised histogram over collation to a txt file. </p>
<p>This method does not make the average histogram directly but, for each leaf node in the collated tree, calculates and outputs the average of the summary associated with that leaf node.</p>
<p>Outputs tab delimited data on the average to a text file. Outputs the normalised average histogram bins and heights.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the file to send the output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00369">369</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l01416">isNegative()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {

        <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {

            <span class="comment">//average only makes sense if all values in the summary are positive</span>
            <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> mySummary = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad7fa37be86eb1d964b384a090dc3552f" title="Accessor for the summary.">getSummary</a>();

            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it = find_if(mySummary.begin(), mySummary.end(), <a class="code" href="adaptivehistogramvcollator_8cpp.shtml#af83155cd50512e4cbad3f931370478ee" title="Find if double is negative.">isNegative</a>);
            <span class="keywordflow">if</span> (it &lt; mySummary.end()) {
                    <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Cannot average this: the collation contains negatives&quot;</span>;
                    std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; msg &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span> &lt;&lt; std::endl;
            }
            <span class="keywordflow">else</span> {
                <span class="comment">// To generate a file output of the AdaptiveHistogramVCollator object</span>
                ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>

                <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {
                    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#ad2fe162c253c15b43027ccd44ce9136b" title="Output for for all leaves of a binary tree.">leavesAverageOutputTabs</a>(os);
                    std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the average AdaptiveHistogram has been &quot;</span>
                        &lt;&lt; <span class="stringliteral">&quot;written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
                }
                <span class="keywordflow">else</span> {
                    std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry, nothing is in collation to average&quot;</span>
                        &lt;&lt; std::endl;
                }
            }
        }
    }

    <span class="keywordflow">catch</span> (exception&amp; e) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Problem averaging: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="ac58c3f7d536168d4c9c8cbceb95b1908"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::outputDifferenceToTxtTabs" ref="ac58c3f7d536168d4c9c8cbceb95b1908" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ac58c3f7d536168d4c9c8cbceb95b1908">AdaptiveHistogramVCollator::outputDifferenceToTxtTabs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00438">438</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l02148">subpavings::SPnodeException::what()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">try</span> {

        <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {

            <span class="comment">// To generate a file output of the AdaptiveHistogramVCollator object</span>
            ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>

            <span class="keywordflow">if</span> (NULL != <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {
                <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a63529191a0b2eb1bc253c5c717fc2965">leavesDifferenceOutputTabs</a>(os);
                std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the accumulated AdaptiveHistograms &quot;</span>
                    &lt;&lt; <span class="stringliteral">&quot;has been written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
            }
            <span class="keywordflow">else</span> {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry, nothing is in collation to accumulate&quot;</span>
                    &lt;&lt; std::endl;
            }
        }
    }
    <span class="keywordflow">catch</span> (<a class="code" href="classsubpavings_1_1SPnodeException.shtml">SPnodeException</a>&amp; e) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Problem acccumulating: &quot;</span> &lt;&lt; e.<a class="code" href="classsubpavings_1_1SPnodeException.shtml#a56f1039ade7b3e954b2f30fcfac4bf2e">what</a>() &lt;&lt; std::endl;
    }

}
</pre></div>
</div>
</div>
<a class="anchor" id="a6cbc7efc97efaa397a6ed5c38b817e3a"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::outputGraphDot" ref="a6cbc7efc97efaa397a6ed5c38b817e3a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#a6cbc7efc97efaa397a6ed5c38b817e3a">AdaptiveHistogramVCollator::outputGraphDot</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a .dot graph file from collated histogram structure. </p>
<p>Makes a simple .dot graph from the histogram using node names and the .png image for this graph.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>a constructed histogram </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>a .dot file and a .png in the same directory as the program creating it was run in. </dd></dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00330">330</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (NULL == <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>) {

        <span class="keywordflow">throw</span> <a class="code" href="classsubpavings_1_1HistException.shtml">HistException</a>(<span class="stringliteral">&quot;No root paving for graph output&quot;</span>);
    }
    <span class="keywordtype">bool</span> success = <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#aaaf0891a67e056e19f8e086c0139fd96" title="Make a .dot graph file from an SPnode tree structure.">outputGraphDot</a>();
    <span class="keywordflow">return</span> success;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad2a470a3974ad963de7debb7fe870efe"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::outputToTxtTabs" ref="ad2a470a3974ad963de7debb7fe870efe" args="(const std::string &amp;s) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad2a470a3974ad963de7debb7fe870efe">AdaptiveHistogramVCollator::outputToTxtTabs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the collated information to a txt file. </p>
<p>Output tab delimited data on the collation to a text file.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the name of the file to send the output to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00345">345</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>

<p>Referenced by <a class="el" href="HoldOutHandExample_8cpp_source.shtml#l00042">main()</a>, and <a class="el" href="adaptivehistogramvalidation_8cpp_source.shtml#l01847">subpavings::AdaptiveHistogramValidation::prioritySplitAndEstimateWithSwitch()</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// To generate a file output of the AdaptiveHistogramVCollator object</span>
    ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>

    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
    std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the AdaptiveHistogramVCollator has been &quot;</span>
        &lt;&lt; <span class="stringliteral">&quot;written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3a6ff433649c11815e6be5dbd04977bf"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::outputToTxtTabs" ref="a3a6ff433649c11815e6be5dbd04977bf" args="(const std::string &amp;s, int whichColl) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#ad2a470a3974ad963de7debb7fe870efe">AdaptiveHistogramVCollator::outputToTxtTabs</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichColl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00355">355</a> of file <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// To generate a file output of the AdaptiveHistogramVCollator object</span>
    ofstream os(s.c_str());         <span class="comment">// Filename, c-string version</span>

    <a class="code" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac" title="Pointer to the root CollatorSPVnode.">rootVCollator</a>-&gt;<a class="code" href="classsubpavings_1_1CollatorSPVnode.shtml#a214a7d5e78c28dbad8da0753eebe31f4" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os, whichColl);
    std::cout &lt;&lt; <span class="stringliteral">&quot;The output of the AdaptiveHistogramVCollator has been &quot;</span>
        &lt;&lt; <span class="stringliteral">&quot;written to &quot;</span> &lt;&lt; s &lt;&lt; std::endl &lt;&lt; std::endl;
}
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aceeaa0eac30ad826088e670544e1fcac"></a><!-- doxytag: member="subpavings::AdaptiveHistogramVCollator::rootVCollator" ref="aceeaa0eac30ad826088e670544e1fcac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml">CollatorSPVnode</a>* <a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml#aceeaa0eac30ad826088e670544e1fcac">subpavings::AdaptiveHistogramVCollator::rootVCollator</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to the root <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a>. </p>
<p>A <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> is a binary tree representation of information from a number of subpavings.</p>
<p>The summary information held by the <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> for an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> is the training data count/(total training data in tree * volume), ie the normalised histogram height for a bin corresponding the box of that <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a>.</p>
<p>The Vemp information held by the <a class="el" href="classsubpavings_1_1CollatorSPVnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPVnode</a> for an <a class="el" href="classsubpavings_1_1SPSVnode.shtml" title="A derived class based on SPSnode for processing sample data split to training and validation sets...">SPSVnode</a> is the validation data count/total validation data. </p>

<p>Definition at line <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml#l00099">99</a> of file <a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml">adaptivehistogramvcollator.hpp</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00107">AdaptiveHistogramVCollator()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00280">makeAverage()</a>, <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00233">operator-()</a>, and <a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml#l00161">operator=()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="adaptivehistogramvcollator_8hpp_source.shtml">adaptivehistogramvcollator.hpp</a></li>
<li><a class="el" href="adaptivehistogramvcollator_8cpp_source.shtml">adaptivehistogramvcollator.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1AdaptiveHistogramVCollator.shtml">AdaptiveHistogramVCollator</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:32 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
