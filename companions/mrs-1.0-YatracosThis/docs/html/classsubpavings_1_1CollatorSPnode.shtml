<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MRS: A C++ Class Library for Statistical Set Processing: subpavings::CollatorSPnode Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MRS: A C++ Class Library for Statistical Set Processing
   &#160;<span id="projectnumber">0.1.2-beta1300</span>
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classsubpavings_1_1CollatorSPnode.shtml','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">subpavings::CollatorSPnode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="subpavings::CollatorSPnode" --><!-- doxytag: inherits="subpavings::SPnode" -->
<p>A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for creating summaries.  
 <a href="classsubpavings_1_1CollatorSPnode.shtml#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="collatorspnode_8hpp_source.shtml">collatorspnode.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for subpavings::CollatorSPnode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1CollatorSPnode__inherit__graph.png" border="0" usemap="#subpavings_1_1CollatorSPnode_inherit__map" alt="Inheritance graph"/></div>
<map name="subpavings_1_1CollatorSPnode_inherit__map" id="subpavings_1_1CollatorSPnode_inherit__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for subpavings::CollatorSPnode:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classsubpavings_1_1CollatorSPnode__coll__graph.png" border="0" usemap="#subpavings_1_1CollatorSPnode_coll__map" alt="Collaboration graph"/></div>
<map name="subpavings_1_1CollatorSPnode_coll__map" id="subpavings_1_1CollatorSPnode_coll__map">
</map>
<center><span class="legend">[<a target="top" href="graph_legend.shtml">legend</a>]</span></center></div>

<p><a href="classsubpavings_1_1CollatorSPnode-members.shtml">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5">CollatorSPnode</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor,  <a href="#a6f444e76ad6e0c65535e6278dbd775e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a561b7d137e120403d17008ff837e0036">CollatorSPnode</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor.  <a href="#a561b7d137e120403d17008ff837e0036"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab4777c2f663dd1faaed8568fd0707a51">CollatorSPnode</a> (ivector &amp;v, int lab, <a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> summ)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialised constructor,.  <a href="#ab4777c2f663dd1faaed8568fd0707a51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a4a01094e0378f8563fbbf40461d5b488">CollatorSPnode</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a4a01094e0378f8563fbbf40461d5b488"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a01020423e529685b484b95a73b6432ee">operator=</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a01020423e529685b484b95a73b6432ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ac71288d7ccff2a3ddf1509f5b3a54930">makeAverageCollation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aecf22d39cbb7289355a08cec62749800">getSummary</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the summary.  <a href="#aecf22d39cbb7289355a08cec62749800"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a6470a98dd502247ca9e86582b3c422eb">getNumberSummarised</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of subpavings summarised.  <a href="#a6470a98dd502247ca9e86582b3c422eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ac0b072587e955a451fab739dcb538c37">getLeafNodeAbsAreaAccumulations</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accumulations of absolute areas for leaf nodes.  <a href="#ac0b072587e955a451fab739dcb538c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a8c566a24d35898fb54133cf310276468">getLeafNodeSummaryAccumulations</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accumulations of summary values for leaf nodes.  <a href="#a8c566a24d35898fb54133cf310276468"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab58b8d4c3a8a879930da943dbe2dd62d">nodePrint</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the details of a specific node.  <a href="#ab58b8d4c3a8a879930da943dbe2dd62d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab2e1cd11ef3dd4424cf491e529ed0fd8">leafOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#ab2e1cd11ef3dd4424cf491e529ed0fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ad54a1befc9cff87c02237caeabe84ea5">leavesOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#ad54a1befc9cff87c02237caeabe84ea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0f37c9801d51df76b2acf7ea4c45e122">leavesAverageOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a0f37c9801d51df76b2acf7ea4c45e122"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#af0789230e2a9612f9b0644113e318f37">nodeExpand</a> (int comp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand leaf node to make two more leaves as children and copy summary down to the children.  <a href="#af0789230e2a9612f9b0644113e318f37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ad54fcce3c5c904f7ecf0f5042515e1a5">nodeExpand</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand leaf node to make two more leaves as children and copy summary down to the children.  <a href="#ad54fcce3c5c904f7ecf0f5042515e1a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ace8192ce1536f578c73c7aa12bb49e35">nodeReunite</a> (<a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *lChild, <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to reunite nodes to form one leaf.  <a href="#ace8192ce1536f578c73c7aa12bb49e35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aca275f3faaa0170c0612f368bae4acdf">nodeAdoptLeft</a> (<a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *lChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes. This adopts a left child rather than attempting to reunite two children into this.  <a href="#aca275f3faaa0170c0612f368bae4acdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a324588afd881d4e695f42f4a286b33a7">nodeAdoptRight</a> (<a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *rChild)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a higher level of a tree from existing nodes.  <a href="#a324588afd881d4e695f42f4a286b33a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ac1d9ea49286eb953b7bc71f89c15f8ec">makeDifferencesToAveragePaving</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a tree which holds differences of this to avg over this.  <a href="#ac1d9ea49286eb953b7bc71f89c15f8ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a700f585b2b61663330b999f459045822">getSumVarsAreaScalar</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of variances of a scalar value.  <a href="#a700f585b2b61663330b999f459045822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a4c623e6456d3ced424aebba699c33fd9">getSumVarsTotalSummarisedValueScalar</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of variances of a scalar value.  <a href="#a4c623e6456d3ced424aebba699c33fd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab32959b197c529211921f3dab4e28177">addPaving</a> (<a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Incorporate a Collator subpaving to this summmary.  <a href="#ab32959b197c529211921f3dab4e28177"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a48244aa234b59b624ec681eaf966cfe4">addNegatedPaving</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const spn, double c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Incorporate negation of a Collator subpaving to this summmary.  <a href="#a48244aa234b59b624ec681eaf966cfe4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a406e23c3f85680631bd30897fb1cfdc2">leavesAccumulationOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for for <b>all leaves</b> of a binary tree.  <a href="#a406e23c3f85680631bd30897fb1cfdc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0ea530d232bf3bb09e6cf44eeeadbfde">leafAccumulationOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a0ea530d232bf3bb09e6cf44eeeadbfde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a812d98c784af382c4a697555a7b0445f">nodeAccumulation</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#acdad2b87cf5f979fb24a7aef392a5895">leafMakeNewFhat</a> (double wt, std::vector&lt; double &gt; &amp;fhatNew)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a236e44d75b1cf0988a014f7ae33c55b6">leavesMakeNewFhat</a> (double wt, std::vector&lt; double &gt; &amp;fhatNew)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a827a6e8b21b3c6e8e8f8e9aeca4b622b">getLeaves</a> (std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp;leaves) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a7fa06e6f1d278157e7c5c6a9d44e2c07">getAllNodes</a> (std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp;allNodes) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0e8574a8a951a2716cbb29b8e1fbbc33">totaliseSummaries</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total the summaries from this node downwards.  <a href="#a0e8574a8a951a2716cbb29b8e1fbbc33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab374777116b7e0af8e7100f303e1f97b">getSplitDim</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the dimension a node split on.  <a href="#ab374777116b7e0af8e7100f303e1f97b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a77e75118f31767497377790cd87e3869">getTotalSummary</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a8c48fd024a9e569830168a3f301d798e">getTotalSummaryAv</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a944e27bc584e24e630411e787456ffe0">getL1DistancesToAverage</a> (<a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;container) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#af089a7955e0dd12ef33af3ec4bfc6627">nodeCheckRowSummary</a> (int theta, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matrix against the columns.  <a href="#af089a7955e0dd12ef33af3ec4bfc6627"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aeb5549c6c555a65ee6cf71e779873b67">nodeCheckColSummary</a> (int theta, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos matrix against the rows.  <a href="#aeb5549c6c555a65ee6cf71e779873b67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a72b47c222d49deba3753259d94d730c3">getNodeDelta</a> (int thisTheta, size_t sizeColl)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the delta value for a specific theta.  <a href="#a72b47c222d49deba3753259d94d730c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aaf5207af98f7fac37ffe63ab3aec15b9">getYatSet</a> (std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &gt; &amp;YatSetRow, std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &gt; &amp;YatSetCol, size_t cand1, size_t cand2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Yatracos set for a particular pair.  <a href="#aaf5207af98f7fac37ffe63ab3aec15b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a9509d8f49407c1b14148f80758f02646">getScheffeNode</a> (int theta1, int theta2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2, where theta1 &lt; theta2.  <a href="#a9509d8f49407c1b14148f80758f02646"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3c3d4df6f965a2eee9b4c517eb045246">getScheffeSet</a> (std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &gt; &amp;ScheffeSet, size_t cand1, size_t cand2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Scheffe set for a particular pair.  <a href="#a3c3d4df6f965a2eee9b4c517eb045246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3b6cd985321d1ecae0a856ab881d6e62">swapCollator</a> (<a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap this and another node.  <a href="#a3b6cd985321d1ecae0a856ab881d6e62"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors for links between the nodes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These accessor methods shadow equivalent methods in the base class. Thus the method used is determined at compile time, not run time as would be the case if virtual methods were used. Because the pointers to parents and children are part of the base class definition, the methods have to cast the base class from to the derived class form in order for the pointer returned to be able to be used with derived class members.</p>
<p>Note that pointers for parent, leftChild, and rightChild are not reference counted so there could potentially be problems with the use of returned pointers (for instance, being used to delete nodes). These pointers might be better implemented with boost::shared_ptr . </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aed3cb2aceae3c384eed427a404a6c8f6">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the parent of a node.  <a href="#aed3cb2aceae3c384eed427a404a6c8f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82">getLeftChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the left child of a node.  <a href="#a5e1b32d7fffa9cfc7865b384c2e89a82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6">getRightChild</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the right child of a node.  <a href="#ab93823657d610d99e885317c2cf2e8f6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a66a0f1bc3a886c904f8192774b531437">addPavings</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two collator subpavings together.  <a href="#a66a0f1bc3a886c904f8192774b531437"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a79e263c5e6b22baeb2f4e543f33f6d5e">subtractPavings</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const lhs, const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const rhs, double c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract one collator subpavings from another together.  <a href="#a79e263c5e6b22baeb2f4e543f33f6d5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ae156be7c91a97c25628edc6fcf00e1f9">_marginalise</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const rhs, const std::vector&lt; int &gt; &amp;outDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a marginalised version of a given node.  <a href="#ae156be7c91a97c25628edc6fcf00e1f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aec7d6bcee79660a09914100f9b878611">marginalise</a> (const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const rhs, const std::vector&lt; int &gt; &amp;reqDims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a marginalised version of subpaving with root node <em>rhs</em>.  <a href="#aec7d6bcee79660a09914100f9b878611"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aa14e448dca22fa7c14de4d21c0624b26">CollatorSPnode</a> (const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const spn, size_t bigN)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3ba268993642c1fd5c702966a4fd4fba">nodeNegate</a> (double c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates the summary for every node in tree rooted at this.  <a href="#a3ba268993642c1fd5c702966a4fd4fba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a9fe7256f1a62884e4bb8599a63abbbdf">leafAverageOutputTabs</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output for a node in a binary tree, tab-delimited.  <a href="#a9fe7256f1a62884e4bb8599a63abbbdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a5ac89a38985d8ff62ca7a29943c6734c">getLeafNodeAbsAreaAccumulations</a> (<a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp;areaAcc) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to the accumulation of absolute areas for leaf nodes.  <a href="#a5ac89a38985d8ff62ca7a29943c6734c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0afe525dbddf958078e9a8eac6ea88a3">getLeafNodeAbsAreaAccumulationTotal</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total accumulated value of absolute areas for leaf nodes.  <a href="#a0afe525dbddf958078e9a8eac6ea88a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a7daf828f08626b5b83654550e5a98bee">getLeafNodeSummaryAccumulations</a> (<a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp;summAcc) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to accumulation of summary values for leaf nodes.  <a href="#a7daf828f08626b5b83654550e5a98bee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a66a1a3e5a8c9c81e4f3b307360c2c495">dotDiffPaving</a> (<a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const spn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">make this the root of a tree representing summary differences  <a href="#a66a1a3e5a8c9c81e4f3b307360c2c495"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3a0733086ac4a95e954da0cd8f0e1dfa">dotDifferenceSummary</a> (<a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> &amp;lhsSummary, <a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> &amp;rhsSummary)</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec">summary</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A container of summary values from the collated subpavings.  <a href="#abecd2f87f50d84f2c3d04e6b0b15a5ec"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A derived class based on <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> for creating summaries. </p>
<p>Creates summaries from other nodes from the SP node family.</p>
<p>The base class <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a> is a node in the representation of a regular subpaving as a binary tree. A node represents a box (interval vector). SPnodes are linked together to form the tree. The initial box of the subpaving is the box represented by the root node of the tree. A box which has been split will be represented as node with one or two children. A subpaving of [<b>x</b>] (union of non-overlapping sub- boxes of [<b>x</b>]) is represented by the leaves (degenerate/ child-less) nodes in the tree.</p>
<p>The <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPnode</a> class collates data from a collection of SPnodes or objects from classes derived from <a class="el" href="classsubpavings_1_1SPnode.shtml" title="SPnodes are nodes in the representation of a subpaving as a binary tree.">SPnode</a>.</p>
<p>An entire tree structure represents a union over each tree collated, ie the boxes of the leaves of the collated tree make a subpaving that is the union of the subpavings represented by each tree collated.</p>
<p>Each node has a container structure (the summary) holding one value for each corresponding collated. </p>

<p>Definition at line <a class="el" href="collatorspnode_8hpp_source.shtml#l00065">65</a> of file <a class="el" href="collatorspnode_8hpp_source.shtml">collatorspnode.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa14e448dca22fa7c14de4d21c0624b26"></a><!-- doxytag: member="subpavings::CollatorSPnode::CollatorSPnode" ref="aa14e448dca22fa7c14de4d21c0624b26" args="(const SPSnode *const spn, size_t bigN)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aa14e448dca22fa7c14de4d21c0624b26">subpavings::CollatorSPnode::CollatorSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bigN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Private initialised constructor.</p>
<p>Initialised with a pointer to an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a> and a normalising constant, eg sum of counts in each node for a histogram The summary becomes count /(normalising constant * vol) for the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bigN</td><td>the normalising constant. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00056">56</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00382">subpavings::SPnode::getDimension()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(spn-&gt;getBox());
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = spn-&gt;getDimension();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = spn-&gt;getLabel();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = spn-&gt;getNodeName();

            <span class="comment">// add the summary to the vector summary</span>
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.push_back((spn-&gt;getCounter())/
                                (1.0 * bigN * spn-&gt;nodeVolume()));

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (spn-&gt;hasLCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(spn-&gt;getLeftChild(), bigN));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (spn-&gt;hasRCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(spn-&gt;getRightChild(), bigN));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6f444e76ad6e0c65535e6278dbd775e5"></a><!-- doxytag: member="subpavings::CollatorSPnode::CollatorSPnode" ref="a6f444e76ad6e0c65535e6278dbd775e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aa14e448dca22fa7c14de4d21c0624b26">subpavings::CollatorSPnode::CollatorSPnode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>default constructor, </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">358</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00912">addPavings()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">CollatorSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">makeAverageCollation()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01048">makeDifferencesToAveragePaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">operator=()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00984">subtractPavings()</a>.</p>
<div class="fragment"><pre class="fragment">{}
</pre></div>
</div>
</div>
<a class="anchor" id="a561b7d137e120403d17008ff837e0036"></a><!-- doxytag: member="subpavings::CollatorSPnode::CollatorSPnode" ref="a561b7d137e120403d17008ff837e0036" args="(const SPSnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aa14e448dca22fa7c14de4d21c0624b26">subpavings::CollatorSPnode::CollatorSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1SPSnode.shtml">SPSnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor. </p>
<p>Initialised with a pointer to an <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>. The collatorSPSnode summary information is the k/vol of the <a class="el" href="classsubpavings_1_1SPSnode.shtml" title="A derived class based on SPnode for processing sample data.">SPSnode</a>, ie effectively the height of a histogram bin formed by the box associated with that node. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00362">362</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l00997">subpavings::SPSnode::getCounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00382">subpavings::SPnode::getDimension()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01034">subpavings::SPSnode::getLeftChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00424">subpavings::SPnode::getNodeName()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01039">subpavings::SPSnode::getRightChild()</a>, <a class="el" href="spsnode_8cpp_source.shtml#l01485">subpavings::SPSnode::getRootCounter()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(spn-&gt;getBox());
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = spn-&gt;getDimension();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = spn-&gt;getLabel();
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = spn-&gt;getNodeName();

            <span class="comment">// add the normalised count/volume to the vector summary</span>

            <span class="keywordtype">size_t</span> rootCounter = spn-&gt;getRootCounter();

            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.push_back(spn-&gt;getCounter()/
                                (rootCounter * spn-&gt;nodeVolume()));

            <span class="comment">//recursion on the children using constructor which normalises counts</span>
            <span class="keywordflow">if</span> (spn-&gt;hasLCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(spn-&gt;getLeftChild(),
                                                    rootCounter));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (spn-&gt;hasRCwithBox()) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(spn-&gt;getRightChild(),
                                                    rootCounter));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab4777c2f663dd1faaed8568fd0707a51"></a><!-- doxytag: member="subpavings::CollatorSPnode::CollatorSPnode" ref="ab4777c2f663dd1faaed8568fd0707a51" args="(ivector &amp;v, int lab, VecDbl summ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aa14e448dca22fa7c14de4d21c0624b26">subpavings::CollatorSPnode::CollatorSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">ivector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a>&#160;</td>
          <td class="paramname"><em>summ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialised constructor,. </p>
<p>Initialised with a box, a label, and a vector summary, </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00401">401</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(v, lab)
    {
        <span class="keywordflow">try</span> {
            <span class="comment">// copy the vector summary</span>
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a> = summ;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4a01094e0378f8563fbbf40461d5b488"></a><!-- doxytag: member="subpavings::CollatorSPnode::CollatorSPnode" ref="a4a01094e0378f8563fbbf40461d5b488" args="(const CollatorSPnode &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aa14e448dca22fa7c14de4d21c0624b26">subpavings::CollatorSPnode::CollatorSPnode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">419</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">        : <a class="code" href="classsubpavings_1_1SPnode.shtml#a7a1699938bb9acff0c04b07be9d64e54" title="Default constructor.">SPnode</a>(*(other.theBox), other.label)
    {
        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a> = other.summary;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = other.nodeName;

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (other.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                    *(other.getLeftChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (other.rightChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                    *(other.getRightChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae156be7c91a97c25628edc6fcf00e1f9"></a><!-- doxytag: member="subpavings::CollatorSPnode::_marginalise" ref="ae156be7c91a97c25628edc6fcf00e1f9" args="(const CollatorSPnode *const rhs, const std::vector&lt; int &gt; &amp;outDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ae156be7c91a97c25628edc6fcf00e1f9">subpavings::CollatorSPnode::_marginalise</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a marginalised version of a given node. </p>
<p>Private version, works recursively to marginalise from this node down.</p>
<p>Marginalises to take out the given dimensions and adjust summaries so that overall sum of (node vol x accumulated summaries) is the same as for <em>rhs</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>is the root of the node to marginalise.  is a vector of the dimensions to take out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>root of a tree of marginalised nodes. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">1503</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00912">addPavings()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01698">getSplitDim()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00562">getSummary()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">totaliseSummaries()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>, and <a class="el" href="AIAsubpaving_8cpp_source.shtml#l00077">Volume()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01636">marginalise()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* marginal = NULL;
    <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a> * newRC = NULL;
    <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a> * newLC = NULL;
        
    <span class="keywordflow">try</span> {
      
      <span class="keywordflow">if</span> (rhs != NULL ) { <span class="comment">// if NULL we just return NULL</span>
              
        ivector box = rhs-&gt;getBox();
        <span class="comment">// will throw an exception if there is no box</span>
        <span class="keywordtype">int</span> dim = VecLen(box);
        <span class="keywordtype">int</span> boxLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
        
        <span class="keywordtype">int</span> splitDim = rhs-&gt;getSplitDim();
        
        <span class="comment">// deal with children first</span>
        <span class="keywordflow">if</span> (!rhs-&gt;isLeaf()) {
                              
          newRC = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ae156be7c91a97c25628edc6fcf00e1f9" title="Make a marginalised version of a given node.">_marginalise</a>(rhs-&gt;getRightChild(), outDims);
          newLC = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ae156be7c91a97c25628edc6fcf00e1f9" title="Make a marginalised version of a given node.">_marginalise</a>(rhs-&gt;getLeftChild(), outDims);
        
        } <span class="comment">// end isLeaf()</span>
        
        <span class="comment">// now deal with this node itself</span>
        <span class="comment">// if rhs a leaf, or did not split on any of the given dimensions</span>
        <span class="comment">// make a node that contracts rhs</span>
        
        <span class="comment">// iterator to vector element:</span>
        std::vector&lt;int&gt;::const_iterator found 
            = find (outDims.begin(), outDims.end(), splitDim);
        
        <span class="keywordflow">if</span> (found &lt; outDims.end()) { <span class="comment">// split on one of the outDims</span>
          <span class="comment">// so this will become the result of adding together</span>
          <span class="comment">// the two new children</span>
          marginal = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a66a0f1bc3a886c904f8192774b531437" title="Add two collator subpavings together.">addPavings</a>(newRC, newLC);
          <span class="comment">// addPavings takes copies of the nodes to be added</span>
          <span class="comment">// so we need to destroy these ones</span>
          <span class="keyword">delete</span> newRC;
          newRC = NULL;
          <span class="keyword">delete</span> newLC;
          newLC = NULL;
          
          marginal-&gt;totaliseSummaries(); 
        }
        <span class="keywordflow">else</span> { <span class="comment">// did not split on an outdim or is a leaf</span>
          <span class="comment">// have to contract rhs and then add the children</span>
          <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp = rhs-&gt;getSummary();
          <span class="keywordtype">int</span> l = rhs-&gt;getLabel();
          <span class="keywordtype">int</span> newDims = dim - outDims.size();
          <span class="comment">// for every missing dimension</span>
          ivector newBox = ivector(newDims); 
          <span class="keywordtype">int</span> index = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(newBox);
          <span class="keywordtype">int</span> oldindex = boxLB;
          
          <span class="keywordflow">for</span> (; oldindex &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(box); oldindex++) {
            std::vector&lt;int&gt;::const_iterator fit 
            = find (outDims.begin(), outDims.end(), (oldindex - boxLB + 1));
            <span class="keywordflow">if</span> (!(fit &lt; outDims.end())) { <span class="comment">// keep this one</span>
              newBox[index] = box[oldindex];
              index++;
              
            }
          }
          
          <span class="keywordtype">double</span> missingVol = <a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(box)/<a class="code" href="AIAsubpaving_8cpp.shtml#a7f6354ab5e7b1310b03f0e190169eabe">Volume</a>(newBox);
          
          transform(temp.begin(), temp.end(), temp.begin(), 
          std::bind1st(multiplies&lt;double&gt;(), missingVol) );
          
          marginal = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(newBox, rhs-&gt;getLabel(), temp);
          marginal-&gt;totaliseSummaries(); 
                    
          <span class="keywordflow">if</span> (!rhs-&gt;isLeaf()) {
            marginal-&gt;nodeAddRight(newRC);
            marginal-&gt;nodeAddLeft(newLC);
          }
          newRC = NULL;
          newLC = NULL;
          
          } <span class="comment">// finished else</span>
      } <span class="comment">// end if not NULL</span>
      
      <span class="comment">// clean up assuming no problems so far</span>
      <span class="keywordflow">if</span> (newRC != NULL) {
        <span class="keywordflow">try</span> {
          <span class="keyword">delete</span> newRC;
        }
        <span class="keywordflow">catch</span> (exception&amp; ee) {} <span class="comment">// catch and swallow</span>
      }
      <span class="keywordflow">if</span> (newLC != NULL) {
        <span class="keywordflow">try</span> {
          <span class="keyword">delete</span> newLC;
        }
        <span class="keywordflow">catch</span> (exception&amp; ee) {} <span class="comment">// catch and swallow</span>
      }
      
      <span class="keywordflow">return</span> marginal;
      
        } <span class="comment">// end try</span>
        <span class="keywordflow">catch</span> (exception&amp; e) {
            
            
            <span class="keywordflow">if</span> (newRC != NULL) {
        <span class="keywordflow">try</span> {
          <span class="keyword">delete</span> newRC;
        }
        <span class="keywordflow">catch</span> (exception&amp; ee) {} <span class="comment">// catch and swallow</span>
      }
      <span class="keywordflow">if</span> (newLC != NULL) {
        <span class="keywordflow">try</span> {
          <span class="keyword">delete</span> newLC;
        }
        <span class="keywordflow">catch</span> (exception&amp; ee) {} <span class="comment">// catch and swallow</span>
      }
      <span class="keywordflow">if</span> (marginal != NULL) {
        <span class="keywordflow">try</span> {
          <span class="keyword">delete</span> marginal;
        }
        <span class="keywordflow">catch</span> (exception&amp; ee) {} <span class="comment">// catch and swallow</span>
      }
            
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = e.what();
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Error in _marginalise:\n &quot;</span> + std::string(msg));
        }
      
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a48244aa234b59b624ec681eaf966cfe4"></a><!-- doxytag: member="subpavings::CollatorSPnode::addNegatedPaving" ref="a48244aa234b59b624ec681eaf966cfe4" args="(const CollatorSPnode *const spn, double c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a48244aa234b59b624ec681eaf966cfe4">subpavings::CollatorSPnode::addNegatedPaving</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Incorporate negation of a Collator subpaving to this summmary. </p>
<p>Adjusts the tree rooted at this node for the tree being added. The tree rooted at this node will expand if necessary to have at least all the leaves of the tree of the tree being added. The summary for this node will increase to include the negation of the summary of the node being added.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>pointer to the Collator subpaving to be incorporated into the summary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that the contents of the Collator subpaving added will be altered: it is assumed that the Collator subpaving to be added is a temporary object made and passed in with a wrapper class </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01323">1323</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00090">nodeNegate()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00564">subpavings::AdaptiveHistogramCollator::addNegationToCollation()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00984">subtractPavings()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        SPSnode* temp = NULL;

        <span class="keywordflow">try</span> {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* temp = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a> (*spn);

            <span class="comment">// negate the node passed in</span>
            temp-&gt;nodeNegate(c);

            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab32959b197c529211921f3dab4e28177" title="Incorporate a Collator subpaving to this summmary.">addPaving</a>(temp);

            <span class="keyword">delete</span> temp;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addNegatedPaving&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab32959b197c529211921f3dab4e28177"></a><!-- doxytag: member="subpavings::CollatorSPnode::addPaving" ref="ab32959b197c529211921f3dab4e28177" args="(CollatorSPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab32959b197c529211921f3dab4e28177">subpavings::CollatorSPnode::addPaving</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Incorporate a Collator subpaving to this summmary. </p>
<p>Adjusts the tree rooted at this node for the tree being added. The tree rooted at this node will expand if necessary to have at least all the leaves of the tree of the tree being added. The summary for this node will increase to include the summary of the node being added.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>pointer to the Collator subpaving to be incorporated into the summary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the paving could be added, false otherwise. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that the contents of the Collator subpaving added will be altered: it is assumed that the Collator subpaving to be added is a temporary object made and passed in from a wrapper class </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">1211</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00562">getSummary()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00753">nodeExpand()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00912">addPavings()</a>, <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00521">subpavings::AdaptiveHistogramCollator::addToCollation()</a>, and <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00381">subpavings::AdaptiveHistogramCollator::operator+=()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;  <span class="comment">// indicator for done adding</span>

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (spn == NULL) {
                done = <span class="keyword">true</span>;

            }

            <span class="comment">// if the boxes are not the same we can&#39;t do anything</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) &amp;&amp; (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != spn-&gt;getBox())) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes do not match&quot;</span>);
            }

            <span class="comment">// if this has no box yet it has not incorporated anything</span>
            <span class="comment">// and so we just use spn to construct this</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> == NULL)) {

                ivector v = spn-&gt;getBox();

                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(v);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(v) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(v) + 1;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = spn-&gt;getLabel();

                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a> = spn-&gt;summary;

                <span class="comment">//recursion on the children</span>
                <span class="keywordflow">if</span> (spn-&gt;leftChild) {
                    <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                        *(spn-&gt;getLeftChild())));

                }
                <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

                <span class="keywordflow">if</span> (spn-&gt;rightChild) {
                    <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                        *(spn-&gt;getRightChild())));
                 }
                <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;

                done = <span class="keyword">true</span>;
                retValue = <span class="keyword">true</span>;

            } <span class="comment">// end if theBox==NULL</span>

            <span class="comment">// do the rest only if done is not true</span>

            <span class="comment">// if this is a leaf and the paving to be added is a leaf,</span>
            <span class="comment">// this just sucks in the counter from spn</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; !done &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; spn-&gt;isLeaf()) {

                <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp = spn-&gt;getSummary();
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.insert(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(), temp.begin(),temp.end());
                done = <span class="keyword">true</span>;
                retValue = <span class="keyword">true</span>;

            }

            <span class="comment">// else not done and not both leaves,</span>
            <span class="comment">// if this is not a leaf or the paving to be added</span>
            <span class="comment">// is not a leaf, we may need to split</span>
            <span class="comment">// and we will need to recurse further</span>
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!done &amp;&amp; (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() || !(spn-&gt;isLeaf()))) {

                <span class="comment">// if this is leaf and spn not we need to split this</span>
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// so spn can&#39;t be a leaf</span>

                    <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ad54fcce3c5c904f7ecf0f5042515e1a5" title="Expand leaf node to make two more leaves as children and copy summary down to the children...">nodeExpand</a>();
                }

                <span class="comment">// if spn is leaf and this is not we need to split spn</span>
                <span class="comment">// THIS WILL CHANGE the CollatorSPnode pointed to by spn</span>

                <span class="keywordflow">if</span> (spn-&gt;isLeaf()) { <span class="comment">// so this can&#39;t be a leaf</span>

                    spn-&gt;nodeExpand();

                }

                <span class="comment">// put in the data</span>
                <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp = spn-&gt;getSummary();
                    <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.insert(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(), temp.begin(),temp.end());

                <span class="comment">// if they are were neither leaves originally</span>
                <span class="comment">// we go straight on to recursing with the children</span>
                <span class="comment">// otherwise expansions above are followed by recursion</span>

                <span class="comment">// recurse with children</span>
                retValue = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab32959b197c529211921f3dab4e28177" title="Incorporate a Collator subpaving to this summmary.">addPaving</a>(spn-&gt;getLeftChild());
                retValue = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab32959b197c529211921f3dab4e28177" title="Incorporate a Collator subpaving to this summmary.">addPaving</a>(spn-&gt;getRightChild());

            } <span class="comment">// end of dealing with case where at least one is not a leaf</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addPaving&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a66a0f1bc3a886c904f8192774b531437"></a><!-- doxytag: member="subpavings::CollatorSPnode::addPavings" ref="a66a0f1bc3a886c904f8192774b531437" args="(const CollatorSPnode *const lhs, const CollatorSPnode *const rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a66a0f1bc3a886c904f8192774b531437">subpavings::CollatorSPnode::addPavings</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add two collator subpavings together. </p>
<p>Collator returned has summary with contents of both operands' summaries.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to the root of one collator to be added. </td></tr>
    <tr><td class="paramname">lhs</td><td>pointer to the root of the other collator to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the root of a new collator subpaving where the summmary is the combined summary of the operands (lhs first, then rhs). </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00912">912</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>, and <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00340">subpavings::AdaptiveHistogramCollator::operator+()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* newCollator = NULL;
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* temp = NULL;

        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (lhs == NULL &amp;&amp; rhs == NULL) done = <span class="keyword">true</span>; <span class="comment">// return null</span>

            <span class="comment">// if exactly one is null we can return a copy of the non-null one</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs == NULL &amp;&amp; rhs != NULL) {

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*rhs);
                done = <span class="keyword">true</span>;

            }
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs == NULL) {

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*lhs);
                done = <span class="keyword">true</span>;
            }
            <span class="comment">// both not null</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs != NULL) {

                <span class="keywordflow">if</span> ((lhs-&gt;getBox() != NULL) &amp;&amp;
                                (lhs-&gt;getBox() != rhs-&gt;getBox())) {
                    <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes do not match&quot;</span>);
                }

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*lhs);
                temp = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*rhs);

                newCollator-&gt;addPaving(temp);
                <span class="keyword">delete</span> temp;
                temp = NULL;
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">if</span> (temp != NULL) {
                <span class="keyword">delete</span> temp;
                temp = NULL;
            }
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addPavings&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">if</span> (temp != NULL) {
                <span class="keyword">delete</span> temp;
                temp = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newCollator;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3a0733086ac4a95e954da0cd8f0e1dfa"></a><!-- doxytag: member="subpavings::CollatorSPnode::dotDifferenceSummary" ref="a3a0733086ac4a95e954da0cd8f0e1dfa" args="(VecDbl &amp;lhsSummary, VecDbl &amp;rhsSummary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3a0733086ac4a95e954da0cd8f0e1dfa">subpavings::CollatorSPnode::dotDifferenceSummary</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> &amp;&#160;</td>
          <td class="paramname"><em>lhsSummary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> &amp;&#160;</td>
          <td class="paramname"><em>rhsSummary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replace lhs data with the the dot difference of lhs and rhs data.</p>
<p>If lhsSummary is originally &lt;h1..hn&gt; and rhsSummary is &lt;H1..Hm&gt; then the lhsSummary becomes &lt;h1-H1, .. Hn-H1, .. , hn-H1, .. ,Hn-Hm&gt; </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00140">140</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="comment">// replace lhs data with the the dot difference of lhs and rhs data</span>
        <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> originalSummary = lhsSummary;
        lhsSummary.clear();
        <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
        <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> sit;
        <span class="keywordflow">for</span> (sit = rhsSummary.begin(); sit &lt; rhsSummary.end(); sit++) {
            <span class="keywordflow">for</span> (it = originalSummary.begin(); it &lt; originalSummary.end();
                                                        it++) {
                lhsSummary.push_back(*it - *sit); <span class="comment">// push back the diff</span>
            }
        }
        <span class="keywordflow">return</span> lhsSummary;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a66a1a3e5a8c9c81e4f3b307360c2c495"></a><!-- doxytag: member="subpavings::CollatorSPnode::dotDiffPaving" ref="a66a1a3e5a8c9c81e4f3b307360c2c495" args="(CollatorSPnode *const spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a66a1a3e5a8c9c81e4f3b307360c2c495">subpavings::CollatorSPnode::dotDiffPaving</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>make this the root of a tree representing summary differences </p>
<p>The tree will be the union of this tree and the spn tree The summary is the element-by-element difference between this's summary and the spn's summary. ie if this node has summary &lt;h1..hn&gt; and spn's equivalent node summary is &lt;H1..Hm&gt; then this's summary becomes &lt;h1-H1, .. Hn-H1, .. , hn-H1, .. ,Hn-Hm&gt; </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">244</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00391">subpavings::SPnode::getLabel()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00562">getSummary()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8cpp_source.shtml#l02192">subpavings::isLeaf()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">nodeExpand()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01048">makeDifferencesToAveragePaving()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordtype">bool</span> retValue = <span class="keyword">false</span>;
        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;  <span class="comment">// indicator for done adding</span>

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (spn == NULL) {
                done = <span class="keyword">true</span>;

            }

            <span class="comment">// if the boxes are not the same we can&#39;t do anything</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) &amp;&amp; (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != spn-&gt;getBox())) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes do not match&quot;</span>);
            }

            <span class="comment">// if this has no box yet it has not incorporated anything</span>
            <span class="comment">// and so we just use spn to construct this</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> == NULL)) {

                ivector v = spn-&gt;getBox();

                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = <span class="keyword">new</span> ivector(v);
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(v) - <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(v) + 1;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = spn-&gt;getLabel();

                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a> = spn-&gt;summary;

                <span class="comment">//recursion on the children</span>
                <span class="keywordflow">if</span> (spn-&gt;leftChild) {
                    <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                        *(spn-&gt;getLeftChild())));

                }
                <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

                <span class="keywordflow">if</span> (spn-&gt;rightChild) {
                    <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                        *(spn-&gt;getRightChild())));
                 }
                <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;

                done = <span class="keyword">true</span>;
                retValue = <span class="keyword">true</span>;

            } <span class="comment">// end if theBox==NULL</span>

            <span class="comment">// do the rest only if done is not true</span>

            <span class="comment">// if this is a leaf and the paving to be added is a leaf</span>
            <span class="comment">// this summary becomes the dot difference of the summaries</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; !done &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() &amp;&amp; spn-&gt;isLeaf()) {

                <span class="comment">// make this summary into the dot difference of this summary</span>
                <span class="comment">// and spn summary</span>
                <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> spnSummary = spn-&gt;getSummary();
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a> = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a3a0733086ac4a95e954da0cd8f0e1dfa">dotDifferenceSummary</a>(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>, spnSummary);
            }

            <span class="comment">// else not done and not both leaves,</span>
            <span class="comment">// if this is not a leaf or the paving to be added</span>
            <span class="comment">// is not a leaf, we may need to split</span>
            <span class="comment">// and we will need to recurse further</span>
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!done &amp;&amp; (!<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() || !(spn-&gt;isLeaf()))) {

                <span class="comment">// if this is leaf and spn not we need to split this</span>
                <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// so spn can&#39;t be a leaf</span>

                    <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ad54fcce3c5c904f7ecf0f5042515e1a5" title="Expand leaf node to make two more leaves as children and copy summary down to the children...">nodeExpand</a>();
                }

                <span class="comment">// if spn is leaf and this is not we need to split spn</span>
                <span class="comment">// THIS WILL CHANGE the CollatorSPnode pointed to by spn</span>

                <span class="keywordflow">if</span> (spn-&gt;isLeaf()) { <span class="comment">// so this can&#39;t be a leaf</span>

                    spn-&gt;nodeExpand();
                }

                <span class="comment">// make this summary into the dot difference of this summary</span>
                <span class="comment">// and spn summary</span>
                <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> spnSummary = spn-&gt;getSummary();
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a> = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a3a0733086ac4a95e954da0cd8f0e1dfa">dotDifferenceSummary</a>(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>, spnSummary);


                <span class="comment">// if they are were neither leaves originally</span>
                <span class="comment">// we go straight on to recursing with the children</span>
                <span class="comment">// otherwise expansions above are followed by recursion</span>

                <span class="comment">// recurse with children</span>
                retValue = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a66a1a3e5a8c9c81e4f3b307360c2c495" title="make this the root of a tree representing summary differences">dotDiffPaving</a>(
                        spn-&gt;getLeftChild());
                retValue = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a66a1a3e5a8c9c81e4f3b307360c2c495" title="make this the root of a tree representing summary differences">dotDiffPaving</a>(
                        spn-&gt;getRightChild());

            } <span class="comment">// end of dealing with case where at least one is not a leaf</span>
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in dotDiffPaving&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> retValue;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7fa06e6f1d278157e7c5c6a9d44e2c07"></a><!-- doxytag: member="subpavings::CollatorSPnode::getAllNodes" ref="a7fa06e6f1d278157e7c5c6a9d44e2c07" args="(std::vector&lt; CollatorSPnode * &gt; &amp;allNodes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a7fa06e6f1d278157e7c5c6a9d44e2c07">subpavings::CollatorSPnode::getAllNodes</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>allNodes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return a reference to a container of node pointers. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">1461</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">getAllNodes()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">getAllNodes()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) { <span class="comment">// this is not empty</span>
      <span class="comment">//if (!hasLCwithBox() &amp;&amp; !hasRCwithBox()) { // this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
        <span class="comment">//cout &lt;&lt; nodeName &lt;&lt; endl;</span>
            allNodes.push_back(const_cast&lt;CollatorSPnode*&gt;(<span class="keyword">this</span>));
        }
      
      <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a7fa06e6f1d278157e7c5c6a9d44e2c07">getAllNodes</a>(allNodes);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a7fa06e6f1d278157e7c5c6a9d44e2c07">getAllNodes</a>(allNodes);
        }       
        <span class="keywordflow">return</span> allNodes;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="a944e27bc584e24e630411e787456ffe0"></a><!-- doxytag: member="subpavings::CollatorSPnode::getL1DistancesToAverage" ref="a944e27bc584e24e630411e787456ffe0" args="(RealVec &amp;container) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a944e27bc584e24e630411e787456ffe0">subpavings::CollatorSPnode::getL1DistancesToAverage</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01765">1765</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00160">getLeafNodeAbsAreaAccumulations()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01048">makeDifferencesToAveragePaving()</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">  {
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* differences = NULL;
        
        <span class="comment">// take this collation</span>
        <span class="keywordflow">try</span> {
            <span class="comment">// make a tree of differences between this and average over this</span>
            differences = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac1d9ea49286eb953b7bc71f89c15f8ec" title="Make a tree which holds differences of this to avg over this.">makeDifferencesToAveragePaving</a>();
      
            <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size();
            dotprecision emptyDP(0.0);
            <a class="code" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605" title="Define type VecDotPrec as a container of cxsc dotprecision variables.">VecDotPrec</a> areaAcc(n, emptyDP); <span class="comment">// n copies of empty dot prec</span>

            areaAcc = differences-&gt;getLeafNodeAbsAreaAccumulations(areaAcc);
      <span class="comment">// one L1 distance-to-average summary, in the form of a dot precision, for </span>
      <span class="comment">// each histogram </span>

      <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> temp(n);
      temp.swap(container); <span class="comment">// clear container and minimize memory</span>
      
      <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> it;
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {
        <span class="comment">// put rounded L1 diff into the container</span>
        container.at(i) = rnd( areaAcc.at(i) ); <span class="comment">// round to nearest</span>
            }

            <span class="keyword">delete</span> differences;
            differences = NULL;
      
      <span class="keywordflow">return</span> container;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (NULL != differences) {
                <span class="keyword">delete</span> differences;
                differences = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5ac89a38985d8ff62ca7a29943c6734c"></a><!-- doxytag: member="subpavings::CollatorSPnode::getLeafNodeAbsAreaAccumulations" ref="a5ac89a38985d8ff62ca7a29943c6734c" args="(VecDotPrec &amp;areaAcc) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a5ac89a38985d8ff62ca7a29943c6734c">subpavings::CollatorSPnode::getLeafNodeAbsAreaAccumulations</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp;&#160;</td>
          <td class="paramname"><em>areaAcc</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add to the accumulation of absolute areas for leaf nodes. </p>
<p>If this node is a leaf, add its accumulation of summary areas to the overall accumulation. Area for a value s in the summary is s * volume of node. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00160">160</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01765">getL1DistancesToAverage()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01100">getSumVarsAreaScalar()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            areaAcc = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5ac89a38985d8ff62ca7a29943c6734c" title="Add to the accumulation of absolute areas for leaf nodes.">getLeafNodeAbsAreaAccumulations</a>(areaAcc);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            areaAcc = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5ac89a38985d8ff62ca7a29943c6734c" title="Add to the accumulation of absolute areas for leaf nodes.">getLeafNodeAbsAreaAccumulations</a>(areaAcc);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();

            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin();
            <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> dpit;

            <span class="keywordflow">for</span> (dpit = areaAcc.begin(); dpit &lt; areaAcc.end(); dpit++) {

                cxsc::accumulate((*dpit), abs(*it), vol);

                it++;
            }
        }

        <span class="keywordflow">return</span> areaAcc;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac0b072587e955a451fab739dcb538c37"></a><!-- doxytag: member="subpavings::CollatorSPnode::getLeafNodeAbsAreaAccumulations" ref="ac0b072587e955a451fab739dcb538c37" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a5ac89a38985d8ff62ca7a29943c6734c">subpavings::CollatorSPnode::getLeafNodeAbsAreaAccumulations</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the accumulations of absolute areas for leaf nodes. </p>
<p>Area for a value s in a summary is s * volume of node. Areas for a leaf node are the areas for each subpaving collated by that node. Accumulated areas over all the leaf nodes are, for each subpaving collated, the accumulated areas for that subpaving over all the leaf nodes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>container of the accumulated leaf areas for all collated subpavings, in the same order as the subpavings are in the collator. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00571">571</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size();
        dotprecision emptyDP(0.0);
        <a class="code" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605" title="Define type VecDotPrec as a container of cxsc dotprecision variables.">VecDotPrec</a> areaAcc(n, emptyDP); <span class="comment">// n copies of empty dot prec</span>

        areaAcc = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac0b072587e955a451fab739dcb538c37" title="Get the accumulations of absolute areas for leaf nodes.">getLeafNodeAbsAreaAccumulations</a>(areaAcc);
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> retvalues;

        <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> it;
        <span class="keywordflow">for</span> (it = areaAcc.begin(); it &lt; areaAcc.end(); it++) {
            retvalues.push_back(rnd(*it)); <span class="comment">// round to nearest</span>
        }

        <span class="keywordflow">return</span> retvalues;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0afe525dbddf958078e9a8eac6ea88a3"></a><!-- doxytag: member="subpavings::CollatorSPnode::getLeafNodeAbsAreaAccumulationTotal" ref="a0afe525dbddf958078e9a8eac6ea88a3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0afe525dbddf958078e9a8eac6ea88a3">subpavings::CollatorSPnode::getLeafNodeAbsAreaAccumulationTotal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total accumulated value of absolute areas for leaf nodes. </p>
<p>Area for a value s in a summary is s * volume of node. Areas for a leaf node are the areas for each subpaving collated by that node. Accumulated areas over all the leaf nodes are, for each subpaving collated, the accumulated areas for that subpaving over all the leaf nodes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>total of accumulated areas of leaf nodes as a real. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00188">188</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size();
        dotprecision emptyDP(0.0);
        <a class="code" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605" title="Define type VecDotPrec as a container of cxsc dotprecision variables.">VecDotPrec</a> areaAcc(n, emptyDP); <span class="comment">// n copies of empty dot prec</span>
    dotprecision tot(0.0);
    
        areaAcc = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac0b072587e955a451fab739dcb538c37" title="Get the accumulations of absolute areas for leaf nodes.">getLeafNodeAbsAreaAccumulations</a>(areaAcc);
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> retvalues;

    <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> it;
        <span class="keywordflow">for</span> (it = areaAcc.begin(); it &lt; areaAcc.end(); it++) {
            tot += *it; 
        }

        <span class="keywordflow">return</span> rnd(tot); <span class="comment">// round to nearest;</span>
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7daf828f08626b5b83654550e5a98bee"></a><!-- doxytag: member="subpavings::CollatorSPnode::getLeafNodeSummaryAccumulations" ref="a7daf828f08626b5b83654550e5a98bee" args="(VecDotPrec &amp;summAcc) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a7daf828f08626b5b83654550e5a98bee">subpavings::CollatorSPnode::getLeafNodeSummaryAccumulations</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605">VecDotPrec</a> &amp;&#160;</td>
          <td class="paramname"><em>summAcc</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add to accumulation of summary values for leaf nodes. </p>
<p>If this node is a leaf, add its summary values to the overall accumulation. If a value in the summary for a particular collated subpaving, s, s is added to the accumulation for that subpaving. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00209">209</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01151">getSumVarsTotalSummarisedValueScalar()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            summAcc =
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a7daf828f08626b5b83654550e5a98bee" title="Add to accumulation of summary values for leaf nodes.">getLeafNodeSummaryAccumulations</a>(summAcc);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            summAcc =
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a7daf828f08626b5b83654550e5a98bee" title="Add to accumulation of summary values for leaf nodes.">getLeafNodeSummaryAccumulations</a>(summAcc);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()==NULL &amp;&amp; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()==NULL) {

            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin();
            <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> dpit;

            <span class="keywordflow">for</span> (dpit = summAcc.begin(); dpit &lt; summAcc.end(); dpit++) {
                cxsc::accumulate((*dpit), (*it), 1.0);
                it++;
            }
        }

        <span class="keywordflow">return</span> summAcc;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8c566a24d35898fb54133cf310276468"></a><!-- doxytag: member="subpavings::CollatorSPnode::getLeafNodeSummaryAccumulations" ref="a8c566a24d35898fb54133cf310276468" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f">RealVec</a> <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a7daf828f08626b5b83654550e5a98bee">subpavings::CollatorSPnode::getLeafNodeSummaryAccumulations</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the accumulations of summary values for leaf nodes. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>container of the accumulated summary values for all collated subpavings, in the same order as the subpavings are in the collator. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00589">589</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01151">getSumVarsTotalSummarisedValueScalar()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size();
        dotprecision emptyDP(0.0);
        <a class="code" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605" title="Define type VecDotPrec as a container of cxsc dotprecision variables.">VecDotPrec</a> areaAcc(n, emptyDP); <span class="comment">// n copies of empty dot prec</span>

        areaAcc = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a8c566a24d35898fb54133cf310276468" title="Get the accumulations of summary values for leaf nodes.">getLeafNodeSummaryAccumulations</a>(areaAcc);
        <a class="code" href="namespacesubpavings.shtml#af2d57bb6e12f4a73169f2e496d6a641f" title="Define type RealVec as a container for reals.">RealVec</a> retvalues;

        <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> it;
        <span class="keywordflow">for</span> (it = areaAcc.begin(); it &lt; areaAcc.end(); it++) {
            retvalues.push_back(rnd(*it)); <span class="comment">// round to nearest</span>
        }

        <span class="keywordflow">return</span> retvalues;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a827a6e8b21b3c6e8e8f8e9aeca4b622b"></a><!-- doxytag: member="subpavings::CollatorSPnode::getLeaves" ref="a827a6e8b21b3c6e8e8f8e9aeca4b622b" args="(std::vector&lt; CollatorSPnode * &gt; &amp;leaves) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a827a6e8b21b3c6e8e8f8e9aeca4b622b">subpavings::CollatorSPnode::getLeaves</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return a reference to a container of node pointers. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01440">1440</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01440">getLeaves()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01440">getLeaves()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">//if children, recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a827a6e8b21b3c6e8e8f8e9aeca4b622b">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a827a6e8b21b3c6e8e8f8e9aeca4b622b">getLeaves</a>(leaves);
        }

        <span class="keywordflow">if</span> (!<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>() &amp;&amp; !<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) { <span class="comment">// this is a leaf</span>
            <span class="comment">// arrgh horrible - cast away const if this node is a leaf</span>
            leaves.push_back(const_cast&lt;CollatorSPnode*&gt;(<span class="keyword">this</span>));
        }
        <span class="keywordflow">return</span> leaves;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5e1b32d7fffa9cfc7865b384c2e89a82"></a><!-- doxytag: member="subpavings::CollatorSPnode::getLeftChild" ref="a5e1b32d7fffa9cfc7865b384c2e89a82" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82">subpavings::CollatorSPnode::getLeftChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the left child of a node. </p>
<p>Returns a copy of the pointer to leftChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a2ae7370c24e6c51a99c8bd29b2ffcec3">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">553</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">CollatorSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">dotDiffPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">getAllNodes()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01440">getLeaves()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">getScheffeSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">getYatSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">leavesAverageOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">leavesMakeNewFhat()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">leavesOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">makeAverageCollation()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">operator=()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">totaliseSummaries()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a72b47c222d49deba3753259d94d730c3"></a><!-- doxytag: member="subpavings::CollatorSPnode::getNodeDelta" ref="a72b47c222d49deba3753259d94d730c3" args="(int thisTheta, size_t sizeColl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a72b47c222d49deba3753259d94d730c3">subpavings::CollatorSPnode::getNodeDelta</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisTheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeColl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the delta value for a specific theta. </p>
<p>Get the delta value for a specific theta. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>split number in the set 0:(theta-1) </td></tr>
    <tr><td class="paramname">theta</td><td>the current split number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the delta value </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01833">1833</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">   { 
     <span class="comment">//cout &lt;&lt; &quot;get delta for &quot; &lt;&lt; nodeName &lt;&lt; endl;</span>
     <span class="comment">// get empirical measure of the training data</span>
     <span class="keywordtype">double</span> muTrain = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[thisTheta] * <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
     <span class="comment">//cout &lt;&lt; &quot;summary: &quot; &lt;&lt; summary[thisTheta] &lt;&lt; &quot;\t muTrain: &quot; &lt;&lt; muTrain &lt;&lt; endl;</span>
      
     <span class="comment">// get empirical measure of the validation data      </span>
     <span class="keywordtype">double</span> muValid = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[sizeColl-1] * <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
    <span class="comment">//cout &lt;&lt; &quot;summary: &quot; &lt;&lt; summary[sizeColl-1] &lt;&lt; &quot;\t muValid: &quot; &lt;&lt; muValid &lt;&lt; endl;</span>

     <span class="keywordtype">double</span> delta= muTrain - muValid;
    <span class="comment">//cout &lt;&lt; &quot;Delta: &quot; &lt;&lt; delta &lt;&lt; endl; </span>

     <span class="keywordflow">return</span> delta; 

   } <span class="comment">// end of function getNodeDelta</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a6470a98dd502247ca9e86582b3c422eb"></a><!-- doxytag: member="subpavings::CollatorSPnode::getNumberSummarised" ref="a6470a98dd502247ca9e86582b3c422eb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a6470a98dd502247ca9e86582b3c422eb">subpavings::CollatorSPnode::getNumberSummarised</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of subpavings summarised. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00566">566</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size(); }
</pre></div>
</div>
</div>
<a class="anchor" id="aed3cb2aceae3c384eed427a404a6c8f6"></a><!-- doxytag: member="subpavings::CollatorSPnode::getParent" ref="aed3cb2aceae3c384eed427a404a6c8f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aed3cb2aceae3c384eed427a404a6c8f6">subpavings::CollatorSPnode::getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the parent of a node. </p>
<p>Returns a copy of the pointer to parent node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ad25db2635b9fa09515a3cb75f4a7ccef">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00548">548</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="ab93823657d610d99e885317c2cf2e8f6"></a><!-- doxytag: member="subpavings::CollatorSPnode::getRightChild" ref="ab93823657d610d99e885317c2cf2e8f6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6">subpavings::CollatorSPnode::getRightChild</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the right child of a node. </p>
<p>Returns a copy of the pointer to rightChild node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a9477b1cfe157f5730a5514c944953689">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">558</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00419">CollatorSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">dotDiffPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01461">getAllNodes()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01440">getLeaves()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">getScheffeSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01698">getSplitDim()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">getYatSet()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">leavesAccumulationOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">leavesAverageOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">leavesMakeNewFhat()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">leavesOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">makeAverageCollation()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">operator=()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">totaliseSummaries()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>*) <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a9509d8f49407c1b14148f80758f02646"></a><!-- doxytag: member="subpavings::CollatorSPnode::getScheffeNode" ref="a9509d8f49407c1b14148f80758f02646" args="(int theta1, int theta2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a9509d8f49407c1b14148f80758f02646">subpavings::CollatorSPnode::getScheffeNode</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2, where theta1 &lt; theta2. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta1</td><td>position of candidate f_theta1 </td></tr>
    <tr><td class="paramname">theta2</td><td>position of candidate f_theta2 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01809">1809</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">getScheffeSet()</a>.</p>
<div class="fragment"><pre class="fragment">   { 
     <span class="comment">//cout.precision(20);</span>
     <span class="comment">//cout &lt;&lt; &quot;Checking for Scheffe set at node: &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
     <span class="comment">//cout &lt;&lt; &quot;Theta1: &quot; &lt;&lt; theta1 &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;Theta2: &quot; &lt;&lt; theta2 &lt;&lt; endl;     </span>
     <span class="comment">//cout &lt;&lt; summary[theta1] &lt;&lt; &quot;\t&quot; &lt;&lt; summary[theta2] &lt;&lt; endl;</span>
     
    <span class="comment">//check that this is an ordered pair theta1 &lt; theta2</span>
    <span class="keywordflow">if</span> (theta1 &lt; theta2) {
      <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[theta1] &gt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[theta2])) {
          <span class="comment">//cout &lt;&lt; getNodeName() &lt;&lt; &quot; is an element of the Scheffe set.****&quot; &lt;&lt; endl;</span>
          <span class="keywordflow">return</span> <span class="keyword">true</span>;          
      } 
      <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
    }
    <span class="keywordflow">else</span> {
      cerr &lt;&lt; <span class="stringliteral">&quot;theta1 must be less than theta2.&quot;</span> &lt;&lt; endl;
      exit(0);
    }
   }    
</pre></div>
</div>
</div>
<a class="anchor" id="a3c3d4df6f965a2eee9b4c517eb045246"></a><!-- doxytag: member="subpavings::CollatorSPnode::getScheffeSet" ref="a3c3d4df6f965a2eee9b4c517eb045246" args="(std::set&lt; CollatorSPnode *, std::less&lt; CollatorSPnode * &gt; &gt; &amp;ScheffeSet, size_t cand1, size_t cand2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3c3d4df6f965a2eee9b4c517eb045246">subpavings::CollatorSPnode::getScheffeSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ScheffeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Scheffe set for a particular pair. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">1918</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01809">getScheffeNode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">getScheffeSet()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, and <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01918">getScheffeSet()</a>.</p>
<div class="fragment"><pre class="fragment">  {
    <span class="comment">//iterate through the leaves in both candidate histograms to get the </span>
    <span class="comment">//Yatracos set</span>
     <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
        <span class="keywordtype">bool</span> ind = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a9509d8f49407c1b14148f80758f02646" title="Find the node that fulfills the Scheffe set, f_theta1 &gt; f_theta2 for candidates f_theta1 and f_theta2...">getScheffeNode</a>(cand1, cand2);
          <span class="comment">// insert the node YatSet if return true</span>
      <span class="keywordflow">if</span> (ind) { 
        ScheffeSet.insert(&amp;(*<span class="keyword">this</span>));
      }
    }
      
     <span class="comment">//recurse on the children</span>
     <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
           <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a3c3d4df6f965a2eee9b4c517eb045246" title="Get the Scheffe set for a particular pair.">getScheffeSet</a>(ScheffeSet, cand1, cand2);
     }
     <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
           <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a3c3d4df6f965a2eee9b4c517eb045246" title="Get the Scheffe set for a particular pair.">getScheffeSet</a>(ScheffeSet, cand1, cand2);
     }
  }
</pre></div>
</div>
</div>
<a class="anchor" id="ab374777116b7e0af8e7100f303e1f97b"></a><!-- doxytag: member="subpavings::CollatorSPnode::getSplitDim" ref="ab374777116b7e0af8e7100f303e1f97b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab374777116b7e0af8e7100f303e1f97b">subpavings::CollatorSPnode::getSplitDim</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the dimension a node split on. </p>
<p>split dimension is -1 if node has not split.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>dimension this node split on if it is not a leaf, -1 it if is a leaf. </dd></dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ad04e240d9152c1a927c2ec280aa29371">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01698">1698</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        
    <span class="keywordflow">try</span> {
      
      <span class="keywordtype">int</span> splitDim = -1;  
      
      <span class="keywordflow">if</span> ( !<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>() ) {
      
        ivector box = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
        <span class="keywordtype">int</span> dim = VecLen(box);
        <span class="keywordtype">int</span> boxLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
          
        ivector boxChild = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();
                    
        <span class="keywordtype">int</span> index = 0;
        <span class="keywordtype">int</span> boxChildLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(boxChild);
        <span class="keywordflow">while</span> (splitDim &lt; 1 &amp;&amp; index &lt; dim) {
          <span class="keywordflow">if</span> ((Inf(box[boxLB + index]) 
              != Inf(boxChild[boxChildLB + index]))
            ||
            (Sup(box[boxLB + index]) != 
              Sup(boxChild[boxChildLB + index]))) {
                <span class="comment">// found splitDim</span>
                splitDim = boxLB + index;
          }
          index ++;
        } <span class="comment">// end while</span>
              
        <span class="keywordflow">if</span> (splitDim &lt; 0) {
          <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Cannot find split dimension&quot;</span>);
        }
      } <span class="comment">// end isLeaf</span>
                
      <span class="keywordflow">return</span> splitDim;
      
        } <span class="comment">// end try</span>
        <span class="keywordflow">catch</span> (exception&amp; e) {
            
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = e.what();
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Error in findParentSplitDim:\n &quot;</span> + std::string(msg));
        }
      
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aecf22d39cbb7289355a08cec62749800"></a><!-- doxytag: member="subpavings::CollatorSPnode::getSummary" ref="aecf22d39cbb7289355a08cec62749800" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aecf22d39cbb7289355a08cec62749800">subpavings::CollatorSPnode::getSummary</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accessor for the summary. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00562">562</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">dotDiffPaving()</a>.</p>
<div class="fragment"><pre class="fragment">    { <span class="keywordflow">return</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>; }
</pre></div>
</div>
</div>
<a class="anchor" id="a700f585b2b61663330b999f459045822"></a><!-- doxytag: member="subpavings::CollatorSPnode::getSumVarsAreaScalar" ref="a700f585b2b61663330b999f459045822" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a700f585b2b61663330b999f459045822">subpavings::CollatorSPnode::getSumVarsAreaScalar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum of variances of a scalar value. </p>
<p>The variance for this scalar value is squared sum of 'area' of difference.</p>
<p>Gives the sum of the variances over the collation where the variance of one of the collated subpaving trees is taken as the square of the sum of the 'areas' of difference between that collated subpaving tree and the average subpaving tree over the collation, where 'area' is absolute value of summary value * node volume.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum of variances over all the collated subpaving trees. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01100">1100</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00160">getLeafNodeAbsAreaAccumulations()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01048">makeDifferencesToAveragePaving()</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* differences = NULL;
        dotprecision accSquares(0.0);

        <span class="comment">// take this collation</span>
        <span class="keywordflow">try</span> {
            <span class="comment">// make a tree of differences between this and average over this</span>
            differences = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac1d9ea49286eb953b7bc71f89c15f8ec" title="Make a tree which holds differences of this to avg over this.">makeDifferencesToAveragePaving</a>();

            <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size(); <span class="comment">//also the number of collations? </span>
            dotprecision emptyDP(0.0);
            <a class="code" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605" title="Define type VecDotPrec as a container of cxsc dotprecision variables.">VecDotPrec</a> areaAcc(n, emptyDP); <span class="comment">// n copies of empty dot prec</span>

            areaAcc = differences-&gt;getLeafNodeAbsAreaAccumulations(areaAcc);

            <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> it;
            <span class="keywordflow">for</span> (it = areaAcc.begin(); it &lt; areaAcc.end(); it++) {
          <span class="comment">// add rnd(*it) times rnd(*it) to accSquares</span>
                cxsc::accumulate(accSquares, rnd(*it), rnd(*it)); <span class="comment">// round to nearest</span>
            }

            <span class="keyword">delete</span> differences;
            differences = NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            <span class="keywordflow">if</span> (NULL != differences) {
                <span class="keyword">delete</span> differences;
                differences = NULL;
            }
            <span class="keywordtype">string</span> oldmsg(ba.what());
            <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory summing variances.&quot;</span>;
            msg += <span class="stringliteral">&quot; Orginal error: &quot;</span> + oldmsg;
            <span class="keywordflow">throw</span> SPnodeException(msg);
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (NULL != differences) {
                <span class="keyword">delete</span> differences;
                differences = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

        <span class="comment">// return sum of squared sum of areas of difference</span>
        <span class="keywordflow">return</span> rnd(accSquares); <span class="comment">// CXSC round nearest</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4c623e6456d3ced424aebba699c33fd9"></a><!-- doxytag: member="subpavings::CollatorSPnode::getSumVarsTotalSummarisedValueScalar" ref="a4c623e6456d3ced424aebba699c33fd9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a4c623e6456d3ced424aebba699c33fd9">subpavings::CollatorSPnode::getSumVarsTotalSummarisedValueScalar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum of variances of a scalar value. </p>
<p>This scalar value is the total summary values.</p>
<p>Gives the sum of the variances over the collation where the variance of one of the collated subpaving trees is taken as the square of the difference between the total summary values for that tree and the total summary values for the average tree across the collation.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum of variances over all the collated subpaving trees. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01151">1151</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00589">getLeafNodeSummaryAccumulations()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">makeAverageCollation()</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* average = NULL;
        dotprecision accSqrdDiffSumSummary(0.0);

        <span class="comment">// take this collation</span>
        <span class="keywordflow">try</span> {
            <span class="comment">// make a tree of the averages</span>
            average = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac71288d7ccff2a3ddf1509f5b3a54930">makeAverageCollation</a>();

            <span class="keywordtype">size_t</span> n = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size();
            dotprecision emptyDP(0.0);
            <a class="code" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605" title="Define type VecDotPrec as a container of cxsc dotprecision variables.">VecDotPrec</a> summAcc(n, emptyDP); <span class="comment">// n copies of empty dot prec</span>

            <span class="comment">// the accumulated summaries for this collation</span>
            summAcc = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a8c566a24d35898fb54133cf310276468" title="Get the accumulations of summary values for leaf nodes.">getLeafNodeSummaryAccumulations</a>(summAcc);

            <a class="code" href="namespacesubpavings.shtml#ad8f0a077ee1c4678bcd1868f3aecd605" title="Define type VecDotPrec as a container of cxsc dotprecision variables.">VecDotPrec</a> avAcc(1, emptyDP); <span class="comment">// only 1 value in av summaries</span>
            avAcc = average-&gt;getLeafNodeSummaryAccumulations(avAcc);

            <a class="code" href="namespacesubpavings.shtml#a80a828acc57552427c90b1f3119af173" title="Define type VecDotPrecIt as an iterator over VecDotPrec container.">VecDotPrecIt</a> it;
            <span class="keywordflow">for</span> (it = summAcc.begin(); it &lt; summAcc.end(); it++) {

                real diffsumsummary = rnd((*it)) - rnd(avAcc[0]); <span class="comment">// rnd nearest</span>
                cxsc::accumulate(accSqrdDiffSumSummary, diffsumsummary,
                                                diffsumsummary); <span class="comment">// acc squares</span>
            }

            <span class="keyword">delete</span> average;
            average = NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            <span class="keywordflow">if</span> (NULL != average) {
                <span class="keyword">delete</span> average;
                average = NULL;
            }
            <span class="keywordtype">string</span> oldmsg(ba.what());
            <span class="keywordtype">string</span> msg = <span class="stringliteral">&quot;Error allocating memory summing variances.&quot;</span>;
            msg += <span class="stringliteral">&quot; Orginal error: &quot;</span> + oldmsg;
            <span class="keywordflow">throw</span> SPnodeException(msg);
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (NULL != average) {
                <span class="keyword">delete</span> average;
                average = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

        <span class="comment">// return sum of squared sum of areas of difference</span>
        <span class="keywordflow">return</span> rnd(accSqrdDiffSumSummary); <span class="comment">// CXSC round nearest</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a77e75118f31767497377790cd87e3869"></a><!-- doxytag: member="subpavings::CollatorSPnode::getTotalSummary" ref="a77e75118f31767497377790cd87e3869" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a77e75118f31767497377790cd87e3869">subpavings::CollatorSPnode::getTotalSummary</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the total of the summary in this. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01744">1744</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01963">subpavings::nodeCompTotalSummary()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">totaliseSummaries()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="keywordtype">double</span> summ = 0;
    summ = accumulate(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(), <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(), summ);

    <span class="keywordflow">return</span> summ;
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a8c48fd024a9e569830168a3f301d798e"></a><!-- doxytag: member="subpavings::CollatorSPnode::getTotalSummaryAv" ref="a8c48fd024a9e569830168a3f301d798e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a8c48fd024a9e569830168a3f301d798e">subpavings::CollatorSPnode::getTotalSummaryAv</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the total of the summary in this. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01753">1753</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01970">subpavings::nodeCompTotalSummaryAv()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="keywordtype">double</span> summ = 0;
    summ = accumulate(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(), <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(), summ)/(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size()*1.0);

    <span class="keywordflow">return</span> summ;
   }
</pre></div>
</div>
</div>
<a class="anchor" id="aaf5207af98f7fac37ffe63ab3aec15b9"></a><!-- doxytag: member="subpavings::CollatorSPnode::getYatSet" ref="aaf5207af98f7fac37ffe63ab3aec15b9" args="(std::set&lt; CollatorSPnode *, std::less&lt; CollatorSPnode * &gt; &gt; &amp;YatSetRow, std::set&lt; CollatorSPnode *, std::less&lt; CollatorSPnode * &gt; &gt; &amp;YatSetCol, size_t cand1, size_t cand2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aaf5207af98f7fac37ffe63ab3aec15b9">subpavings::CollatorSPnode::getYatSet</a> </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSetRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *, std::less&lt; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>YatSetCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cand2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Yatracos set for a particular pair. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">1885</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">getYatSet()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01869">nodeCheckColSummary()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01854">nodeCheckRowSummary()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">getYatSet()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">//iterate through the leaves in both candidate histograms to get the </span>
  <span class="comment">//Yatracos set</span>
   <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
      <span class="keywordtype">bool</span> rowInd = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#af089a7955e0dd12ef33af3ec4bfc6627" title="Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matr...">nodeCheckRowSummary</a>(cand1, cand2);
      <span class="keywordtype">bool</span> colInd = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#aeb5549c6c555a65ee6cf71e779873b67" title="Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos m...">nodeCheckColSummary</a>(cand1, cand2);
      <span class="comment">// insert the node YatSet if return true</span>
    <span class="keywordflow">if</span> (rowInd) { 
      <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; getNodeName() &lt;&lt; &quot; into YatSetRow&quot; &lt;&lt; endl; </span>
      YatSetRow.insert(&amp;(*<span class="keyword">this</span>));
    }
    <span class="keywordflow">if</span> (colInd) { 
      <span class="comment">//cout &lt;&lt; &quot;inserting &quot; &lt;&lt; getNodeName() &lt;&lt; &quot; into YatSetCol&quot; &lt;&lt; endl; </span>
      YatSetCol.insert(&amp;(*<span class="keyword">this</span>));
    }
   }
 
   <span class="comment">//recurse on the children</span>
   <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
         <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#aaf5207af98f7fac37ffe63ab3aec15b9" title="Get the Yatracos set for a particular pair.">getYatSet</a>(YatSetRow, YatSetCol, cand1, cand2);
   }
   <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
         <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#aaf5207af98f7fac37ffe63ab3aec15b9" title="Get the Yatracos set for a particular pair.">getYatSet</a>(YatSetRow, YatSetCol, cand1, cand2);
   }
} <span class="comment">// end of getYatset</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a0ea530d232bf3bb09e6cf44eeeadbfde"></a><!-- doxytag: member="subpavings::CollatorSPnode::leafAccumulationOutputTabs" ref="a0ea530d232bf3bb09e6cf44eeeadbfde" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0ea530d232bf3bb09e6cf44eeeadbfde">subpavings::CollatorSPnode::leafAccumulationOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only. Outputs the accumulated sum of the summary for the node, ie the summary added together.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector with m elements in the summary is</p>
<p>label [tab] volume [tab] empirical measure [tab] sum(summary[1]... summary[m]) [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[n]) [tab] Sup(ivector[n] </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01348">1348</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01371">nodeAccumulation()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">leavesAccumulationOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>
            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>
            <span class="comment">// output the nodeName, nodeVolume</span>
          os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
          <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
           <span class="comment">// followed by the sum of the summary        </span>
        os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a812d98c784af382c4a697555a7b0445f">nodeAccumulation</a>();

            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                   &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a9fe7256f1a62884e4bb8599a63abbbdf"></a><!-- doxytag: member="subpavings::CollatorSPnode::leafAverageOutputTabs" ref="a9fe7256f1a62884e4bb8599a63abbbdf" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a9fe7256f1a62884e4bb8599a63abbbdf">subpavings::CollatorSPnode::leafAverageOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only. Outputs the average over the summary.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector is</p>
<p>nodeName [tab] volume [tabl] average summary [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[n]) [tab] Sup(ivector[n] </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00107">107</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">leavesAverageOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            <span class="keywordtype">double</span> summ = 0;
            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;

            summ = accumulate(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(), <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(), summ);

            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            <span class="keywordtype">double</span> av =  summ/(1.0*<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size());

            <span class="comment">// output the nodeName, nodeVolume</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
            <span class="comment">// followed by the average</span>
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; av;

            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="acdad2b87cf5f979fb24a7aef392a5895"></a><!-- doxytag: member="subpavings::CollatorSPnode::leafMakeNewFhat" ref="acdad2b87cf5f979fb24a7aef392a5895" args="(double wt, std::vector&lt; double &gt; &amp;fhatNew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#acdad2b87cf5f979fb24a7aef392a5895">subpavings::CollatorSPnode::leafMakeNewFhat</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fhatNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the current summary in the leaf node by adding mass </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01408">1408</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">leavesMakeNewFhat()</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>
      <span class="keywordtype">double</span> summ = 0;
      <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
      summ = accumulate(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(), <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(), summ);
      <span class="keywordtype">double</span> av =  summ/(1.0*<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size());          
    fhatNew.push_back((1-wt)*av + wt);
  } 
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab2e1cd11ef3dd4424cf491e529ed0fd8"></a><!-- doxytag: member="subpavings::CollatorSPnode::leafOutputTabs" ref="ab2e1cd11ef3dd4424cf491e529ed0fd8" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab2e1cd11ef3dd4424cf491e529ed0fd8">subpavings::CollatorSPnode::leafOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for a node in a binary tree, tab-delimited. </p>
<p>Output intended for a txt file, in numeric form only. Outputs summary for the node.</p>
<p>Replaces the format that that the cxsc::&lt;&lt; operator produces for interval vectors. The format used here includes the box label and produces numeric tab-delimited data. The format for an n-dimensional interval vector with m elements in the summary is</p>
<p>label [tab] volume [tab] summary[1] [tab] ... summary[m] [tab] Inf(ivector[1]) [tab] Sup(ivector[1].[tab] . . [tab] Inf(ivector[n]) [tab] Sup(ivector[n] </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0f2381175b37224a185eedbe9601d814">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00607">607</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            <span class="comment">// output the nodeName, nodeVolume</span>
            os &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>;
            <span class="keywordtype">double</span> vol = <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>();
            os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; vol;
            <span class="comment">// followed by the summary</span>
            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; (*it);
            }
            <span class="comment">// followed by intervals making up box using Inf &amp; Sup</span>
            <span class="comment">// ie unlike cxsc output, there is no [  ] around them</span>
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {

                os &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Inf(thisBox[i])
                    &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; Sup(thisBox[i]);
            }

        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a406e23c3f85680631bd30897fb1cfdc2"></a><!-- doxytag: member="subpavings::CollatorSPnode::leavesAccumulationOutputTabs" ref="a406e23c3f85680631bd30897fb1cfdc2" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a406e23c3f85680631bd30897fb1cfdc2">subpavings::CollatorSPnode::leavesAccumulationOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0ea530d232bf3bb09e6cf44eeeadbfde" title="Output for a node in a binary tree, tab-delimited.">leafAccumulationOutputTabs()</a> to output information for each leaf node. Outputs a accumulated summary for each leaf node, ie the sum of the summary. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">1385</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01348">leafAccumulationOutputTabs()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">leavesAccumulationOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01385">leavesAccumulationOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">     {
         <span class="comment">// uses  member function leafAccumulationOutputTabs for nodes</span>
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
             <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a0ea530d232bf3bb09e6cf44eeeadbfde" title="Output for a node in a binary tree, tab-delimited.">leafAccumulationOutputTabs</a>(os);
             <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);
 
         }
 
             <span class="comment">//recurse on the children</span>
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a406e23c3f85680631bd30897fb1cfdc2" title="Output for for all leaves of a binary tree.">leavesAccumulationOutputTabs</a>(os);
         }
 
         <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
             <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a406e23c3f85680631bd30897fb1cfdc2" title="Output for for all leaves of a binary tree.">leavesAccumulationOutputTabs</a>(os);
         }
 
     }
</pre></div>
</div>
</div>
<a class="anchor" id="a0f37c9801d51df76b2acf7ea4c45e122"></a><!-- doxytag: member="subpavings::CollatorSPnode::leavesAverageOutputTabs" ref="a0f37c9801d51df76b2acf7ea4c45e122" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0f37c9801d51df76b2acf7ea4c45e122">subpavings::CollatorSPnode::leavesAverageOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a9fe7256f1a62884e4bb8599a63abbbdf" title="Output for a node in a binary tree, tab-delimited.">leafAverageOutputTabs()</a> to output information for each leaf node. Outputs the average over the summary for each leaf. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">659</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00107">leafAverageOutputTabs()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">leavesAverageOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00659">leavesAverageOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// uses  member function leafAverageOutputTabs for node output</span>
        <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a9fe7256f1a62884e4bb8599a63abbbdf" title="Output for a node in a binary tree, tab-delimited.">leafAverageOutputTabs</a>(os);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);
        }
            <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a0f37c9801d51df76b2acf7ea4c45e122" title="Output for for all leaves of a binary tree.">leavesAverageOutputTabs</a>(os);
        }
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a0f37c9801d51df76b2acf7ea4c45e122" title="Output for for all leaves of a binary tree.">leavesAverageOutputTabs</a>(os);
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a236e44d75b1cf0988a014f7ae33c55b6"></a><!-- doxytag: member="subpavings::CollatorSPnode::leavesMakeNewFhat" ref="a236e44d75b1cf0988a014f7ae33c55b6" args="(double wt, std::vector&lt; double &gt; &amp;fhatNew)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a236e44d75b1cf0988a014f7ae33c55b6">subpavings::CollatorSPnode::leavesMakeNewFhat</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>fhatNew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the current summary in the leaf nodes by adding mass </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">1420</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01408">leafMakeNewFhat()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">leavesMakeNewFhat()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01420">leavesMakeNewFhat()</a>.</p>
<div class="fragment"><pre class="fragment">{
   <span class="comment">// uses  member function leafMakeNewFhat for nodes</span>
   <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
      <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#acdad2b87cf5f979fb24a7aef392a5895">leafMakeNewFhat</a>(wt, fhatNew);       
   }
 
   <span class="comment">//recurse on the children</span>
   <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
      <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a236e44d75b1cf0988a014f7ae33c55b6">leavesMakeNewFhat</a>(wt, fhatNew);
   }
 
  <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
      <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a236e44d75b1cf0988a014f7ae33c55b6">leavesMakeNewFhat</a>(wt, fhatNew);
   }
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad54a1befc9cff87c02237caeabe84ea5"></a><!-- doxytag: member="subpavings::CollatorSPnode::leavesOutputTabs" ref="ad54a1befc9cff87c02237caeabe84ea5" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ad54a1befc9cff87c02237caeabe84ea5">subpavings::CollatorSPnode::leavesOutputTabs</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output for for <b>all leaves</b> of a binary tree. </p>
<p>Output intended for a txt file, in numeric form only.</p>
<p>Recursively uses <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab2e1cd11ef3dd4424cf491e529ed0fd8" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs()</a> to output summary information for each leaf node. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a3663133a2c9f0fce79f3f551c1d163de">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">637</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00475">subpavings::SPnode::isEmpty()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00607">leafOutputTabs()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">leavesOutputTabs()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00637">leavesOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
         <span class="keywordflow">if</span> (!(<a class="code" href="classsubpavings_1_1SPnode.shtml#a42410c54c2a5cc045ec63b26fb6ae593" title="Check if this SPnode is empty.">isEmpty</a>()) &amp;&amp; <a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) { <span class="comment">// this is a non-empty leaf</span>
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab2e1cd11ef3dd4424cf491e529ed0fd8" title="Output for a node in a binary tree, tab-delimited.">leafOutputTabs</a>(os);
            <span class="keywordflow">return</span> (os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);

        }

            <span class="comment">//recurse on the children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ad54a1befc9cff87c02237caeabe84ea5" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
        }

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()!=NULL) {
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ad54a1befc9cff87c02237caeabe84ea5" title="Output for for all leaves of a binary tree.">leavesOutputTabs</a>(os);
        }

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac71288d7ccff2a3ddf1509f5b3a54930"></a><!-- doxytag: member="subpavings::CollatorSPnode::makeAverageCollation" ref="ac71288d7ccff2a3ddf1509f5b3a54930" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ac71288d7ccff2a3ddf1509f5b3a54930">subpavings::CollatorSPnode::makeAverageCollation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>make a <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml" title="A derived class based on SPnode for creating summaries.">CollatorSPnode</a> which represents an average. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">504</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">subpavings::SPnode::setNodeName()</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01151">getSumVarsTotalSummarisedValueScalar()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01048">makeDifferencesToAveragePaving()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* newnode = NULL;

        <span class="keywordflow">try</span> {
            <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> newsumm;
            <span class="keywordtype">double</span> summ = 0;
            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="comment">// should change this to use for_each</span>
            summ = accumulate(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(), <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(), summ);

            newsumm.push_back(
                summ/(1.0*(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>).size()));

            ivector v = <a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>();

            <span class="comment">// make the new node</span>
            newnode = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(v, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>, newsumm);
            newnode-&gt;setNodeName(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a>); <span class="comment">// set name to this node name</span>

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
                newnode-&gt;nodeAddLeft(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac71288d7ccff2a3ddf1509f5b3a54930">makeAverageCollation</a>());
            }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
                newnode-&gt;nodeAddRight(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac71288d7ccff2a3ddf1509f5b3a54930">makeAverageCollation</a>());
            }
        }

        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newnode;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ac1d9ea49286eb953b7bc71f89c15f8ec"></a><!-- doxytag: member="subpavings::CollatorSPnode::makeDifferencesToAveragePaving" ref="ac1d9ea49286eb953b7bc71f89c15f8ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ac1d9ea49286eb953b7bc71f89c15f8ec">subpavings::CollatorSPnode::makeDifferencesToAveragePaving</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a tree which holds differences of this to avg over this. </p>
<p>The tree has the same structure as this tree and the summary values are the difference between the summary values for this and the average summary value over the summary for this ie if this has summary &lt;h1..hn&gt; and the mean is h. then then the new summary becomes &lt;h1-h., .. Hn-h.&gt; </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01048">1048</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">dotDiffPaving()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">makeAverageCollation()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01765">getL1DistancesToAverage()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01100">getSumVarsAreaScalar()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* newCollator = NULL;
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* avg = NULL;

        <span class="keywordflow">try</span> {

            avg = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ac71288d7ccff2a3ddf1509f5b3a54930">makeAverageCollation</a>(); <span class="comment">// must delete at end!</span>

            newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*<span class="keyword">this</span>);

            newCollator-&gt;dotDiffPaving(avg);

            <span class="keyword">delete</span> avg;
            avg = NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">if</span> (avg != NULL) {
                <span class="keyword">delete</span> avg;
                avg = NULL;
            }
            std::cerr
                &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in makeDifferencesToAveragePavings&quot;</span>
                &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">if</span> (avg != NULL) {
                <span class="keyword">delete</span> avg;
                avg = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newCollator;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aec7d6bcee79660a09914100f9b878611"></a><!-- doxytag: member="subpavings::CollatorSPnode::marginalise" ref="aec7d6bcee79660a09914100f9b878611" args="(const CollatorSPnode *const rhs, const std::vector&lt; int &gt; &amp;reqDims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aec7d6bcee79660a09914100f9b878611">subpavings::CollatorSPnode::marginalise</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>reqDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a marginalised version of subpaving with root node <em>rhs</em>. </p>
<p>Marginalises to take out the given dimensions and adjust summaries so that overall sum of (node vol x accumulated summaries) is the same as for <em>rhs</em>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>is the root of the node to marginalise.  is a vector of the dimensions to include in marginal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>root of a tree of marginalised nodes. </dd></dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><em>rhs</em> must be non-NULL. </dd>
<dd>
<em>reqDims</em> must be compatible with current dimensions. </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>allowed dimensions start at 1, ie dimensions to marginalise on can include 1, 2, ... #dimensions of  </dd></dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>returned tree will have one summary value for each node and have sum of (node vol x accumulated summaries) = that for <em>rhs</em>. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01636">1636</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">subpavings::SPnode::recursiveRename()</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00978">subpavings::AdaptiveHistogramCollator::marginalise()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a> * marginal = NULL;
    
    <span class="keywordflow">try</span> { <span class="comment">// throw exception if it is NULL or if dimensions incompatible</span>
      <span class="keywordflow">if</span> (rhs == NULL) {
        <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Cannot marginalise null subpaving&quot;</span>);
      }
      <span class="keywordflow">if</span> (reqDims.empty()) {
        <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;No dimensions to marginalise on&quot;</span>);
      }
      
      ivector box = rhs-&gt;getBox();
      <span class="keywordtype">int</span> dim = VecLen(box);
      <span class="keywordtype">int</span> boxLB = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(box);
      <span class="keywordtype">int</span> boxUB = <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(box);
      <span class="comment">//each of the required dims must be there</span>
      std::vector&lt;int&gt; sorted = reqDims;
      sort(sorted.begin(), sorted.end());
      
      <span class="comment">// remove any duplicates</span>
      vector&lt;int&gt;::iterator it = unique (sorted.begin(), sorted.end());
      sorted.resize( it - sorted.begin() );

      <span class="keywordflow">if</span> ( (*(sorted.begin()) &lt; 1)) {
        <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Dimensions must be &gt;= 1&quot;</span>);
      }
      
      <span class="keywordflow">if</span> (*(sorted.rbegin()) &gt; boxUB - boxLB + 1)  {
        <span class="keywordflow">throw</span> SPnodeException(
          <span class="stringliteral">&quot;At least one dimension too large for subpaving box&quot;</span>);
      }
      <span class="comment">// could use min and max, but we want the not-req dims anyway</span>
      std::vector&lt;int&gt; outDims;
      
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= dim; i++) {
        <span class="keywordflow">if</span> (!(find(reqDims.begin(), reqDims.end(), i) &lt; reqDims.end())) {
          <span class="comment">// dim of box was not in reqDims </span>
          outDims.push_back(i);
        }
      }
      
      marginal = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ae156be7c91a97c25628edc6fcf00e1f9" title="Make a marginalised version of a given node.">_marginalise</a>(rhs, outDims);
      marginal-&gt;recursiveRename();
      <span class="keywordflow">return</span> marginal;
    }
    <span class="keywordflow">catch</span> (exception&amp; e) {
      
      <span class="keywordflow">if</span> (marginal != NULL) {
        <span class="keywordflow">try</span> {
          <span class="keyword">delete</span> marginal;
        }
        <span class="keywordflow">catch</span> (exception&amp; ee) {} <span class="comment">// catch and swallow</span>
      }
      <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = e.what();
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Error in marginalise:\n &quot;</span> + std::string(msg));
    } 
  }
</pre></div>
</div>
</div>
<a class="anchor" id="a812d98c784af382c4a697555a7b0445f"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeAccumulation" ref="a812d98c784af382c4a697555a7b0445f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">real <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a812d98c784af382c4a697555a7b0445f">subpavings::CollatorSPnode::nodeAccumulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the accumulated summary for a node.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the sum over the summary for this node. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01371">1371</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01348">leafAccumulationOutputTabs()</a>.</p>
<div class="fragment"><pre class="fragment">    {
      dotprecision dpSumm;    <span class="comment">// use type dotprecision for summation  </span>
      dpSumm=0.0;
    <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
      <span class="comment">// should change this to use for_each</span>
            <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
           accumulate(dpSumm, (*it), 1.0);
            }
        real summ = rnd(dpSumm);
            <span class="keywordflow">return</span> summ;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aca275f3faaa0170c0612f368bae4acdf"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeAdoptLeft" ref="aca275f3faaa0170c0612f368bae4acdf" args="(CollatorSPnode *lChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aca275f3faaa0170c0612f368bae4acdf">subpavings::CollatorSPnode::nodeAdoptLeft</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. This adopts a left child rather than attempting to reunite two children into this. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00827">827</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="keywordtype">size_t</span> i = 0;

        <span class="keywordtype">size_t</span> n = (lChild-&gt;summary).size();

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.empty()) { <span class="comment">// no summary in this box already</span>
            <span class="comment">// put into this summary 0.5* the summary of the new child</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.push_back(0.5*(lChild-&gt;summary)[i]);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// has summary already</span>

            <span class="comment">// we have to make summary for this match</span>
            <span class="comment">// that of the children</span>
            <span class="comment">// number of elements in this summary should = child</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size() != n) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Summaries do not match&quot;</span>);
            }

            <span class="comment">// store current summary temporarily</span>
            <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp_summary = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>;

            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.clear();

            <span class="comment">// put into this summary the average of</span>
            <span class="comment">// the summary of the new child and the old summary</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.push_back(((lChild-&gt;summary)[i]
                                + temp_summary[i])/2.0);
            }
        }

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddLeft() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(lChild);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a324588afd881d4e695f42f4a286b33a7"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeAdoptRight" ref="a324588afd881d4e695f42f4a286b33a7" args="(CollatorSPnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a324588afd881d4e695f42f4a286b33a7">subpavings::CollatorSPnode::nodeAdoptRight</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a higher level of a tree from existing nodes. </p>
<p>This adopts a right child rather than attempting to reunite two children into this. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00872">872</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, and <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">nodeReunite()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>
        <span class="keywordtype">size_t</span> i = 0;

        <span class="keywordtype">size_t</span> n = (rChild-&gt;summary).size();

        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.empty()) { <span class="comment">// no summary in this box already</span>
            <span class="comment">// put into this summary 0.5 * the summary of the new child</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.push_back(0.5*(rChild-&gt;summary)[i]);
            }
        }
        <span class="keywordflow">else</span> { <span class="comment">// has summary already</span>

            <span class="comment">// we have to make summary for this match</span>
            <span class="comment">// that of the children</span>
            <span class="comment">// number of elements in this summary should = child</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size() != n) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Summaries do not match&quot;</span>);
            }
            <span class="comment">// store current summary temporarily</span>
            <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> temp_summary = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>;

            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.clear();

            <span class="comment">// put into this summary the average of the summary</span>
            <span class="comment">// of the new child and the old summary</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.push_back(((rChild-&gt;summary)[i]
                                + temp_summary[i])/2.0);
            }
        }

        <span class="comment">// point parent and child pointers in the right directions</span>
        <span class="comment">// nodeAddRight() checks labels, hull size, present children</span>
        <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(rChild);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aeb5549c6c555a65ee6cf71e779873b67"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeCheckColSummary" ref="aeb5549c6c555a65ee6cf71e779873b67" args="(int theta, int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#aeb5549c6c555a65ee6cf71e779873b67">subpavings::CollatorSPnode::nodeCheckColSummary</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the node that fulfills the Yatracos condition by comparing the columns of the growing Yatracos matrix against the rows. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>current split number </td></tr>
    <tr><td class="paramname">k</td><td>split number in the set 0:(theta-1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01869">1869</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">getYatSet()</a>.</p>
<div class="fragment"><pre class="fragment">   { 
   <span class="comment">//  cout &lt;&lt; &quot;checking for Yat at node: &quot; &lt;&lt; getNodeName() &lt;&lt; endl;     </span>
    <span class="comment">//  cout &lt;&lt; &quot;theta: &quot; &lt;&lt; theta &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;k: &quot; &lt;&lt; k &lt;&lt; endl;</span>
    <span class="comment">//  cout &lt;&lt; summary[theta] &lt;&lt; &quot;\t&quot; &lt;&lt; summary[k] &lt;&lt; endl;</span>
      <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[k] &gt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[theta])) {
   <span class="comment">// cout &lt;&lt; &quot;height at &quot; &lt;&lt; k &lt;&lt; &quot; larger than height at &quot; &lt;&lt; theta &lt;&lt; endl;</span>
         <span class="keywordflow">return</span> <span class="keyword">true</span>;
      }   
    <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <span class="keyword">false</span>; }    
  }
</pre></div>
</div>
</div>
<a class="anchor" id="af089a7955e0dd12ef33af3ec4bfc6627"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeCheckRowSummary" ref="af089a7955e0dd12ef33af3ec4bfc6627" args="(int theta, int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#af089a7955e0dd12ef33af3ec4bfc6627">subpavings::CollatorSPnode::nodeCheckRowSummary</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the node that fulfills the Yatracos condition by comparing the rows of the growing Yatracos matrix against the columns. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>current split number </td></tr>
    <tr><td class="paramname">k</td><td>split number in the set 0:(theta-1) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01854">1854</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01885">getYatSet()</a>.</p>
<div class="fragment"><pre class="fragment">   { 
     <span class="comment">//cout &lt;&lt; &quot;checking for Yat at node: &quot; &lt;&lt; getNodeName() &lt;&lt; endl;</span>
     <span class="comment">//cout &lt;&lt; &quot;theta: &quot; &lt;&lt; theta &lt;&lt; &quot;\t&quot; &lt;&lt; &quot;k: &quot; &lt;&lt; k &lt;&lt; endl;     </span>
     <span class="comment">//cout &lt;&lt; summary[theta] &lt;&lt; &quot;\t&quot; &lt;&lt; summary[k] &lt;&lt; endl;</span>
      
      <span class="keywordflow">if</span> ((<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[theta] &gt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[k])) {
    <span class="comment">//cout &lt;&lt; &quot;height at &quot; &lt;&lt; theta &lt;&lt; &quot; larger than height at &quot; &lt;&lt; k &lt;&lt; endl;</span>
            <span class="keywordflow">return</span> <span class="keyword">true</span>;          
      } <span class="comment">// end of filling up rows</span>
      <span class="keywordflow">else</span> { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
   }   
</pre></div>
</div>
</div>
<a class="anchor" id="af0789230e2a9612f9b0644113e318f37"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeExpand" ref="af0789230e2a9612f9b0644113e318f37" args="(int comp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#af0789230e2a9612f9b0644113e318f37">subpavings::CollatorSPnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand leaf node to make two more leaves as children and copy summary down to the children. </p>
<p>Equivalent to bisecting a box in a regular subpaving. Makes two new sibling child nodes of this one and grafts them on. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>is the dimension on which to bisect theBox. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#ac27ee8ea1399ed0121ed970c8fd51543">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">711</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="toolz_8cpp_source.shtml#l00234">Lower()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8cpp_source.shtml#l00430">subpavings::SPnode::setNodeName()</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00242">Upper()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">dotDiffPaving()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span>
        {
            <span class="comment">// only do something if this CollatorSPnode is a leaf</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#af5ad3b1f3ca82ba135c491e99c53eda7" title="Check if this SPnode is a leaf.">isLeaf</a>()) {
                <span class="comment">// ivectors to become boxes for new children</span>
                ivector lC, rC;
                <span class="comment">// Call Lower() and Upper() to put split boxes</span>
                <span class="comment">// into lC and rC respectively</span>
                <a class="code" href="toolz_8cpp.shtml#ae667f0f5dcaff56bf979f20da13e9c9f" title="Bisect box x normal to direction &quot;split&quot; and return the lower half.">Lower</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), lC, comp);
                <a class="code" href="toolz_8cpp.shtml#acb5cc90c84a0b29fbbf2bed1f4ece8d3" title="Bisect box x normal to direction &quot;split&quot; and return the upper half.">Upper</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), rC, comp);

                <span class="comment">// make and add the new children</span>
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                    lC, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>, <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>));

                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                    rC, <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>, <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>));

                <span class="comment">//name the new children</span>
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;L&quot;</span>);
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1SPnode.shtml#a628f03ae2795efd1135e6f4d06db987f" title="Set the node name.">setNodeName</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> + <span class="stringliteral">&quot;R&quot;</span>);

                <span class="comment">// new children have summary from this</span>

            }
        }

        <span class="keywordflow">catch</span> (bad_alloc&amp;)
        {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in &quot;</span>
                &lt;&lt; <span class="stringliteral">&quot;CollatorSPnode::nodeExpand()&quot;</span>
                &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }


    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad54fcce3c5c904f7ecf0f5042515e1a5"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeExpand" ref="ad54fcce3c5c904f7ecf0f5042515e1a5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#af0789230e2a9612f9b0644113e318f37">subpavings::CollatorSPnode::nodeExpand</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Expand leaf node to make two more leaves as children and copy summary down to the children. </p>
<p>Finds the dimension to split on and passes to NodeExpand(int comp) to carry out the bisection. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#a0540c55967e7f35843fac029b450ab55">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00753">753</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="toolz_8cpp_source.shtml#l00192">MaxDiam()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordtype">int</span> maxdiamcomp; <span class="comment">// variable to hold first longest dimension</span>
        <span class="keywordtype">double</span> temp = <a class="code" href="toolz_8cpp.shtml#ac7e3723f9b82103197575fd3be3db667" title="Return the maximal diameter of box x.">::MaxDiam</a>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a8ff024c82f00ff7420ba62005a5558ac" title="Accessor for theBox of a node.">getBox</a>(), maxdiamcomp);
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ad54fcce3c5c904f7ecf0f5042515e1a5" title="Expand leaf node to make two more leaves as children and copy summary down to the children...">nodeExpand</a>(maxdiamcomp); <span class="comment">// complete nodeExpand</span>

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3ba268993642c1fd5c702966a4fd4fba"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeNegate" ref="a3ba268993642c1fd5c702966a4fd4fba" args="(double c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3ba268993642c1fd5c702966a4fd4fba">subpavings::CollatorSPnode::nodeNegate</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negates the summary for every node in tree rooted at this. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00090">90</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00984">subtractPavings()</a>.</p>
<div class="fragment"><pre class="fragment">   {
      <span class="comment">// transform(summary.begin(), summary.end(), summary.begin(),</span>
      <span class="comment">//                                negate&lt;double&gt;());</span>
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size(); i++) {  
      <span class="keywordtype">double</span> temp = c * <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>[i];
      <span class="keywordflow">if</span> ( temp == -0) { temp = 0; }
      summary[i] = temp;        
    }

        <span class="comment">// recurse on children</span>
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a3ba268993642c1fd5c702966a4fd4fba" title="Negates the summary for every node in tree rooted at this.">nodeNegate</a>(c);
        <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a3ba268993642c1fd5c702966a4fd4fba" title="Negates the summary for every node in tree rooted at this.">nodeNegate</a>(c);
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab58b8d4c3a8a879930da943dbe2dd62d"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodePrint" ref="ab58b8d4c3a8a879930da943dbe2dd62d" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ab58b8d4c3a8a879930da943dbe2dd62d">subpavings::CollatorSPnode::nodePrint</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output the details of a specific node. </p>
<p>This is intended for console output or output to a mixed alpha and numeric file. </p>

<p>Reimplemented from <a class="el" href="classsubpavings_1_1SPnode.shtml#aaf14185437d50e955c5ea938dc6e7559">subpavings::SPnode</a>.</p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00677">677</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="dim2taylor_8cpp_source.shtml#l01624">taylor::Lb()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00437">subpavings::SPnode::nodeVolume()</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>, and <a class="el" href="dim2taylor_8cpp_source.shtml#l01629">taylor::Ub()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// output for box in form:</span>
        <span class="comment">// box, volume, summary data</span>

        <span class="keywordflow">if</span>(<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) { <span class="comment">// do nothing if there is no box</span>

            ivector thisBox = *<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>; <span class="comment">// copy theBox</span>

            os &lt;&lt; <span class="stringliteral">&quot;Box is :&quot;</span>;

            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = <a class="code" href="namespacetaylor.shtml#a2bb1593763f084acddd2e1a1e1efaa11">Lb</a>(thisBox); i &lt;= <a class="code" href="namespacetaylor.shtml#a38b201904beee95d9528b9d656430c07">Ub</a>(thisBox) ; i++) {
                <span class="comment">// c-xsc default output for intervals</span>
                os &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; thisBox[i];   }

            os &lt;&lt; std::endl;
            os &lt;&lt; <span class="stringliteral">&quot;Box volume is &quot;</span> &lt;&lt; <a class="code" href="classsubpavings_1_1SPnode.shtml#ab8a45c1ea71b3c1e90f0fd9bd23562eb" title="Return the volume of the box as a double.">nodeVolume</a>() &lt;&lt; std::endl;
            os &lt;&lt; <span class="stringliteral">&quot;Summary data: &quot;</span> ;

            <a class="code" href="namespacesubpavings.shtml#a0b710d91e323ef0b7c2c811a535c5fab" title="Define type VecDblIt as an iterator over VecDbl/.">VecDblIt</a> it;
            <span class="keywordflow">for</span> (it = <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.begin(); it&lt; <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.end(); it++) {
                os &lt;&lt; *it &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
            }

            os &lt;&lt; std::endl;
        }
        <span class="keywordflow">return</span> os;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="ace8192ce1536f578c73c7aa12bb49e35"></a><!-- doxytag: member="subpavings::CollatorSPnode::nodeReunite" ref="ace8192ce1536f578c73c7aa12bb49e35" args="(CollatorSPnode *lChild, CollatorSPnode *rChild)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#ace8192ce1536f578c73c7aa12bb49e35">subpavings::CollatorSPnode::nodeReunite</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td>
          <td class="paramname"><em>lChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *&#160;</td>
          <td class="paramname"><em>rChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to reunite nodes to form one leaf. </p>
<p>Note that the nodes provided, lChild and rChild, are not the actual children of this, they are potential children which we are trying to either totally bring into this (if there are two of them) or to graft onto this if there is only one of them. This is typically a new, part-formed node whose formation can be completed by reuniting already two already-formed nodes into it or by adding on one child if only one is available. nodeReunite is used in building a tree upwards (rather than in pruning leaves of formed tree from the bottom up).</p>
<p>If two potential children are provided and they are both leaves, it combines the two leaf siblings into this. If the potential children are not leaves or if only one potential child is provided, it grafts the potential child/children onto this as its child/children.</p>
<p>Summary data associated with the children is related to the new parent.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>nodeReunite would not normally be used with CollatorSPnodes but is in the base class and is reimplemented to try do it appropriately for this derived class should it be needed. This function is untested. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">774</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="spnode_8cpp_source.shtml#l00479">subpavings::SPnode::isLeaf()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00827">nodeAdoptLeft()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00872">nodeAdoptRight()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00351">subpavings::SPnode::recursiveRename()</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="comment">// *this is the node which will become the parent</span>

        <span class="comment">// check that the labels match and exit if not</span>
        <span class="keywordflow">if</span> ((lChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> ) || (rChild-&gt;label != <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a>)) {
            <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Labels do not match&quot;</span>);
        }

        <span class="comment">// if both subpavings are leaves and hull of boxes is x</span>
        <span class="comment">// discard them: *this is a leaf</span>
        <span class="keywordflow">if</span> (lChild-&gt;isLeaf() &amp;&amp; rChild-&gt;isLeaf()) {
            <span class="keywordflow">if</span> (*<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != (*(lChild-&gt;theBox) |
                            *(rChild-&gt;theBox))) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes cannot be combined&quot;</span>);

            }
            <span class="comment">// how many elements in the left child&#39;s summary</span>
            <span class="keywordtype">size_t</span> n = (lChild-&gt;summary).size();
            <span class="comment">// elements in summary for each child should be same</span>
            <span class="keywordflow">if</span> ((rChild-&gt;summary).size() != n) {
                <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Summaries cannot be combined&quot;</span>);

            }

            <span class="keywordtype">size_t</span> i = 0;

            <span class="comment">// put into this summary the average of summary of children</span>
            <span class="keywordflow">for</span> (i=0; i &lt; n; i++) {
                <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.push_back(((lChild-&gt;summary)[i]
                                +(rChild-&gt;summary)[i])/2.0);
            }

            <span class="comment">//discard the two subpavings given</span>
            <span class="keyword">delete</span> lChild;
            <span class="keyword">delete</span> rChild;

        }

        <span class="keywordflow">else</span> {  <span class="comment">// at least one child is not a leaf</span>
            <span class="comment">// this has to adopt them rather than reuniting them</span>
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#aca275f3faaa0170c0612f368bae4acdf" title="Builds a higher level of a tree from existing nodes. This adopts a left child rather than attempting ...">nodeAdoptLeft</a>(lChild);
            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a324588afd881d4e695f42f4a286b33a7" title="Builds a higher level of a tree from existing nodes.">nodeAdoptRight</a>(rChild);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a84eef536420ee82e9b6ec4eb17a0b14e" title="Recursively rename children based on this node&#39;s nodeName.">recursiveRename</a>();
        }
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a01020423e529685b484b95a73b6432ee"></a><!-- doxytag: member="subpavings::CollatorSPnode::operator=" ref="a01020423e529685b484b95a73b6432ee" args="(const CollatorSPnode &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp; subpavings::CollatorSPnode::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">450</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00098">subpavings::SPnode::dimension</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00109">subpavings::SPnode::label</a>, <a class="el" href="spnode_8hpp_source.shtml#l00120">subpavings::SPnode::leftChild</a>, <a class="el" href="spnode_8cpp_source.shtml#l01411">subpavings::SPnode::nodeAddLeft()</a>, <a class="el" href="spnode_8cpp_source.shtml#l01440">subpavings::SPnode::nodeAddRight()</a>, <a class="el" href="spnode_8hpp_source.shtml#l00128">subpavings::SPnode::nodeName</a>, <a class="el" href="spnode_8hpp_source.shtml#l00116">subpavings::SPnode::parent</a>, <a class="el" href="spnode_8hpp_source.shtml#l00124">subpavings::SPnode::rightChild</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, and <a class="el" href="spnode_8hpp_source.shtml#l00090">subpavings::SPnode::theBox</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <span class="keywordflow">try</span> {

            <span class="comment">// delete the current children (deletes their children as well)</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>();
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a> = NULL;
            }

            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>();
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a> = NULL;
            }
            <span class="comment">// and delete the current box</span>
            <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> != NULL) {
                <span class="keyword">delete</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>;
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a> = NULL;
            }

            <a class="code" href="classsubpavings_1_1SPnode.shtml#ad39c8dad1a8fa89110da4bad250521d8" title="The node&#39;s parent.">parent</a>=NULL;

            <a class="code" href="classsubpavings_1_1SPnode.shtml#a2c09d2f687401550468bad6a6dae9832" title="Pointer to the interval vector the node represents.">theBox</a>=<span class="keyword">new</span> ivector(*rhs.theBox);
            <a class="code" href="classsubpavings_1_1SPnode.shtml#ac28ce64cdc1aed5e545659699a38c16e" title="The dimensions in which we are working.">dimension</a> = rhs.dimension;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a4add69f42780515a4f817f02770e38cb" title="The label for the box.">label</a> = rhs.label;
            <a class="code" href="classsubpavings_1_1SPnode.shtml#a90803dc066d955d4aec89c00879ff610" title="The name given to the node.">nodeName</a> = rhs.nodeName;

            <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a> = rhs.summary;

            <span class="comment">//recursion on the children</span>
            <span class="keywordflow">if</span> (rhs.leftChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#a7124dae3fa53ae2d0061deebe9787d7f" title="Builds a tree downwards.">nodeAddLeft</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                    *(rhs.getLeftChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a5c047856140d3143bec18abc584c2646" title="The node&#39;s left child.">leftChild</a>=NULL;

            <span class="keywordflow">if</span> (rhs.rightChild) {
                <a class="code" href="classsubpavings_1_1SPnode.shtml#ab826f2bf3a9c492c61ca260c16d99c26" title="Builds a tree downwards.">nodeAddRight</a>(<span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(
                    *(rhs.getRightChild())));
            }
            <span class="keywordflow">else</span> <a class="code" href="classsubpavings_1_1SPnode.shtml#a4d5e29412292750e36196b55e186b6dd" title="The node&#39;s right child.">rightChild</a>=NULL;
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> *<span class="keyword">this</span>;

    }
</pre></div>
</div>
</div>
<a class="anchor" id="a79e263c5e6b22baeb2f4e543f33f6d5e"></a><!-- doxytag: member="subpavings::CollatorSPnode::subtractPavings" ref="a79e263c5e6b22baeb2f4e543f33f6d5e" args="(const CollatorSPnode *const lhs, const CollatorSPnode *const rhs, double c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> * <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a79e263c5e6b22baeb2f4e543f33f6d5e">subpavings::CollatorSPnode::subtractPavings</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> *const&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract one collator subpavings from another together. </p>
<p>Collator returned has tree which is the union of lhs and rhs trees and summary with lhs summary and negative of rhs summary values.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to the root of one collator. </td></tr>
    <tr><td class="paramname">lhs</td><td>pointer to the root of the other collator to be subtracted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the root of a new collator subpaving where the summmary is the summary of lhs and the negative values from the summary of rhs. </dd></dl>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l00984">984</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l01323">addNegatedPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00358">CollatorSPnode()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00387">subpavings::SPnode::getBox()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l00090">nodeNegate()</a>.</p>

<p>Referenced by <a class="el" href="adaptivehistogramcollator_8cpp_source.shtml#l00422">subpavings::AdaptiveHistogramCollator::operator-()</a>.</p>
<div class="fragment"><pre class="fragment">    {
        <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>* newCollator = NULL;

        <span class="keywordtype">bool</span> done = <span class="keyword">false</span>;

        <span class="keywordflow">try</span> {

            <span class="keywordflow">if</span> (lhs == NULL &amp;&amp; rhs == NULL) done = <span class="keyword">true</span>; <span class="comment">// return null</span>

            <span class="keywordflow">if</span> (!done &amp;&amp; lhs == NULL &amp;&amp; rhs != NULL) {

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*rhs);
                newCollator-&gt;nodeNegate(c);

                done = <span class="keyword">true</span>;

            }
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs == NULL) {

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*lhs);
                done = <span class="keyword">true</span>;
            }
            <span class="comment">// both not null</span>
            <span class="keywordflow">if</span> (!done &amp;&amp; lhs != NULL &amp;&amp; rhs != NULL) {

                <span class="keywordflow">if</span> ((lhs-&gt;getBox() != NULL) &amp;&amp;
                                (lhs-&gt;getBox() != rhs-&gt;getBox())) {
                    <span class="keywordflow">throw</span> SPnodeException(<span class="stringliteral">&quot;Boxes do not match&quot;</span>);
                }

                newCollator = <span class="keyword">new</span> <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a6f444e76ad6e0c65535e6278dbd775e5" title="default constructor,">CollatorSPnode</a>(*lhs);
                newCollator-&gt;addNegatedPaving(rhs, c);  <span class="comment">// uses a temp copy of rhs</span>
            }
        }
        <span class="keywordflow">catch</span> (bad_alloc&amp; ba) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error allocating memory in addPavings&quot;</span> &lt;&lt; endl;
            <span class="keyword">const</span> <span class="keywordtype">char</span>* msg = ba.what();
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            <span class="keywordflow">throw</span>;
        }
        <span class="keywordflow">catch</span> (exception&amp; e) {
            <span class="keywordflow">if</span> (newCollator != NULL) {
                <span class="keyword">delete</span> newCollator;
                newCollator = NULL;
            }
            <span class="keywordflow">throw</span>;
        }

        <span class="keywordflow">return</span> newCollator;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a3b6cd985321d1ecae0a856ab881d6e62"></a><!-- doxytag: member="subpavings::CollatorSPnode::swapCollator" ref="a3b6cd985321d1ecae0a856ab881d6e62" args="(CollatorSPnode &amp;spn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a3b6cd985321d1ecae0a856ab881d6e62">subpavings::CollatorSPnode::swapCollator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a> &amp;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this and another node. </p>
<p>Swaps all the data members of this with the other node.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spn</td><td>a reference to the node to swap with </td></tr>
  </table>
  </dd>
</dl>
<dl class="post"><dt><b>Postcondition:</b></dt><dd>this is identical,in terms of its data members, to spn before the swap, and spn is identical to this after the swap. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e8574a8a951a2716cbb29b8e1fbbc33"></a><!-- doxytag: member="subpavings::CollatorSPnode::totaliseSummaries" ref="a0e8574a8a951a2716cbb29b8e1fbbc33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#a0e8574a8a951a2716cbb29b8e1fbbc33">subpavings::CollatorSPnode::totaliseSummaries</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Total the summaries from this node downwards. </p>
<p>Works recursively to make each summary into a single element </p>

<p>Definition at line <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">1483</a> of file <a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a>.</p>

<p>References <a class="el" href="collatorspnode_8cpp_source.shtml#l00553">getLeftChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00558">getRightChild()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01744">getTotalSummary()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00483">subpavings::SPnode::hasLCwithBox()</a>, <a class="el" href="spnode_8cpp_source.shtml#l00487">subpavings::SPnode::hasRCwithBox()</a>, <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">summary</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">totaliseSummaries()</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01503">_marginalise()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">totaliseSummaries()</a>.</p>
<div class="fragment"><pre class="fragment">    {
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.size() &gt; 1) {
      <a class="code" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37" title="Define type VecDbl as a container of doubles.">VecDbl</a> tmp;
      tmp.push_back(<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a77e75118f31767497377790cd87e3869">getTotalSummary</a>());
      <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec" title="A container of summary values from the collated subpavings.">summary</a>.swap(tmp);
    }
    
    <span class="comment">//recursion on the children</span>
    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a91a9483f923c30474b817c26ec8afbad" title="Check if this has a non-empty left child.">hasLCwithBox</a>()) {
      <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a5e1b32d7fffa9cfc7865b384c2e89a82" title="Accessor for the left child of a node.">getLeftChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a0e8574a8a951a2716cbb29b8e1fbbc33" title="Total the summaries from this node downwards.">totaliseSummaries</a>();
    }

    <span class="keywordflow">if</span> (<a class="code" href="classsubpavings_1_1SPnode.shtml#a8127bcccc0023f632307c22f685196aa" title="Check if this has a non-empty right child.">hasRCwithBox</a>()) {
      <a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#ab93823657d610d99e885317c2cf2e8f6" title="Accessor for the right child of a node.">getRightChild</a>()-&gt;<a class="code" href="classsubpavings_1_1CollatorSPnode.shtml#a0e8574a8a951a2716cbb29b8e1fbbc33" title="Total the summaries from this node downwards.">totaliseSummaries</a>();
    }
   }
</pre></div>
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="abecd2f87f50d84f2c3d04e6b0b15a5ec"></a><!-- doxytag: member="subpavings::CollatorSPnode::summary" ref="abecd2f87f50d84f2c3d04e6b0b15a5ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesubpavings.shtml#a6b4d2e61b2f0b65cacc9c9322d89bc37">VecDbl</a> <a class="el" href="classsubpavings_1_1CollatorSPnode.shtml#abecd2f87f50d84f2c3d04e6b0b15a5ec">subpavings::CollatorSPnode::summary</a><code> [mutable, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A container of summary values from the collated subpavings. </p>

<p>Definition at line <a class="el" href="collatorspnode_8hpp_source.shtml#l00073">73</a> of file <a class="el" href="collatorspnode_8hpp_source.shtml">collatorspnode.hpp</a>.</p>

<p>Referenced by <a class="el" href="collatorspnode_8cpp_source.shtml#l01211">addPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00401">CollatorSPnode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00244">dotDiffPaving()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01765">getL1DistancesToAverage()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00571">getLeafNodeAbsAreaAccumulations()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00589">getLeafNodeSummaryAccumulations()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01833">getNodeDelta()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00566">getNumberSummarised()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01809">getScheffeNode()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00562">getSummary()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01100">getSumVarsAreaScalar()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01151">getSumVarsTotalSummarisedValueScalar()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01744">getTotalSummary()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01753">getTotalSummaryAv()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01408">leafMakeNewFhat()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00607">leafOutputTabs()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00504">makeAverageCollation()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01371">nodeAccumulation()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00827">nodeAdoptLeft()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00872">nodeAdoptRight()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01869">nodeCheckColSummary()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l01854">nodeCheckRowSummary()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00711">nodeExpand()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00677">nodePrint()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00774">nodeReunite()</a>, <a class="el" href="collatorspnode_8cpp_source.shtml#l00450">operator=()</a>, and <a class="el" href="collatorspnode_8cpp_source.shtml#l01483">totaliseSummaries()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="collatorspnode_8hpp_source.shtml">collatorspnode.hpp</a></li>
<li><a class="el" href="collatorspnode_8cpp_source.shtml">collatorspnode.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacesubpavings.shtml">subpavings</a>      </li>
      <li class="navelem"><a class="el" href="classsubpavings_1_1CollatorSPnode.shtml">CollatorSPnode</a>      </li>

    <li class="footer">Generated on Mon Sep 28 2015 15:58:33 for MRS: A C++ Class Library for Statistical Set Processing by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
